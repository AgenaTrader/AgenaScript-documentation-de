<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Schlüsselworte - AgenaScript Dokumentation (Deutsch)</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  <link href="../custom.css" rel="stylesheet">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Schl\u00fcsselworte";
    var mkdocs_page_input_path = "schluesselworte.md";
    var mkdocs_page_url = "/AgenaScript-documentation-de/index.html/schluesselworte/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-74646070-1', 'agenatrader.github.io');
      ga('send', 'pageview');
  </script>
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> AgenaScript Dokumentation (Deutsch)</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Los gehts</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../umgang_mit_bars_und_instrumenten/">Umgang mit Bars und Instrumenten</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../ereignisse/">Ereignisse</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../strategieprogrammierung/">Strategieprogrammierung</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">Schlüsselworte</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#schlusselworte">Schlüsselworte</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#addoutput">AddOutput()</a></li>
        
            <li><a class="toctree-l3" href="#addline">AddLine()</a></li>
        
            <li><a class="toctree-l3" href="#allowremovalofchartdrawings">AllowRemovalOfChartDrawings</a></li>
        
            <li><a class="toctree-l3" href="#attribute">Attribute</a></li>
        
            <li><a class="toctree-l3" href="#browsable">Browsable</a></li>
        
            <li><a class="toctree-l3" href="#category">Category</a></li>
        
            <li><a class="toctree-l3" href="#conditionalvalue">ConditionalValue</a></li>
        
            <li><a class="toctree-l3" href="#description">Description</a></li>
        
            <li><a class="toctree-l3" href="#displayname">DisplayName</a></li>
        
            <li><a class="toctree-l3" href="#timeframerequirements">TimeFrameRequirements</a></li>
        
            <li><a class="toctree-l3" href="#xmlignore">XMLIgnore</a></li>
        
            <li><a class="toctree-l3" href="#calculateonclosedbar">CalculateOnClosedBar</a></li>
        
            <li><a class="toctree-l3" href="#chart">Chart</a></li>
        
            <li><a class="toctree-l3" href="#cleartracewindow">ClearTraceWindow()</a></li>
        
            <li><a class="toctree-l3" href="#colors">Colors</a></li>
        
            <li><a class="toctree-l3" href="#backcolor">BackColor</a></li>
        
            <li><a class="toctree-l3" href="#backcolorall">BackColorAll</a></li>
        
            <li><a class="toctree-l3" href="#backcolorallseries">BackColorAllSeries</a></li>
        
            <li><a class="toctree-l3" href="#backcolorseries">BackColorSeries</a></li>
        
            <li><a class="toctree-l3" href="#barcolor">BarColor</a></li>
        
            <li><a class="toctree-l3" href="#barcolorseries">BarColorSeries</a></li>
        
            <li><a class="toctree-l3" href="#candleoutlinecolor">CandleOutlineColor</a></li>
        
            <li><a class="toctree-l3" href="#candleoutlinecolorseries">CandleOutlineColorSeries</a></li>
        
            <li><a class="toctree-l3" href="#crossabove">CrossAbove()</a></li>
        
            <li><a class="toctree-l3" href="#crossbelow">CrossBelow()</a></li>
        
            <li><a class="toctree-l3" href="#datafeedhistoryperiodicity">DatafeedHistoryPeriodicity</a></li>
        
            <li><a class="toctree-l3" href="#dataseries">DataSeries</a></li>
        
            <li><a class="toctree-l3" href="#boolseries">BoolSeries</a></li>
        
            <li><a class="toctree-l3" href="#dataseries_1">DataSeries</a></li>
        
            <li><a class="toctree-l3" href="#datetimeseries">DateTimeSeries</a></li>
        
            <li><a class="toctree-l3" href="#floatseries">FloatSeries</a></li>
        
            <li><a class="toctree-l3" href="#intseries">IntSeries</a></li>
        
            <li><a class="toctree-l3" href="#longseries">LongSeries</a></li>
        
            <li><a class="toctree-l3" href="#stringseries">StringSeries</a></li>
        
            <li><a class="toctree-l3" href="#dayofweek">DayOfWeek</a></li>
        
            <li><a class="toctree-l3" href="#displacement">Displacement</a></li>
        
            <li><a class="toctree-l3" href="#email-function">Email function</a></li>
        
            <li><a class="toctree-l3" href="#firsttickofbar">FirstTickOfBar</a></li>
        
            <li><a class="toctree-l3" href="#firsttickofbarmtf">FirstTickOfBarMtf</a></li>
        
            <li><a class="toctree-l3" href="#getcurrentask">GetCurrentAsk()</a></li>
        
            <li><a class="toctree-l3" href="#getcurrentaskvolume">GetCurrentAskVolume()</a></li>
        
            <li><a class="toctree-l3" href="#getcurrentbid">GetCurrentBid()</a></li>
        
            <li><a class="toctree-l3" href="#getcurrentbidvolume">GetCurrentBidVolume()</a></li>
        
            <li><a class="toctree-l3" href="#getcurrentprice">GetCurrentPrice()</a></li>
        
            <li><a class="toctree-l3" href="#getcurrentspread">GetCurrentSpread()</a></li>
        
            <li><a class="toctree-l3" href="#getdayasint">GetDayAsInt()</a></li>
        
            <li><a class="toctree-l3" href="#getserieshighestvalue">GetSeriesHighestValue</a></li>
        
            <li><a class="toctree-l3" href="#getserieslowestvalue">GetSeriesLowestValue</a></li>
        
            <li><a class="toctree-l3" href="#gettimeasint">GetTimeAsInt()</a></li>
        
            <li><a class="toctree-l3" href="#historical">Historical</a></li>
        
            <li><a class="toctree-l3" href="#inputpricetype">InputPriceType</a></li>
        
            <li><a class="toctree-l3" href="#instrument">Instrument</a></li>
        
            <li><a class="toctree-l3" href="#isadddrawingstopricepanel">IsAddDrawingsToPricePanel</a></li>
        
            <li><a class="toctree-l3" href="#isautoadjustablescale">IsAutoAdjustableScale</a></li>
        
            <li><a class="toctree-l3" href="#isoverlay">IsOverlay</a></li>
        
            <li><a class="toctree-l3" href="#isprocessingbarindexlast">IsProcessingBarIndexLast</a></li>
        
            <li><a class="toctree-l3" href="#isserierising">IsSerieRising()</a></li>
        
            <li><a class="toctree-l3" href="#isseriesfalling">IsSeriesFalling()</a></li>
        
            <li><a class="toctree-l3" href="#isshowchartverticalgrid">IsShowChartVerticalGrid</a></li>
        
            <li><a class="toctree-l3" href="#isshowindatabox">IsShowInDataBox</a></li>
        
            <li><a class="toctree-l3" href="#isshowpricemarkers">IsShowPriceMarkers</a></li>
        
            <li><a class="toctree-l3" href="#level1args">Level1Args</a></li>
        
            <li><a class="toctree-l3" href="#level2args">Level2Args</a></li>
        
            <li><a class="toctree-l3" href="#levelline">LevelLine()</a></li>
        
            <li><a class="toctree-l3" href="#log">Log()</a></li>
        
            <li><a class="toctree-l3" href="#occurred">Occurred</a></li>
        
            <li><a class="toctree-l3" href="#onbarsrequirements">OnBarsRequirements()</a></li>
        
            <li><a class="toctree-l3" href="#oninit">OnInit()</a></li>
        
            <li><a class="toctree-l3" href="#outputdescriptor">OutputDescriptor()</a></li>
        
            <li><a class="toctree-l3" href="#inputparameter">InputParameter()</a></li>
        
            <li><a class="toctree-l3" href="#playsound">PlaySound()</a></li>
        
            <li><a class="toctree-l3" href="#plotmethod">PlotMethod</a></li>
        
            <li><a class="toctree-l3" href="#pricetype">PriceType</a></li>
        
            <li><a class="toctree-l3" href="#print">Print()</a></li>
        
            <li><a class="toctree-l3" href="#processingbarindex">ProcessingBarIndex</a></li>
        
            <li><a class="toctree-l3" href="#removechartdrawing">RemoveChartDrawing()</a></li>
        
            <li><a class="toctree-l3" href="#removechartdrawings">RemoveChartDrawings()</a></li>
        
            <li><a class="toctree-l3" href="#requiredbarscount">RequiredBarsCount</a></li>
        
            <li><a class="toctree-l3" href="#showalert">ShowAlert()</a></li>
        
            <li><a class="toctree-l3" href="#ticksize">TickSize</a></li>
        
            <li><a class="toctree-l3" href="#timeframe">TimeFrame</a></li>
        
            <li><a class="toctree-l3" href="#update">Update()</a></li>
        
            <li><a class="toctree-l3" href="#value">Value</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../zeichenobjekte/">Zeichenobjekte</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../tipps_und_tricks/">Tipps und Tricks</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">AgenaScript Dokumentation (Deutsch)</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Schlüsselworte</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/AgenaTrader/AgenaScript-documentation-de/edit/master/sources/schluesselworte.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="schlusselworte">Schlüsselworte</h1>
<h2 id="addoutput">AddOutput()</h2>
<h2 id="addline">AddLine()</h2>
<h3 id="beschreibung">Beschreibung</h3>
<p>Mit der Methode Add() werden dem Chart Plot - bzw. Line-Objekte  hinzugefügt. Wenn mit Add() ein neues Plot-Objekt hinzugefügt wird, wird automatisch auch eine Datenserie vom Typ DataSeries erzeugt, die diesem Plot zugeordnet ist. Auf diese Datenserie kann über die Value-Collection zugegriffen werden.
Add() kann in der  OnInit() Methode und in der OnCalculate() Methode verwendet werden..</p>
<h3 id="parameter">Parameter</h3>
<p>plot – ein <em>OutputDescriptor</em> Objekt
line – ein <em>LevelLine</em> Objekt</p>
<h3 id="verwendung">Verwendung</h3>
<pre><code class="cs">
AddOutput(new OutputDescriptor(Color.FromKnownColor(KnownColor.Black), &quot;MyPlot1&quot;));
Add(LevelLine line)
</code></pre>

<h3 id="beispiel">Beispiel</h3>
<pre><code class="cs">#region Usings
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Linq;
using System.Xml;
using System.Xml.Serialization;
using AgenaTrader.API;
using AgenaTrader.Custom;
using AgenaTrader.Plugins;
using AgenaTrader.Helper;
#endregion
namespace AgenaTrader.UserCode
{
  [Description(&quot;Enter the description for the new custom indicator here&quot;)]
  public class MyIndicator : UserIndicator
  {
    protected override void OnInit()
    {
    // 2 blaue Linien in den Chart legen, eine bei 70 und eine bei 30
    Add(new LevelLine(Color.Blue, 70, &quot;UpperLine&quot;));
    Add(new LevelLine(Color.Blue, 30, &quot;LowerLine&quot;));

   // 2 Plots hinzufügen
    Add(new OutputDescriptor(Color.Red, &quot;myFastSMA&quot;));
    Add(new OutputDescriptor(Color.Blue, &quot;mySlowSMA&quot;));
    }

    protected override void OnCalculate()
    {
   //Mit der Set-Methode wird der Wert für den aktuellen Bar zugewiesen.
    FastSMA.Set( SMA(8)[0] ); // ist identisch mit Values[0].Set( SMA(8)[0] );
    SlowSMA.Set( SMA(50)[0] );// ist identisch mit Values[1].Set( SMA(50)[0] );
    }

    / Hier werden 2 Datenserien zur Verfügung gestellt.
        // Zur Darstellung des Indikators auf dem Chart sind diese nicht notwendig.
        // Mit Hilfe dieser Datenserien kann von anderen Indikatoren aus auf diesen Indikator
        // zugegriffen werden.
        // Z.B. mit double d = MeinIndikator.FastSMA[0] - MeinIndikator.SlowSMA[0];
    [Browsable(false)]
    [XmlIgnore()]
    public DataSeries FastSMA
    {
      get { return Outputs[0]; }
    }

    [Browsable(false)]
    [XmlIgnore()]
    public DataSeries SlowSMA
    {
      get { return Outputs[1]; }
    }
  }
}
</code></pre>

<h2 id="allowremovalofchartdrawings">AllowRemovalOfChartDrawings</h2>
<h3 id="beschreibung_1">Beschreibung</h3>
<p>AllowRemovalOfDrawObjects ist eine Eigenschaft von Indikatoren, die in der Methode <a href="#oninit"><em>OnInit()</em></a> gesetzt werden kann..</p>
<p><strong>AllowRemovalOfChartDrawings = true</strong></p>
<p>Zeichenobjekte (DrawObjects), die von einem Indikator bzw. einer Strategie in einen Chart gezeichnet wurden, können manuell aus dem Chart entfernt werden.</p>
<p><strong>AllowRemovalOfChartDrawings = false (default)</strong></p>
<p>Zeichenobjekte (DrawObjects), die von einem Indikator bzw. einer Strategie in einen Chart gezeichnet wurden, können nicht manuell aus dem Chart entfernt werden. Sie werden erst dann vom Chart entfernt, wenn auch der Indikator bzw. die Strategie entfernt wird.</p>
<p>Die Eigenschaft kann abgefragt werden, und liefert "true" bzw. "false".</p>
<h3 id="verwendung_1">Verwendung</h3>
<pre><code class="cs">AllowRemovalOfChartDrawings
</code></pre>

<h3 id="beispiel_1">Beispiel</h3>
<pre><code class="cs">protected override void OnInit()
{
Add(new OutputDescriptor(Color.FromKnownColor(KnownColor.Red), &quot;MyPlot1&quot;));
//DrawObjects können aus dem Chart manuell entfernt werden
AllowRemovalOfChartDrawings = true;
}
</code></pre>

<h2 id="attribute">Attribute</h2>
<p>Attribute sind Bestandteil der Programmiersprache C#. In eigenen AgenaScript-Indikatoren bzw. Strategien können Attribute genauso verwendet werden, wie es auch in C# selbst möglich ist.
Informationen über Die Verwendung von Attributen finden Sie u.a. hier:</p>
<p><a href="http://msdn.microsoft.com/de-de/library/z0w1kczw%28v=vs.80%29.aspx"><em>http://msdn.microsoft.com/de-de/library/z0w1kczw%28v=vs.80%29.aspx</em></a></p>
<p>Die in AgenaScript am häufigsten verwendeten Attribute sind:</p>
<ul>
<li><a href="#browsable"><em>Browsable</em></a></li>
<li><a href="#category"><em>Category</em></a></li>
<li><a href="#conditionalvalue"><em>ConditionalValue</em></a></li>
<li><a href="#description"><em>Description</em></a></li>
<li><a href="#displayname"><em>DisplayName</em></a></li>
<li><a href="#timeframerequirements"><em>TimeFrameRequirements</em></a></li>
<li><a href="#xmlignore"><em>XmlIgnore</em></a></li>
</ul>
<h2 id="browsable">Browsable</h2>
<p>Browsable ist ein  <a href="#attribute">Attribute</a>  in AgenaScript.</p>
<p>In AgenaScript werden öffentliche Variablen (public variables) zum einen für die Eingabe von Parametern für Indikatoren genutzt (z.B. die Periode für einen SMA) und zum anderen für die Ausgabe von Ergebnissen einer Berechnung innerhalb eines Indikators (z.B. Datenserien).
Variablen, die der Eingabe von Parametern dienen, müssen im Eigenschaften-Dialog angezeigt werden. Datenserien hingegen nicht.</p>
<p>Eine public Variable, die mit dem Attribut Browsable=false gekennzeichnet wurde, wird nicht im Eigenschaftendialog von AgenaTrader angezeigt.</p>
<p>Standardmäßig wird Browsable = true angenommen. Daher kann bei einer Variable, die einen Eingabeparameter beinhaltet, das Attribut Browsable auch weggelassen weren.</p>
<p><strong>Beispiel für einen Parameter:</strong></p>
<p>Der Parameter soll im Eigenschaftsfenster angezeigt und abgefragt werden. Daher ist "Browsable = true" zu setzen oder das Attribut kann entfallen.</p>
<pre><code class="cs">[Description(&quot;Numbers of bars used for calculations&quot;)]
[Category(&quot;InputParameter&quot;)]
public int Period
{
get { return period; }
set { period = Math.Max(1, value); }
}
</code></pre>

<p><strong>Beispiel für eine Datenserie:</strong></p>
<pre><code class="cs">[Browsable(false)]
[DisplayName(&quot;Lower band&quot;)]
[XmlIgnore]
public DataSeries Lower
{
get { return Outputs[0]; }
}
</code></pre>

<h2 id="category">Category</h2>
<p>Category ist ein <a href="#attribute">Attribute</a> in AgenaScript.</p>
<p>Das Attribut Category gibt für einen Parameter an, unter welcher Kategorie im Eigenschaften-Dialog der Parameter erscheint.</p>
<p>Wenn das Attribut fehlt, wird standardmäßig die Kategorie "InputParameter" angenommen.</p>
<p>Das folgende Beispiel erzeugt im Eigenschaften-Dialog die neue Kategorie "My InputParameter".</p>
<pre><code class="cs">[Category(&quot;My InputParameter&quot;)]
[DisplayName(&quot;Period number&quot;)]
public double _period
{
get { return _period; }
set { _period = value; }
}
</code></pre>

<p><img alt="Category" src="../media/ClimDistance.png" /></p>
<p>Category ist ein  <a href="#attribute">Attribute</a> in AgenaScript.</p>
<p>Das Attribut Category gibt für einen Parameter an, unter welcher Kategorie im Eigenschaften-Dialog der Parameter erscheint.</p>
<p>Wenn das Attribut fehlt, wird standardmäßig die Kategorie "InputParameter" angenommen.</p>
<p>Das folgende Beispiel erzeugt im Eigenschaften-Dialog die neue Kategorie "My InputParameter".</p>
<pre><code class="cs">namespace AgenaTrader.UserCode
{
    [Description(&quot;Description what this indicator doing.&quot;)]
    [Category(&quot;My Package&quot;)]
    public class MyHolyGrail_Indicator : UserIndicator
    {
        /* your code here */
    }
}
</code></pre>

<h2 id="conditionalvalue">ConditionalValue</h2>
<p>ConditionalValue ist ein <a href="#attribute">Attribute</a> in AgenaScript.</p>
<p>Normalerweise werden im ConditionEscort für Vergleiche die von Indikatoren bereitgestellten Datenserien (DataSeries) benutzt. Beispielsweise wird geprüft, ob ein gleitender Durchschnitt über oder unter einem bestimmten Kurswert liegt.
Ein Indikator kann aber auch Werte als Ergebnis haben, die keine Datenserien sind, also z.B. Werte vom Typ int, double, char, boolean, string usw.</p>
<p>Um diese Werte im Scanner oder im Condition-Escort nutzen zu können, müssen sie mit dem Attribut "ConditionalValue" gekennzeichnet sein.</p>
<pre><code class="cs">[Browsable(false)]
[XmlIgnore]
[ConditionalValue]
public int PublicVariable
{
get
{
Update();
return _internVariable;
}
}
</code></pre>

<h2 id="description">Description</h2>
<p>Description ist ein  <a href="#attribute">Attribute</a> in AgenaScript.</p>
<p>Das Attribute Description wird In AgenaScript für die Klasse und für public-Variablen verwendet.</p>
<p>Als Attribut der Klasse ist der Text eine Beschreibung der Funktion des gesamten Indikators (bzw. der Strategie usw.)</p>
<pre><code class="cs">[Description(&quot;Displays the tick count of a bar.&quot;)]
public class TickCounter : UserIndicator
{
</code></pre>

<p>As an attribute of a public variable, the text is a description of the function of the parameter.</p>
<pre><code class="cs">[Description(&quot;Number of standard deviations&quot;)]
[DisplayName(&quot;# of std. dev.&quot;)]
public double NumStdDev
{
get { return numStdDev; }
set { numStdDev = Math.Max(0, value); }
}
}
</code></pre>

<p>Die Beschreibungen werden jeweils im Eigenschaften-Dialog angezeigt.</p>
<h2 id="displayname">DisplayName</h2>
<p>DisplayName ist ein <a href="#attribute">Attribute</a> in AgenaScript.</p>
<p>Das Attribute DisplayName legt den Text fest, der im Eigenschaften-Dialog für den Parameter verwendet werden soll.</p>
<p>Wird dieses Attribut nicht angegeben, wird der Name der public Variable verwendet.</p>
<pre><code class="cs">[Description(&quot;Number of standard deviations&quot;)]
[DisplayName(&quot;# of std. dev.&quot;)]
public double NumStdDev
{
get { return numStdDev; }
set { numStdDev = Math.Max(0, value); }
}
</code></pre>

<h2 id="timeframerequirements">TimeFrameRequirements</h2>
<p>TimeFrameRequirements ist ein <a href="#attribute">Attribute</a> in AgenaScript.</p>
<p>Sollen in einem AgenaScript Daten verschiedener Zeiteinheiten verwendet werden, ist der Klasse das Attribut "TimeFrameRequirements" voranzustellen. Es können hier auch mehrere Zeiteinheiten angegeben werden:</p>
<pre><code class="cs">[TimeFrameRequirements(&quot;1 day&quot;)]
[TimeFrameRequirements(&quot;15 minutes&quot;, &quot;1 day&quot;, &quot;1 week&quot;)]
</code></pre>

<p>Es werden immer so viele Daten der anderen Zeiteinheit(en) bereitgestellt, wie auch Kerzen im Chart geladen sind.
Sind in einem 5 Minuten-Chart beispielsweise 500 Kerzen geladen, werden auch 500 Kerzen einer anderen Zeiteinheit geladen.
Im Beispiel oben also 500 Tageskerzen bzw. im 2. Beispiel 500 15-Minuen-Kerzen, 500 Tageskerzen und 500 Wochenkerzen.
Die Datenmengen können schnell sehr groß werden. Das Attribut ist daher mit Umsicht zu verwenden.</p>
<p>siehe auch <a href="#multibars"><em>MultiBars</em></a>.</p>
<p><strong>Wichtig:</strong></p>
<p>Wenn in einer Klasse ein anderer Indikator verwendet wird, der seinerseits eine (oder mehrere) sekundäre Zeiteinheit(en) erfordert, muß für die aufrufende Klasse ebenfalls das Attribut "TimeFrameRequirements" angegeben werden. Ein Beispiel hierzu siehe unter <a href="#getdaybar"><em>GetDayBar</em></a>.</p>
<h2 id="xmlignore">XMLIgnore</h2>
<p>XML ignore st ein <a href="#attribute">Attribute</a> in AgenaScript.</p>
<p>AgenaTrader speichert in einem Template u.a. auch alle Parameter-Einstellungen eines Indikators. Die Template-Files liegen im XML-Format vor. Um zu verhindern, dass ein Parameter als Teil eines Templates gespeichert wird, kann das Attribut "XmlIgnore" angegeben werden.</p>
<p>Um Parameter in einem XML-File speichern zu können, müssen die Werte zuvor serialisiert werden. In den meisten Fällen, d.h. für alle gängigen Variablentypen geschieht dies durch AgenaTrader automatisch. Selbst definierte Datentypen können jedoch nicht automatisch serialisiert werden. Der Programmierer muß selbst für die korrekte Serialisierung sorgen.</p>
<p>Im Beispiel werden Farbe und Schriftart als Parameter eines Indikators verwendet. In AgenaTrader existieren für die Serialisierung von Farb- und Schriftart-Informationen 2 Methoden (TextColorSerialize und TextFontSerialize), die die Serialisierung übernehmen. Die beiden Parameter "TextColor" und "TextFont" sind daher mit dem Attribute "XmlIgnore" zu kennzeichnen.</p>
<pre><code class="cs">private Color _textColor = Color.Blue;
private Font _textFont = new Font(&quot;Arial&quot;, 12, FontStyle.Bold);
[XmlIgnore]
[Description(&quot;Textcolor&quot;)]
public Color TextColor
{
get { return _textColor; }
set { _textColor = value; }
}
[Browsable(false)]
public string TextColorSerialize
{
get { return SerializableColor.ToString(_textColor); }
set { _textColor = SerializableColor.FromString(value); }
}
[XmlIgnore()]
[Description(&quot;TextFont&quot;)]
public Font TextFont
{
get { return _textFont; }
set { _textFont = value; }
}
[Browsable(false)]
public string TextFontSerialize
{
get { return SerializableFont.ToString(_textFont); }
set { _textFont = SerializableFont.FromString(value); }
}
</code></pre>

<h2 id="calculateonclosedbar">CalculateOnClosedBar</h2>
<h3 id="beschreibung_2">Beschreibung</h3>
<p>Die Eigenschaft "CalculateOnClosedBar" legt fest, für welche Ereignisse AgenaTrader die Methode  OnCalculate() aufrufen soll.</p>
<pre><code class="cs">CalculateOnClosedBar = true
</code></pre>

<p><strong>OnCalculate()</strong>  wird aufgerufen, wenn ein Bar beendet ist, und der nächste hereinkommende Tick einen neuen Bar entstehen läßt.</p>
<pre><code class="cs">CalculateOnClosedBar = false
</code></pre>

<p>OnCalculate() wird für jeden neu hereinkommenden Tick aufgerufen.
Achtung bei älterer Hardware: dies führt bei sehr liquiden Werten zu einer erhöhten Rechnerbelastung.
Die Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false).
CalculateOnClosedBar  kann sowohl in OnInit() aals auch in OnCalculate() eingesetzt werden..
OnCalculate wird für historische Daten immer nur für den Schlusskurs eines jeden Bars aufgerufen, auch wenn CalculateOnClosedBar=false gesetzt ist.
Wird ein Indikator von einem anderen Indikator aufgerufen, so wird die Eigenschaft  CalculateOnClosedBar des aufgerufenen Indikators vom aufrufenden Indikator überschrieben.</p>
<h3 id="verwendung_2">Verwendung</h3>
<p>CalculateOnClosedBar</p>
<h3 id="weitere-informationen">Weitere Informationen</h3>
<p>Siehe auch die Beschreibung zu <a href="#bars"><em>Bars</em></a>.</p>
<h3 id="beispiel_2">Beispiel</h3>
<pre><code class="cs">protected override void OnInit()
{
//Indikatorberechnung nur, wenn ein Bar fertig ausgeprägt ist
CalculateOnClosedBar = true;
}
</code></pre>

<h2 id="chart">Chart</h2>
<p>Chart  ist ein Objekt, über welches der lesende Zugriff auf verschiedene Eigenschaften des Charts möglich ist.</p>
<p>Die wichtigsten Eigenschaften sind:</p>
<ul>
<li>ChartFontColor, BackColor</li>
<li>UpColor, DownColor</li>
<li>Font</li>
<li>BarMarginLeft, BarMarginRight</li>
<li>BarSpace, BarWidth</li>
<li>BarsPainted</li>
<li>FirstBarPainted, LastBarPainted</li>
<li>BarsVisible</li>
<li>FirstBarVisible, LastBarVisible</li>
<li>GetXByBarIdx, GetYByValue</li>
</ul>
<p>Zur Verwendung der wichtigsten Eigenschaften von Chart siehe Beispiel <a href="#plotsample"><em>PlotSample</em></a>.</p>
<p><strong>BarsPainted und BarsVisible:</strong></p>
<p>BarsPainted enthält die Anzahl der Bars, die ein Chart von seinem linken Rand zu seinem rechten Rand mit der momentanen Breite der</p>
<p>Kerzen und dem Abstand der Kerzen zueinander anzeigen <em>könnte</em>.</p>
<p>BarsVisible enthält die Anzahl der Bars, die tatsächlich zu sehen sind.</p>
<p><strong>FirstBarPainted und FirstBarVisible:</strong></p>
<p>FirstBarPainted enthält die Nummer des Bars, der am linken Rand des Charts angezeigt werden <em>würde</em>.</p>
<p>FirstBarVisible  enthält die Nummer des Bars, der tatsächlich als erster Bar links im Chart angezeigt wird.</p>
<p>Beispiel: der Chart ist so verschoben, dass der erste Bar des Charts erst in der Mitte des Charts angezeigt wird.</p>
<p>FirstBarPainted wäre in diesem Fall negativ.</p>
<p>FirstBarVisible  wäre 0.</p>
<p><strong>LastBarPainted und LastBarVisible:</strong></p>
<p>LastBarPainted enthält die Nummer des Bars, der am rechten Rand des Charts angezeigt werden <em>würde</em>.</p>
<p>LastBarVisible  enthält die Nummer des Bars, der tatsächlich als letzter Bar rechts im Chart angezeigt wird.</p>
<p>Beispiel: der Chart ist so verschoben, dass der letzte Bar des Charts bereits in der Mitte des Charts angezeigt wird.</p>
<p>LastBarPainted wäre in diesem Fall größer als Bars.Count.</p>
<p>LastBarVisible wäre in Bars.Count -1.</p>
<h2 id="cleartracewindow">ClearTraceWindow()</h2>
<h3 id="beschreibung_3">Beschreibung</h3>
<p>Die Methode ClearTraceWindow() leert das Output-Fenster. Die Methode kann sowohl in OnInit() als auch in OnCalculate() eingesetzt werden.
Das OutputWindow beinhaltet alle Ausgaben, die mit dem <a href="#print"><em>Print()</em></a> -Befehl erstellt wurden.
Der Einsatz des OutputWindows ist eine sehr gute Möglichkeit für Code-Debugging.</p>
<h3 id="verwendung_3">Verwendung</h3>
<pre><code class="cs">ClearTraceWindow()
</code></pre>

<h3 id="parameter_1">Parameter</h3>
<p>keiner</p>
<h3 id="ruckgabewert">Rückgabewert</h3>
<p>keiner</p>
<h3 id="beispiel_3">Beispiel</h3>
<pre><code class="cs">protected override void OnInit()
{
//Inhalt des OutputWindow löschen
ClearTraceWindow();
}
</code></pre>

<h2 id="colors">Colors</h2>
<p>In AgenaSript stehen die folgenden Befehle für Farbfestlegungen bzw. -änderungen im Chart zur Verfügung:</p>
<p><a href="#backcolor"><em>BackColor</em></a> Hintergrundfarbe des Kurs-Charts</p>
<p><a href="#backcolorall"><em>BackColorAll</em></a> Hintergrundfarbe des Kurs-Charts und aller Indikator-Panels</p>
<p><a href="#backcolorallseries"><em>BackColorAllSeries</em></a></p>
<p><a href="#backcolorseries"><em>BackColorSeries</em></a></p>
<p>Chart.UpColor Farbe für Up Ticks (Up Bars)
Chart.DownColor Farbe für Down Ticks (Down Bars)</p>
<p>Für jeden Bar werden seine Farben in folgenden Dataserien gespeichert. Wird in diese Datenserien geschrieben, ändern sich die Farben des referenzierten Bars.</p>
<p><a href="#barcolor"><em>BarColor</em></a> Farbe eines Bars</p>
<p><a href="#barcolorseries"><em>BarColorSeries</em></a></p>
<p><a href="#candleoutlinecolor"><em>CandleOutlineColor</em></a></p>
<p><a href="#candleoutlinecolorseries"><em>CandleOutlineColorSeries</em></a></p>
<h2 id="backcolor">BackColor</h2>
<h3 id="beschreibung_4">Beschreibung</h3>
<p>BackColor ändert die Hintergrundfarbe eines Bars bzw. gibt die aktuelle Hintergrundfarbe eines Bars zurück.</p>
<p>Siehe auch <a href="#colors"><em>Colors</em></a>, <a href="#barcolor"><em>BarColor</em></a>, <a href="#backcolor"><em>BackColor</em></a>, <a href="#backcolorall"><em>BackColorAll</em></a>, <a href="#barcolorseries"><em>BarColorSeries</em></a>, <a href="#backcolorall"><em>BackColorAll</em></a>, <a href="#candleoutlinecolor"><em>CandleOutlineColor</em></a>.</p>
<h3 id="parameter_2">Parameter</h3>
<p>ein Color-Objekt vom Typ  public struct Color</p>
<h3 id="verwendung_4">Verwendung</h3>
<p>BackColor</p>
<h3 id="beispiele">Beispiele</h3>
<pre><code class="cs">// immer montags Bar-Hintergrundfarbe auf Blau ändern
if (Time[0].DayOfWeek == DayOfWeek.Monday)
BackColor = Color.Blue;
</code></pre>

<p><img alt="BackColor" src="../media/image16.png" /></p>
<pre><code class="cs">// Ändern der Bar-Hintergrundfarbe in Abhängigkeit von einem gl. Durchschnitt
// Kurs über SMA(14) --&gt; Grün
// Kurs unter SMA(14) --&gt; Maroon
BackColor = SMA(14)[0] &gt;= Close[0] ? Color.Maroon : Color.LimeGreen;
</code></pre>

<p><img alt="BackColor" src="../media/image17.png" /></p>
<h2 id="backcolorall">BackColorAll</h2>
<h3 id="beschreibung_5">Beschreibung</h3>
<p>BackColorAll ändert die Hintergrundfarbe eines Bars im Chartfenster und in allen Subcharts bzw. gibt die aktuelle Hintergrundfarbe eines Bars zurück.
Siehe auch <a href="#colors"><em>Colors</em></a>, <a href="#barcolor"><em>BarColor</em></a>, <a href="#backcolor"><em>BackColor</em></a>, <a href="#backcolorall"><em>BackColorAll</em></a>, <a href="#barcolorseries"><em>BarColorSeries</em></a>, <a href="#backcolorall"><em>BackColorAll</em></a>, <a href="#candleoutlinecolor"><em>CandleOutlineColor</em></a>.</p>
<h3 id="parameter_3">Parameter</h3>
<p>ein Color-Objekt vom Typ  public struct Color</p>
<h3 id="verwendung_5">Verwendung</h3>
<p>BackColorAll</p>
<h3 id="beispiel_4">Beispiel</h3>
<pre><code class="cs">// immer montags Bar-Hintergrundfarbe auf Blau ändern
if (Time[0].DayOfWeek == DayOfWeek.Monday)
BackColorAll = Color.Blue;
</code></pre>

<p><img alt="BackColorAll" src="../media/image18.png" /></p>
<h2 id="backcolorallseries">BackColorAllSeries</h2>
<h3 id="beschreibung_6">Beschreibung</h3>
<p>BackColorAllSeries ist eine Datenserie, die für jeden Bar die Hintergrundfarbe speichert. Im Unterschied zu BackColorSeries wird die Hinterrundfarbe der Subcharts mit berücksichtigt.</p>
<p>Siehe auch <a href="#colors"><em>Colors</em></a>, <a href="#barcolor"><em>BarColor</em></a>, <a href="#backcolor"><em>BackColor</em></a>, <a href="#backcolorall"><em>BackColorAll</em></a>, <a href="#barcolorseries"><em>BarColorSeries</em></a>, <a href="#backcolorall"><em>BackColorAll</em></a>, <a href="#candleoutlinecolor"><em>CandleOutlineColor</em></a>.</p>
<h3 id="parameter_4">Parameter</h3>
<p>ein Color-Objekt vom Typ  public struct Color</p>
<p>int barsAgo</p>
<h3 id="verwendung_6">Verwendung</h3>
<pre><code class="cs">BackColorAllSeries
BackColorAllSeries[int barsAgo]
</code></pre>

<p>Bei Verwendung der Methode mit einem Index [int barsAgo] wird die Hintergrundfarbe für den referenzierten Bar geändert bzw. ausgegeben.</p>
<h3 id="beispiel_5">Beispiel</h3>
<p>siehe <a href="#backcolorseries"><em>BackColorSeries</em></a>.</p>
<h2 id="backcolorseries">BackColorSeries</h2>
<h3 id="beschreibung_7">Beschreibung</h3>
<p>BackColorSeries ist eine Datenserie, die für jeden Bar die Hintergrundfarbe speichert. Soll die Hintergrundfarbe von Subcharts mit berücksichtigt werden, ist "BackColorAllSeries" zu verwenden.</p>
<p>Siehe auch <a href="#colors"><em>Colors</em></a>, <a href="#barcolor"><em>BarColor</em></a>, <a href="#backcolor"><em>BackColor</em></a>, <a href="#backcolorall"><em>BackColorAll</em></a>, <a href="#barcolorseries"><em>BarColorSeries</em></a>, <a href="#backcolorall"><em>BackColorAll</em></a>, <a href="#candleoutlinecolor"><em>CandleOutlineColor</em></a>.</p>
<h3 id="parameter_5">Parameter</h3>
<p>ein Color-Objekt vom Typ  public struct Color</p>
<p>int barsAgo</p>
<h3 id="verwendung_7">Verwendung</h3>
<pre><code class="cs">BackColorSeries
BackColorSeries[int barsAgo]
</code></pre>

<p>ei Verwendung der Methode mit einem Index [<strong>int</strong> barsAgo]  wird die Hintergrundfarbe für den referenzierten Bar geändert bzw. ausgegeben.</p>
<h3 id="beispiele_1">Beispiele</h3>
<pre><code class="cs">// Welche Hintergrundfarbe hat der aktuelle Bar? (im ARGB-Format)
Print (BackColorSeries[0]);
// Hintergrundfarbe des aktuellen Bars auf Blau setzen
// Dies ist identisch mit BackColor = Color.Blue
BackColorSeries[3] = Color.Blue;
// Hintergrundfarbe des vorhergehenden Bars auf Grün setzen
BackColorSeries[1] = Color.Green;
</code></pre>

<h2 id="barcolor">BarColor</h2>
<h3 id="beschreibung_8">Beschreibung</h3>
<p>BarColor ändert die Farbe eines Bars</p>
<p>Siehe auch <a href="#colors"><em>Colors</em></a>, <a href="#barcolor"><em>BarColor</em></a>, <a href="#backcolor"><em>BackColor</em></a>, <a href="#backcolorall"><em>BackColorAll</em></a>, <a href="#barcolorseries"><em>BarColorSeries</em></a>, <a href="#backcolorall"><em>BackColorAll</em></a>, <a href="#candleoutlinecolor"><em>CandleOutlineColor</em></a>.</p>
<h3 id="parameter_6">Parameter</h3>
<p>ein Color-Objekt vom Typ  public struct Color</p>
<h3 id="verwendung_8">Verwendung</h3>
<p>BarColor</p>
<h3 id="beispiel_6">Beispiel</h3>
<pre><code class="cs">// Wenn der Schlusskurs über dem SMA(14) liegt, den Bar orange einfärben
if (Close[0] &gt; SMA(14)[0]) BarColor = Color.Orange;
</code></pre>

<p><img alt="BarColor" src="../media/image15.png" /></p>
<h2 id="barcolorseries">BarColorSeries</h2>
<h3 id="beschreibung_9">Beschreibung</h3>
<p>BarColorSeries ist eine Datenserie, die für jeden Bar die Farbe speichert.</p>
<p>Siehe auch<a href="#colors"><em>Colors</em></a>, <a href="#barcolor"><em>BarColor</em></a>, <a href="#backcolor"><em>BackColor</em></a>, <a href="#backcolorall"><em>BackColorAll</em></a>, <a href="#barcolorseries"><em>BarColorSeries</em></a>, <a href="#backcolorall"><em>BackColorAll</em></a>, <a href="#candleoutlinecolor"><em>CandleOutlineColor</em></a>.</p>
<h3 id="parameter_7">Parameter</h3>
<p>ein Color-Objekt vom Typ  public struct Color</p>
<p>int barsAgo</p>
<h3 id="verwendung_9">Verwendung</h3>
<p>BarColorSeries</p>
<p>BarColorSeries[<strong>int</strong> barsAgo]</p>
<p>Bei Verwendung der Methode mit einem Index [int barsAgo] wird die Farbe für den referenzierten Bar geändert bzw. ausgegeben.</p>
<p><strong>Achtung: Es wird nur die Farbe eines Bars zurückgegeben, dessen Farbe vorher explizit verändert wurde. In allen anderen Fällen wird Color.Empty zurückgegeben.</strong></p>
<h3 id="beispiel_7">Beispiel</h3>
<pre><code class="cs">protected override void OnCalculate()
{
if (ProcessingBarIndex == Bars.Count-1-(CalculateOnClosedBar?1:0))
{
// Farbe des aktuellen Bars auf Blau setzen
// Dies ist identisch mit BarColor = Color.Blue
BarColorSeries[0] = Color.Blue;
// Farbe des vorhergehenden Bars auf Grün setzen
BarColorSeries[1] = Color.Orange;
// Farbe des 3. Bars auf Gelb setzen
BarColorSeries[2] = Color.Yellow;
}
}
</code></pre>

<p><img alt="BarColorSeries" src="../media/image19.png" /></p>
<h2 id="candleoutlinecolor">CandleOutlineColor</h2>
<h3 id="beschreibung_10">Beschreibung</h3>
<p>CandleOutlineColor ändert die Randfarbe (incl. "Dochte" und "Lunte") eines Bars.</p>
<p>Wenn die Farbe eines Bars mit BarColor geändert wird, und die Umrandung des Bars wurde nicht mit CandleOutlineColor verändert, wird die Randfarbe auf die Farbe des Bars angepasst.</p>
<p>Siehe auch<a href="#colors"><em>Colors</em></a>, <a href="#barcolor"><em>BarColor</em></a>, <a href="#backcolor"><em>BackColor</em></a>, <a href="#backcolorall"><em>BackColorAll</em></a>, <a href="#barcolorseries"><em>BarColorSeries</em></a>, <a href="#backcolorall"><em>BackColorAll</em></a>, <a href="#candleoutlinecolor"><em>CandleOutlineColor</em></a>.</p>
<h3 id="parameter_8">Parameter</h3>
<p>ein Color-Objekt vom Typ  public struct Color</p>
<h3 id="verwendung_10">Verwendung</h3>
<p>CandleOutlineColor</p>
<h3 id="beispiel_8">Beispiel</h3>
<pre><code class="cs">if (SMA(14)[0] &gt; SMA(200)[0])
CandleOutlineColor = Color.LimeGreen;
else
CandleOutlineColor = Color.Red;
</code></pre>

<p><img alt="CandleOutlineColor" src="../media/image20.png" /></p>
<h2 id="candleoutlinecolorseries">CandleOutlineColorSeries</h2>
<h3 id="beschreibung_11">Beschreibung</h3>
<p>CandleOutlineColorSeries ist eine Datenserie, die für jeden Bar die Randfarbe speichert.</p>
<p>Siehe auch <a href="#colors"><em>Colors</em></a>, <a href="#barcolor"><em>BarColor</em></a>, <a href="#backcolor"><em>BackColor</em></a>, <a href="#backcolorall"><em>BackColorAll</em></a>, <a href="#barcolorseries"><em>BarColorSeries</em></a>, <a href="#backcolorall"><em>BackColorAll</em></a>, <a href="#candleoutlinecolor"><em>CandleOutlineColor</em></a>.</p>
<h3 id="parameter_9">Parameter</h3>
<p>ein Color-Objekt vom Typ  public struct Color
int barsAgo</p>
<h3 id="verwendung_11">Verwendung</h3>
<pre><code class="cs">CandleOutlineColorSeries
CandleOutlineColorSeries[int barsAgo]
</code></pre>

<p>Bei Verwendung der Methode mit einem Index  [<strong>int</strong> barsAgo] wird die Randfarbe für den referenzierten Bar ausgegeben.</p>
<p><strong>Achtung: Es wird nur die RandFarbe eines Bars zurückgegeben, dessen Randfarbe vorher explizit verändert wurde. In allen anderen Fällen wird Color.Empty zurückgegeben.</strong></p>
<h3 id="beispiel_9">Beispiel</h3>
<pre><code class="cs">// Randfarbe des aktuellen Bars auf Blau setzen
CandleOutlineColorSeries[0] = Color.Blue;
// Randfarbe auf Chart-default zurücksetzen
CandleOutlineColorSeries[0] = Color.Empty;
</code></pre>

<h2 id="crossabove">CrossAbove()</h2>
<h3 id="beschreibung_12">Beschreibung</h3>
<p>Mit der Methode CrossAbove() kann geprüft werden, ob es innerhalb einer festgelegten Anzahl von Perioden eine Überkreuzung zweier Werte von unten nach oben gab. Die Werte können dabei der Kurs, ein Indikator, jede beliebige Datenserie oder ein fester Wert sein.</p>
<p>Siehe auch <a href="#crossabove"><em>CrossAbove()</em></a>, <a href="#crossbelow"><em>CrossBelow()</em></a>, <a href="#isserierising"><em>IsSerieRising()</em></a>, <a href="#isseriefalling"><em>IsSerieFalling()</em></a>.</p>
<h3 id="verwendung_12">Verwendung</h3>
<pre><code class="cs">CrossAbove(IDataSeries series1, double value, int lookBackPeriod)
CrossAbove(IDataSeries series1, IDataSeries series2, int lookBackPeriod)
</code></pre>

<h3 id="ruckgabewert_1">Rückgabewert</h3>
<p><strong>true</strong> eine Überkreuzung hat stattgefunden
<strong>false</strong> eine Überkreuzung hat nicht stattgefunden</p>
<h3 id="parameter_10">Parameter</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>lookBackPeriod</td>
<td>Anzahl der Bars innerhalb derer nach dem Aufterten einer Überkreuzung gesucht wird</td>
</tr>
<tr>
<td>series1 und series2</td>
<td>eine Datenserie, wie z.B. ein Indikator, Close, High o.ä</td>
</tr>
<tr>
<td>value</td>
<td>ein fester Wert vom Typ double</td>
</tr>
</tbody>
</table>
<h3 id="beispiele_2">Beispiele</h3>
<pre><code class="cs">// Hinweis ausgeben, wenn der SMA(20) über SMA(50) kreuzt
if (CrossAbove(SMA(20), SMA(50), 1))
Print(&quot;SMA(20) has risen above SMA(50)!&quot;);
// Hinweis ausgeben, wenn der SMA(20) über den Wert 40 steigt
if (CrossAbove(SMA(20), 40, 1))
Print(&quot;SMA(20) has risen above 40!&quot;);
// Hinweis auf Long-Einstieg ausgeben, wenn innerhalb der letzten 5 Bars
// der SMA(20) über SMA(50) kreuzt und der Kurs innerhalb des letzten Bars gestiegen ist
if (CrossAbove(SMA(20), SMA(50), 1) &amp;&amp; Close[0] &gt; Close[1])
Print(&quot;Long entry !!!&quot;);
</code></pre>

<h2 id="crossbelow">CrossBelow()</h2>
<h3 id="beschreibung_13">Beschreibung</h3>
<p>Mit der Methode CrossBelow() kann geprüft werden, ob es innerhalb einer festgelegten Anzahl von Perioden eine Überkreuzung zweier Werte von oben nach unten gab. Die Werte können dabei der Kurs, ein Indikator, jede beliebige Datenserie oder ein fester Wert sein.</p>
<p>Siehe auch <a href="#crossabove"><em>CrossAbove()</em></a>, <a href="#crossbelow"><em>CrossBelow()</em></a>, <a href="#isserierising"><em>IsSerieRising()</em></a>, <a href="#isseriefalling"><em>IsSerieFalling()</em></a>.</p>
<h3 id="verwendung_13">Verwendung</h3>
<pre><code class="cs">CrossBelow(IDataSeries series1, double value, int lookBackPeriod)
CrossBelow(IDataSeries series1, IDataSeries series2, int lookBackPeriod)
</code></pre>

<h3 id="ruckgabewert_2">Rückgabewert</h3>
<p><strong>true</strong> eine Überkreuzung hat stattgefunden
<strong>false</strong> eine Überkreuzung hat nicht stattgefunden</p>
<h3 id="parameter_11">Parameter</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>lookBackPeriod</td>
<td>Anzahl der Bars innerhalb derer nach dem Aufterten einer Überkreuzung gesucht wird</td>
</tr>
<tr>
<td>series1 und series2</td>
<td>eine Datenserie, wie z.B. ein Indikator, Close, High o</td>
</tr>
<tr>
<td>value</td>
<td>ein fester Wert vom Typ double</td>
</tr>
</tbody>
</table>
<h3 id="beispiele_3">Beispiele</h3>
<pre><code class="cs">// Hinweis ausgeben, wenn der SMA(20) unter SMA(50) kreuzt
if (CrossBelow(SMA(20), SMA(50), 1))
Print(&quot;SMA(20) has fallen below SMA(50)!&quot;);
// Hinweis ausgeben, wenn der SMA(20) unter den Wert 40 fällt
if (CrossBelow(SMA(20), 40, 1))
Print(&quot;SMA(20) has fallen below 40!&quot;);
// Hinweis auf Short-Einstieg ausgeben, wenn innerhalb der letzten 5 Bars
// der SMA(20) unter SMA(50) kreuzt und der Kurs innerhalb des letzten Bars gefallen ist.
if (CrossBelow(SMA(20), SMA(50), 1) &amp;&amp; Close[1] &gt; Close[0])
Print(&quot;Short entry !!!&quot;);
</code></pre>

<h2 id="datafeedhistoryperiodicity">DatafeedHistoryPeriodicity</h2>
<h3 id="beschreibung_14">Beschreibung</h3>
<p>DatafeedHistoryPeriodicity ist ein Datentyp.</p>
<h3 id="definition">Definition</h3>
<p>public enum DatafeedHistoryPeriodicity
-   DatafeedHistoryPeriodicity.Tick
-   DatafeedHistoryPeriodicity.Second
-   DatafeedHistoryPeriodicity.Minute
-   DatafeedHistoryPeriodicity.Hour
-   DatafeedHistoryPeriodicity.Day
-   DatafeedHistoryPeriodicity.Week
-   DatafeedHistoryPeriodicity.Month
-   DatafeedHistoryPeriodicity.Volume
-   DatafeedHistoryPeriodicity.Range
-   DatafeedHistoryPeriodicity.Quarter
-   DatafeedHistoryPeriodicity.Year
-   DatafeedHistoryPeriodicity.HeikinAshi
-   DatafeedHistoryPeriodicity.Renko
-   DatafeedHistoryPeriodicity.LineBreak
-   DatafeedHistoryPeriodicity.Kagi
-   DatafeedHistoryPeriodicity.PointAndFigure
-   DatafeedHistoryPeriodicity.Custom</p>
<p>Siehe <em>TimeFrame</em>, <em>TimeFrames</em>.</p>
<h2 id="dataseries">DataSeries</h2>
<h3 id="beschreibung_15">Beschreibung</h3>
<p>Datenserien (DataSeries) sind eine sehr komfortable und sehr mächtige Möglichkeit, zusätzliche Werte für jeden einzelnen Bar zu speichern. Z.B. wird bei der Berechnung eines gleitenden Durchschnitts jedem Bar der für diesen Bar errechnete Wert zugeordnet.
Eine Datenserie ist ein Array, welches exakt so viele Elemente enthält, wie Bars im Chart angezeigt werden. AgenaTrader sorgt dafür, dass die Datenserien zu jedem Zeitpunkt korrekt mit den Bars synchronisiert sind.
Datenserien werden exakt so benutzt, wie z.B. die Serien Close oder Time. Sie können deshalb natürlich auch als Eingangsdaten (Input) für weitere Indikatoren verwendet werden.
In der Tabelle ist zu sehen, dass 4 neue Datenserien (farbig markiert) angelegt worden sind. Jede dieser Datenserien kann genau einen Wert eines speziellen Datentyps (int, bool, string, DateTime) je Bar aufnehmen. Die Indizierung mit barsAgo ist dabei identisch mit den vom System bereitgestellten Datenserien..</p>
<p><img alt="DataSeries" src="../media/image12.png" /></p>
<h3 id="in-agenatrader-verwendbare-datenserien">In AgenaTrader verwendbare Datenserien</h3>
<p><a href="#boolseries"><em>BoolSeries</em></a></p>
<p><a href="#dataseries"><em>DataSeries</em></a></p>
<p><a href="#datetimeseries"><em>DateTimeSeries</em></a></p>
<p><a href="#floatseries"><em>FloatSeries</em></a></p>
<p><a href="#intseries"><em>IntSeries</em></a></p>
<p><a href="#longseries"><em>LongSeries</em></a></p>
<p><a href="#stringseries"><em>StringSeries</em></a></p>
<p>Darüberhinaus gibt es die Datenserie ColorSeries, die jedoch nur für interne Zwecke bestimmt ist und nicht direkt verwendet werden sollte.
Um die Farbe von Plots zu ändern, verwenden Sie bitte <a href="#plotcolors"><em>PlotColors</em></a>.</p>
<h3 id="set-reset-und-containsvalue">Set(), Reset() und ContainsValue()</h3>
<p>Jede Datenserie verfügt über die Methoden  <strong>Set()</strong>, <strong>Reset()</strong> und <strong>ContainsValue()</strong>.
Mit Set(value) bzw. Set(int barsAgo, value) werden Werte in die Datenserie an der aktuellen Position bzw. an der Position "barsAgo" übernommen.
Mit Reset() bzw. Reset(int barsAgo) kann an der aktuellen Position  bzw. an der Position "barsAgo" ein Wert aus der Datenserie gelöscht werden, d.h. an dieser Position existiert kein gültiger Wert mehr.
Die Programmierung mit Hilfe der Reset-Methode kann eine ansonsten sehr komplexe Logik spürbar vereinfachen.Insbesondere bei Bool-Serien, die nur true oder false enthalten können, ist diese Eigenschaft extrem hilfreich.
Mit ContainsValue() kann geprüft werden, ob die Datenserie an einer bestimmten Position einen gültigen Wert enthält.</p>
<h3 id="informationen-zu-den-einzelnen-datentypen">Informationen zu den einzelnen Datentypen</h3>
<p><a href="http://msdn.microsoft.com/de-de/library/s1ax56ch%28v=vs.80%29.aspx"><em>http://msdn.microsoft.com/de-de/library/s1ax56ch%28v=vs.80%29.aspx</em></a></p>
<h2 id="boolseries">BoolSeries</h2>
<h3 id="beschreibung_16">Beschreibung</h3>
<p>BoolSeries ist eine Datenserie, die für jeden Bar einen boolschen Wert (true oder false) aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.</p>
<h3 id="neue-boolseries-anlegen">Neue BoolSeries anlegen</h3>
<p>Im Bereich für die Deklaration von Variablen eine neue Variable anlegen:</p>
<pre><code class="cs">//Variablendeklaration
private BoolSeries myBoolSeries;
</code></pre>

<p>In der Methode OnInit()dieser Variable eine neue Instanz von BoolSeries zuweisen:</p>
<pre><code class="cs">protected override void OnInit()
{
myBoolSeries = new BoolSeries(this);
CalculateOnClosedBar = true;
}
</code></pre>

<h3 id="werte-zuweisen">Werte zuweisen</h3>
<p>Der Datenserie an aktueller Position einen Wert zuweisen:</p>
<pre><code class="cs">myBoolSeries.Set(true);
</code></pre>

<p>Einen Wert in der Vergangenheit in die Datenserie schreiben:</p>
<pre><code class="cs">myBoolSeries.Set(int barsAgo, bool Value);
</code></pre>

<h3 id="werte-loschen">Werte löschen</h3>
<p>Den aktuellen Wert aus der Datenserie entfernen:</p>
<pre><code class="cs">myBoolSeries.Reset();
</code></pre>

<p>Einen Wert in der Vergangenheit aus der Datenserie entfernen:</p>
<pre><code class="cs">myBoolSeries.Reset(int barsAgo);
</code></pre>

<h3 id="werte-auf-gultigkeit-prufen">Werte auf Gültigkeit prüfen</h3>
<pre><code class="cs">myBoolSeries.ContainsValue(int barsAgo);
</code></pre>

<h3 id="wert-auslesen">Wert auslesen</h3>
<pre><code class="cs">Print (&quot;Für den Bar von &quot; + Time[0] + &quot; ist der Wert der Datenserie: &quot; + myBoolSeries[0]);
</code></pre>

<h3 id="beispiel_10">Beispiel</h3>
<pre><code class="cs">protected override void OnCalculate()
{
if (Close[0] &gt; Open[0])
myBoolSeries.Set(true);
else
myBoolSeries.Set(false);
}
</code></pre>

<h2 id="dataseries_1">DataSeries</h2>
<h3 id="beschreibung_17">Beschreibung</h3>
<p>DataSeries ist eine <a href="#dataseries"><em>DataSeries</em></a> die für jeden Bar einen double-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.</p>
<p>Datenserien für double-Werte sind die für Indikatoren am häufigsten genutzen Datenserien.</p>
<h3 id="neue-datenserie-anlegen">Neue DatenSerie anlegen</h3>
<p>Im Bereich für die Deklaration von Variablen eine neue Variable anlegen:</p>
<pre><code class="cs">//Variablendeklaration
private DataSeries myDataSeries;
</code></pre>

<p>In der Methode OnInit()  dieser Variable eine neue Instanz von DataSeries zuweisen:</p>
<pre><code class="cs">protected override void OnInit()
{
myDataSeries = new DataSeries(this);
CalculateOnClosedBar = true;
}
</code></pre>

<h3 id="werte-zuweisen_1">Werte zuweisen</h3>
<p>Der Datenserie an aktueller Position einen Wert zuweisen:</p>
<pre><code class="cs">myDataSeries.Set(Bars[0].Close);
</code></pre>

<p>Einen Wert in der Vergangenheit in die Datenserie schreiben:</p>
<pre><code class="cs">myDataSeries.Set(int barsAgo, double Value);
</code></pre>

<h3 id="werte-loschen_1">Werte löschen</h3>
<p>Den aktuellen Wert aus der Datenserie entfernen:</p>
<pre><code class="cs">myDataSeries.Reset();
</code></pre>

<p>Einen Wert in der Vergangenheit aus der Datenserie entfernen:</p>
<pre><code class="cs">myDataSeries.Reset(int barsAgo);
</code></pre>

<h3 id="werte-auf-gultigkeit-prufen_1">Werte auf Gültigkeit prüfen</h3>
<pre><code class="cs">myDataSeries.ContainsValue(int barsAgo);
</code></pre>

<h3 id="wert-auslesen_1">Wert auslesen</h3>
<pre><code class="cs">Print (&quot;Für den Bar von  &quot; + Time[0] + &quot;ist der Wert der Datenserie: &quot; + myDataSeries[0]);
</code></pre>

<h3 id="beispiel_11">Beispiel</h3>
<pre><code class="cs">//Speichert die Spanne zwischen dem Hoch und dem Tief eines Bars
myDataSeries.Set(Math.Abs(High[0]-Low[0]));
</code></pre>

<h2 id="datetimeseries">DateTimeSeries</h2>
<h3 id="beschreibung_18">Beschreibung</h3>
<p>Date time series  ist eine <a href="#dataseries"><em>DataSeries</em></a> die für jeden Bar einen DateTime-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.</p>
<h3 id="neue-datenserie-anlegen_1">Neue DatenSerie anlegen</h3>
<p>Im Bereich für die Deklaration von Variablen eine neue Variable anlegen:</p>
<pre><code class="cs">//Variablendeklaration
private DateTimeSeries myDataSeries;
</code></pre>

<p>In der Methode OnInit() dieser Variable eine neue Instanz von StringSeries zuweisen:</p>
<pre><code class="cs">protected override void OnInit()
{
myDataSeries = new DateTimeSeries(this);
CalculateOnClosedBar = true;
}
</code></pre>

<h3 id="werte-zuweisen_2">Werte zuweisen</h3>
<p>Der Datenserie an aktueller Position einen Wert zuweisen:</p>
<pre><code class="cs">myDataSeries.Set(DateTime Value);
</code></pre>

<p>Einen Wert in der Vergangenheit in die Datenserie schreiben:</p>
<pre><code class="cs">myDataSeries.Set(int barsAgo, DateTime Value);
</code></pre>

<h3 id="werte-loschen_2">Werte löschen</h3>
<p>Den aktuellen Wert aus der Datenserie entfernen:</p>
<pre><code class="cs">myDataSeries.Reset();
</code></pre>

<p>Einen Wert in der Vergangenheit aus der Datenserie entfernen:</p>
<pre><code class="cs">myDataSeries.Reset(int barsAgo);
</code></pre>

<h3 id="werte-auf-gultigkeit-prufen_2">Werte auf Gültigkeit prüfen</h3>
<pre><code class="cs">myDataSeries.ContainsValue(int barsAgo);
</code></pre>

<h3 id="wert-auslesen_2">Wert auslesen</h3>
<pre><code class="cs">Print (&quot;Für den Bar von&quot; + Time[0] + &quot; ist der Wert der Datenserie: &quot; + myDataSeries[0]);
</code></pre>

<h3 id="beispiel_12">Beispiel</h3>
<pre><code class="cs">//Speichert einen Versatz von -6 Stunden (Eastern Time, New York) für eine Zeitzonenumrechnung
myDataSeries.Set(Time[0].AddHours(-6));
</code></pre>

<h2 id="floatseries">FloatSeries</h2>
<h3 id="beschreibung_19">Beschreibung</h3>
<p>FloatSeries ist eine Datenserie, die für jeden Bar einen Float-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.</p>
<h3 id="neue-datenserie-anlegen_2">Neue DatenSerie anlegen</h3>
<p>Im Bereich für die Deklaration von Variablen eine neue Variable anlegen:</p>
<pre><code class="cs">//Variablendeklaration
private FloatSeries myDataSeries;
</code></pre>

<p>In der Methode OnInit() dieser Variable eine neue Instanz von StringSeries zuweisen:</p>
<pre><code class="cs">protected override void OnInit()
{
myDatatSeries = new FloatSeries(this);
CalculateOnClosedBar = true;
}
</code></pre>

<h3 id="werte-zuweisen_3">Werte zuweisen</h3>
<p>Der Datenserie an aktueller Position einen Wert zuweisen:</p>
<pre><code class="cs">myDataSeries.Set(float Value);
</code></pre>

<p>Einen Wert in der Vergangenheit in die Datenserie schreiben:</p>
<pre><code class="cs">myDataSeries.Set(int barsAgo, float Value);
</code></pre>

<h3 id="werte-loschen_3">Werte löschen</h3>
<p>Den aktuellen Wert aus der Datenserie entfernen:</p>
<pre><code class="cs">myDataSeries.Reset();
</code></pre>

<p>Einen Wert in der Vergangenheit aus der Datenserie entfernen:</p>
<pre><code class="cs">myDataSeries.Reset(int barsAgo);
</code></pre>

<h3 id="werte-auf-gultigkeit-prufen_3">Werte auf Gültigkeit prüfen</h3>
<pre><code class="cs">myDataSeries.ContainsValue(int barsAgo);
</code></pre>

<h3 id="wert-auslesen_3">Wert auslesen</h3>
<pre><code class="cs">Print (&quot;Für den Bar von&quot; + Time[0] + &quot; ist der Wert der Datenserie: &quot; + myDataSeries[0]);
</code></pre>

<h3 id="beispiel_13">Beispiel</h3>
<pre><code class="cs">//Speichert die Spanne zwischen dem Hoch und dem Tief eines Bars
myDataSeries.Set(Math.Abs((float) High[0] - (float) Low[0]));
</code></pre>

<h2 id="intseries">IntSeries</h2>
<h3 id="beschreibung_20">Beschreibung</h3>
<p>IntSeries ist eine Datenserie, die für jeden Bar einen Integer-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.</p>
<h3 id="neue-datenserie-anlegen_3">Neue DatenSerie anlegen</h3>
<p>Im Bereich für die Deklaration von Variablen eine neue Variable anlegen:</p>
<pre><code class="cs">//Variablendeklaration
private IntSeries myDataSeries;
</code></pre>

<p>In der Methode OnInit() dieser Variable eine neue Instanz von StringSeries zuweisen:</p>
<pre><code class="cs">protected override void OnInit()
{
myDataSeries = new IntSeries(this);
CalculateOnClosedBar = true;
}
</code></pre>

<h3 id="werte-zuweisen_4">Werte zuweisen</h3>
<p>Der Datenserie an aktueller Position einen Wert zuweisen:</p>
<pre><code class="cs">myDataSeries.Set(int Value);
</code></pre>

<p>Einen Wert in der Vergangenheit in die Datenserie schreiben:</p>
<pre><code class="cs">myDataSeries.Set(int barsAgo, int Value);
</code></pre>

<h3 id="werte-loschen_4">Werte löschen</h3>
<p>Den aktuellen Wert aus der Datenserie entfernen:</p>
<pre><code class="cs">myDataSeries.Reset();
</code></pre>

<p>Einen Wert in der Vergangenheit aus der Datenserie entfernen:</p>
<pre><code class="cs">myDataSeries.Reset(int barsAgo);
</code></pre>

<h3 id="werte-auf-gultigkeit-prufen_4">Werte auf Gültigkeit prüfen</h3>
<pre><code class="cs">myDataSeries.ContainsValue(int barsAgo);
</code></pre>

<h3 id="wert-auslesen_4">Wert auslesen</h3>
<pre><code class="cs">Print (&quot;Für den Bar von &quot; + Time[0] + &quot;ist der Wert der Datenserie&quot;+ myDataSeries[0]);
</code></pre>

<h3 id="beispiel_14">Beispiel</h3>
<pre><code class="cs">//Speichert für jeden Bar die Spanne in Ticks zwischen dem Hoch und dem Tief
myDataSeries.Set((int) ((High[0] - Low[0]) / TickSize));
</code></pre>

<h2 id="longseries">LongSeries</h2>
<h3 id="beschreibung_21">Beschreibung</h3>
<p>LongSeries ist eine Datenserie, die für jeden Bar einen Integer-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.</p>
<h3 id="neue-datenserie-anlegen_4">Neue DatenSerie anlegen</h3>
<p>Im Bereich für die Deklaration von Variablen eine neue Variable anlegen:</p>
<pre><code class="cs">//Variablendeklaration
private LongSeries myDataSeries;
</code></pre>

<p>In der Methode OnInit() dieser Variable eine neue Instanz von LongSeries zuweisen:</p>
<pre><code class="cs">protected override void OnInit()
{
myDataSeries = new LongSeries(this);
CalculateOnClosedBar = true;
}
</code></pre>

<h3 id="werte-zuweisen_5">Werte zuweisen</h3>
<p>Der Datenserie an aktueller Position einen Wert zuweisen:</p>
<pre><code class="cs">myDataSeries.Set(long Value);
</code></pre>

<p>Einen Wert in der Vergangenheit aus der Datenserie entfernen:</p>
<pre><code class="cs">myDataSeries.Set(int barsAgo, long Value);
</code></pre>

<h3 id="werte-loschen_5">Werte löschen</h3>
<p>Den aktuellen Wert aus der Datenserie entfernen:</p>
<pre><code class="cs">myDataSeries.Reset();
</code></pre>

<p>Einen Wert in der Vergangenheit aus der Datenserie entfernen:</p>
<pre><code class="cs">myDataSeries.Reset(int barsAgo);
</code></pre>

<h3 id="werte-auf-gultigkeit-prufen_5">Werte auf Gültigkeit prüfen</h3>
<pre><code class="cs">myDataSeries.ContainsValue(int barsAgo);
</code></pre>

<h3 id="wert-auslesen_5">Wert auslesen</h3>
<pre><code class="cs">Print (&quot;Für den Bar von &quot; + Time[0] + &quot;ist der Wert der Datenserie: &quot; + myDataSeries[0]);
</code></pre>

<h3 id="beispiel_15">Beispiel</h3>
<pre><code class="cs">//Speichert für jeden Bar die Spanne in Ticks zwischen dem Hoch und dem Tief
myDataSeries.Set((long) ((High[0] - Low[0]) / TickSize));
</code></pre>

<h2 id="stringseries">StringSeries</h2>
<h3 id="beschreibung_22">Beschreibung</h3>
<p>StringSeries ist eine Datenserie, die für jeden Bar einen String-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.</p>
<h3 id="neue-datenserie-anlegen_5">Neue DatenSerie anlegen</h3>
<p>Im Bereich für die Deklaration von Variablen eine neue Variable anlegen:</p>
<pre><code class="cs">//Variablendeklaration
private StringSeries myDataSeries;
</code></pre>

<p>In der Methode OnInit() dieser Variable eine neue Instanz von StringSeries zuweisen:</p>
<pre><code class="cs">protected override void OnInit()
{
myDataSeries = new StringSeries(this);
CalculateOnClosedBar = true;
}
</code></pre>

<h3 id="werte-zuweisen_6">Werte zuweisen</h3>
<p>Der Datenserie an aktueller Position einen Wert zuweisen:</p>
<pre><code class="cs">myDataSeries.Set(string Value);
</code></pre>

<p>Einen Wert in der Vergangenheit in die Datenserie schreiben:</p>
<pre><code class="cs">myDataSeries.Set(int barsAgo, string Value);
</code></pre>

<h3 id="werte-loschen_6">Werte löschen</h3>
<p>Den aktuellen Wert aus der Datenserie entfernen:</p>
<pre><code class="cs">myDataSeries.Reset();
</code></pre>

<p>Einen Wert in der Vergangenheit aus der Datenserie entfernen:</p>
<pre><code class="cs">myDataSeries.Reset(int barsAgo);
</code></pre>

<h3 id="werte-auf-gultigkeit-prufen_6">Werte auf Gültigkeit prüfen</h3>
<pre><code class="cs">myDataSeries.ContainsValue(int barsAgo);
</code></pre>

<h3 id="wert-auslesen_6">Wert auslesen</h3>
<pre><code class="cs">Print (&quot;Für den Bar von &quot; + Time[0] + &quot;ist der Wert der Datenserie: &quot; + myDataSeries[0]);
</code></pre>

<h3 id="beispiel_16">Beispiel</h3>
<pre><code class="cs">//Speichert für jeden Bar den Wochentag (Montag, Dienstag ...)
myDataSeries.Set(string.Format(&quot;{0:dddd}&quot;, Time[0]));
</code></pre>

<h2 id="dayofweek">DayOfWeek</h2>
<h3 id="beschreibung_23">Beschreibung</h3>
<p>"DayOfWeek" gibt den zu einem DateTime-Wert, wie z.B. dem Zeitstempel eines Bars, gehörenden Wochentag aus.</p>
<p>Darüberhinaus sind natürlich auch alle Methoden verwendbar, die in C# für DateTime-Objekte definiert sind, z.B. Day, Month, Year, Hour, Minute, Second, DayOfWeek usw.</p>
<p>Siehe <a href="http://msdn.microsoft.com/de-de/library/03ybds8y.aspx"><em>http://msdn.microsoft.com/de-de/library/03ybds8y.aspx</em></a></p>
<h3 id="definition_1">Definition</h3>
<p>Eigenschaft DayOfWeek</p>
<p>public enum DayOfWeek
-   DayOfWeek.Monday
-   DayOfWeek.Tuesday
-   DayOfWeek.Wednesday
-   DayOfWeek.Thursday
-   DayOfWeek.Friday
-   DayOfWeek.Saturday
-   DayOfWeek.Sunday</p>
<h3 id="beispiele_4">Beispiele</h3>
<pre><code class="cs">//Ausgabe des Wochentages für jeden Bar
Print(Time[0].DayOfWeek);
//An einem Freitag keine Trades ausführen
if (Time[0].DayOfWeek == DayOfWeek.Friday)
return;
</code></pre>

<h2 id="displacement">Displacement</h2>
<h3 id="beschreibung_24">Beschreibung</h3>
<p>Mit der Angabe Displacement kann eine gezeichnete Indikatorlinie auf der Zeitachse (x-Achse) nach links bzw. rechts verschoben werden.
Die Eigenschaft kann im Script abgefragt werden und liefert einen int-Wert.</p>
<p>Blue line: Displacement = 0 (Original)
Red line: Displacement = -5
Green line: Displacement = +5</p>
<p><img alt="Displacement" src="../media/image13.png" /></p>
<h3 id="verwendung_14">Verwendung</h3>
<p>Displacement</p>
<h3 id="parameter_12">Parameter</h3>
<p>int Offfset Anzahl Bars, um die der Indikator verschoben werden soll.</p>
<h3 id="beispiel_17">Beispiel</h3>
<pre><code class="cs">protected override void OnInit()
{
Add(new (Color.FromKnownColor(KnownColor.Red), &quot;MyPlot1&quot;));
//Displacement of the plot by one bar to the right
Displacement = 1;
}
</code></pre>

<h2 id="email-function">Email function</h2>
<h3 id="beschreibung_25">Beschreibung</h3>
<p>Override-Methode zum Senden von E-Mails.</p>
<h3 id="parameter_13">Parameter</h3>
<p>keine</p>
<h3 id="ruckgabewert_3">Rückgabewert</h3>
<p>string</p>
<h3 id="verwendung_15">Verwendung</h3>
<p>Verwendet für komplizierte Berechnung auf einem letzten Bar</p>
<h3 id="beispiel_18">Beispiel</h3>
<pre><code class="cs">protected override void OnOrderExecution(IExecution execution)
{
if (execution.Order != null &amp;&amp; execution.Order.OrderState == OrderState.Filled)
{
if (oEnter != null &amp;&amp; execution.Name == oEnter.Name)
{
// Enter-Order gefüllt
if (_sendMail) this.SendEmail(Core.AccountManager.Core.Settings.MailDefaultFromAddress, Core.PreferenceManager.DefaultEmailAddress,
execution.Instrument.Symbol + &quot; order &quot; + execution.Name + &quot; executed.&quot;, &quot;The order for &quot; + execution.Instrument.Name + &quot; was executed. Invest: &quot; + (Trade.Quantity * Trade.AvgPrice).ToString(&quot;F2&quot;));
}
else if (oTStop != null &amp;&amp; execution.Name == oTStop.Name)
{
OrderStatus = 0; // Trend-Stopp-Order gefüllt
if (_sendMail) this.SendEmail(Core.AccountManager.Core.Settings.MailDefaultFromAddress, Core.PreferenceManager.DefaultEmailAddress,
execution.Instrument.Symbol +&quot; order &quot; + execution.Name + &quot; executed.&quot;,
execution.Instrument.Symbol +&quot; order &quot; + execution.Name + &quot; executed. Profit:&quot; + Trade.ClosedProfitLoss.ToString(&quot;F2&quot;));
}
}
}
</code></pre>

<h2 id="firsttickofbar">FirstTickOfBar</h2>
<h3 id="beschreibung_26">Beschreibung</h3>
<p>FirstTickOfBar ist eine Eigenschaft, vom Type bool, die immer dann "true" ergibt, wenn der aktuell hereinkommende Tick einem neuen Bar zugeordnet wird, dieser Tick also der erste Tick eines neuen Bars ist.
Die Eigenschaft kann nur sinnvoll eingesetzt werden, wenn der Indikator bzw. die Startegie im Tick-by-Tick-Modus läuft, d.h. wenn CalculateOnClosedBar = false gesetzt ist und der verwendete Datenfeed Realtime-Kurse liefert.
Bei Verwendung von EoD-Daten in einem Tageschart ist FirstTickOfBar für den letzten Bar immer true.
FirstTickOfBar sollte nicht außerhalb der OnCalculate() Methode verwendet werden..</p>
<p>siehe auch <a href="#barstickscountforlastbar"><em>Bars.TicksCountForLastBar</em></a>.</p>
<h3 id="verwendung_16">Verwendung</h3>
<p>FirstTickOfBar</p>
<h3 id="beispiel_19">Beispiel</h3>
<pre><code class="cs">// Innerhalb einer Tick-By-Tick-Strategie einen Teil nur Bar-by-Bar ausführen
if (FirstTickOfBar)
{
if (CCI(20)[1] &lt; -250)
OpenLong();
return;
}
</code></pre>

<h2 id="firsttickofbarmtf">FirstTickOfBarMtf</h2>
<h3 id="beschreibung_27">Beschreibung</h3>
<p>FirstTickOfBarMtf ist die  <strong>multi-time frame</strong> Variante von <a href="#firsttickofbar"><em>FirstTickOfBar</em></a>.</p>
<p>Die Einstellung von CalculateOnClosedBar wirkt sich nur auf die primäre Zeiteinheit (Chart-Zeiteinheit) aus. Wenn jedoch mit multi-bars gearbeitet wird, werden die Ticks der sekundären Zeiteinheit(en) unabhängig von der Einstellung von CalculateOnClosedBar  immer Tick-by-Tick bereitgestellt.
Mit Hilfe von FirstTickOfBarMtf, ist es möglich, festzustellen, wann in einer sekundären Zeiteinheit ein neuer Bar beginnt.   </p>
<h3 id="verwendung_17">Verwendung</h3>
<p>FirstTickOfBarMtf(ProcessingBarSeriesIndex)</p>
<h3 id="parameter_14">Parameter</h3>
<p>FirstTickOfBarMtf(ProcessingBarSeriesIndex).</p>
<p>siehe <a href="#processingbarseriesindex"><em>ProcessingBarSeriesIndex</em></a>.</p>
<h3 id="beispiel_20">Beispiel</h3>
<pre><code class="cs">if (FirstTickOfBarMtf(ProcessingBarSeriesIndex))
Print(&quot;A new bar has begun.&quot;);
</code></pre>

<h2 id="getcurrentask">GetCurrentAsk()</h2>
<h3 id="beschreibung_28">Beschreibung</h3>
<p>Die Methode GetCurrentAsk() liefert den aktuellen Kurs auf der Ask-Seite des Orderbuchs. Wenn AgenaTrader keine Level1-Daten zur Verfügung stehen, liefert die Funktion den Kurs des letzten Umsatzes.</p>
<p>siehe auch  <a href="#getcurrentbid"><em>GetCurrentBid()</em></a> und <a href="#onlevel1"><em>OnLevel1()</em></a>.</p>
<h3 id="verwendung_18">Verwendung</h3>
<p>GetCurrentAsk()</p>
<h3 id="ruckgabewert_4">Rückgabewert</h3>
<p>double value</p>
<h3 id="parameter_15">Parameter</h3>
<p>keiner</p>
<h3 id="beispiel_21">Beispiel</h3>
<p>Wenn eine Einstiegsbedingung erfüllt ist, soll 1 Kontrakt zum aktuellen Ask-Kurs verkauft werden.</p>
<pre><code class="cs">private IOrder entryOrder = null;
protected override void OnCalculate()
{
// Einstiegsbedingung
if (Close[0] &lt; SMA(20)[0] &amp;&amp; entryOrder == null)
// Verkauf 1 Kontrakt zum aktuellen AskKurs
entryOrder = SubmitOrder(0, OrderAction.SellShort, OrderType.Limit, 1, GetCurrentAsk(), 0, &quot;&quot;, &quot;Enter short&quot;);
}
</code></pre>

<h2 id="getcurrentaskvolume">GetCurrentAskVolume()</h2>
<h3 id="beschreibung_29">Beschreibung</h3>
<p>Die Methode GetCurrentAskVolume() liefert das aktuelle Volumen auf der Ask-Seite des Orderbuchs. Diese Funktion ist nur lauffähig, wenn der Datenanbieter Level2-Daten liefert.</p>
<p>siehe auch <a href="#getcurrentbidvolume"><em>GetCurrentBidVolume()</em></a>, <a href="#getcurrentbid"><em>GetCurrentBid()</em></a> und <a href="#onlevel1"><em>OnLevel1()</em></a>.</p>
<h3 id="verwendung_19">Verwendung</h3>
<p>GetCurrentAskVolume()</p>
<h3 id="ruckgabewert_5">Rückgabewert</h3>
<p>Long  value</p>
<h3 id="parameter_16">Parameter</h3>
<p>keiner</p>
<h3 id="beispiel_22">Beispiel</h3>
<pre><code class="cs">protected override void OnCalculate()
{
   if (GetCurrentAskVolume() &lt; GetCurrentBidVolume())
       Print(&quot;AskVolume {0} &lt; BidVolume {1}&quot;, GetCurrentAskVolume(), GetCurrentBidVolume());
}
</code></pre>

<h2 id="getcurrentbid">GetCurrentBid()</h2>
<h3 id="beschreibung_30">Beschreibung</h3>
<p>Die Methode GetCurrentBid() liefert den aktuellen Kurs auf der Bid-Seite des Orderbuchs. Wenn AgenaTrader keine Level1-Daten zur Verfügung stehen, liefert die Funktion den Kurs des letzten Umsatzes.</p>
<p>siehe auch <a href="#getcurrentask"><em>GetCurrentAsk()</em></a> und <a href="#onlevel1"><em>OnLevel1()</em></a>.</p>
<h3 id="verwendung_20">Verwendung</h3>
<p>GetCurrentBid()</p>
<h3 id="ruckgabewert_6">Rückgabewert</h3>
<p>double value</p>
<h3 id="parameter_17">Parameter</h3>
<p>keiner</p>
<h3 id="beispiel_23">Beispiel</h3>
<p>Wenn eine Einstiegsbedingung erfüllt ist, soll 1 Kontrakt zum aktuellen Bid-Kurs gekauft werden.</p>
<pre><code class="cs">private IOrder entryOrder = null;
protected override void OnCalculate()
{
// Einstiegsbedingung
if (Close[0] &gt; SMA(20)[0] &amp;&amp; entryOrder == null)
// Kauf 1 Kontrakt zum aktuellen BidKurs
entryOrder = SubmitOrder(0, OrderAction.Buy, OrderType.Limit, 1, GetCurrentBid(), 0, &quot;&quot;, &quot;Enter long&quot;);
}
</code></pre>

<h2 id="getcurrentbidvolume">GetCurrentBidVolume()</h2>
<h3 id="beschreibung_31">Beschreibung</h3>
<p>Die Methode GetCurrentBidVolume() liefert das aktuelle Volumen auf der Bid-Seite des Orderbuchs. Diese Funktion ist nur lauffähig, wenn der Datenanbieter Level2-Daten liefert.</p>
<p>siehe auch <a href="#getcurrentaskvolume"><em>GetCurrentAskVolume</em></a>, <a href="#getcurrentbid"><em>GetCurrentBid()</em></a> und <a href="#onlevel1"><em>OnLevel1()</em></a>.</p>
<h3 id="verwendung_21">Verwendung</h3>
<p>GetCurrentBidVolume()</p>
<h3 id="ruckgabewert_7">Rückgabewert</h3>
<p>Long value</p>
<h3 id="parameter_18">Parameter</h3>
<p>keiner</p>
<h3 id="beispiel_24">Beispiel</h3>
<pre><code class="cs">protected override void OnCalculate()
{
   if (GetCurrentAskVolume() &lt; GetCurrentBidVolume())
       Print(&quot;AskVolume {0} &lt; BidVolume {1}&quot;, GetCurrentAskVolume(), GetCurrentBidVolume());
}
</code></pre>

<h2 id="getcurrentprice">GetCurrentPrice()</h2>
<h3 id="beschreibung_32">Beschreibung</h3>
<p>Die Methode GetCurrentPrice() liefert den aktuellen Kurs (Latest). Wenn AgenaTrader keine Level1-Daten zur Verfügung stehen, liefert die Funktion den Kurs des letzten Umsatzes.</p>
<p>siehe auch <a href="#getcurrentask"><em>GetCurrentAsk</em></a>, <a href="#getcurrentbid"><em>GetCurrentBid()</em></a> und <a href="#onlevel1"><em>OnLevel1()</em></a>.</p>
<h3 id="verwendung_22">Verwendung</h3>
<p>GetCurrentPrice()</p>
<h3 id="ruckgabewert_8">Rückgabewert</h3>
<p>keiner</p>
<h3 id="parameter_19">Parameter</h3>
<p>double value</p>
<h3 id="beispiel_25">Beispiel</h3>
<p>Wenn eine Einstiegsbedingung erfüllt ist, soll 1 Kontrakt zum aktuellen Kurs gekauft werden.</p>
<pre><code class="cs">private IOrder entryOrder = null;

protected override void OnCalculate()
{
   // Einstiegsbedingung
   if (Close[0] &gt; SMA(20)[0] &amp;&amp; entryOrder == null)
       // Kauf 1 Kontrakt zum aktuellen BidKurs
       entryOrder = SubmitOrder(0, OrderAction.Buy, OrderType.Limit, 1, GetCurrentPrice(), 0,&quot;&quot;, &quot;Enter Long&quot;);
}
</code></pre>

<h2 id="getcurrentspread">GetCurrentSpread()</h2>
<h3 id="beschreibung_33">Beschreibung</h3>
<p>Die Methode GetCurrentSpread() liefert den aktuellen Spread.</p>
<p>siehe auch <a href="#getcurrentask"><em>GetCurrentAsk</em></a>, <a href="#getcurrentbid"><em>GetCurrentBid()</em></a> and <a href="#onlevel1"><em>OnLevel1()</em></a>.</p>
<h3 id="verwendung_23">Verwendung</h3>
<p>GetCurrentSpread()</p>
<h3 id="ruckgabewert_9">Rückgabewert</h3>
<p>keiner</p>
<h3 id="parameter_20">Parameter</h3>
<p>double</p>
<h3 id="beispiel_26">Beispiel</h3>
<p>Wenn eine Anfangsbedingung erfüllt ist, sollte ein Vertrag zum aktuellen Wechselkurs gekauft werden.</p>
<pre><code class="cs">protected override void OnCalculate()
{
       Print(&quot;Der aktuelle Spread ist {0}&quot;, GetCurrentSpread());
}
</code></pre>

<h2 id="getdayasint">GetDayAsInt()</h2>
<h3 id="beschreibung_34">Beschreibung</h3>
<p>GetDayAsIntist eine Methode, die sich speziell an unerfahrene Programmierer richtet, die mit der durchaus komplizierten .Net-DateTime-Struktur aus C# Schwierigkeiten haben.
Erfahrene Programmierer können die DateTime-Funktionen auch direkt verwenden.</p>
<p>GetDayAsInt liefert eine int-Repräsentation im Format yyyyMMdd.
(yyyy = Jahr,  MM = Monat, dd = Tag)</p>
<p>Die Zahl für den 13.08.2012 lautet damit 20120813.</p>
<p>Siehe auch <a href="#gettimeasint"><em>GetTimeAsInt</em></a>.</p>
<p>Hilfe zu DateTime: <a href="http://msdn.microsoft.com/de-de/library/system.datetime.aspx"><em>http://msdn.microsoft.com/de-de/library/system.datetime.aspx</em></a></p>
<h3 id="verwendung_24">Verwendung</h3>
<p>GetDayAsInt(DateTime time)</p>
<h3 id="beispiele_5">Beispiele</h3>
<pre><code class="cs">// Am 11. September besser keine Trades eingehen
if (GetDayAsInt(Time[0]) = 20130911)
return;
</code></pre>

<h2 id="getserieshighestvalue">GetSeriesHighestValue</h2>
<h3 id="beschreibung_35">Beschreibung</h3>
<p>Die Methode GetSeriesHighestValue() sucht in einer vorgegebenen Anzahl von Perioden nach dem höchsten Bar und gibt an, vor wievielen Bars dieser höchste Bar zu finden ist</p>
<p>Siehe auch <a href="#getserieslowestvalue"><em>GetSeriesLowestValue()</em></a>.</p>
<h3 id="parameter_21">Parameter</h3>
<p>period Anzahl von Bars, innerhalb derer gesucht werden soll</p>
<p>series Jede Datenserie, wie Close, High, Low usw.</p>
<h3 id="ruckgabewert_10">Rückgabewert</h3>
<pre><code class="cs">int barsAgo Vor wievielen Bars trat das Hoch auf
</code></pre>

<h3 id="verwendung_25">Verwendung</h3>
<pre><code class="cs">GetSeriesHighestValue(IDataSeries series, int period)
</code></pre>

<h3 id="beispiele_6">Beispiele</h3>
<pre><code class="cs">// Vor wievielen Bars lag das höchste Hoch der aktuellen Session?
Print(GetSeriesHighestValue(High, Bars.BarsCountForSession - 1));
// Welchen Kurs hatte das bisher höchste Open der aktuellen Session?
Print(&quot;The highest price for the session was: &quot; + Open[GetSeriesHighestValue(High, Bars.BarsCountForSession - 1)]);
</code></pre>

<h2 id="getserieslowestvalue">GetSeriesLowestValue</h2>
<h3 id="beschreibung_36">Beschreibung</h3>
<p>Die Methode  GetSeriesLowestValue() sucht in einer vorgegebenen Anzahl von Perioden nach dem tiefsten Bar und gibt an, vor wievielen Bars dieser tiefste Bar zu finden ist.</p>
<p>Siehe auch <a href="#getserieshighestvalue"><em>GetSeriesHighestValue()</em></a>.</p>
<h3 id="parameter_22">Parameter</h3>
<p>period Anzahl von Bars, innerhalb derer gesucht werden soll</p>
<p>series Jede Datenserie, wie Close, High, Low usw.</p>
<h3 id="ruckgabewert_11">Rückgabewert</h3>
<p><strong>int</strong> barsAgo Vor wievielen Bars trat das Tief auf</p>
<h3 id="verwendung_26">Verwendung</h3>
<pre><code class="cs">GetSerieLowestValue(IDataSeries series, int period)
</code></pre>

<h3 id="beispiele_7">Beispiele</h3>
<pre><code class="cs">// Vor wievielen Bars lag das tiefste Tief der aktuellen Session?
Print(GetSeriesLowestValue(Low, Bars.BarsCountForSession - 1));
// Welchen Kurs hatte das bisher tiefste Open der aktuellen Session?
Print(&quot;The lowest open price of the current session was: &quot; + Open[GetSeriesLowestValue(Low, Bars.BarsCountForSession - 1)]);
</code></pre>

<h2 id="gettimeasint">GetTimeAsInt()</h2>
<h3 id="beschreibung_37">Beschreibung</h3>
<p>GetTimeAsInt ist eine Methode, die sich speziell an unerfahrene Programmierer richtet, die mit der durchaus komplizierten .Net-DateTime-Struktur aus C# Schwierigkeiten haben.
Erfahrene Programmierer können die DateTime-Funktionen auch direkt verwenden..</p>
<p>GetTimeAsInt liefert eine int-Repräsentation im Format HHmmss.
(HH = Stunde,  mm = Minute, ss = Sekunde)</p>
<p>Die Uhrzeit 07:30 Uhr wird dargestellt als 73000 und 14:15:12 wird zu 141512.</p>
<p>Siehe auch <a href="#getdayasint"><em>GetDayAsInt</em></a>.</p>
<p>Hilfe zu DateTime: <a href="http://msdn.microsoft.com/de-de/library/system.datetime.aspx"><em>http://msdn.microsoft.com/de-de/library/system.datetime.aspx</em></a></p>
<h3 id="verwendung_27">Verwendung</h3>
<p>GetTimeAsInt(DateTime time)</p>
<h3 id="beispiele_8">Beispiele</h3>
<pre><code class="cs">// Nur zwischen 08:15 Uhr und 16:35 Uhr Trades eingehen
if (GetTimeAsInt(Time[0]) &gt;= 81500 &amp;&amp; GetTimeAsInt(Time[0]) &lt;= 163500)
{
// irgendeine Handelslogic
}
</code></pre>

<h2 id="historical">Historical</h2>
<h3 id="beschreibung_38">Beschreibung</h3>
<p>Mit Historical läßt sich überprüfen, ob AgenaScript mit historen Daten oder mit Real-Time-Daten arbeitet.
Solange OnCalculate() für historische Daten aufgerufen wird, ist Historical = true, in dem Moment, in dem die Verarbeitung von Live-Daten beginnt, wird Historical = false.
Während ein Backtest ausgeführt wird, ist Historical immer true.</p>
<h3 id="verwendung_28">Verwendung</h3>
<p>Historical</p>
<h3 id="ruckgabewert_12">Rückgabewert</h3>
<p><strong>true</strong> bei Verarbeitung von historischen Daten
<strong>false</strong> bei Verarbeitung von Real-Time-Daten</p>
<h3 id="beispiele_9">Beispiele</h3>
<pre><code class="cs">protected override void OnCalculate()
{
// Nur für realtime-Daten ausführen
if (IsHistoricalMode) return;
// irgendeine Handelslogik
}
</code></pre>

<h2 id="inputpricetype">InputPriceType</h2>
<h3 id="beschreibung_39">Beschreibung</h3>
<p>Die Eigenschaft InputPriceType legt fest, welche Kursreihe bei der Berechnung in Indikatoren als Standard verwendet werden soll, wenn keine Datenreihe explizit angegeben ist.
InputPriceType kann in der OnInit()-Methode stehen. Die Angabe hat dann für alle weiteren Berechnungen im Indikator Gültigkeit.
Steht InputPriceType in OnCalculate(), gilt die Änderung der Eingangsdatenreihe ab der nächsten Anweisung.
Jedes weitere Auftreten von InputPriceType wird ignoriert!</p>
<p>Siehe auch  <a href="#pricetype"><em>PriceType</em></a></p>
<h3 id="verwendung_29">Verwendung</h3>
<pre><code class="cs">InputPriceType
</code></pre>

<h3 id="beispiel1">Beispiel1</h3>
<pre><code class="cs">protected override void OnInit()
{
ClearTraceWindow();
InputPriceType = PriceType.Low;
}
protected override void OnCalculate()
{
// Die Eingangsdatenreihe für den Indikator (Input) ist Low
Print(Low[0] + &quot; &quot; + InSeries[0] + &quot; &quot; + InputPriceType);
}
</code></pre>

<h3 id="beispiel2">Beispiel2</h3>
<pre><code class="cs">protected override void OnCalculate()
{
// Diese Werte sind identisch,
     // da standardmäßig Close als Inputdatenreihe verwendet wird
Print(SMA(20)[0] + &quot; &quot; + SMA(Close, 20)[0]);
InputPriceType = PriceType.Low;
// ab hier wird Low anstatt Close als Standard verwendet
// Die beiden Werte sind identisch
Print(SMA(20)[0] + &quot; &quot; + SMA(Low, 20)[0]);
InputPriceType = PriceType.High;
// Diese Anweisung wird ignoriert.
     // Es gilt weiterhin Input = Low !!!
}
</code></pre>

<h2 id="instrument">Instrument</h2>
<h3 id="beschreibung_40">Beschreibung</h3>
<p>Mit Instrument werden Informationen zum Handelsinstrument (Aktie, Future etc.) bereitgestellt, für welches ein Indikator, eine Strategie usw. gerade läuft.</p>
<p>Ausführliche Details finden sich unter <em>Instruments</em>.</p>
<h2 id="isadddrawingstopricepanel">IsAddDrawingsToPricePanel</h2>
<h3 id="beschreibung_41">Beschreibung</h3>
<p>Die Eigenschaft  "IsAddDrawingsToPricePanel" legt fest, in welchem Panel Zeichenobjekte gezeichnet werden.</p>
<pre><code class="cs">IsAddDrawingsToPricePanel = true (default)
</code></pre>

<p>Zeichenobjekte werden im Preischart gezeichnet</p>
<pre><code class="cs">IsAddDrawingsToPricePanel = false
</code></pre>

<p>Zeichenobjekte werden in dem Panel (Subchart) gezeichnet, das dem Indikator zugeordnet ist.</p>
<p>Ist der Indikator bereits dem Preischart zugeordnet (Overlay = true) ist diese Eigenschaft wirkungslos, d.h. es wird in diesem Fall kein neuer Subchart geöffnet.</p>
<p>Die Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false)</p>
<h3 id="verwendung_30">Verwendung</h3>
<p>IsAddDrawingsToPricePanel</p>
<h3 id="beispiel_27">Beispiel</h3>
<pre><code class="cs">protected override void OnInit()
{
// Indikator in einem neuen Subchart zeichnen
IsOverlay = false;
(Color.FromKnownColor(KnownColor.Red), &quot;MyPlot1&quot;));
// Zeichenobjekte im Preischart zeichnen
IsAddDrawingsToPricePanel = true;
}
protected override void OnCalculate()
{
// zeichnet im Preischart eine vertikale Linie am Bar von vor 5 Perioden
AddChartVerticalLine(&quot;MyVerticalLine&quot;, 5, Color.Black);
}
</code></pre>

<h2 id="isautoadjustablescale">IsAutoAdjustableScale</h2>
<h3 id="beschreibung_42">Beschreibung</h3>
<p>Auto scale is a property of indicators that can be set within the OnInit() method.</p>
<pre><code class="cs">IsAutoAdjustableScale = true (default)
</code></pre>

<p>Die Preisachse (y-Achse) des Charts wird so eingestellt, dass alle Plots und Lines eines Indikators bzw. einer Strategie im Chart sichtbar sind.</p>
<pre><code class="cs">IsAutoAdjustableScale = false
</code></pre>

<p>Plots und Lines eines Indikators bzw. einer Strategie werden nicht in die Skalierung der Preisachse (y-Achse) eines Charts mit einbezogen. Sie können auch ausserhalb des sichtbaren Chartbereichs liegen.</p>
<p>Die Eigenschaft kann abgefragt werden, und liefert "true" bzw. "false".</p>
<h3 id="verwendung_31">Verwendung</h3>
<p>IsAutoAdjustableScale</p>
<h3 id="beispiel_28">Beispiel</h3>
<pre><code class="cs">protected override void OnInit()
{
//Chart so skalieren, dass alle Zeichenobjekte sichtbar sind
IsAutoAdjustableScale = true;
}
</code></pre>

<h2 id="isoverlay">IsOverlay</h2>
<h3 id="beschreibung_43">Beschreibung</h3>
<p>Die Eigenschaft Overlay legt fest, ob die Indikatorausgaben, wie Plots und Linien, im Preischart über die Kursbars gezeichnet werden oder ob ein neues separates Chartfenster unterhalb des Preischarts geöffnet wird.</p>
<pre><code class="cs">IsOverlay = true
</code></pre>

<p>Es wird über den Kurs gezeichnet (wie z.B. ein <em>SMA</em>)</p>
<pre><code class="cs">IsOverlay = false (default)
</code></pre>

<p>Es wird ein separates Chartfenster geöffnet (wie z.B. ein <em>RSI</em>)</p>
<p>Die Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false).</p>
<h3 id="verwendung_32">Verwendung</h3>
<p>IsOverlay</p>
<h3 id="beispiel_29">Beispiel</h3>
<pre><code class="cs">protected override void OnInit()
{
(Color.FromKnownColor(KnownColor.Red), &quot;MyPlot1&quot;));
//Der Indikator soll in einem separaten Fenster dargestellt werden
IsOverlay = false;
}
</code></pre>

<h2 id="isprocessingbarindexlast">IsProcessingBarIndexLast</h2>
<h3 id="description_1">Description</h3>
<p>Indicates if current bar is last in calculation.</p>
<h3 id="parameter_23">Parameter</h3>
<p>None</p>
<h3 id="return-value">Return value</h3>
<p>Type bool</p>
<h3 id="usage">Usage</h3>
<p>used for complicated calculation on a last bar</p>
<h3 id="example">Example</h3>
<pre><code class="cs">protected override void OnCalculate()
{
            base.OnCalculate();
            if (!IsProcessingBarIndexLast)
                return;
            bool isUpdated;
}
</code></pre>

<h2 id="isserierising">IsSerieRising()</h2>
<h3 id="beschreibung_44">Beschreibung</h3>
<p>Mit der Methode IsSerieRising() kann geprüft werden, ob eine "ist steigend"-Bedingung vorliegt, d.h. ob der aktuelle Wert größer ist als der Wert des vorhergehenden Bars.</p>
<p>Siehe auch <a href="#crossabove"><em>CrossAbove()</em></a>, <a href="#crossbelow"><em>CrossBelow()</em></a>, <a href="#isserierising"><em>IsSerieRising()</em></a>, <a href="#isseriefalling"><em>IsSerieFalling()</em></a>.</p>
<h3 id="verwendung_33">Verwendung</h3>
<pre><code class="cs">IsSerieRising(IDataSeries series)
</code></pre>

<h3 id="ruckgabewert_13">Rückgabewert</h3>
<p><strong>true</strong> wenn die Datenreihe steigt
<strong>false</strong> wenn die Datenreihe nicht steigt</p>
<h3 id="parameter_24">Parameter</h3>
<p>series eine Datenserie, wie z.B. ein Indikator, Close, High o.ä</p>
<h3 id="beispiele_10">Beispiele</h3>
<pre><code class="cs">// Prüfen, ob der SMA(20) steigt
if (IsSerieRising(SMA(20)))
Print(&quot;The SMA(20) is currently rising.&quot;);
</code></pre>

<h2 id="isseriesfalling">IsSeriesFalling()</h2>
<h3 id="beschreibung_45">Beschreibung</h3>
<p>Mit der Methode  IsSeriesFalling() kann geprüft werden, ob eine "ist fallend"-Bedingung vorliegt, d.h. ob der aktuelle Wert kleiner ist als der Wert des vorhergehenden Bars.</p>
<p>Siehe auch  <a href="#crossabove"><em>CrossAbove()</em></a>, <a href="#crossbelow"><em>CrossBelow()</em></a>, <a href="#isserierising"><em>IsSerieRising()</em></a>, <a href="#isseriefalling"><em>IsSerieFalling()</em></a>.</p>
<h3 id="verwendung_34">Verwendung</h3>
<pre><code class="cs">IsSerieFalling(IDataSeries series)
</code></pre>

<h3 id="ruckgabewert_14">Rückgabewert</h3>
<p><strong>true</strong> wenn die Datenreihe fällt
<strong>false</strong> wenn die Datenreihe nicht fällt</p>
<h3 id="parameter_25">Parameter</h3>
<p>series eine Datenserie, wie z.B. ein Indikator, Close, High o.ä</p>
<h3 id="beispiele_11">Beispiele</h3>
<pre><code class="cs">// Prüfen, ob der SMA(20) fällt
if (IsSerieFalling(SMA(20)))
Print(&quot;The SMA(20) is currently falling.&quot;);
</code></pre>

<h2 id="isshowchartverticalgrid">IsShowChartVerticalGrid</h2>
<h3 id="beschreibung_46">Beschreibung</h3>
<p>Die Eigenschaft IsShowChartVerticalGrid legt fest, ob in regelmäßigen Abständen vertikale Linien im Chart (das sog. vertikale Grid) angezeigt werden sollen.</p>
<p><strong>IsShowChartVerticalGrid = true (default)</strong></p>
<p>Vertikale Gitternetzlinien werden im Chart angezeigt.</p>
<p><strong>IsShowChartVerticalGrid = false</strong></p>
<p>Vertikale Gitternetzlinien werden nicht im Chart angezeigt.</p>
<p>Die Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false).</p>
<h3 id="verwendung_35">Verwendung</h3>
<p>IsShowChartVerticalGrid</p>
<h3 id="beispiel_30">Beispiel</h3>
<pre><code class="cs">protected override void OnInit()
{
(Color.FromKnownColor(KnownColor.Black), &quot;MyPlot1&quot;));
// Vertikale Gitternetzlinien sollen nicht im Chart angezeigt werden
IsShowChartVerticalGrid = false;
}
</code></pre>

<h2 id="isshowindatabox">IsShowInDataBox</h2>
<h3 id="beschreibung_47">Beschreibung</h3>
<p>Die Eigenschaft  "IsShowInDataBox" gibt an, ob die Werte des Indikators (Datenserien) in der DataBox des Charts enthalten sein sollen oder nicht.</p>
<p>Die Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false)</p>
<pre><code class="cs">IsShowInDataBox = true (default)
</code></pre>

<p>Die Indikatorwerte werden in der DataBox angezeigt.</p>
<pre><code class="cs">IsShowInDataBox = false
</code></pre>

<p>Die Indikatorwerte werden nicht in der DataBox angezeigt.</p>
<p>Im Bild werden die Werte von 3 gleitenden Durchschnitten in der DataBox angezeigt.</p>
<p><img alt="IsShowInDataBox" src="../media/image14.png" /></p>
<h3 id="verwendung_36">Verwendung</h3>
<p>IsShowInDataBox</p>
<h3 id="beispiel_31">Beispiel</h3>
<pre><code class="cs">protected override void OnInit()
{
(Color.FromKnownColor(KnownColor.Black), &quot;MyPlot1&quot;));
//Werte sollen nicht in der DataBox angezeigt werden
IsShowInDataBox = false;
}
</code></pre>

<h2 id="isshowpricemarkers">IsShowPriceMarkers</h2>
<h3 id="beschreibung_48">Beschreibung</h3>
<p>Die Eigenschaft PaintPriceMarkers legt fest, ob für die Indikatorausgaben, am rechten Chartrand (in der Preisachse) die sog. PriceMarkers angezeigt werden sollen oder nicht. In manchen Fällen ist es sinnvoll, dies für eine bessere Übersicht im Chart auszuschalten.
<strong>IsShowPriceMarkers = true (default)</strong></p>
<p>PriceMarkers werden in der Preisachse angezeigt.</p>
<p><strong>IsShowPriceMarkers = false</strong></p>
<p>PriceMarkers werden nicht in der Preisachse angezeigt.</p>
<p>Die Eigenschaft kann imScript abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false).</p>
<h3 id="verwendung_37">Verwendung</h3>
<p>IsShowPriceMarkers</p>
<h3 id="beispiel_32">Beispiel</h3>
<pre><code class="cs">protected override void OnInit()
{
(Color.FromKnownColor(KnownColor.Black), &quot;MyPlot1&quot;));
//IsShowPriceMarkers sollen nicht angezeigt werden
IsShowPriceMarkers = false;
}
</code></pre>

<h2 id="level1args">Level1Args</h2>
<h3 id="beschreibung_49">Beschreibung</h3>
<p>Der Datentyp MarketDataEventArgs repräsentiert eine Änderung in den Level-I-Daten und wird als Parameter in der Funktion OnLevel1() verwendet.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>AskSize</td>
<td>Das aktuelle Ordervolumen auf der Ask-Seite.</td>
</tr>
<tr>
<td>AskPrice</td>
<td>Der aktuelle Ask-Kurs</td>
</tr>
<tr>
<td>BidSize</td>
<td>Das aktuelle Ordervolumen auf der Bid-Seite</td>
</tr>
<tr>
<td>BidPrice</td>
<td>Der aktuelle Bid-Kurs.</td>
</tr>
<tr>
<td>Instrument</td>
<td>Ein Objekt des Types IInstrument, das das Handelsinstrument beinhaltet, für welches die Level-I-Daten geliefert werden. Siehe <em>Instruments</em></td>
</tr>
<tr>
<td>LastPrice</td>
<td>Der letzte durch einen Umsatz entstandene Kurs</td>
</tr>
<tr>
<td>MarketDataType</td>
<td>Mögliche Werte sind: MarketDataType.Ask, MarketDataType.AskSize, MarketDataType.Bid, MarketDataType.BidSize, MarketDataType.Last, MarketDataType.Volume</td>
</tr>
<tr>
<td>Price</td>
<td>Tenthält den gleichen Wert wie LastPrice. Das Feld ist nur aus Kompatibilitätsgründen vorhanden.</td>
</tr>
<tr>
<td>Time</td>
<td>Ein DateTime-Wert, der den Zeitstempel der Änderung beinhaltet.</td>
</tr>
<tr>
<td>Volume</td>
<td>Ein long-Wert, der das Volumen, d.h. den letzten realen Umsatz angiebt.</td>
</tr>
</tbody>
</table>
<h3 id="beispiel_33">Beispiel</h3>
<p>siehe Beispiel unter <a href="#onlevel1"><em>OnLevel1()</em></a>.</p>
<h2 id="level2args">Level2Args</h2>
<h3 id="beschreibung_50">Beschreibung</h3>
<p>Der Datentyp  Level2Args repräsentiert eine Änderung in den Level-II-Daten (Markttiefe) und wird als Parameter in der Funktion OnLevel2() verwendet.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>MarketDataType</td>
<td>Mögliche Werte sind: MarketDataType.Ask, MarketDataType.Bid</td>
</tr>
<tr>
<td>MarketMaker</td>
<td>Ein string-Wert, der die Market Maker ID enthällt</td>
</tr>
<tr>
<td>Position</td>
<td>Ein int-Wert, der die Position innerhalb der Markttiefe angiebt</td>
</tr>
<tr>
<td>Operation</td>
<td>Steht für die Aktion, die durch die Änderung in einem Orderbuch ausgelöst wird.  Mögliche Werte sind: Operation.Insert, Operation.Remove, Operation.Update</td>
</tr>
<tr>
<td>Price</td>
<td>Eine double-Wert, der den jeweiligen Bid/Ask-Kurs</td>
</tr>
<tr>
<td>Time</td>
<td>Ein DateTime-Wert, der den Zeitstempel der Änderung beinhaltet</td>
</tr>
<tr>
<td>Volume</td>
<td>Ein long-Wert, der das Volumen angiebt</td>
</tr>
</tbody>
</table>
<h3 id="beispiel_34">Beispiel</h3>
<p>siehe Beispiel unter <a href="#onlevel2"><em>OnLevel2()</em></a>.</p>
<h2 id="levelline">LevelLine()</h2>
<h3 id="beschreibung_51">Beschreibung</h3>
<p>EinA LevelLine object wird genutzt, um eine horizontale Linie in einen Chart zu zeichnen. Üblicherweise sind dies obere und untere Triggerlinien wie z.B. beim RSI-Indikator die 70 und die 30 Linie.
Diese hier beschriebenen Linien sind nicht zu verwechseln mit der Linie aus den Zeichenobjekten  (siehe "AddChartHorizontalLine").
LevelLine objectwerden einem Indikator mit Hilfe der Add()-Methode hinzugefügt und damit in die Lines-Collection aufgenommen.</p>
<p>Siehe auch <a href="#onpaint"><em>OutputDescriptor</em></a>.</p>
<h3 id="parameter_26">Parameter</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Color</td>
<td>Linienfarbe</td>
</tr>
<tr>
<td>Name</td>
<td>Bezeichnung</td>
</tr>
<tr>
<td>Pen</td>
<td>ein Pen-Objekt</td>
</tr>
<tr>
<td>Value</td>
<td>Gibt an, bei welchem Wert auf der y-Achse (Preisachse) die Linie gezeichnet werden soll</td>
</tr>
</tbody>
</table>
<h3 id="verwendung_38">Verwendung</h3>
<pre><code class="cs">LevelLine(Color color, double value, string name)
LevelLine(Pen pen, double value, string name)
</code></pre>

<h3 id="weitere-informationen_1">Weitere Informationen</h3>
<p>Informationen zur Klasse Pen: <a href="http://msdn.microsoft.com/de-de/library/system.drawing.pen.aspx"><em>http://msdn.microsoft.com/de-de/library/system.drawing.pen.aspx</em></a></p>
<h3 id="beispiele_12">Beispiele</h3>
<pre><code class="cs">// Beispiel 1
// Eine Linie mit Standardwerten bei 70 in den Chart zeichnen
Add(new LevelLine(Color.Black, 70, &quot;Upper&quot;));
// Beispiel 2
// Eine Linie mit selbstdefinierten Werten in den Chart zeichnen
private LevelLine line;
private Pen pen;
protected override void OnInit()
{
// einen roten Stift mit der Linienstärke 1 definieren
pen = new Pen(Color.Red, 1);
// eine horizontale Linie bei 10 definieren
line = new LevelLine(pen, 10, &quot;MyLine&quot;);
// die oben def. Linie dem Indikator hinzufügen
Add(line);
}
// Beispiel 3
// Kurzform für die Linie aus Bespiel 2
Add(new LevelLine(new Pen(Color.Red, 1), 10, &quot;MyLine&quot;));
</code></pre>

<h2 id="log">Log()</h2>
<h3 id="beschreibung_52">Beschreibung</h3>
<p>Mit Log() ist es möglich, Ausgaben in das LogFile (Log Tab) von AgenaTrader zu schreiben. Es werden 5 verschiedene LogLevel unterstützt.</p>
<p>Hinweis: Ist der Log-Tab nicht sichtbar, kann er mit Tools-Log angezeigt werden.</p>
<h3 id="verwendung_39">Verwendung</h3>
<pre><code class="cs">**Log**(string message, LogLevel logLevel)
</code></pre>

<h3 id="parameter_27">Parameter</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>message</td>
<td>Text (message)</td>
</tr>
<tr>
<td>logLevel</td>
<td>Mögliche Werte sind: InfoLogLevel.Info, InfoLogLevel.Message, InfoLogLevel.Warning, InfoLogLevel.ShowAlert, InfoLogLevel.Error</td>
</tr>
</tbody>
</table>
<h3 id="beispiel_35">Beispiel</h3>
<pre><code class="cs">//Tab protocol
Log(&quot;Das ist eine Information.&quot;, InfoLogLevel.Info); //white
Log(&quot;Das ist eine Nachricht.&quot;, InfoLogLevel.Message); // white
Log(&quot;Das ist eine Warnung.&quot;, InfoLogLevel.Warning); // blue
Log(&quot;Das ist ein Alarm.&quot;, InfoLogLevel.ShowAlert); //green
Log(&quot;Das ist ein Fehler.&quot;, InfoLogLevel.Error); // red
//Tab messages
Log(&quot;This is a message (messages).&quot;, InfoLogLevel.Message); //white
//PopUp &amp; protocoll
Log(&quot;This is an alert popup window.&quot;, InfoLogLevel.ShowAlert); //green

//Output-Tab:
//InfoLogLevel.Message = send to Tab &quot;Messages&quot; not &quot;Log&quot;

//Action:
/*
InfoLogLevel.Error: also the AT-Status-Line is red and flashes
InfoLogLevel.ShowAlert: opens also a modeless messagebox
*/

/*
Summary: * - InfoLogLevel.ShowAlert Color: green Tab: Log Action: modeless Messagebox * - InfoLogLevel.Warning Color: blue Tab: Log * - InfoLogLevel.Info Color: white Tab: Log * - InfoLogLevel.Error Color: red Tab: Log Action: AT-Status-Line: red + flashing (Error) * - InfoLogLevel.Message Color: white Tab: Messages
*/
</code></pre>

<p>Crossreference:
a crossreference to Print() and ShowAlert()</p>
<h2 id="occurred">Occurred</h2>
<h3 id="beschreibung_53">Beschreibung</h3>
<p>Diese DataSeries werden unter Bedingungen verwendet und geben an, ob ein Signal aufgetreten ist(1-long, -1 short, 0- kein signal )</p>
<h3 id="parameter_28">Parameter</h3>
<p>keiner</p>
<h3 id="ruckgabewert_15">Rückgabewert</h3>
<p>Int</p>
<h3 id="verwendung_40">Verwendung</h3>
<p>Im Skriptzustand für short, long, kein Signal</p>
<h3 id="beispiel_36">Beispiel</h3>
<pre><code class="cs">protected override void OnCalculate()
{
if ( ProcessingBarIndex %2 == 0 )
Occurred.Set(1); // Long
else if ( ProcessingBarIndex %3 == 0 )
Occurred.Set(-1); // Short
else
Occurred.Set(0);
}
</code></pre>

<h2 id="onbarsrequirements">OnBarsRequirements()</h2>
<h3 id="beschreibung_54">Beschreibung</h3>
<p>Die OnBarsRequirements() Methode wird einmal zu Beginn einer Indikator- bzw. Strategieberechnung aufgerufen. Die Methode ist nur bei Verwendung von MultiBars notwendig.
Innerhalb von InitRequirements werden keine weiteren Programmierbefehle ausgeführt.
Für eigene Initialisierungen sind die MethodenOnInit() bzw. OnStart() zu verwenden.</p>
<h3 id="parameter_29">Parameter</h3>
<p>keiner</p>
<h3 id="ruckgabewert_16">Rückgabewert</h3>
<p>keiner</p>
<h3 id="beispiel_37">Beispiel</h3>
<pre><code class="cs">protected override void OnBarsRequirements()
{
Add(DatafeedHistoryPeriodicity.Day, 1);
Add(DatafeedHistoryPeriodicity.Week, 1);
}
</code></pre>

<h2 id="oninit">OnInit()</h2>
<h3 id="beschreibung_55">Beschreibung</h3>
<p>Die OnInit()-Methode wird einmal zu Beginn einer Indikator- bzw. Strategieberechnung aufgerufen. Die Methode kann verwendet werden um Indikatoreigenschaften zu setzen, eigene Variablen zu initialisieren oder Plots hinzuzufügen.</p>
<h3 id="parameter_30">Parameter</h3>
<p>keiner</p>
<h3 id="ruckgabewert_17">Rückgabewert</h3>
<p>keiner</p>
<h3 id="verwendung_41">Verwendung</h3>
<pre><code class="cs">protected override void OnInit()
</code></pre>

<h3 id="wichtige-schlusselworte">wichtige Schlüsselworte</h3>
<ul>
<li><a href="#add"><em>Add()</em></a></li>
<li><a href="#allowremovalofchartdrawings"><em>AllowRemovalOfChartDrawings</em></a></li>
<li><a href="#isautoscale"><em>IsAutoScale</em></a></li>
<li><a href="#requiredbarscount"><em>RequiredBarsCount</em></a></li>
<li><a href="calculateonclosedbar"><em>CalculateOnClosedBar</em></a></li>
<li><a href="#cleartracewindow"><em>ClearTraceWindow</em></a></li>
<li><a href="#displacement"><em>Displacement</em></a></li>
<li><a href="#isshowindatabox"><em>IsShowInDataBox</em></a></li>
<li><a href="#isadddrawingstopricepanel"><em>IsAddDrawingsToPricePanel</em></a></li>
<li><a href="#inputpricetype"><em>InputPriceType</em></a></li>
<li><a href="#isoverlay"><em>IsOverlay</em></a></li>
<li><a href="#isshowpricemarkers"><em>IsShowPriceMarkers</em></a></li>
<li><a href="#isshowchartverticalgrid"><em>IsShowChartVerticalGrid</em></a></li>
</ul>
<p><strong>zusätzlich für Strategien</strong></p>
<ul>
<li><a href="#defaultorderquantity"><em>DefaultOrderQuantity</em></a></li>
<li><a href="#entriesperdirection"><em>EntriesPerDirection</em></a></li>
<li><a href="#setupstoploss"><em>SetUpStopLoss()</em></a></li>
<li><a href="#setupprofittarget"><em>SetUpProfitTarget()</em></a></li>
<li><a href="#setuptrailstop"><em>SetUpTrailStop()</em></a></li>
<li><a href="#timeinforce"><em>TimeInForce</em></a></li>
<li><a href="#traceorders"><em>TraceOrders</em></a></li>
</ul>
<h3 id="weitere-informationen_2">Weitere Informationen</h3>
<p><strong>Achtung:</strong>
Die OnInit()-Methode wird nicht nur am Beginn einer Indikator- bzw. Strategieberechnung aufgerufen, sondern auch unerwartet z.B. wenn ein Chart neu geladen wird oder der Eigenschaftsdialog von Indikatoren geöffnet wird usw.
Entwickler von eigenen AgenaScripts sollten diese Methode NICHT verwenden, um eigene Routinen laufen zu lassen, Forms zu öffnen, Lizenzchecks auszuführen u. dgl. mehr. Hierzu ist die Methode  OnStart() zu verwenden.</p>
<h3 id="beispiel_38">Beispiel</h3>
<pre><code class="cs">protected override void OnInit()
{
AddOutput(new OutputDescriptor(Color.FromKnownColor(KnownColor.Black), &quot;MyPlot1&quot;));
ClearTraceWindow();
IsAutoScale = false;
IsOverlay = true;
IsShowPriceMarkers = false;
IsShowInDataBox = false;
CalculateOnClosedBar = true;
}
</code></pre>

<h2 id="outputdescriptor">OutputDescriptor()</h2>
<h3 id="beschreibung_56">Beschreibung</h3>
<p>Ein OutputDescriptor (drawing)wird genutzt, um einen Indikator in einem Chart graphisch darzustellen. Plot-Objekte werden einem Indikator mit Hilfe der Add()-Methode hinzugefügt und damit in die Plots-Collection aufgenommen.
Siehe auch  <a href="#levelline"><em>LevelLine</em></a>.</p>
<h3 id="parameter_31">Parameter</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Color</td>
<td>Zeichenfarbe</td>
</tr>
<tr>
<td>Pen</td>
<td>ein Pen-Objekt</td>
</tr>
<tr>
<td>PlotStyle</td>
<td>Linienart: PlotStyle.Bar, PlotStyle.Block, PlotStyle.Cross, PlotStyle.Dot, PlotStyle.Hash, PlotStyle.LevelLine, PlotStyle.Square, PlotStyle.TriangleDown, PlotStyle.TriangleUp</td>
</tr>
<tr>
<td>Name</td>
<td>Bezeichnung</td>
</tr>
</tbody>
</table>
<h3 id="verwendung_42">Verwendung</h3>
<pre><code class="cs">OutputDescriptor(Color color, string name)
OutputDescriptorOutputDescriptorOutputDescriptor(Pen pen, string name)
OutputDescriptorOutputDescriptor(Color color, PlotStyle plotStyle, string name)
OutputDescriptor(Pen pen, PlotStyle plotStyle, string name)
</code></pre>

<h3 id="weitere-informationen_3">Weitere Informationen</h3>
<p>Informationen zur Klasse Pen: <a href="http://msdn.microsoft.com/de-de/library/system.drawing.pen.aspx"><em>http://msdn.microsoft.com/de-de/library/system.drawing.pen.aspx</em></a></p>
<h3 id="beispiele_13">Beispiele</h3>
<pre><code class="cs">// Beispiel 1
// Plot mit Standardwerten (Linie mit Linienstärke 1)
Add(new OutputDescriptor(Color.Green, &quot;MyPlot&quot;));
// Beispiel 2
// benutzerdefinierte Werte für Pen und PlotStyle
private OutputDescriptor plot;
private Pen pen;
protected override void OnInit()
{
// einen roten Stift mit der Linienstärke 6 definieren
pen = new Pen(Color.Blue, 6);
// eine Punkt-Linie mit dem dicken roten Stift von oben definieren
plot = new OutputDescriptor(pen, PlotStyle.Dot, &quot;MyPlot&quot;);
// den oben def. Plot als Darstellung für den Indikator verwenden
Add(plot);
}
// Beispiel 3
// Kurzform von Beispiel 2
protected override void OnInit()
{
Add(new OutputDescriptor(new Pen(Color.Blue, 6), PlotStyle.Dot, &quot;MyPlot&quot;));
}
</code></pre>

<h2 id="inputparameter">InputParameter()</h2>
<h3 id="beschreibung_57">Beschreibung</h3>
<p>Attribut, das für die Anpassung der Indikatoren verwendet wird</p>
<h3 id="ruckgabewert_18">Rückgabewert</h3>
<p>keiner</p>
<h3 id="parameter_32">Parameter</h3>
<p>keiner</p>
<h3 id="beispiele_14">Beispiele</h3>
<pre><code class="cs">[Description(&quot;Period for the medium mean average&quot;)]
[InputParameter]
[DisplayName(&quot;MA Medium&quot;)]
public int MA_Medium
{
    get 
    { 
        return _ma_medium; 
    }
    set
    {
        _ma_medium = value;
    }
}
</code></pre>

<h2 id="playsound">PlaySound()</h2>
<h3 id="beschreibung_58">Beschreibung</h3>
<p>Die Methode PlaySound() dient dazu, ein Wav-File abzuspielen.</p>
<h3 id="verwendung_43">Verwendung</h3>
<p><strong>PlaySound</strong>(wavFile)</p>
<h3 id="ruckgabewert_19">Rückgabewert</h3>
<p>keiner</p>
<h3 id="parameter_33">Parameter</h3>
<p>wavFile Dateiname der Wav-Datei zum Abspielen</p>
<h3 id="beispiel_39">Beispiel</h3>
<pre><code class="cs">using System.IO;
string path = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
string file = &quot;\\\\AgenaTrader\\\\Sounds\\\\Alert1.wav&quot;;
PlaySound(path + file);
</code></pre>

<h2 id="plotmethod">PlotMethod</h2>
<h3 id="beschreibung_59">Beschreibung</h3>
<p>In jedem Indikator kann die Plot-Methode überschrieben werden um mit Mittlen der Graphics-Klasse (System.Drawing) dem Preis-Chart  eigene Grafiken hinzuzufügen (GDI+).</p>
<p>Siehe <a href="http://msdn.microsoft.com/de-de/library/system.drawing.graphics.aspx"><em>http://msdn.microsoft.com/de-de/library/system.drawing.graphics.aspx</em></a>.</p>
<p>Das Objekt  <em>Chart</em> bietet einige nützliche Parameter.</p>
<p>Weitere Beispiele: <em>Bar Numbering</em>, <em>PlotSample</em>, <em>Chart Background Image</em>.</p>
<h3 id="parameter_34">Parameter</h3>
<p>graphics Das graphics-Objekt des Preischarts (der sog. context)</p>
<p>rectangle Die Größe der Zeichenfläche (Type public struct rectangle)</p>
<p>double min Der kleinste Kurs in der y-Achse</p>
<p>double max Der größte Kurs in der y-Achse</p>
<h3 id="ruckgabewert_20">Rückgabewert</h3>
<p>keiner</p>
<h3 id="verwendung_44">Verwendung</h3>
<pre><code class="cs">public override void OutputDescriptor(Graphics graphics, Rectangle r, double min, double max)
</code></pre>

<h3 id="beispiel_40">Beispiel</h3>
<pre><code class="cs">using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Drawing2D;
using AgenaTrader.API;
using AgenaTrader.Custom;
using AgenaTrader.Plugins;
namespace AgenaTrader.UserCode
{
[Description(&quot;Example for the usage of the plot method.&quot;)]
public class PlotSample : UserIndicator
{
private StringFormat stringFormat = new StringFormat();
private SolidBrush brush = new SolidBrush(Color.Black);
private Font font = new Font(&quot;Arial&quot;, 10);
protected override void OnInit()
{
IsChartOnlyIndicator = true;
IsOverlay = true;
}
protected override void OnCalculate()
{}
protected override void OnDispose()
{
brush.Dispose();
stringFormat.Dispose();
}
public override void OutputDescriptor(Graphics graphics, Rectangle r, double min, double max)
{
// Ausfuellen eines Rechtecks
SolidBrush tmpBrush = new SolidBrush(Color.LightGray);
graphics.FillRectangle(tmpBrush, new Rectangle (0, 0, 300, 300));
tmpBrush.Dispose();
// Zeichnen einer roten Linie von oben links nach unten recht
Pen pen = new Pen(Color.Red);
graphics.AddChartLine(pen, r.X, r.Y, r.X + r.Width, r.Y + r.Height);
// Zeichnen einer roten Linie von unten links nach oben rechts
// Verwenden von AnitAlias (Die Linie erscheint glatter)
// Die aktuellen Einstellungen fuer die Glaettung werden gesichert
 // und nach dem Zeichnen wiederhergestellt
SmoothingMode oldSmoothingMode = graphics.SmoothingMode; //Einstellung sichern
graphics.SmoothingMode = SmoothingMode.AntiAlias; // hohe Glaettung verwenden
graphics.AddChartLine(pen, r.X, r.Y + r.Height, r.X + r.Width, r.Y);
graphics.SmoothingMode = oldSmoothingMode; // Einstellungen wiederherstellen
pen.Dispose();
// Text in die obere linke Ecke (Position 10,35) schreiben
stringFormat.Alignment = StringAlignment.Near; // Text links ausrichten
brush.Color = Color.Blue;
graphics.DrawString(&quot;Hello world!&quot;, font, brush, r.X + 10, r.Y + 35, stringFormat);
// Text in die linke untere Ecke schreiben und eine Linie darum herumzeichnen
brush.Color = Color.Aquamarine;
graphics.FillRectangle(brush, r.X + 10, r.Y + r.Height - 20, 140, 19);
// Aeussere Linie zeichnen
pen = new Pen(Color.Black);
graphics.AddChartRectangle(pen, r.X + 10, r.Y + r.Height - 20, 140, 19);
pen.Dispose();
// Text schreiben
brush.Color = Color.Red;
graphics.DrawString(&quot;Here is bottom left!&quot;, font, brush, r.X + 10, r.Y + r.Height - 20, stringFormat);
}
}
}
</code></pre>

<h2 id="pricetype">PriceType</h2>
<h3 id="beschreibung_60">Beschreibung</h3>
<p>PriceType beschreibt die Art von Kursdaten.</p>
<p>Siehe auch <a href="#inputpricetype"><em>InputPriceType</em></a></p>
<p>Folgende Werte stehen zur Verfügung:
-   PriceType.Close
-   PriceType.High
-   PriceType.Low
-   PriceType.Median
-   PriceType.Open
-   PriceType.Typical
-   PriceType.Volume
-   PriceType.Weighted</p>
<h3 id="verwendung_45">Verwendung</h3>
<p>PriceType</p>
<h3 id="beispiel_41">Beispiel</h3>
<p>Siehe Beispiel unter <a href="#inputpricetype"><em>InputPriceType</em></a></p>
<h2 id="print">Print()</h2>
<h3 id="beschreibung_61">Beschreibung</h3>
<p>Die Methode Print() schreibt Ausgaben in das AgenaTrader Output-Window.
Siehe auch <a href="#cleartracewindow"><em>ClearTraceWindow</em></a>.</p>
<h3 id="verwendung_46">Verwendung</h3>
<pre><code class="cs">Print(string message)
Print(bool value)
Print(double value)
Print(int value)
Print(DateTime value)
Print(string format, string message)
</code></pre>

<h3 id="parameter_35">Parameter</h3>
<p>string Text ein individueller Meldungstext</p>
<h3 id="ruckgabewert_21">Rückgabewert</h3>
<p>keiner</p>
<h3 id="weitere-informationen_4">Weitere Informationen</h3>
<p>Hinweise zum Formatieren von Ausgaben finden Sie unter <em>Formatting numbers</em>.</p>
<p>Hinweise zur String.Format()-Methode:  <a href="http://msdn.microsoft.com/de-de/library/fht0f5be%28v=vs.80%29.aspx"><em>http://msdn.microsoft.com/de-de/library/fht0f5be%28v=vs.80%29.aspx</em></a></p>
<h3 id="beispiel_42">Beispiel</h3>
<pre><code class="cs">// &quot;Quick&amp;Dirty&quot;-Formatierung einer Zahl mit 2 Nachkommastellen
Print(Close[0].ToString(&quot;0.00&quot;));
// Wochentag aus dem Zeitstempel des Bars ausgeben
Print(string.Format(&quot;{0:dddd}&quot;, Time[0]));
// Ein zusätzlicher Zeilenvorschub mit ESC-Sequenz
Print(&quot;One empty row afterwards \\n&quot;);
</code></pre>

<h2 id="processingbarindex">ProcessingBarIndex</h2>
<h3 id="beschreibung_62">Beschreibung</h3>
<p>ProcessingBarIndex  ist eine Nummerierung von Bars, die in der Methode OnCalculate()  verwendet wird. Wenn in einem Chart z.B. 500 Bars dargestellt werden und auf diese ein Indikator berechnet werden soll, so beginnt AgenaTrader mit der Berechnung (also dem Aufruf von OnCalculate() bei dem ältesten Bar. Dieser bekommt die Nummer 0. Ist die Berechnung für diesen Bar abgeschlossen, wird OnCalculate() für den nächsten Bar aufgerufen. Dieser bekommt dann die Nummer 1 usw. bis zum letzten Bar, der die Nummer 499 bekommt.</p>
<h3 id="parameter_36">Parameter</h3>
<p>keiner</p>
<h3 id="ruckgabewert_22">Rückgabewert</h3>
<p>ProcessingBarIndex ist eine Variable vom Typ int, die immer die Nummer des sich gerade in Bearbeitung befindenden Bars enthält.</p>
<h3 id="verwendung_47">Verwendung</h3>
<p>ProcessingBarIndex</p>
<h3 id="weitere-informationen_5">Weitere Informationen</h3>
<p>Die in der Methode  OnCalculate() verwendete Nummerierung mit ProcessingBarIndex unterscheidet sich vom <a href="#barindex"><em>Barindex</em></a> und <a href="#bars"><em>Bars</em></a>. Das Verständnis dieses Unterschiedes ist sehr wichtig! Bitte das folgende genau lesen!</p>
<p>ProcessingBarIndex nummeriert fortlaufend vom ältesten zum jüngsten Bar beginnend bei 0. Der Barindex ist für den jüngsten Bar immer 0. Im Beispiel unten steht Time[0] für den Zeitstempel des aktuellen Bars. Der Index des ältesten Bars wird mit jedem neu hinzukommenden Damit wird eine logische Zählung für barsAgo möglich. Der Zeitstempel für den Bar von vor 5 Perioden ist damit Time[5].
Bei Verwendung mehrerer Zeiteinheiten (multi-bars)in einem Indikator siehe ProcessingBarIndexes.</p>
<h3 id="beispiel_43">Beispiel</h3>
<pre><code class="cs">protected override void OnCalculate()
{
Print(&quot;Call of OnCalculate for bar nr. &quot; + ProcessingBarIndex + &quot; of &quot; + Time[0]);
}
</code></pre>

<h2 id="removechartdrawing">RemoveChartDrawing()</h2>
<h3 id="beschreibung_63">Beschreibung</h3>
<p>Die Methode RemoveChartDrawing() entfernt ein bestimmtes Zeichenobjekt vom Chart anhand einer eindeutigen Kennzeichnung (tag).
Siehe auch <a href="#removechartdrawings"><em>RemoveChartDrawings()</em></a>.</p>
<h3 id="verwendung_48">Verwendung</h3>
<p>RemoveChartDrawings(string tag)</p>
<h3 id="ruckgabewert_23">Rückgabewert</h3>
<p>keiner</p>
<h3 id="parameter_37">Parameter</h3>
<p>string tag Der Name eines Zeichenobjekts zur eindeutigen Identifizierung</p>
<h3 id="beispiel_44">Beispiel</h3>
<pre><code class="cs">RemoveChartDrawings(&quot;Meine Linie&quot;);
</code></pre>

<h2 id="removechartdrawings">RemoveChartDrawings()</h2>
<h3 id="beschreibung_64">Beschreibung</h3>
<p>Die Methode RemoveDrawObjects() entfernt alle Zeichenobjekte vom Chart.
Siehe auch <a href="#removechartdrawings"><em>RemoveChartDrawings()</em></a>.</p>
<h3 id="verwendung_49">Verwendung</h3>
<p>RemoveChartDrawings()</p>
<h3 id="ruckgabewert_24">Rückgabewert</h3>
<p>keiner</p>
<h3 id="beispiel_45">Beispiel</h3>
<pre><code class="cs">//Alle Zeicheobjekte vom Chart löschen
RemoveChartDrawings();
</code></pre>

<h2 id="requiredbarscount">RequiredBarsCount</h2>
<h3 id="beschreibung_65">Beschreibung</h3>
<p>Die Eigenschaft BarsRequired gibt an, wieviele historische Bars mindestens benötigt werden, damit ein Indikator bzw. eine Strategie erstmal die Methode OnCalculate() aufrufen und mit den Berechnungen beginnen kann. BarsRequired sollte in der OnInit() Methode angegeben werden.
Die Einstellung sollte sorgfältig gewählt werden. Z.B. braucht man zur Berechnung eines gleitenden Durchschnittes über 100 Tage auch mindestens 100 Tage historische Daten, damit das Ergebnis korrekt ist.</p>
<p>Die Eigenschaft kann im Script abgefragt werden und liefert einen int-Wert.</p>
<p>Wenn OnBarUpdate erstmals aufgerufen wird, ist  ProcessingBarIndex property = 0, unabhängig vom Wert von RequiredBarsCount.</p>
<h3 id="verwendung_50">Verwendung</h3>
<p>RequiredBarsCount</p>
<h3 id="beispiel_46">Beispiel</h3>
<pre><code class="cs">protected override void OnInit()
{
//Der Indikator benötigt mindestens 50 Bars Historie
RequiredBarsCount = 50;
}
</code></pre>

<h2 id="showalert">ShowAlert()</h2>
<h3 id="beschreibung_66">Beschreibung</h3>
<p>Mit der Methode  ShowAlert wird ein akustischer und/oder visueller Alarm erzeugt.</p>
<h3 id="verwendung_51">Verwendung</h3>
<pre><code class="cs">ShowAlert(string message, bool showMessageBox, string soundLocation);
//Aus Kompatibilitätsgründen ist noch eine veraltete Signatur enthalten. Bei Nutzung dieses Aufrufvariante werden die Farbangaben und &quot;rearmSeconds&quot; ignoriert.
ShowAlert(string id, AlertPriority priority, string message, string soundLocation, int rearmSeconds, Color backColor, Color forColor);
</code></pre>

<h3 id="ruckgabewert_25">Rückgabewert</h3>
<p>keiner</p>
<h3 id="parameter_38">Parameter</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>message</td>
<td>Nachrichtentext, der im Messages-Tab angezeigt wird.</td>
</tr>
<tr>
<td>soundLocation</td>
<td>Name eines Sound-Files im *.wav Format. Ist kein Pfad angegeben, wird "Eigene Dokumente\AgenaTrader\Sounds" verwendet.</td>
</tr>
<tr>
<td>showMessageBox</td>
<td>wenn true, wird zusätzlich zum Sound eine Messagebox auf dem Bildschim angezeigt.</td>
</tr>
</tbody>
</table>
<h3 id="beispiel_47">Beispiel</h3>
<pre><code class="cs">// Hinweis ausgeben, wenn der SMA(20) unter SMA(50) kreuzt
if (CrossBelow(SMA(20), SMA(50), 1))
Alert(&quot;Check short signal!&quot;, true, &quot;Alert4.wav&quot;);
</code></pre>

<p>Um Musikdateien in anderen Verzeichnissen wiederzugeben, muss der vollständige Pfad angegeben werden, z.B.:</p>
<pre><code class="cs">string pathOfSoundfile = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments)+@&quot;\\MyAlertSounds\\&quot;;
string nameOfSoundFile = &quot;MyAlertSoundFile.wav&quot;;
Alert(&quot;Message text&quot;, true, pathOfSoundfile + nameOfSoundFile);
</code></pre>

<h2 id="ticksize">TickSize</h2>
<p>Ein Tick ist die kleinst mögliche Kursänderung eines Finanzinstruments an einer Börse. Wenn die Handelspreise z.B. mit zwei Stellen nach dem Komma angegeben werden, beträgt ein Tick 0,01. Im Forexhandel (Währungshandel) wird mit 4 bzw. 5 Stellen nach dem Komma gearbeitet. Ein Tick - der im Forexhandel als Pip bezeichnet wird - beträgt dementsprechend 0,0001 bzw. 0,00001.
Der Tickwert wird durch die Börse fest vorgegeben und ändert sich (in der Regel) nicht.
Siehe auch <a href="#instrumentticksize"><em>Instrument.TickSize</em></a>.</p>
<p>Üblicherweise wird heute ein Tick als Dezimalzahl angegeben. Historisch wurden besonders im amerikanischen Raum Aktien jedoch mit einer Tickgröße von 1/16 von einem Dollar notiert.</p>
<p>Bei Rohstoffen ist diese Notierung noch weit verbreitet. Der Corn-Future (ZC - Mais) wird genau wie Wheat (ZW - Weizen) in ¼ US-Cent/bushel (entspricht 12,50 US-$ je Kontrakt) notiert.</p>
<p>US-Statsanleihen (T-Bonds) werden mit Tickgrößen von 1/32 Punkten gehandelt, was 31,25 US-Dollar entspricht.</p>
<p>Die Notierung erfolgt mit Hochkomma:
149'00 entspricht genau 149,
149'01 entspricht 149 1/32 (also 149,03125),
149'31 enspricht 149 31/32 (149,96875),
danach folgt dann 150'00.</p>
<p>In sog. T-Bond-Intermonth Spreads werden die Notierungen in Vierteln von 1/32 angegeben, was dann einem Punktwert von $7.8125 per Kontrakt entspricht.</p>
<p>Die Notierungen erfolgt mit Bindestrich:</p>
<p>17-24 entspricht 17 24/32 Punkten,
17-242 entspricht 17 24,25/32 Punkten,
17-245 entspricht 17 24,5/32 Punkten und
17-247 entspricht 17 24,75/32 Punkten.
Die nächste Notierung nach 17-247 ist 17-25, dann wieder 17-252, 17-255 usw.
Nach 17-317 folgt 18.</p>
<p>Die Kontraktspezifikationen sind auf den Internetseiten der jeweiligen Börsen veröffentlicht.</p>
<p>CME: <a href="http://www.cmegroup.com"><em>http://www.cmegroup.com</em></a> under Products &amp; Trading
Eurex (FDAX): <a href="http://www.eurexchange.com/exchange-en/products/idx/dax/17206/"><em>http://www.eurexchange.com/exchange-en/products/idx/dax/17206/</em></a></p>
<p>siehe auch  <a href="#instrumentticksize"><em>Instrument.TickSize</em></a>.</p>
<h2 id="timeframe">TimeFrame</h2>
<p>siehe <a href="#barstimeframe"><em>Bars.TimeFrame</em></a>.</p>
<p>Bei Verwendung mehrerer Zeiteinheiten (<a href="#multibars"><em>Multibars</em></a>) in einem Indikator siehe <a href="#timeframes"><em>TimeFrames</em></a>.</p>
<h2 id="update">Update()</h2>
<h3 id="beschreibung_67">Beschreibung</h3>
<p>Die Methode Update() ruft die OnCalculateMethode einmal auf, um Indikatorwerte neu zu berechnen.</p>
<p>Update() ist mit Vorsicht und nur von erfahrenen Programmierern zu verwenden.</p>
<h3 id="verwendung_52">Verwendung</h3>
<pre><code class="cs">Update()
</code></pre>

<h3 id="ruckgabewert_26">Rückgabewert</h3>
<p>keiner</p>
<h3 id="parameter_39">Parameter</h3>
<p>keiner</p>
<h3 id="beispiel_48">Beispiel</h3>
<p>Die Wirkung von Update läßt sich mit Hilfe von 2 Indikatoren veranschaulichen.
Der erste Indikator "Ind1" nutzt eine public Variable aus Indikator "Ind2".</p>
<p><strong>Code von Ind1:</strong></p>
<pre><code class="cs">public class Ind1 : UserIndicator
{
protected override void OnCalculate()
{
Print( Ind2().MyPublicVariable );
}
}
</code></pre>

<p><strong>Code von Ind2:</strong></p>
<pre><code class="cs">private double myPublicVariable = 0;
protected override void OnCalculate()
{
myPublicVariable = 1;
}
public double MyPublicVariable
{
get
{
Update();
return myPublicVariable;
}
}
</code></pre>

<p><strong>Ohne Update() - Falsch</strong>
Wenn Ind2 von Ind1 aufgerufen wird, wird die get-Methode von MyPublicVariable in Ind2 aufgerufen. Ohne Update() würde der Wert von myPublicVariable zurückgegeben werden. In diesem Falle eine 0.</p>
<p><strong>Mit Update() - Richtig</strong>
Durch den Aufruf von Update() wird zunächst OnBarUpdate() von Ind2 ausgeführt. Damit wird myPublicVariable auf 1 gesetzt. Anschließend wird der Wert 1 an den aufrufenden Indikator Ind1 übergeben.</p>
<h2 id="value">Value</h2>
<h3 id="beschreibung_68">Beschreibung</h3>
<p>Value ist ein DataSeries-Objekt, welches die erste Datenserie eines Indikators enthält.</p>
<p>Beim Aufruf der Add()-Methode wird automatisch ein Value-Objekt erzeugt und der Collection Values hinzugefügt.</p>
<p>Value ist identisch mit  Values[0].</p>
<h3 id="verwendung_53">Verwendung</h3>
<p>Value</p>
<p>Value[<strong>int</strong> barsAgo]</p>
<h3 id="weitere-informationen_6">Weitere Informationen</h3>
<p>Die für eine Collection bekannten Methoden Set(), Reset() und Count() sind auf Value anwendbar.</p>
<h3 id="beispiel_49">Beispiel</h3>
<p>Siehe <a href="#values"><em>Values</em></a>.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../zeichenobjekte/" class="btn btn-neutral float-right" title="Zeichenobjekte">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../strategieprogrammierung/" class="btn btn-neutral" title="Strategieprogrammierung"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/AgenaTrader/AgenaScript-documentation-de/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../strategieprogrammierung/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../zeichenobjekte/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
