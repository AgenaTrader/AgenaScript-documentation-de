{
    "docs": [
        {
            "location": "/",
            "text": "Die folgende API-Dokumentation ben\u00f6tigt AgenaTrader in der Version 2.0.1.x\n\n\nAgenaScript ist eine in die Handelsplattform AgenaTrader integrierte Programmiersprache. Die Syntax von AgenaScript ist von der Programmiersprache C# abgeleitet.\nMit AgenaScript k\u00f6nnen alle Anliegen umgesetzt werden, die z.B. f\u00fcr den Condition Escort zu komplex sind. Das Spektrum reicht von der Programmierung eines einfachen Indikators bis hin zu eigenen Applikationen, bei denen AgenaTrader sozusagen nur noch im Hintergrund ben\u00f6tigt wird. Generell sind alle Dinge umsetzbar, die auch in DotNet realisierbar sind: Indikatoren fast beliebiger Komplexit\u00e4t, Signalanzeige, Excel-Export, Auswertungen, Chartanzeigen, Sound, Farben uvm.\n\n\nInformation contained in this help document:\n\n\nEreignisse\n\n\nAgenaScript arbeitet ereignisorientiert. Wenn z.B. eine Kerze in einer Zeiteinheit abgeschlossen ist und eine neue Kerze beginnt, ist dies ein Ereignis. Wenn neue Kurse vom Datenanbieter geliefert werden oder eine Order vom Broker ausgef\u00fchrt wird, immer handelt es sich um Ereignisse.\nMit AgenaScript k\u00f6nnen Sie auf alle diese Ereignisse reagieren. Wie dies genau funktioniert und welche Ereignisse es gibt, ist Gegenstand dieses Abschnitts.\n\n\nSchl\u00fcsselworte\n\n\nWie jede Programmiersprache besitzt auch AgenaTrader einen Satz von Befehlen, die Sie in eigenen Scripts verwenden k\u00f6nnen. Mit diesen sog. Schl\u00fcsselworten sollten Sie gut vertraut sein, wenn Sie Ihre eignenen Indikatoren bzw. Handelssysteme erstellen m\u00f6chten.\n\n\nStrategieprogrammierung\n\n\nMit AgenaScript ist es m\u00f6glich, eigene Handelsstrategien zu erstellen um diese live im Markt handeln zu lassen.\nWelche Voraussetzungen dazu notwendig sind und wie Orders an den Broker \u00fcbergeben und intern verwaltet werden, erfahren Sie hier.\n\n\nTipps und Tricks\n\n\nIn diesem Bereich werden L\u00f6sungen f\u00fcr nicht ganz allt\u00e4gliche Probleme gezeigt. Um diese Beispiele nachvollziehen zu k\u00f6nnen, ist allerdings einiges an Erfahrung in der Programmierung Voraussetzung. Der fortgeschrittene Anwender wird hier einige Dinge finden, die er in seine eigenen Programmierungen \u00fcbernehmen kann.\n\n\nUmgang mit Bars und Instrumenten\n\n\nHier wird im Detail gezeigt, wie mit AgenaScript auf die einzelnen Bars bzw. Kerzen und auf verschiedene Handelsinstrumente zugegriffen werden kann.\n\n\nZeichenobjekte\n\n\nAlle Zeichenobjekte, die Sie im Chart verwenden k\u00f6nnen, sind auh \u00fcber AgenaScript erreichbar. So k\u00f6nnen Sie z.B. Linien, Pfeile, Rechtecke, Kreise usw. an bestimmten Stellen im Chart automatisch anzeigen und wieder entfernen lassen. Die M\u00f6glichkeiten sind nahezu un\u00fcberschaubar.",
            "title": "Los gehts"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/",
            "text": "Umgang mit Bars und Instrumenten\n\n\nUnter \"Daten\" werden hier einerseits Informationen verstanden, die \"von au\u00dfen\" in AgenaTrader geladen werden und zum anderen Datenreihen, die aus selbst erstellten AgenaSripts stammen.\n\n\nDetailierte Informatonen finden sich unter dem jeweiligen Stichwort.\n\n\nBars\n\n\nCollections\n\n\nData series\n\n\nInstruments\n\n\nMultibars\n\n\nBars\n\n\nFunktionsweise\n\n\nEin klassischer Indikator berechnet \u00fcblicherweise aus einer vorliegenden Datenreihe einen oder mehrere Werte.\n\n\nDatenreihen k\u00f6nnen dabei z.B. alle Schlusskurse oder auch alle Tiefkurse eines Tages, einer Stunde oder einer 10 Min. Periode sein.\n\n\nJeder Periode (also jeder Kerze eines Tages, einer Stunde usw.) wird/werden folglich ein oder mehrere Indikatorwert(e) zugeordnet.\n\n\nIm Folgenden gehen wir von einem Indikatorwert, wie z.B. bei einem gleitenden Durchschnitt aus.\n\n\nZur Berechnung eines gleitenden Durchschnitts ben\u00f6tigt AgenaTrader eine Datenreihe. Im Beispiel nehmen wir die Schlusskurse. Alle Schlusskurse der Bars (Kerzen), die in einem Chart dargestellt sind, sind in einer Liste gespeichert und sozusagen durchnummeriert.\n\n\nDer aktuelle Schlusskurs, also der Schlusskurs des Bars, der am rechten Rand des Charts dargestellt wird, bekommt die Nummer 0. Der Bar links davon die Nummer 1 usw. Der \u00e4lteste dargestellte Bar hat dann z.B. die Nummer 500.\n\n\nKommt im Laufe der Handelssitzung ein neuer Bar hinzu, erh\u00e4lt dieser nun die Nummer 0, der links von ihm, der gerade noch die Nummer 0 hatte, wird zu Nummer 1 usw. Der letzte dargestellte Bar wird zu Nummer 501.\n\n\nIn einem Script (einem selbsterstellten Programm) steht \nClose\n close f\u00fcr die Liste (Array) aller Schlusskurse. Der letzte Schlusskurs ist dann \nClose [0]\n; t der Schlusskurs davor (bei Tagesdaten ist das z.B. der Schlusskurs von gestern) ist \nClose [1]\n,  der davor  \nClose [2]\n bis zum ersten Bar im Chart (ganz links) mit \nClose [501]\n. Die Zahl in den eckigen Klammern ist ein Index. In AgenaTrader steht hierf\u00fcr im allgemeinen Fall der Ausdruck \"barsAgo\".\n\n\nF\u00fcr jeden Bar gibt es nicht nur Close, sondern zudem auch \nHigh\n, \nLow\n, \nOpen\n, \nMedian\n, \nTypical\n, \nWeighted\n, \nTime\n and \nVolume\n. Das Hoch der Kerze, von vor 10 Tagen ist also z.B.  \nHigh [10]\n, Das Tief von gestern \nLow [1]\n...\n\n\nwichtiger Hinweis\n\n\nDie o.g. Beispiele gelten, wenn die Berechnung am Ende einer Periode erfolgt. Die Werte der aktuell laufenden (noch nicht fertigen Kerze) sind nicht ber\u00fccksichtigt.\nM\u00f6chte man bereits auf die Werte der sich gerade ausbildenden Kerze zur\u00fcckgreifen, mu\u00df man dies AgenaTrader im Script mit \nCalculateOnClosedBar\n= false mitteilen.\n\n\nIn diesem Fall bekommt der aktuell laufende Bar die Nummer 0, der Bar links neben dem aktuell laufenden die Nummer 1 usw. Der letzte Bar (im Beispiel oben) h\u00e4tte jetzt die Nummer 502.\n\n\nMit close [0] bekommt man nun den jeweils letzten Kurs, der gerade vom Datenanbieter an AgenaTrader \u00fcbermittelt wurde. Alle Werte des Bars (high [0], low [0]\u2026) k\u00f6nnen sich solange ver\u00e4ndern, bis der Bar fertig ausgebildet ist und ein neuer Bar begonnen hat. Nur Open[0] \u00e4ndert sich auch in diesem Fall nicht mehr.\n\n\nEigenschaften\n\n\nEigenschaften von Bars\n\n\n\"Bars\" steht f\u00fcr eine Liste aller Bars (Kerzen) in einem Chart (siehe \nFunktionsweise\n, \nBars\n).\n\n\nBars (\npublic\n IBars Bars) kann direkt in einem Script verwendet werden und entspricht in diesem Fall BarsArray [0] (siehe Bars.GetNextSessionTimeSpan).\n\n\nEigenschaften werden immer mit einem Punkt hinter dem Objekt (in diesem Falle Bars, der Liste der Kerzen) angegeben.\n\n\nBars.Count\n\n\nBars.CurrentSessionBeginTime\n\n\nBars.CurrentSessionEndTime\n\n\nBars.GetBar\n\n\nBars.GetBarIndex\n\n\nBars.GetBarsAgo\n\n\nBars.GetByIndex\n\n\nBars.GetClose\n\n\nBars.GetHigh\n\n\nBars.GetLow\n\n\nBars.GetNextSessionTimeSpan\n\n\nBars.GetOpen\n\n\nBars.GetSessionBegin\n\n\nBars.GetTime\n\n\nBars.GetVolume\n\n\nBars.Instrument\n\n\nBars.IsEod\n\n\nBars.IsFalling\n\n\nBars.IsFirstBarInSession\n\n\nBars.IsGrowing\n\n\nBars.IsIntraday\n\n\nBars.IsNtb\n\n\nBars.SessionBreak\n\n\nBars.LastBarCompleteness\n\n\nBars.NextSessionBeginTime\n\n\nBars.NextSessionEndTime\n\n\nBars.TailBottom\n\n\nBars.TailTop\n\n\nBars.TicksCountForLastBar\n\n\nBars.TicksCountInTotal\n\n\nBars.TimeFrame\n\n\nBarsCountForSession\n\n\nIsProcessingBarIndexLast\n\n\nInnerhalb von \nOnCalculate()\n  k\u00f6nnen alle Eigenschaften verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Funktion \nOnCalculate()\n von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden. Falls diese Eigenschaften ausserhalb von \nOnCalculate()\n  verwendet werden, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit \nif\n (Bars != \nnull\n) ausgef\u00fchrt werden.\n\n\nBars.Count\n\n\nBeschreibung\n\n\nBars.Count liefert die Anzahl der Bars in einer Datenreihe.\n\n\nSiehe auch weitere \nEigenschaften\n von Bars.\n\n\nR\u00fcckgabewert\n\n\nTyp int Anzahl der Bars\n\n\nVerwendung\n\n\nBars.Count\n\n\nWeitere Informationen\n\n\nDer Wert von \nProcessingBarIndex\n kann immer nur kleiner oder gleich Bars.Count - 1 sein.\n\n\nWenn in AgenaTrader angegeben wurde, wieviel Bars in einen Chart geladen werden sollen, entspricht der Wert von Bars.Count genau dieser Einstellung. Im Beispiel unten w\u00fcrde Bars.Count 500 liefern.\n\n\n\n\nBeispiel\n\n\nPrint (\"Es stehen insgesamt\" + Bars.Count + \"Bars zur Verf\u00fcgung.\");\n\n\n\n\nBars.CurrentSessionBeginTime\n\n\nBeschreibung\n\n\nBars.CurrentSessionBeginTime  liefert das Datum und die Uhrzeit des Beginns der aktuell laufenden Handelssitzung.\n\n\nDatum und Uhrzeit f\u00fcr den Beginn der aktuellen Handelssitzung werden auch dann korrekt angegeben, wenn die Funktion von einem Bar in der Vergangenheit aufgerufen wird.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nTyp DateTime\n\n\nVerwendung\n\n\nBars.GetSessionBegin\n\n\nWeitere Informationen\n\n\nDie Uhrzeit des zur\u00fcckgegebenen Wertes entspricht der im MarketEscort angegebenen Startzeit der Handelssitzung des jeweiligen Handelsplatzes. Der f\u00fcr den Wert verwendete Handelsplatz wird im Instrumet Escort eingestellt und kann in AgenaSript mit der Funktion \nInstrument.Exchange\n ermittelt.\n\n\n\n\nBeispiel\n\n\nPrint(\"Die laufende Handelssitzung hat um  \" + Bars.CurrentSessionBeginTime );\n\n\n\n\nBars.CurrentSessionEndTime\n\n\nBeschreibung\n\n\nBars.CurrentSessionEndTime  liefert das Datum und die Uhrzeit f\u00fcr das Ende der aktuell laufenden Handelssitzung.\nDatum und Uhrzeit f\u00fcr das Ende der aktuellen Handelssitzung werden auch dann korrekt angegeben, wenn die Funktion von einem Bar in der Vergangenheit aufgerufen wird.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nTyp DateTime\n\n\nVerwendung\n\n\nBars.GetSessionEnd\n\n\nWeitere Informationen\n\n\nDie Uhrzeit des zur\u00fcckgegebenen Wertes entspricht der im MarketEscort angegebenen Endezeit der Handelssitzung des jeweiligen Handelsplatzes. Der f\u00fcr den Wert verwendete Handelsplatz wird im Instrumet Escort eingestellt und kann in AgenaSript mit der Funktion  \nInstrument.Exchange\n ermittelt werden.\n\n\n\n\nBeispiel\n\n\nPrint(\"Die laufende Handelssitzung endet um \" + Bars.CurrentSessionEndTime);\n\n\n\n\nBars.GetBar\n\n\nBeschreibung\n\n\nBars.GetBar liefert den ersten Bars (vom \u00e4ltesten zum j\u00fcngsten), der dem \u00fcbergebenen Datum bzw. der Uhrzeit entspricht.\n\n\nSiehe auch \nBars.GetBarsAgo\n, \nBars.GetByIndex\n, \nBars.GetBarIndex\n.\n\n\nParameter\n\n\nTyp DateTime\n\n\nR\u00fcckgabewert\n\n\nTyp IBar Bar-Objekt, des dem Zeitstempel entsprichenden Bars\n\n\nbei Zeitstempel \u00e4lter als der \u00e4lteste Bar: 0 (Null)\nbei Zeitstempel j\u00fcnger als der letzte Bar: Index des letzten Bars\n\n\nVerwendung\n\n\nBars.GetBar(DateTime time)\n\n\n\n\nWeitere Informationen\n\n\nzur Indizierung von Bars siehe \nFunktionsweise\n, \nBars\n\n\nzur Benutzung von DateTime siehe \nhttp://msdn.microsoft.com/de-de/library/system.datetime.aspx\n\n\nBeispiel\n\n\nPrint (\"Der Schlusskurs f\u00fcr den 01.03.2012 um 18:00:00 Uhr war \" + Bars.GetBar(new DateTime(2012, 01, 03, 18, 0, 0)).Close);\n\n\n\n\nBars.GetBarIndex\n\n\nBeschreibung\n\n\nBars.GetBarIndex liefert den Index eines Bars. \u00dcbergeben werden kann der Methode entweder ein Bar-Objekt oder ein DateTime-Objekt.\n\n\nSiehe \nBars.GetBar\n, \nBars.GetBarsAgo\n, \nBars.GetByIndex\n.\n\n\nParameter\n\n\nTyp IBar bar\noder\nTyp DateTime\n\n\nR\u00fcckgabewert\n\n\nTyp int der zu dem \u00fcbergebenen Bar-Objekt bzw. dem \u00fcbergebenen DateTime-Objekt geh\u00f6rende Bar-Index\n\n\nVerwendung\n\n\nBars.GetBarIndex (IBar bar)\nBars.GetBarIndex (DateTime dt)\n\n\n\n\nWeitere Informationen\n\n\nzur Indizierung von Bars siehe \nFunktionsweise\n, \nBars\n\n\nBeispiel\n\n\nint barsAgo = 5;\nIBar bar = Bars.GetBar(Time[barsAgo]);\nPrint(barsAgo + \" und \" + Bars.GetBarIndex(bar) + \" sind in diesem Beispiel gleich.\");\n\n\n\n\nBars.GetBarsAgo\n\n\nBeschreibung\n\n\nBars.GetBarsAgo liefert den Index des ersten Bars (vom \u00e4ltesten zum j\u00fcngsten), der dem \u00fcbergebenen Datum bzw. der Uhrzeit entspricht.\n\n\nSiehe auch:: \nBars.GetBar\n, \nBars.GetByIndex\n, \nBars.GetBarIndex\n.\n\n\nParameter\n\n\nTyp DateTime\n\n\nR\u00fcckgabewert\n\n\nTyp int Index des Bars, der dem Zeitstempel als erstes entspricht.\n\n\nbei Zeitstempel \u00e4lter als der \u00e4lteste Bar: 0 (Null)\nbei Zeitstempel j\u00fcnger als der letzte Bar: Index des letzten Bars\n\n\nVerwendung\n\n\nBars.GetBarsAgo(DateTime time)\n\n\n\n\nWeitere Informationen\n\n\nzur Indizierung von Bars siehe \nFunktionsweise\n, \nBars\n\n\nzur Benutzung von DateTime siehe  \nhttp://msdn.microsoft.com/de-de/library/system.datetime.aspx\n\n\nBeispiel\n\n\nPrint(\"Der Bar f\u00fcr den 01.03.2012 um 18:00:00 Uhr hat den Index\" + Bars.GetBarsAgo(new DateTime(2012, 01, 03, 18, 0, 0)));\n\n\n\n\nBars.GetByIndex\n\n\nBeschreibung\n\n\nBars.GetByIndex liefert das zu einem \u00fcbergebenen Index geh\u00f6rende Bar-Objekt.\n\n\nSiehe \nBars.GetBar\n, \nBars.GetBarsAgo\n, \nBars.GetBarIndex\n.\n\n\nParameter\n\n\nTyp int Index\n\n\nR\u00fcckgabewert\n\n\nTyp IBar Bar-Objekt zu dem \u00fcbergebenen Index\n\n\nVerwendung\n\n\nBars.GetByIndex (int Index)\n\n\n\n\nWeitere Informationen\n\n\nzur Indizierung von Bars siehe \nFunktionsweise\n, \nBars\n\n\nBeispiel\n\n\nPrint(Close[0] + \" und \" + Bars.GetByIndex(ProcessingBarIndex).Close + \" sind in diesem Beispiel gleich.\");\n\n\n\n\nBars.GetClose\n\n\nBars.GetClose(int index) \u2013 siehe \nBars.GetOpen\n.\n\n\nBars.GetHigh\n\n\nBars.GetHigh(int index) \u2013 siehe \nBars.GetOpen\n.\n\n\nBars.GetLow\n\n\nBars.GetLow(int index) \u2013 siehe \nBars.GetOpen\n.\n\n\nBars.GetNextSessionTimeSpan\n\n\nBeschreibung\n\n\nBars.GetNextSessionTimeSpan liefert jeweils Datum und Uhrzeit von Beginn und Ende der n\u00e4chsten Handelssitzung.\n\n\nSiehe \nBars.CurrentSessionBeginTime\n, \nBars.CurrentSessionEndTime\n, \nBars.NextSessionBeginTime\n, \nBars.NextSessionEndTime\n.\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDateTime\n\n\ntime\n\n\nDatum bzw. Uhrzeit, f\u00fcr die die Daten der folgenden Handelssitzung gesucht werden\n\n\n\n\n\n\niBars\n\n\nbars\n\n\nBarobjekt, f\u00fcr das die Daten der folgenden Handelssitzung gesucht werden\n\n\n\n\n\n\nint\n\n\nbarsago\n\n\nAnzahl der Tage in der Vergangenheit, f\u00fcr die die Daten der folgenden Handelssitzung gesucht werden\n\n\n\n\n\n\n\n\nR\u00fcckgabewert\n\n\nDateTime sessionBegin\nDateTime sessionEnd\n\n\nHinweis:\n\nDas Datum von Beginn und Ende sind jeweils f\u00fcr eine Handelssitzung zusammengeh\u00f6rend. Wenn das \u00fcbergebene Datum dem Ende-Datum der aktuellen Handelssitzung entspricht, kann das zur\u00fcckgegebene Datum f\u00fcr den Beginn der Handelssitzung bereits in der Vergangenheit liegen.\nEs wird in diesem Fall nicht das Datum der n\u00e4chstfolgenden Handelssitzung zur\u00fcckgegeben.\n\n\nVerwendung\n\n\nBars.GetNextSessionTimeSpan(Bars bars, int barsAgo, out DateTime sessionBegin, out DateTime sessionEnd)\nBars.GetNextSessionTimeSpan(DateTime time, out DateTime sessionBegin, out DateTime sessionEnd)\n\n\n\n\nWeitere Informationen\n\n\nDie beiden Signaturen liefern nicht notwendigerweise auch die gleichen Ergebnisse.\nBei Verwendung der Bar-Signatur wird der ubergebene Bar daraufhin untersucht, zu welchem Session-Template er geh\u00f6rt. Beginn und Ende der n\u00e4chsten Session werden dann diesem Template entnommen.\n\n\nBei Verwendung der Zeit-Signatur wierden Datum und Uhrzeit des \u00fcbergebenen Bars genutzt, um die Daten der aktuellen und damit der folgenden Session zu berechnen.\n\n\nWenn bei Verwendung der Zeit-Signatur ein Zeitstempel \u00fcbergeben wird, der exakt einer Beginn bzw. Endezeit einer Session entspricht, werden Beginn und Ende der davorliegenden Session zur\u00fcckgegeben, d.h. der Zeitstempel wird als \"in der Session enthalten\" angesehen, selbst wenn der fragliche Bar bereits in einer neuen Session enthalten ist. Um dieses Verhaten sicher auszuschlie\u00dfen, ist die Verwendung der Bar-Signatur empfohlen.\n\n\nzur Benutzung von DateTime siehe \nhttp://msdn.microsoft.com/de-de/library/system.datetime.aspx\n\n\nBeispiel\n\n\nDateTime sessionBegin;\nDateTime sessionEnd;\nprotected override void OnCalculate()\n{\nBars.GetNextSessionTimeSpan(Bars, 0, out sessionBegin, out sessionEnd);\nPrint(\"Session Start: \" + sessionBegin + \" Session End: \" + sessionEnd);\n}\n\n\n\n\nBars.GetOpen\n\n\nBeschreibung\n\n\nDie folgenden Methoden sind aus Gr\u00fcnden der Kompatibilit\u00e4t vorhanden.\n\n\n\n\nBars.GetOpen(int index) liefert das Open des mit <index> referenzierten Bars.\n\n\nBars.GetHigh(int index) liefert das High des mit <index> referenzierten Bars..\n\n\nBars.GetLow(int index) liefert das Low des mit <index> referenzierten Bars.\n\n\nBars.GetClose(int index) liefert das Close des mit <index> referenzierten Bars.\n\n\nBars.GetTime(int index) liefert das Zeitstempel des mit <index> referenzierten Bars.\n\n\nBars.GetVolume(int index) liefert das Volumen des mit <index> referenzierten Bars.\n\n\n\n\nAchtung\n: Die Indizierung weicht von der sonst verwendeten \nIndexing\n, \nBars\n ab.\nHier beginnt die Indizierung mit 0 am \u00e4ltesten Bar (links im Chart) und endet mit dem j\u00fcngsten Bar rechts im Chart  (=Bars.Count-1).\n\n\nDie Indizierungen k\u00f6nnen leicht (in beiden Richtungen!) wie folgt umgerechnet werden:\n\n\nprivate int Convert(int idx)\n{\nreturn Math.Max(0,Bars.Count-idx-1-(CalculateOnClosedBar?1:0));\n}\n\n\n\n\nParameter\n\n\nint index (0 .. Bars.Count-1)\n\n\nR\u00fcckgabewert\n\n\nTyp double f\u00fcr GetOpen, GetHigh, GetLow, GetClose und GetVolume\n\n\nTyp DateTime f\u00fcr GetTime\n\n\nBars.GetSessionBegin\n\n\nBeschreibung\n\n\nBars.GetSessionBegin liefert das Datum und die Uhrzeit des Beginns einer bestimmten Handelssitzung.\nDatum und Uhrzeit f\u00fcr den Beginn der aktuellen Handelssitzung werden auch dann korrekt angegeben, wenn die Funktion von einem Bar in der Vergangenheit aufgerufen wird.\nSiehe auch weitere \nEigenschaften\n von Bars.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nTyp DateTime\n\n\nVerwendung\n\n\nBars.GetSessionBegin(DateTime dt)\n\n\nWeitere Informationen\n\n\nDie Uhrzeit des zur\u00fcckgegebenen Wertes entspricht der im MarketEscort angegebenen Startzeit der Handelssitzung des jeweiligen Handelsplatzes. Der f\u00fcr den Wert verwendete Handelsplatz wird im Instrumet Escort eingestellt und kann in AgenaSript mit der Funktion Instrument.Exchange ermittelt werden.\n\n\n\n\nBeispiel\n\n\nPrint(\"Die Handelssitzung am 25.03.2015 hat um \"+ Bars.GetSessionBegin(new DateTime(2015, 03, 25)) + \" begonnen.\");\n}\n\n\n\n\nBars.GetTime\n\n\nBars.GetTime(int index) \u2013 siehe \nBars.GetOpen\n.\n\n\nBars.GetVolume\n\n\nBars.GetVolume(int index) \u2013 siehe \nBars.GetOpen\n.\n\n\nBars.Instrument\n\n\nBeschreibung\n\n\nBars.Instrument liefert ein Instrument-Objekt, f\u00fcr das im Chart dargestellte Handelsinstrument.\n\n\nSiehe auch weitere \nEigenschaften\n von Bars.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nTyp Instrument\n\n\nVerwendung\n\n\nBars.Instrument\n\n\nWeitere Informationen\n\n\nF\u00fcr weitere Informationen zu Handelsinstrumenten siehe unter  \nInstrument\n.\n\n\nBeispiel\n\n\n// beide Ausgaben liefern das gleiche Ergebnis\nPrint(\"Das aktuell dargestellte Handelsinstrument hat das Symbol \" + Bars.Instrument);\nInstrument i = Bars.Instrument;\nPrint(\"Das aktuell dargestellte Handelsinstrument hat das Symbol \" + i.Symbol);\n\n\n\n\nBars.IsEod\n\n\nBeschreibung\n\n\nMit Bars.IsEod kann \u00fcberpr\u00fcft werden, ob es sich um End-of-Day-Bars handelt.\n\n\nSiehe auch weitere \nEigenschaften\n von Bars.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nTyp bool\n\n\nVerwendung\n\n\nBars.IsEod\n\n\nMore Information\n\n\nInnerhalb von  \nOnCalculate()\n kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden.\n\n\nFalls diese Eigenschaft ausserhalb von  OnCalculate ()verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit  if (bars! = Null) ausgef\u00fchrt werden.\n\n\nBeispiel\n\n\nPrint(\"Die Bars sind Eod: \" + Bars.IsEod);\n\n\n\n\nBars.IsFalling\n\n\nBeschreibung\n\n\nBar-Eigenschaften, die verwendet werden, wenn Bar herunterf\u00e4llt.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nkeine\n\n\nBeispiel\n\n\nBars[0].IsFalling;\n\n\n\n\nBars.IsFirstBarInSession\n\n\nBeschreibung\n\n\nMit Bars.IsFirstBarInSession kann festgestellt werden, ob der aktuelle Bar der erste Bar einer Handelssitzung ist.\n\n\nSiehe auch weitere  \nEigenschaften\n von Bars.\n\n\nR\u00fcckgabewert\n\n\nTyp bool\n\n\ntrue\n: Der Bar ist der erste Bar einer Handelssitzung\n\nfalse\n: Der Bar ist nicht der erste Bar einer Handelssitzung\n\n\nVerwendung\n\n\nBars.IsFirstBarInSession\n\n\nWeitere Informationen\n\n\nInnerhalb von \nOnCalculate()\n kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden.\nFalls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null) ausgef\u00fchrt werden.\n\n\nBeispiel\n\n\nif (Bars.IsFirstBarInSession)\nPrint (\"Die aktuelle Handelsitzung hat um\" + Time [0]);\n\n\n\n\nBars.isGrowing\n\n\nBeschreibung\n\n\nBar-Eigenschaften verwendet, wenn Bar aufw\u00e4chst.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nkeine\n\n\nBeispiel\n\n\nBars[0].isGrowing;\n\n\n\n\nBars.IsIntraday\n\n\nBeschreibung\n\n\nMit Bars.IsIntraday kann \u00fcberpr\u00fcft werden, ob es sich um reine Intraday-Bars handelt. Entweder mit Ber\u00fccksichtigung von Ticks - Bars.IsIntraday.\n\n\nR\u00fcckgabewert\n\n\nbool\n\n\nEr gibt \"true\" zur\u00fcck, wenn TimeFrame intra-day (z. B. 1 min, 15 min, 1 h usw.) und \"false\" in anderen F\u00e4llen ist.\n\n\nVerwendung\n\n\nBars.IsIntraday\n\n\n\n\nBeispiel\n\n\nif(Bars.IsIntraday) {\n    Print(\"TimeFrame is Intraday.\");\n} else {\n    Print(\"TimeFrame is not Intraday.\");\n}\n\n\n\n\nBars.IsNtb\n\n\nBeschreibung\n\n\nMit Bars.IsNtb kann \u00fcberpr\u00fcft werden, ob es sich um Not-Time-Based-Bars handelt. Bei Ntb-Bars handelt es sich beispielsweise um Point & Figure oder Renko Charts.\nSiehe auch weitere  \nEigenschaften\n von Bars.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nTyp bool\n\n\nVerwendung\n\n\nBars.IsNtb\n\n\nWeitere Informationen\n\n\nInnerhalb von \nOnCalculate()\n kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden.\nFalls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null) ausgef\u00fchrt werden.\n\n\nBeispiel\n\n\nPrint(\"Die angezeigten Bars sind Ntb:\" + Bars.IsNtb);\n\n\n\n\nBars.IsSessionBreak\n\n\nBeschreibung\n\n\nMit Bars.IsSessionBreak kann ermittelt werden, ob die Bars innerhalb der laufenden Handelssitzung in den im Marktplatz-Escort definierten Handelspausen liegen.\n\n\nSiehe auch weitere \nEigenschaften\n von Bars.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nTyp bool\n\n\nVerwendung\n\n\nBars.IsSessionBreak\n\n\nWeitere Informationen\n\n\n\n\nBeispiel\n\n\nif (Bars.IsSessionBreak)\n{\nPrint(\"Die B\u00f6rse Xetra hat gerade eine Handelspause.\");\n}\n\n\n\n\nBars.LastBarCompleteness\n\n\nBeschreibung\n\n\nBars.LastBarCompleteness liefert einen Wert, der angibt, zu wieviel Prozent ein Bar bereits fertiggestellt ist. Ein Bar in der Zeiteinheit 10 Minuten ist z.B. nach 5 Minuten genau zu 50% fertig.\n\n\nF\u00fcr nicht-zeitbasierte Chartarten (Kagi, LineBreak, Renko, Range, P&F usw.) und w\u00e4hrend eines Backtests liefert die Eigenschaft immer eine 0.\n\n\nR\u00fcckgabewert\n\n\ndouble\n\n\nals Prozentwert, d.h. f\u00fcr 30% wird 0.3 zur\u00fcckgegeben-\n\n\nVerwendung\n\n\nBars.LastBarCompleteness\n\n\nWeitere Informationen\n\n\nInnerhalb von \nOnCalculate()\n kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden.\n\n\nFalls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null) ausgef\u00fchrt werden.\n\n\nBeispiel\n\n\n// Ein 60 Min. Chart wird intraday beobachtet.\n// Jeweils 5 Min. bevor der aktuelle Bar schlie\u00dft,\n// soll ein akustisches Signal ausgegeben werden.\n// 55 Min. entsprechen 92%\n\nbool remind = false;\nprotected override void OnCalculate()\n{\nif (FirstTickOfBar) remind = true;\nif (remind && Bars.LastBarCompleteness >= 0.92)\n{\nremind = false;\nPlaySound(\"Alert1\");\n}\n}\n\n\n\n\nBars.NextSessionBeginTime\n\n\nBeschreibung\n\n\nBars.NextSessionBeginTime liefert das Datum und die Uhrzeit des Beginns der auf die aktuell laufende Handelssitzung folgenden Sitzung.\nDatum und Uhrzeit f\u00fcr den Beginn der n\u00e4chsten Handelssitzung werden auch dann korrekt angegeben, wenn die Funktion von einem Bar in der Vergangenheit aufgerufen wird.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nTyp DateTime\n\n\nVerwendung\n\n\nBars.GetSessionNextBegin\n\n\nWeitere Informationen\n\n\nDie Uhrzeit des zur\u00fcckgegebenen Wertes entspricht der im MarketEscort angegebenen Startzeit der Handelssitzung des jeweiligen Handelsplatzes. Der f\u00fcr den Wert verwendete Handelsplatz wird im Instrumet Escort eingestellt und kann in AgenaSript mit der Funktion \nInstrument.Exchange\n ermittelt werden.\n\n\n\n\nBeispiel\n\n\nPrint(\"Die n\u00e4chste Handelssitzung beginnt um \" + Bars.NextSessionBeginTime);\n\n\n\n\nBars.NextSessionEndTime\n\n\nBeschreibung\n\n\nBars.NextSessionEndTime liefert das Datum und die Uhrzeit f\u00fcr das Ende der auf die aktuell laufende Handelssitzung folgenden Sitzung.\nDatum und Uhrzeit f\u00fcr das Ende der n\u00e4chsten Handelssitzung werden auch dann korrekt angegeben, wenn die Funktion von einem Bar in der Vergangenheit aufgerufen wird.\nSiehe auch weitere  \nEigenschaften\n von Bars.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nTyp DateTime\n\n\nVerwendung\n\n\nBars.GetSessionNextEnd\n\n\nWeitere Informationen\n\n\nDie Uhrzeit des zur\u00fcckgegebenen Wertes entspricht der im MarketEscort angegebenen Endezeit der Handelssitzung des jeweiligen Handelsplatzes. Der f\u00fcr den Wert verwendete Handelsplatz wird im Instrumet Escort eingestellt und kann in AgenaSript mit der Funktion \nInstrument.Exchange\n ermittelt werden.\n\n\n\n\nBeispiel\n\n\nPrint(\"Die n\u00e4chste Handelssitzung endet um \" + Bars.NextSessionEndTime);\n\n\n\n\nBars.TailBottom\n\n\nBeschreibung\n\n\nMit dieser Eigenschaft ist es m\u00f6glich die H\u00f6he des unteren Dochtes der Kerze zu ermitteln.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nkeine\n\n\nVerwendung\n\n\nBars[0].TailBottom;\n\n\n\n\nBeispiel\n\n\nPrint(\"Die H\u00f6he des unteren Dochtes ist: \" + Bars.TailBottom);\n\n\n\n\nBars.TailTop\n\n\nBeschreibung\n\n\nMit dieser Eigenschaft ist es m\u00f6glich die H\u00f6he des oberen Dochtes der Kerze zu ermitteln.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nkeine\n\n\nVerwendung\n\n\nBars[0].TailTop;\n\n\n\n\nBeispiel\n\n\nPrint(\"Die H\u00f6he des oberen Dochtes ist: \" + Bars.TailTop);\n\n\n\n\nBars.TicksCountForLastBar\n\n\nBeschreibung\n\n\nBars.TicksCountForLastBar liefert die Gesamtanzahl der in einem Bar enthaltenen Ticks.\n\n\nSiehe auch weitere \nEigenschaften\n von Bars.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nTyp int\n\n\nVerwendung\n\n\nBars.TicksCountForLastBar\n\n\nWeitere Informationen\n\n\nInnerhalb von \nOnCalculate()\n kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden.\n\n\nFalls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit \nif\n (Bars != \nnull\n) ausgef\u00fchrt werden.\n\n\nBeispiel\n\n\nPrint(\"Der aktuelle Bar besteht aus \" + Bars.TicksCountForLastBar + \" Ticks.\");\n\n\n\n\nBars.TicksCountInTotal\n\n\nBeschreibung\n\n\nBars.TicksCountInTotal  liefert die Gesamtzahl aller Ticks von dem Moment an, von dem die Funktion aufgerufen wird.\n\n\nSiehe auch weitere  \nEigenschaften\n von Bars.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nTyp int\n\n\nVerwendung\n\n\nBars.TicksCountInTotal\n\n\nWeitere Informationen\n\n\nDer Datentyp int hat einen positiven Wertebereich von 2147483647. Wenn 10 Ticks je Sekunde angenommen werden, gibt es auch nach 2 Handelsmonaten bei einem 24h-Handel noch kein \u00dcberlauf.\n\n\nInnerhalb von \nOnCalculate()\nkann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden.\n\n\nFalls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit \nif\n (Bars != \nnull\n) ausgef\u00fchrt werden.\n\n\nBeispiel\n\n\n//Anwendung in einem 30 Minuten Chart\nPrint(\"Die Gesamtanzahl der gelieferten Ticks in diesem Wert betr\u00e4gt \" + Bars.TicksCountInTotal);\n\n\n\n\nBars.TimeFrame\n\n\nBeschreibung\n\n\nBars.TimeFrame liefert ein TimeFrame-Objekt, das Informationen zum aktuell verwendeten Zeiteinheit enth\u00e4lt.\n\n\nSiehe auch weitere \nEigenschaften\n von Bars.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nTyp ITimeFrame\n\n\nVerwendung\n\n\nBars.TimeFrame\n\n\nWeitere Informationen\n\n\nF\u00fcr weitere Informationen zum TimeFrame-Objekt siehe unter \nTimeFrame\n.\n\n\nInnerhalb von \nOnCalculate()\n kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden.\n\n\nFalls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit  \nif\n (Bars != \nnull\n) ausgef\u00fchrt werden.\n\n\nBeispiel\n\n\n//Anwendung in einem 30 Minuten Chart\nTimeFrame tf = (TimeFrame) Bars.TimeFrame;\nPrint(Bars.TimeFrame); //liefert \"30 Min\"\nPrint(tf.Periodicity); // liefert \"Minute\"\nPrint(tf.PeriodicityValue); // liefert \"30\"\n\n\n\n\nBarsCountForSession\n\n\nBeschreibung\n\n\nBars.BarsCountForSession liefert die Anzahl der Bars, die seit dem Beginn der aktuellen Handelssitzung entstanden sind.\n\n\nSiehe auch weitere \nEigenschaften\n von Bars.\n\n\nR\u00fcckgabewert\n\n\nTyp int Anzahl der Bars\n\n\nEin Wert von -1 deutet auf ein Problem bei der Ermittlung des Sessionbeginns hin.\n\n\nVerwendung\n\n\nBars.BarsCountForSession\n\n\nWeitere Informationen\n\n\nInnerhalb von \nOnCalculate()\n kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden.\n\n\nFalls diese Eigenschaft ausserhalb von OnBarUpdate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit  \nif\n (Bars!= \nnull\n)  ausgef\u00fchrt werden.\n\n\nBeispiel\n\n\nPrint (\"Seit dem Start der letzten Handelssitzung sind\" + Bars.BarsCountForSession + \"Bars entstanden.\");\n\n\n\n\nProcessingBarIndexLast\n\n\nBeschreibung\n\n\nGibt an, ob der aktuelle Bar zuletzt berechnet wurde.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nTyp bool\n\n\nVerwendung\n\n\nProcessingBarIndexLast\n\n\nWeitere Informationen\n\n\nVerwendet f\u00fcr komplizierte Berechnung auf einem letzten Bar\n\n\nBeispiel\n\n\nprotected override void OnCalculate()\n        {\n            base.OnCalculate();\n            if (!IsProcessingBarIndexLast)\n                return;\n            bool isUpdated;\n}\n\n\n\n\nCollections\n\n\nChartDrawings\n\n\nBeschreibung\n\n\nChartDrawings  ist eine Collection, die alle Zeichenobjekte im Chart enth\u00e4lt. In ChartDrawings werden sowohl dem Chart manuell hinzugef\u00fcgte Zeichenobjekte, als auch von einem Script gezeichnete Objekte aufgenommen.\n\n\nDer Index f\u00fcr ChartDrawings ist der eindeutige Name der Zeichenobjekte (string tag).\n\n\nVerwendung\n\n\nChartDrawings [string tag]\n\n\nBeispiele\n\n\nHinweis:\n  Um die Interface-Definitionen nutzen zu k\u00f6nnen, mu\u00df in den Using-Anweisungen\n\n\nusing AgenaTrader.Plugins;\n// Anzahl der Zeichenobjekte auf dem Chart und deren Tags ausgeben\nPrint(\"Auf dem Chart befinden sich  \" + ChartDrawings.Count + \" Zeichenobjekte\");\nforeach (IDrawObject draw in ChartDrawings) Print(draw.Tag);\n//Eine schwarze Trendlinie zeichnen ...\nAddChartLine(\"MyLine\", true, 10, Close[10], 0, Close[0], Color.Black, DashStyle.Solid, 3);\n/ ... und die Farbe auf Rot \u00e4ndern\nITrendLine line = (ITrendLine) ChartDrawings[\"MyLine\"];\nif (line != null) line.Pen.Color = Color.Red;\n// alle vertikalen Linien in Chart auf Linienst\u00e4rke 3 setzen,\n// und nicht verschiebbar und nicht editierbar machen\nforeach (IDrawObject draw in ChartDrawings)\nif (draw is IVerticalLine)\n{\nIVerticalLine vline = (IVerticalLine) draw;\nvline.IsLocked = true;\nvline.Editable = false;\nvline.Pen.Width = 3;\n}\n\n\n\n\nInSeries\n\n\nBeschreibung\n\n\nInSeries ist ein  \nDatenSerien\n Objekt, in dem die Eingangsdaten f\u00fcr einen Indikator bzw. eine Strategie enthalten sind.\n\n\nWird ein Indikator ohne explizite Angabe von Eingangsdaten aufgerufen, wird immer der Schlusskurs (Close) der aktuell im Chart geladenen Kursdaten verwendet.\n\n\nBei einem Aufruf von SMA(20) wird der gl. Durchschnitt auf die Schlusskurse der aktuellen Chart-Kursdaten berechnet (dies entspricht SMA(Close, 20).\n\n\nInSeries[0] = Close[0].\n\n\nBei dem Aufruf von SMA(High, 20) werden die H\u00f6chstkurse der geladenen Daten f\u00fcr die Berechnung des gl. Durchschnitts verwendet.\n\n\nInSeries[0] = High[0].\n\n\nSo kann jede beliebige Datenreihe als Input f\u00fcr einen Indikator verwendet werden.\n\n\ndouble\n d = \nRSI\n(\nSMA\n(20), 14, 3)[0]; berechnet beispielsweise den 14-Perioden-RSI \u00fcber die SMA(20) Werte als Eingangsdatenreihe.\nInSeries[0] = SMA(20)[0].\n\n\nVerwendung\n\n\nInSeries\nInSeries[int barsAgo]\n\n\n\n\nBeispiele\n\n\nPrint(\"Die Eingangsdaten f\u00fcr den Indikator sind \" + InSeries[0]);\n\n\n\n\nLines\n\n\nBeschreibung\n\n\nLines ist eine Collection, die die  \nLevelLine\n Objekte eines Indikators enth\u00e4lt.\n\n\nWenn einem Indikator mit der \nAdd()\n Methode ein Line-Objekt hinzugef\u00fcgt wird, wird dieses automatisch der Collection Lines hinzugef\u00fcgt.\n\n\nDie Reihenfolge der Add-Befehle bestimmt dabei auch die Sortierung in Lines. Der erste Aufruf von Add() erzeugt Lines[0], der n\u00e4chste Lines[1] usw.\n\n\nSiehe auch \nOutputDescriptor\n.\n\n\nVerwendung\n\n\nLines[int index]\n\n\n\n\nBeispiele\n\n\n// Add \"using System.Drawing.Drawing2D;\" for DashStyle\nprotected override void OnInit()\n{\nAdd(new LevelLine(Color.Blue, 70, \"Upper\")); // gespeichert in Lines[0]\nAdd(new LevelLine(Color.Blue, 30, \"Lower\")); // gespeichert in Lines[1]\n}\nprotected override void OnCalculate()\n{\n// Wenn RSI \u00fcber 70, Eigenschaften der Linie \u00e4ndern\nif (RSI(14 ,3) >= 70)\n{\nLines[0].Width = 3;\nLines[0].Color = Color.Red;\nLines[0].DashStyle = DashStyle.Dot;\n}\nelse\n{\nLines[0].Width = 1;\nLines[0].Color = Color.Blue;\nLines[0].DashStyle = DashStyle.Solid;\n}\n}\n\n\n\n\nPlotColors\n\n\nBeschreibung\n\n\nPlotColors ist eine Collection, die die ColorSeries aller Plot-Objekte enth\u00e4lt.\n\n\nWenn einem Indikator mit der \nAdd()\n Methode ein Plot hinzugef\u00fcgt wird, wird automatisch auch ein ColorSeries-Objekt erzeugt und der Collection PlotColors hinzugef\u00fcgt.\n\n\nDie Reihenfolge der Add-Befehle bestimmt dabei auch die Sortierung in PlotColors. Der erste Aufruf von Add() erzeugt PlotColors[0], der n\u00e4chste PlotColors[1] usw.\n\n\nVerwendung\n\n\nPlotColors[int PlotIndex][int barsAgo]\n\n\n\n\nWeitere Informationen\n\n\nInformationen zur Klasse Collection:\n\nhttp://msdn.microsoft.com/en-us/library/ybcx56wz%28v=vs.80%29.aspx\n\n\nBeispiel\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing AgenaTrader.API;\nnamespace AgenaTrader.UserCode\n{\n[Description(\"PlotColor Demo\")]\npublic class PlotColorsDemo : UserIndicator\n{\npublic DataSeries SMA20 { get {return Outputs[0];} }\npublic DataSeries SMA50 { get {return Outputs[1];} }\npublic DataSeries SMA100 { get {return Outputs[2];} }\nprivate Pen pen;\nprotected override void OnInit()\n{\n// Linienst\u00e4rke (Width) auf 4 einstellen\npen = new Pen(Color.Empty, 4);\n // Dem Chart drei Plots mit der def. Linienst\u00e4rke hinzuf\u00fcgen\nAdd(new OnPaint(pen, OutputSeriesDisplayStyle.LevelLine, \"SMA20\" )); //attached to PlotColors[0]\nAdd(new OnPaint(pen, OutputSeriesDisplayStyle.LevelLine, \"SMA50\" )); //attached to PlotColors[1]\nAdd(new OnPaint(pen, OutputSeriesDisplayStyle.LevelLine, \"SMA100\")); //attached to PlotColors[2]\nIsOverlay = true;\n}\nprotected override void OnCalculate()\n{\n // Den drei Plots Werte zuweisen\nSMA20.Set (SMA(20) [0]);\nSMA50.Set (SMA(50) [0]);\nSMA100.Set(SMA(100)[0]);\n// Farben je nach Kursverlauf \u00e4ndern\nif (IsSerieRising(Close))\n{\nPlotColors[0][0] = Color.LightGreen;\nPlotColors[1][0] = Color.Green;\nPlotColors[2][0] = Color.DarkGreen;\n}\nelse if (IsSerieFalling(Close))\n{\nPlotColors[0][0] = Color.LightSalmon;\nPlotColors[1][0] = Color.Red;\nPlotColors[2][0] = Color.DarkRed;\n}\nelse\n{\nPlotColors[0][0] = Color.LightGray;\nPlotColors[1][0] = Color.Gray;\nPlotColors[2][0] = Color.DarkGray;\n}\n}\n}\n}\n\n\n\n\nOutputDescriptor\n\n\nBeschreibung\n\n\nOutputDescriptor ist eine Collection, die die Plot-Objekte eines Indikators enth\u00e4lt.\n\n\nWenn einem Indikator mit der Add()-Methode ein Plot-Objekt hinzugef\u00fcgt wird, wird dieses automatisch der Collection Plots hinzugef\u00fcgt.\n\n\nDie Reihenfolge der Add-Befehle bestimmt dabei auch die Sortierung in Plots. Der erste Aufruf von Add() erzeugt OutputDescriptor\n[0], der n\u00e4chste OutputDescriptor[1]\\ usw.\n\n\nSiehe auch \nLines\n.\n\n\nVerwendung\n\n\nOutputDescriptor[int index]\n\n\n\n\nBeispiele\n\n\nprotected override void OnInit()\n{\nAdd(new OnPaint(Color.Blue, \"MySMA 20\")); // saved to OutputDescriptor[0]\n}\nprotected override void OnCalculate()\n{\nValue.Set(SMA(20)[0]);\n// Wenn Kurs \u00fcber SMA, Plot gr\u00fcn f\u00e4rben, sonst rot\nif (Close[0] > SMA(20)[0])\n    OutputDescriptor[0].PlotColor = Color.Green;\nelse\n    OutputDescriptor[0].PlotColor = Color.Red;\n}\n\n\n\n\nValues\n\n\nBeschreibung\n\n\nValues ist eine Collection, die die DataSeries-Objekte eines Indikators enth\u00e4lt.\n\n\nWenn einem Indikator mit der Add()-Methode ein Plot hinzugef\u00fcgt wird, wird automatisch auch ein Value-Objekt erzeugt und der Collection Values hinzugef\u00fcgt.\n\n\nDie Reihenfolge der Add-Befehle bestimmt dabei auch die Sortierung in Values. Der erste Aufruf von Add() erzeugt Values[0], der n\u00e4chste Values[1] usw.\n\n\nValue\n ist immer identisch mit Values[0].\n\n\nVerwendung\n\n\nOutputs[int index]\nOutputs[int index][int barsAgo]\n\n\n\n\nWeitere Informationen\n\n\nDie f\u00fcr eine Collection bekannten Methoden Set(), Reset() und Count() sind auf Value bzw. Values anwendbar.\n\n\nInformationen zur Klasse Collection:\n\nhttp://msdn.microsoft.com/en-us/library/ybcx56wz%28v=vs.80%29.aspx\n\n\nBeispiel\n\n\n// \u00dcberp\u00fcfung des zweiten Indikatorwertes (d.h. der sekund\u00e4ren DatenSerie)\n// von vor einem Bar\n// und in Abh\u00e4ngigkeit davon Setzen des aktuellen Indikatorwertes\nif (Outputs[1][1] < High[0] - Low[0])\nValue.Set(High[0] - Low[0]);\nelse\nValue.Set(High[0] - Close[0]);\n\n\n\n\nData Series\n\n\nBeschreibung\n\n\nDatenserien werden in AgenaTrader zum einen unterschieden in die frei f\u00fcr die eigene Programmierung verwendbaren Datenserien zum Speichern von Werten unterschiedlicher Datentypen und zum anderen in die in AgenaTrader fest integrierten Datenserien, die die Kursdaten der einzelnen Bars enthalten. Die letzteren werden hier vorgestellt.\nDas Konzept von Datenserien wird sehr konsequent und durchg\u00e4ngig verfolgt. Alle Kursdaten der einzelnen Bars sind in Datenserien organisiert.\nFolgende Datenserien sind verf\u00fcgbar:\n\n\nOpen\n \nOpens\n\n\nHigh\n \nHighs\n\n\nLow\n \nLows\n\n\nClose\n \nCloses\n\n\nMedian\n \nMedians\n\n\nTypical\n \nTypicals\n\n\nWeighted\n \nWeighteds\n\n\nTime\n \nTimes\n\n\nTimeFrame\n \nTimeFrames\n\n\nVolume\n \nVolumes\n\n\nOpen\n\n\nBeschreibung\n\n\nOpen ist eine \nDataSeries\n vom Typ \nDataSeries\n,  in der die historischen Er\u00f6ffnungskurse gespeichert sind.\n\n\nParameter\n\n\nBarsAgo Indexwert (s. \nBars\n)\n\n\nVerwendung\n\n\nOpen\nOpen[int barsAgo]\n\n\n\n\nWeitere Informationen\n\n\nDer zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft  \nCalculateOnClosedBar\n.\n\n\nBeispiel\n\n\n// Er\u00f6ffnungskurs der aktuellen Periode\nPrint(Time[0] + \" \" + Open[0]);\n// Er\u00f6ffnungskurs des Bars von vor 5 Perioden\nPrint(Time[5] + \" \" + Open[5]);\n// aktueller Wert f\u00fcr den SMA 14 \u00fcber die Er\u00f6ffnungskurse (gerundet)\nPrint(\"SMA(14) calculated using the opening prices: \" + Instrument.Round2TickSize(SMA(Open, 14)[0]));\n\n\n\n\nOpens\n\n\nBeschreibung\n\n\nOpens ist ein Array von Datenserien, welches alle Open-Datenserien enth\u00e4lt.\n\n\nDieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.\n\n\nEin neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird.\n\n\nMit \n[TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]\n enth\u00e4lt das Array 3 Eintr\u00e4ge:\n\n\nOpens[0] die Open-Dataseries der Chart-Zeiteinheit\nOpens[1] die Open-Dataseries aller Bars auf Tagesbasis\nOpens[2] die Open-Dataseries aller Bars auf Wochenbasis.\n\n\nOpens[0][0] entspricht Open[0].\n\n\nSiehe auch \nMultiBars\n\n\nParameter\n\n\nbarsAgo Indexwert der einzelnen Bars innerhalb der Dataseries (s. \nBars\n)\nbarSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten\n\n\nVerwendung\n\n\nOpens[int barSeriesIndex]\nOpens[int barSeriesIndex][int barsAgo]\n\n\n\n\nWeitere Informationen\n\n\nDer zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft \nCalculateOnClosedBar\n.\n\n\nBeispiel\n\n\nSiehe Beispiel unter \nMultibars\n.\n\n\nHigh\n\n\nDescription\n\n\nHigh ist eine \nDataSeries\n vom Typ \nDataSeries\n, in der die historischen H\u00f6chstkurse gespeichert sind.\n\n\nParameter\n\n\nbarsAgo Indexwert (s. \nBars\n)\n\n\nVerwendung\n\n\nHigh\nHigh[int barsAgo]\n\n\n\n\nWeitere Informationen\n\n\nDer zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft  \nCalculateOnClosedBar\n.\n\n\nBeispiel\n\n\n//H\u00f6chstkurs der aktuellen Periode\nPrint(Time[0] + \" \" + High[0]);\n// H\u00f6chstkurs des Bars von vor 5 Perioden\nPrint(Time[5] + \" \" + High[5]);\n// aktueller Wert f\u00fcr den SMA 14 \u00fcber die H\u00f6chstkurse (gerundet)\nPrint(\"SMA(14) Calculated using the high prices: \" + Instrument.Round2TickSize(SMA(High, 14)[0]));\n\n\n\n\nHighs\n\n\nBeschreibung\n\n\nHighs ist ein Array von [\nDataSeries\n][1] welches alle High-Datenserien enth\u00e4lt.\n\n\nDieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.\n\n\nEin neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird\n\n\nMit \n[TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]\n enth\u00e4lt das Array 3 Eintr\u00e4ge.\n\n\nHighs[0] die High-Dataseries der Chart-Zeiteinheit\nHighs[1] die High-Dataseries aller Bars auf Tagesbasis\nHighs[2] die High-Dataseries aller Bars auf Wochenbasis.\n\n\nHighs[0][0] entspricht High[0].\n\n\nSiehe auch \nMultiBars\n.\n\n\nParameter\n\n\nbarsAgo  Indexwert der einzelnen Bars innerhalb der Dataseries (s. \nBars\n)\nbarSeriesIndex  Indexwert der unterschiedlichen Zeiteinheiten\n\n\nVerwendung\n\n\nHighs[int barSeriesIndex]\nHighs[int barSeriesIndex][int barsAgo]\n\n\n\n\nWeitere Informationen\n\n\nDer zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft \nCalculateOnClosedBar\n.\n\n\nBeispiel\n\n\nSiehe Beispiel unter  \nMultibars\n.\n\n\nLow\n\n\nBeschreibung\n\n\nLow ist eine \nDataSeries\n vom Typ \nDataSeries\n,  in der die historischen Tiefstkurse gespeichert sind.\n\n\nParameter\n\n\nbarsAgo Indexwert (s. \nBars\n)\n\n\nVerwendung\n\n\nLow\nLow[int barsAgo]\n\n\n\n\nWeitere Informationen\n\n\nDer zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft \nCalculateOnClosedBar\n.\n\n\nBeispiel\n\n\n// Tiefstkurs der aktuellen Periode\nPrint(Time[0] + \" \" + Low[0]);\n// Tiefstkurs des Bars von vor 5 Perioden\nPrint(Time[5] + \" \" + Low[5]);\n// aktueller Wert f\u00fcr den SMA 14 \u00fcber die Tiefstkurse (gerundet)\nPrint(\"SMA(14) calculated using the high prices: \" + Instrument.Round2TickSize(SMA(Low, 14)[0]));\n\n\n\n\nLows\n\n\nBeschreibung\n\n\nLows ist ein Array von [\nDataSeries\n][1] welches alle \nLow\n-Datenserien enth\u00e4lt.\n\n\nDieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.\n\n\nEin neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird.\n\n\nMit \n[TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]\n  enth\u00e4lt das Array 3 Eintr\u00e4ge.\n\n\nLows[0] die Low-Dataseries der Chart-Zeiteinheit\nLows[1] die Low-Dataseries aller Bars auf Tagesbasis\nLows[2] die Low-Dataseries aller Bars auf Wochenbasis.\n\n\nLows[0][0] entspricht Low[0].\n\n\nSiehe auch \nMultiBars\n.\n\n\nParameter\n\n\nbarsAgo  Indexwert der einzelnen Bars innerhalb der Dataseries\nbarSeriesIndex  Indexwert der unterschiedlichen Zeiteinheiten\n\n\nVerwendung\n\n\nLows[int barSeriesIndex]\nLows[int barSeriesIndex][int barsAgo]\n\n\n\n\nWeitere Informationen\n\n\nDer zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft \nCalculateOnClosedBar\n.\n\n\nBeispiel\n\n\nSiehe Beispiel unter \nMultibars\n.\n\n\nClose\n\n\nBeschreibung\n\n\nClose ist eine \nDataSeries\n vom Typ \nDataSeries\n, in der die historischen Schlusskurse gespeichert sind.\n\n\nParameter\n\n\nbarsAgo Indexwert (s. \nBars\n)\n\n\nVerwendung\n\n\nClose\nClose[int barsAgo]\n\n\n\n\nWeitere Informationen\n\n\nDer zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft \nCalculateOnClosedBar\n.\n\n\nIndikatoren werden standardm\u00e4\u00dfig \u00fcber die Schlusskurse berechnet. Die Angabe der Input-Serie kann weggelassen werden (siehe Beispiel unten).\n\n\nBeispiel\n\n\n// Schlusskurs der aktuellen Periode\nPrint(Time[0] + \" \" + Close[0]);\n// Schlusskurs des Bars von vor 5 Perioden\nPrint(Time[5] + \" \" + Close[5]);\n// aktueller Wert f\u00fcr den SMA 14 \u00fcber die Schlusskurse (gerundet)\nPrint(\"SMA(14) calculated using the closing prices: \" + Instrument.Round2TickSize(SMA(Close, 14)[0]));\n// Close kann auch weggelassen werden, da es per Default verwendet wird.\nPrint(\"SMA(14) calculated using the closing prices: \" + Instrument.Round2TickSize(SMA(14)[0]));\n\n\n\n\nCloses\n\n\nBeschreibung\n\n\nCloses ist ein Array von [\nDataSeries\n][1] welches alle \nLow\n-Datenserien enth\u00e4lt.\n\n\nDieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.\n\n\nEin neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird.\n\n\nMit \n[TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]\n enth\u00e4lt das Array 3 Eintr\u00e4ge.\n\n\nCloses[0] die Close-Dataseries der Chart-Zeiteinheit\nCloses[1] die Close-Dataseries aller Bars auf Tagesbasis\nCloses[2] die Close-Dataseries aller Bars auf Wochenbasis.\n\n\nCloses[0][0] entspricht Close[0].\n\n\nSiehe auch \nMultiBars\n.\n\n\nParameter\n\n\nbarsAgo Indexwert der einzelnen Bars innerhalb der Dataseries\nbarSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten\n\n\nVerwendung\n\n\nCloses[int barSeriesIndex]\nCloses[int barSeriesIndex][int barsAgo]\n\n\n\n\nWeitere Informationen\n\n\nDer zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft \nCalculateOnClosedBar\n.\n\n\nBeispiel\n\n\nSiehe Beispiel unter \nMultibars\n.\n\n\nMedian\n\n\nBeschreibung\n\n\nMedian ist eine \nDataSeries\n vom Typ \nDataSeries\nin der die historischen Median-Werte gespeichert sind.\n\n\nDer Median-Preis eines Bars ergibt sich aus (High + Low) / 2.\n\n\nSiehe auch \nTypical\n und \nWeighted\n.\n\n\nParameter\n\n\nbarsAgo Indexwert (s. \nBars\n)\n\n\nVerwendung\n\n\nMedian\nMedian[int barsAgo]\n\n\n\n\nWeitere Informationen\n\n\nDer zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft \nCalculateOnClosedBar\n.\n\n\nInformationen zu Median, Typical und Weighted:\n\nhttp://blog.nobletrading.com/2009/12/median-price-typical-price-weighted.html\n\n\nBeispiel\n\n\n// Median-Preis der aktuellen Periode\nPrint(Time[0] + \" \" + Median[0]);\n// Median-Preis des Bars von vor 5 Perioden\nPrint(Time[5] + \" \" + Median[5]);\n// aktueller Wert f\u00fcr den SMA 14 \u00fcber die Median-Preise (gerundet)\nPrint(\"SMA(14) calculated using the median prices: \" + Instrument.Round2TickSize(SMA(Median, 14)[0]));\n\n\n\n\nMedians\n\n\nBeschreibung\n\n\nMedians ist ein Array von  [\nDataSeries\n][1] welches alle \nMedian\n-Datenserien enth\u00e4lt.\n\n\nDieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.\n\n\nEin neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird.\n\n\nMit \n[TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]\n  enth\u00e4lt das Array 3 Eintr\u00e4ge.\n\n\nMedians[0] die Median-Dataseries der Chart-Zeiteinheit\nMedians[1] die Median-Dataseries aller Bars auf Tagesbasis\nMedians[2] die Median-Dataseries aller Bars auf Wochenbasis.\n\n\nMedians[0][0]entspricht Medians[0].\n\n\nSiehe auch \nMultiBars\n.\n\n\nParameter\n\n\nbarsAgo Indexwert der einzelnen Bars innerhalb der Dataseries\nbarSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten\n\n\nVerwendung\n\n\nMedians[int barSeriesIndex]\nMedians[int barSeriesIndex][int barsAgo]\n\n\n\n\nWeitere Informationen\n\n\nDer zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft  \nCalculateOnClosedBar\n.\n\n\nInformationen zu Median, Typical und Weighted: \nhttp://www.investopedia.com/terms/m/median.asp\n\n\nBeispiel\n\n\nSiehe Beispiel unter \nMultibars\n.\n\n\nTypical\n\n\nBeschreibung\n\n\nTypical ist eine \nDataSeries\n vom Typ \nDataSeries\nin der die historischen Typical-Werte gespeichert sind.\n\n\nDer Typical-Preis eines Bars ergibt sich aus (High + Low + Close) / 3.\n\n\nSiehe auch \nMedian\n und \nWeighted\n.\n\n\nParameter\n\n\nbarsAgo Indexwert (s. \nBars\n)\n\n\nVerwendung\n\n\nTypical\nTypical[int barsAgo]\n\n\n\n\nWeitere Informationen\n\n\nDer zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft  \nCalculateOnClosedBar\n.\n\n\nInformationen zu Median, Typical und Weighted: \nhttps://technicianapp.com/resources/typical-price/\n\n\nBeispiel\n\n\n// Typical-Preis der aktuellen Periode\nPrint(Time[0] + \" \" + Typical[0]);\n// Typical-Preis des Bars von vor 5 Perioden\nPrint(Time[5] + \" \" + Typical[5]);\n// aktueller Wert f\u00fcr den SMA 14 \u00fcber die Typical-Preise (gerundet)\nPrint(\"SMA(14) calculated using the typical price: \" + Instrument.Round2TickSize(SMA(Typical, 14)[0]));\n\n\n\n\nTypicals\n\n\nBeschreibung\n\n\nTypicals ist ein Array von \nDatenserien\n, welches alle  \nTypical\n-Datenserien enth\u00e4lt.\n\n\nDieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.\n\n\nEin neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird.\n\n\nMit \n[TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]\n enth\u00e4lt das Array 3 Eintr\u00e4ge.\n\n\nTypicals[0] die Typical-Dataseries der Chart-Zeiteinheit\nTypicals[1] die Typical-Dataseries aller Bars auf Tagesbasis\nTypicals[2] die Typical-Dataseries aller Bars auf Wochenbasis.\n\n\nTypicals[0][0] entspricht Typicals[0].\n\n\nSiehe auch \nMultiBars\n.\n\n\nParameter\n\n\nbarsAgo Indexwert der einzelnen Bars innerhalb der Dataseries\nbarSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten\n\n\nVerwendung\n\n\nTypicals[int barSeriesIndex]\nTypicals[int barSeriesIndex][int barsAgo]\n\n\n\n\nWeitere Informationen\n\n\nDer zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft  \nCalculateOnClosedBar\n.\n\n\nBeispiel\n\n\nSiehe Beispiel unter  \nMultibars\n.\n\n\nWeighted\n\n\nBeschreibung\n\n\nWeighted ist eine \nDataSeries\n vom Typ \nDataSeries\n, in der die historischen Weighted-Werte gespeichert.\n\n\nDer Weighted-Preis eines Bars ergibt sich aus (high + low + 2*close) / gewichtet auf den Schlusskurs.\n\n\nSiehe auch \nMedian\n und \nTypical\n.\n\n\nParameter\n\n\nbarsAgo Indexwert (s. \nBars\n)\n\n\nVerwendung\n\n\nWeighted[int barsAgo]\n\n\n\n\nWeitere Informationen\n\n\nDer zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft  \nCalculateOnClosedBar\n.\n\n\nInformationen zu Median, Typical und Weighted: \nhttp://www.stock-trading-infocentre.com/pivot-points.html\n\n\nBeispiel\n\n\n// Weighted-Preis der aktuellen Periode\nPrint(Time[0] + \" \" + Weighted[0]);\n// Weighted-Preis des Bars von vor 5 Perioden\nPrint(Time[5] + \" \" + Weighted[5]);\n// aktueller Wert f\u00fcr den SMA 14 \u00fcber die Weighted-Preise (gerundet)\nPrint(\"SMA(14) calculated using the weighted price: \" + Instrument.Round2TickSize(SMA(Weighted, 14)[0]));\n\n\n\n\nWeighteds\n\n\nBeschreibung\n\n\nWeighteds ist ein Array von  [\nDataSeries\n][1] welches alle \nWeighted\n-Datenserien enth\u00e4lt.\n\n\nDieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.\n\n\nEin neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird.\n\n\nMit \n[TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]\n   enth\u00e4lt das Array 3 Eintr\u00e4ge.\n\n\nWeighteds[0] die Weighted-Dataseries der Chart-Zeiteinheit\nWeighteds[1] die Weighted-Dataseries aller Bars auf Tagesbasis\nWeighteds[2] die Weighted-Dataseries aller Bars auf Wochenbasis\n\n\nWeighteds[0][0] entspricht Weighteds[0].\n\n\nSiehe auch  \nMultiBars\n.\n\n\nParameter\n\n\nbarsAgo Indexwert der einzelnen Bars innerhalb der Dataseries\nbarSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten\n\n\nVerwendung\n\n\nWeighteds[int barSeriesIndex]\nWeighteds[int barSeriesIndex][int barsAgo]\n\n\n\n\nWeitere Informationen\n\n\nDer zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft \nCalculateOnClosedBar\n.\n\n\nBeispiel\n\n\nSiehe Beispiel unter \nMultibars\n.\n\n\nTime\n\n\nBeschreibung\n\n\nTime ist eine \nDataSeries\n vom Typ \nDateTimeSeries\n, in der die Zeitstempel der einzelnen Bars gespeichert sind.\n\n\nParameter\n\n\nbarsAgo Indexwert (s. \nBars\n)\n\n\nVerwendung\n\n\nTime\nTime[int barsAgo]\n\n\n\n\nWeitere Informationen\n\n\nDer zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft  \nCalculateOnClosedBar\n.\n\n\nBeispiel\n\n\n// Zeitstempel der aktuellen Periode\nPrint(Time[0]);\n// Zeitstempel des Bars von vor 5 Perioden\nPrint(Time[5]);\n\n\n\n\nTimes\n\n\nBeschreibung\n\n\nTimes ist ein Array von \nDataSeries\n welches alle \nTime\n-Datenserien enth\u00e4lt.\n\n\nDieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.\nEin neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird.\n\n\nMit \n[TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]\n   enth\u00e4lt das Array 3 Eintr\u00e4ge.\n\n\nTimes[0] die Time-Dataseries der Chart-Zeiteinheit\nTimes[1] die Time-Dataseries aller Bars auf Tagesbasis\nTimes[2] die Time-Dataseries der Chart-Zeiteinheit\n\n\nTimes[0][0] entspricht Times[0].\n\n\nSiehe auch  \nMultiBars\n.\n\n\nParameter\n\n\nbarsAgo Indexwert der einzelnen Bars innerhalb der Dataseries\nbarSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten\n\n\nVerwendung\n\n\nTimes[int barSeriesIndex]\nTimes[int barSeriesIndex][int barsAgo]\n\n\n\n\nWeitere Informationen\n\n\nDer zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft \nCalculateOnClosedBar\n.\n\n\nBeispiel\n\n\nSiehe Beispiel unter \nMultibars\n.\n\n\nVolume\n\n\nBeschreibung\n\n\nVolume ist eine \nDataSeries\n vom Typ \nDataSeries\n,  in der die historischen Ums\u00e4tze gespeichert sind.\n\n\nParameter\n\n\nbarsAgo Indexwert (s. \nBars\n)\n\n\nVerwendung\n\n\nVolume\n\n\nVolume[\nint\n barsAgo]\n\n\nWeitere Informationen\n\n\nDer zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft \nCalculateOnClosedBar\n.\n\n\nDer vom Indikator \nVOL()\n zur\u00fcckgelieferte Wert ist identisch mit dem hier beschriebenen Volumen.\nZ.B. liefert Vol()[3]  den gleichen Wert wie Volume[3].\n\n\nBeispiel\n\n\n// Volumen der aktuellen Periode\nPrint(Time[0] + \" \" + Volume[0]);\n// Volumen des Bars von vor 5 Perioden\nPrint(Time[5] + \" \" + Volume[5]);\n// aktueller Wert f\u00fcr den SMA 14 \u00fcber das Volumen (gerundet)\nPrint(\"SMA(14) berechnet \u00fcber das Volumen: \" + Instrument.Round2TickSize(SMA(Volume, 14)[0]));\n\n\n\n\nVolumes\n\n\nBeschreibung\n\n\nVolumes ist ein Array von \nDataSeries\n welches alle \nVolume\n-Datenserien enth\u00e4lt.\n\n\nDieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.\n\n\nEin neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird.\n\n\nMit \n[TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]\n   enth\u00e4lt das Array 3 Eintr\u00e4ge.\n\n\nVolumes[0] die Volume-Dataseries der Chart-Zeiteinheit\nVolumes[1] die Volume-Dataseries aller Bars auf Tagesbasis\nVolumes[2] die Volume-Dataseries aller Bars auf Wochenbasis.\n\n\nVolumes[0][0] entspricht Volumes[0].\n\n\nSiehe auch \nMultiBars\n.\n\n\nParameter\n\n\nbarsAgo Indexwert der einzelnen Bars innerhalb der Dataseries\n\n\nbarSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten\n\n\nVerwendung\n\n\nVolumes[int barSeriesIndex]\nVolumes[int barSeriesIndex][int barsAgo]\n\n\n\n\nWeitere Informationen\n\n\nDer zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft  \nCalculateOnClosedBar\n.\n\n\nBeispiel\n\n\nSiehe Beispiel unter  \nMultibars\n.\n\n\nTimeFrame\n\n\nBeschreibung\n\n\nTimeFrame ist ein Zeitrahmenobjekt. Diese Einstellung/Men\u00fcpunkt wird verwendet, um die aktuelle Zeiteinheit zu lesen, nicht um sie zu festzulegen\n\n\nVerwendung\n\n\nTimeFrame\n\n\n\n\nTimeFrames\n\n\nBeschreibung\n\n\nTimeFrames ist ein Array von TimeFrame-Objekten, welches f\u00fcr jedes Bar-Objekt ein separates TimeFrame-Objekt  enth\u00e4lt.\n\n\nDieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.\n\n\nEin neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird.\n\n\nMit \n[TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]\n enth\u00e4lt das Array 3 Eintr\u00e4ge:\n\n\nTimeFrames [0] TimeFrame der prim\u00e4ren Datenserie (Chart-Zeiteinheit)\nTimeFrames [1] \nPrint\n(TimeFrames[1]);  // liefert \"1 Day\"\nTimeFrames [2] \nPrint\n(TimeFrames[2]); // liefert \"1 Week\"\n\n\nTimeFrames [0] entspricht \nTimeFrame\n.\n\n\nSiehe auch \nMultiBars\n.\n\n\nParameter\n\n\nbarSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten\n\n\nVerwendung\n\n\nTimeFrames [int barSeriesIndex]\n\n\n\n\nBeispiel\n\n\nif (ProcessingBarSeriesIndex == 0 && ProcessingBarIndex == 0)\nfor (int i = BarsArray.Count-1; i >= 0; i--)\nPrint(\"The Indicator \" + this.Name + \" uses Bars of the Timeframe \" + TimeFrames[i]);\n\n\n\n\nInstruments\n\n\n\"Instrument\" bezeichnet einen handelbaren Wert, wie z.B. eine Aktie, einen ETF, einen Future, einen CFD usw.\n\n\nEin Instrument hat viele Eigenschaften, die in einem selbst erstellten AgenaScript verwendet werden k\u00f6nnen.\n\n\nInstrument.Compare\n\n\nInstrument.Currency\n\n\nInstrument.Digits\n\n\nInstrument.ETF\n\n\nInstrument.Exchange\n\n\nInstrument.Expiry\n\n\nInstrument.GetCurrencyFactor\n\n\nInstrument.InstrumentType\n\n\nInstrument.MainSector\n\n\nInstrument.Margin\n\n\nInstrument.Name\n\n\nInstrument.PointValue\n\n\nInstrument.Round2TickSize\n\n\nInstrument.Symbol\n\n\nInstrument.TickSize\n\n\nInnerhalb von  \nOnCalculate()\n k\u00f6nnen diese Eigenschaften verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen.\nSobald die Funktion  \nOnCalculate()\n  von AgenaScript aufgerufen wird, ist immer auch ein Instrument-Objekt vorhanden. Falls diese Eigenschafte ausserhalb von \nOnCalculate()\n, verwendet werden, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit \nif\n (Bars != \nnull\n)\n\n\nInstrument.Compare\n\n\nBeschreibung\n\n\nDie Funktion Instrument.Compare vergleicht 2 Kursdaten unter Ber\u00fccksichtigung der richtigen Anzahl Nachkommastellen. Die kleinstm\u00f6gliche Preis\u00e4nderung wird durch den Wert TickSize angegeben. Diese Funktion vereinfacht den sonst etwas aufw\u00e4ndigeren Vergleich mit Hilfe von Floating-Point-Operationen.\n\n\nParameter\n\n\ndouble value1\ndouble value2\n\n\nR\u00fcckgabewert\n\n\nTyp int\n\n\n1 - Kurs1 ist gr\u00f6\u00dfer als Kurs2\n-1 - Kurs1 ist kleiner als Kurs2\n 0 - Kurs1 und Kurs2 sind gleich\n\n\nVerwendung\n\n\nInstrument.Compare(double Value1, double Value2)\n\n\n\n\nWeitere Informationen\n\n\nBe aware this function compares prices based on TickSize.\n If the ticksize of your instrument is 0.01 these prices will be rounded and compared on 2 decimal digits. If you want a regular comparation of two numbers, you should use the operator \"greater than\" (>) or the operator \"smaller than\" (<).\n\n\nMore infomation about \nmath.round()\n\n\nWenn TickSize z.B. 0,00001 ist, wie bei FX-Werten \u00fcblich, dann liefert\n\n\nCompare(2, 1.99999) eine 1, d.h. 2 ist gr\u00f6\u00dfer als 1.99999\nCompare(2, 2.000001)    eine 0, d.h. die Kurse sind gleich\nCompare(2, 1.999999)    eine 0, d.h. die Kurse sind gleich\nCompare(2, 2.00001) eine -1, d.h. 2 ist kleiner als 2.00001.\n\n\nBeispiel\n\n\nPrint(Instrument.Compare(2, 1.999999));\n\n\n\n\nInstrument.Currency\n\n\nBeschreibung\n\n\nInstrument.Currency liefert ein Currencies-Objekt zur\u00fcck, das die jeweilige W\u00e4hrung beinhaltet, in der das Instrument gehandelt wird.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\neine Konstante vom Typ public enum Currencies\n\n\nVerwendung\n\n\nInstrument.Currency\n\n\nWeitere Informationen\n\n\n\u00dcbliche W\u00e4hrungen sind z.B. AUD, CAD, EUR, GBP, JPY oder USD.\n\n\nBeispiel\n\n\nPrint(Instrument.Name + \"wird in  \" + Instrument.Currency + \" gehandelt\".);\n\n\n\n\nInstrument.Digits\n\n\nBeschreibung\n\n\nInstrument.Digits liefert die Anzahl der Nachkommastellen, mit denen der Kurs des Instrument notiert wird.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nint Digits\n\n\nVerwendung\n\n\nInstrument.Digits\n\n\nWeitere Informationen\n\n\nAktie werden \u00fcblicherweise mit 2 Stellen nach dem Komma gehandelt. Bei Forex sind es je nach Datenanbieter 4 oder 5 Stellen.\n\n\nDie Funktion findet u.a. Verwendung f\u00fcr das Formatieren von Ausgaben oder zur Rundung von Kursdaten. Siehe auch \nTickSize\n und \nInstrument.Round2Ticks\n, \nInstrument.Round2TickSize\n.\n\n\nAusf\u00fchrliche Anleitung zum: \nFormatieren von Zahlen.\n.\n\n\nBeispiel\n\n\nPrint(\"Der Kurs von  \" +Instrument.Name + \" wird mit einer Genauigkeit von\" + Instrument.Digits +\" Nachkommastellen angegeben.\");\n\n\n\n\nInstrument.ETF\n\n\nBeschreibung\n\n\nInstrument.ETF dient der Unterscheidung zwischen einer Aktie und einem ETF. Dies ist notwendig, da ETF's von den B\u00f6rsen auch als \"Stock\" (dt. Aktie) angesehen werden..\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nTyp bool\n\n\nVerwendung\n\n\nInstrument.ETF\n\n\nWeitere Informationen\n\n\nWas ist ein ETF?\n\n\nWikipedia: \nhttp://de.wikipedia.org/wiki/Exchange-traded_fund\n\n\nBeispiel\n\n\nif (Instrument.InstrumentType == InstrumentType.Stock)\nif (Instrument.ETF)\nPrint(\"Der Wert ist ein Exchange-traded Fund.\");\nelse\nPrint(\"Der Wert ist eine Aktie.\");\n\n\n\n\nInstrument.Exchange\n\n\nBeschreibung\n\n\nInstrument.Exchange (Exchange = dt. B\u00f6rse) liefert die Bezeichnung des B\u00f6rsenhandelsplatzes f\u00fcr das aktuelle Instrument.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nein Exchange-Objekt vom Typ public enum Exchanges\n\n\nVerwendung\n\n\nInstrument.Exchange\n\n\nWeitere Informationen\n\n\n\u00dcbersicht B\u00f6rsenhandelspl\u00e4tze\n\n\nBeispiel\n\n\nPrint(\"Das Instrument \" + Instrument.Name +\"  wird an der B\u00f6rse \" + Instrument.Exchange + \" gehandelt.\");\n\n\n\n\nInstrument.Expiry\n\n\nBeschreibung\n\n\nInstrument.Expiry gibt das Datum (Monat und Jahr) des Ablauf eines Finanzinstrumentes an. Nur derivative Handelsinstrumente, wie Optionen oder Futures besitzen ein Ablaufdatum, das sog. Verfallsdatum.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nTyp DateTime\n\n\nF\u00fcr Instrumente ohne Verfallsdatum wird Instrument.Expiry auf DateTime.MaxValue (= 31.12.9999 23.59:59) gesetzt.\n\n\nVerwendung\n\n\nInstrument.Expiry\n\n\nWeitere Informationen\n\n\nDas Verfallsdatum (Expiry) ist auch im Instrument Escort ersichtlich:\n\n\n\n\nBeispiel\n\n\nPrint(\"Das Instrument \" + Instrument.Name +\" verf\u00e4llt am \" + Instrument.Expiry);\n\n\n\n\nInstrument.GetCurrencyFactor\n\n\nBeschreibung\n\n\nInstrument.GetCurrencyFactor liefert einen Umrechnungsfaktor zur\u00fcck, mit dessen Hilfe man den Kurs eines Instruments in die W\u00e4hrung des Accounts umrechnen kann.\n\n\nParameter\n\n\nTyp Currencies\n\n\nR\u00fcckgabewert\n\n\nein double\n\n\nVerwendung\n\n\nInstrument.GetCurrencyFactor(Currencies)\n\n\nWeitere Informationen\n\n\n\u00dcbliche W\u00e4hrungen sind z.B. AUD, CAD, EUR, GBP, JPY oder USD.\n\n\nBeispiel\n\n\nProtected override void OnCalculate()\n{\n   double currFactor = Instrument.GetCurrencyFactor(Account.Currency);\n   Print(Close[0] + \" in \" + Instrument.Currency.ToString() + \" = \" + (Close[0] * currFactor) + \" in \" + Account.Currency.ToString());\n}\n\n\n\n\nInstrument.InstrumentType\n\n\nBeschreibung\n\n\nInstrument.InstrumentType liefert ein Typ-Objekt des Handelsinstrumentes.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nObjekt vom Typ public enum InstrumentType\n\n\nVerwendung\n\n\nInstrument.InstrumentType\n\n\nWeitere Informationen\n\n\nM\u00f6gliche Werte sind: Future, Stock, Index, Currency, Option, CFD und Unknown.\nEinen Typ ETF gibt es nicht. ETF's sind vom Typ Stock, siehe\nInstrument.ETF\n.\n\n\nDer Instrument-Typ ist auch im Instrument Escort ersichtlich:\n\n\n\n\nBeispiel\n\n\nPrint(\"Das Instrument  \" + Instrument.Name + \"  ist vom Typ \" + Instrument.InstrumentType);\n\n\n\n\nInstrument.MainSector\n\n\nBeschreibung\n\n\nInstrument.MainSector liefert den Hauptsektor des Handelsinstrumentes zur\u00fcck.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nString\n\n\nVerwendung\n\n\nInstrument.MainSector\n\n\nWeitere Informationen\n\n\nDer  Hauptsektor ist auch im Instrument Escort ersichtlich:\n\n\n\nBeispiel\n\n\nPrint(\"Das Instrument \" + Instrument.Name + \" ist im Sektor \" + Instrument.MainSector + \" t\u00e4tig.\");\n\n\n\n\nInstrument.Margin\n\n\nBeschreibung\n\n\nInstrument.Margin liefert die erforderliche Margin des Handelsinstrumentes zur\u00fcck.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nint\n\n\nVerwendung\n\n\nInstrument.Margin\n\n\nWeitere Informationen\n\n\nMargin ist auch im Instrument Escort ersichtlich:\n\n\n\nBeispiel\n\n\nPrint(\"Das Instrument\" + Instrument.Name + \" hat eine Margin von  \" + Instrument.Margin);\n\n\n\n\nInstrument.Name\n\n\nBeschreibung\n\n\nInstrument.Name liefert die Bezeichnung des Handelsinstrumentes.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nTyp string\n\n\nVerwendung\n\n\nInstrument.Name\n\n\nWeitere Informationen\n\n\nDer Instrument Name ist auch im Instrument Escort ersichtlich:\n\n\n\n\nBeispiel\n\n\nPrint(\"Das aktuell im Chart geladene Instrument hei\u00dft \" + Instrument.Name);\n\n\n\n\nInstrument.PointValue\n\n\nBeschreibung\n\n\nInstrument.PointValue liefert den Geldwert f\u00fcr die Bewegung eines Instrumentes von einem vollen Punkt.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nTyp double - Punktwert\n\n\nVerwendung\n\n\nInstrument.PointValue\n\n\nWeitere Informationen\n\n\nBeispiele verschieder Punktwerte\n  (je St\u00fcck, CDF, Futurekontrakt, Lot usw.)\n\n\nAktie: im .allg. 1,00 Euro bzw. 1,00 USD.\nEUR/USD: 100,000 USD\nDax-Future: 25,00 Euro\n\n\nTickwert\n\n\nDer Tickwert ergibt sich, wenn man den Punktwert mit der TickGr\u00f6\u00dfe (TickSize) multipliziert.\n\n\nz.B. hat der E-mini S&P 500 einen Punktwert von $ 50. Die TickSize betr\u00e4gt 0,25. Es braucht also eine Bewegung von 4 Ticks f\u00fcr einen vollen Punkt.\nAus 50 * 0,25 = 50 / 4 ergibt sich ein Tickwert von 12,50 $/ je Tick.\n\n\nDer Punktwert ist auch im Instrument Escort ersichtlich:\n\n\n\n\nBeispiel\n\n\nPrint(\"Wenn \" + Instrument.Name + \" einen vollen Punkt steigt, entspricht dies dem Gegenwert von  \" + Instrument.PointValue + \" \" + Instrument.Currency);\n\n\n\n\nInstrument.Round2TickSize\n\n\nBeschreibung\n\n\nDie Funktion Instrument.Round2TickSize rundet einen \u00fcbergebenen Kurswert auf den kleinstm\u00f6glichen Wert, der durch die Tickgr\u00f6\u00dfe (TickSize) des Instrumentes teilbar ist.\n\n\nParameter\n\n\ndouble - Kurswert\n\n\nR\u00fcckgabewert\n\n\ndouble\n\n\nVerwendung\n\n\nInstrument.Round2TickSize(double MarketPrice)\n\n\n\n\nWeitere Informationen\n\n\nDie Anzahl der Nachkommastellen, auf die gerundet wird, ist je nach Instrument unterschiedlich.\nIst das Instrument eine Aktie, wird auf 2 Nachkommastellen gerundet, bei einem Forex-Wert auf 4 bzw. 5 Nachkommastellen.\n\n\nSiehe auch  \nTickSize\n und \nInstrument.Digits\n.\n\n\nBeispiele f\u00fcr professionelle  \nFormatting\n, \nFormatting of Numbers\n.\n\n\nBeispiel\n\n\ndouble Price = 12.3456789;\nPrint(Price + \"  gerundet auf einen f\u00fcr \" + Instrument.Name + \" g\u00fcltigen Kurs ist \" + Instrument.Round2TickSize(Price));\n\n\n\n\nInstrument.Symbol\n\n\nBeschreibung\n\n\nInstrument.Symbol liefert das Symbol, unter welchem das Handelsinstrument in AgenaTrader eindeutig identifizierbar ist. Anhand des Symbols werden die Mappings zu den verschiedenen Datenanbietern und Brokern verwaltet.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nTyp string\n\n\nVerwendung\n\n\nInstrument.Symbol\n\n\nWeitere Informationen\n\n\nMit dem Symbol werden gleiche Aktion an verschiedenen B\u00f6rsenpl\u00e4tzen unterschieden. Das Symbol BMW.DE ist z.B. die BMW-Aktie an der Xetra, BMW.CFD ist der CFD auf die BMW-Aktie.\n\n\nDas Instrument Symbol ist auch im Instrument Escort ersichtlich:\n\n\n\n\nBeispiel\n\n\nPrint(\"Das aktuell im Chart geladene Instrument hat das Symbol  \" + Instrument.Symbol);\n\n\n\n\nInstrument.TickSize\n\n\nBeschreibung\n\n\nDie Tickgr\u00f6\u00dfe oder TickSize ist die kleinste m\u00f6gliche Einheit um die sich ein Finanzinstrument bewegen kann. Dies ist umgangssprachlich 1 Tick.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\ndouble\n\n\nVerwendung\n\n\nInstrument.TickSize oder vereinfacht TickSize\n\n\nWeitere Informationen\n\n\nDas Schl\u00fcsselwort \nTickSize\n entspricht Instrument.TickSize. Beide Aufrufe liefern identische Werte und sind gegeneinander austauschbar.\n\n\nBeispiele\n\n\nAktie:  0,01\nES-Future: 0,25\nEUR/USD: 0,00001\n\n\nSiehe auch \nInstrument.PointValue\n und \nInstrument.Digits\n.\n\n\nBeispiele f\u00fcr professionelle  \nFormatting\n, \nFormatting of Numbers\n.\n\n\nBeispiel\n\n\nPrint(\"Der Kurs von \" + Instrument.Name + \"  kann sich minimal um  \" + Instrument.TickSize + \" Punkt(e) ver\u00e4ndern.\");\n\n\n\n\nMultibars\n\n\nBeschreibung\n\n\nEinem Indikator bzw. eine Strategie liegt immer die gleiche Zeiteinheit zugrunde, wie diejenige, in der der Chart angezeigt wird. Wird z.B. ein SMA(14) in einem 5-Minuten-Chart dargestellt, wird der gleitende Durchschnitt \u00fcber die 14 letzten 5-Minuten-Bars berechnet. Auf einem Tageschart w\u00fcrden entsprechend die Schlusskurse der letzten 14 Tage zur Berechnung herangezogen werden.\n\n\nDas gleiche Prinzip gilt f\u00fcr selbst entwickelte Indikatoren. In einem 5-Minuten-Chart w\u00fcrde die Methode \nOnCalculate()\n  f\u00fcr jeden 5-Minuten-Bar aufgerufen werden.\nMit Multibars ist es au\u00dferdem m\u00f6glich, Daten eines anderen Instrumentes zu laden.\n\n\nBeispiel\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Linq;\nusing System.Xml;\nusing System.Xml.Serialization;\nusing AgenaTrader.API;\nusing AgenaTrader.Custom;\nusing AgenaTrader.Plugins;\nusing AgenaTrader.Helper;\nnamespace AgenaTrader.UserCode\n{\n    [Description(\"Multibar Demo\")]\n    // Der Indikator ben\u00f6tigt Tages- und Wochendaten\n    [TimeFrameRequirements(\"1 Day\", \"1 Week\")]\n    public class MultiBarDemo : UserIndicator\n    {\n        private static readonly TimeFrame TF_Day = new TimeFrame(DatafeedHistoryPeriodicity.Day, 1);\n        private static readonly TimeFrame TF_Week = new TimeFrame(DatafeedHistoryPeriodicity.Week, 1);\n\n        protected override void OnBarsRequirements()\n        {\n            Add(TF_Day);\n            Add(TF_Week);\n        }\n\n        protected override void OnInit()\n        {\n            CalculateOnClosedBar = true;\n        }\n        protected override void OnCalculate()\n        {\n            // aktueller Wert f\u00fcr den SMA 14 auf Tagesbasis\n            Print(\"TF0: \" + SMA(Closes[0], 14)[0]);\n            // The current value for the SMA 14 in a daily timeframe\n            Print(\"TF1: \" + SMA(Closes[1], 14)[0]);\n             // aktueller Wert f\u00fcr den SMA 14 auf Wochenbasis\n            Print(\"TF2: \" + SMA(Closes[2], 14)[0]);\n        }\n    }\n}\n\n\n\n\nWeitere Hinweise\n\n\nBei Verwendung weiterer Zeiteinheiten wird den Arrays \nOpens\n, \nHighs\n, \nLows\n, \nCloses\n, \nMedians\n, \nTypicals\n, \nWeighteds\n, \nTimes\n und \nVolumes\n  ein weiterer Eintrag mit den jeweiligen Datenserien der Bars der neuen Zeiteinheit hinzugef\u00fcgt. Die Indizierung erfolgt in der Reihenfolge des Hinzuf\u00fcgens der Zeiteinheiten.\nCloses[0][0] entspricht Close[0].\nCloses[1][0] entspricht dem aktuellen Schlusskurs der Tagesdatenreihe.\nCloses[2][0] entspricht dem aktuellen Schlusskurs der Wochendatenreihe.\n\n\n\"Closes\"kann in den Beispielen selbstverst\u00e4ndlich auch durch Opens, Highs, Lows usw. ersetzt werden.\n\n\nSiehe auch \nProcessingBarIndexes\n, \nProcessingBarSeriesIndex\n, \nTimeFrames\n, \nTimeFrameRequirements\n.\n\n\nEs gibt noch eine weitere Schreibweise f\u00fcr Multbars:\n\n\n// unter Variablendeklaration wird die Variable TF_Day definiert\nprivate static readonly TimeFrame TF_Day = new TimeFrame(DatafeedHistoryPeriodicity.Day, 1);\nprivate static readonly TimeFrame TF_Week = new TimeFrame(DatafeedHistoryPeriodicity.Week, 1);\n// Die folgende Anweisung ist identisch mit double d = Closes[1][0];\ndouble d = MultiBars.GetBarsItem(TF_Day).Close[0];\n//  Die folgende Anweisung ist identisch mit double w = Closes[2][0];\ndouble w = MultiBars.GetBarsItem(TF_Week).Close[0];\n\n\n\n\nProcessingBarIndexes\n\n\nBeschreibung\n\n\nCurrentBars ist ein Array von int-Werten, welches f\u00fcr jedes Bar-Objekt die Nummer von \nProcessingBarIndex\n enth\u00e4lt.\n\n\nDieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.\n\n\nEin neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird.\n\n\nMit \n[TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]\n enth\u00e4lt das Array 3 Eintr\u00e4ge:\n\n\nProcessingBarIndexes[0] ProcessingBarIndexes der prim\u00e4ren Datenserie (Chart-Zeiteinheit)\nProcessingBarIndexes[1] ProcessingBarIndexes f\u00fcr die Tagesbars\nProcessingBarIndexes[2] ProcessingBarIndexes f\u00fcr die Wochenbars.\n\n\nProcessingBarIndexes[0] entspricht \nProcessingBarIndex\n.\n\n\nSiehe auch \nMultiBars\n.\n\n\nParameter\n\n\nbarSeriesIndex  Indexwert der unterschiedlichen Zeiteinheiten\n\n\nVerwendung\n\n\nProcessingBarIndexes[int barSeriesIndex]\n\n\n\n\nBeispiel\n\n\n//Sicherstellen, dass mind. 20 Bars geladen sind\nfor (int i=0; i<ProcessingBarIndexes.Count; i++)\nif (ProcessingBarIndexes[i] < 20) return;\n\n\n\n\nProcessingBarSeriesIndex\n\n\nDescription\n\n\nIn einem Multibar-Script, d.h. in einem Indikator (bzw. einer Strategie), der mit mehreren Zeiteinheiten arbeitet, sind mehrere Bars-Objekte vorhanden. Die Methode OnCalculate() wird f\u00fcr jeden Bar im Script aufgerufen. Um Ereignisse bestimmter Datenreihen in die Berechnung einzubeziehen bzw. auszublenden ist BarsInProgress zu verwenden.\n\n\nProcessingBarSeriesIndex ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.\nMit \n[TimeFrameRequirements(\"1 Day\", \"1 Week\")]\n werden 2 weitere Zeiteinheiten zur prim\u00e4ren Chart-Zeiteinheit hinzugef\u00fcgt.\n\n\nWenn OnCalculate() von der prim\u00e4ren Datenreihe aufgerufen wird, ist ProcessingBarSeriesIndex=0. Wird OnCalculate() von den Tagesbars aufgerufen, ist ProcessingBarSeriesIndex=1, bei den Wochendaten hat BarsInProgress den Wert 2.\n\n\nSiehe auch \nMultibars\n and \nProcessingBarIndexes\n.\n\n\nParameter\n\n\nkeine\n\n\nVerwendung\n\n\nProcessingBarSeriesIndex\n\n\nWeitere Informationen\n\n\nIn einem Script, welches nur auf der prim\u00e4ren Zeiteinheit arbeitet, hat BarsInProgress immer den Wert 0.\n\n\nBeispiel\n\n\n// Arbeitsweise veranschaulichen\n// ggf. CalculateOnBarClose=false setzen\nPrint(Time[0] + \" \" + ProcessingBarSeriesIndex);\n// Berechnungen nur f\u00fcr die Chart-Zeiteinheit\nprotected override void OnCalculate()\n{\nif (ProcessingBarSeriesIndex > 0) return;\n// Logik f\u00fcr prim\u00e4re Datenreihe\n}",
            "title": "Umgang mit Bars und Instrumenten"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#umgang-mit-bars-und-instrumenten",
            "text": "Unter \"Daten\" werden hier einerseits Informationen verstanden, die \"von au\u00dfen\" in AgenaTrader geladen werden und zum anderen Datenreihen, die aus selbst erstellten AgenaSripts stammen.  Detailierte Informatonen finden sich unter dem jeweiligen Stichwort.  Bars  Collections  Data series  Instruments  Multibars",
            "title": "Umgang mit Bars und Instrumenten"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#bars",
            "text": "",
            "title": "Bars"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#funktionsweise",
            "text": "Ein klassischer Indikator berechnet \u00fcblicherweise aus einer vorliegenden Datenreihe einen oder mehrere Werte.  Datenreihen k\u00f6nnen dabei z.B. alle Schlusskurse oder auch alle Tiefkurse eines Tages, einer Stunde oder einer 10 Min. Periode sein.  Jeder Periode (also jeder Kerze eines Tages, einer Stunde usw.) wird/werden folglich ein oder mehrere Indikatorwert(e) zugeordnet.  Im Folgenden gehen wir von einem Indikatorwert, wie z.B. bei einem gleitenden Durchschnitt aus.  Zur Berechnung eines gleitenden Durchschnitts ben\u00f6tigt AgenaTrader eine Datenreihe. Im Beispiel nehmen wir die Schlusskurse. Alle Schlusskurse der Bars (Kerzen), die in einem Chart dargestellt sind, sind in einer Liste gespeichert und sozusagen durchnummeriert.  Der aktuelle Schlusskurs, also der Schlusskurs des Bars, der am rechten Rand des Charts dargestellt wird, bekommt die Nummer 0. Der Bar links davon die Nummer 1 usw. Der \u00e4lteste dargestellte Bar hat dann z.B. die Nummer 500.  Kommt im Laufe der Handelssitzung ein neuer Bar hinzu, erh\u00e4lt dieser nun die Nummer 0, der links von ihm, der gerade noch die Nummer 0 hatte, wird zu Nummer 1 usw. Der letzte dargestellte Bar wird zu Nummer 501.  In einem Script (einem selbsterstellten Programm) steht  Close  close f\u00fcr die Liste (Array) aller Schlusskurse. Der letzte Schlusskurs ist dann  Close [0] ; t der Schlusskurs davor (bei Tagesdaten ist das z.B. der Schlusskurs von gestern) ist  Close [1] ,  der davor   Close [2]  bis zum ersten Bar im Chart (ganz links) mit  Close [501] . Die Zahl in den eckigen Klammern ist ein Index. In AgenaTrader steht hierf\u00fcr im allgemeinen Fall der Ausdruck \"barsAgo\".  F\u00fcr jeden Bar gibt es nicht nur Close, sondern zudem auch  High ,  Low ,  Open ,  Median ,  Typical ,  Weighted ,  Time  and  Volume . Das Hoch der Kerze, von vor 10 Tagen ist also z.B.   High [10] , Das Tief von gestern  Low [1] ...  wichtiger Hinweis  Die o.g. Beispiele gelten, wenn die Berechnung am Ende einer Periode erfolgt. Die Werte der aktuell laufenden (noch nicht fertigen Kerze) sind nicht ber\u00fccksichtigt.\nM\u00f6chte man bereits auf die Werte der sich gerade ausbildenden Kerze zur\u00fcckgreifen, mu\u00df man dies AgenaTrader im Script mit  CalculateOnClosedBar = false mitteilen.  In diesem Fall bekommt der aktuell laufende Bar die Nummer 0, der Bar links neben dem aktuell laufenden die Nummer 1 usw. Der letzte Bar (im Beispiel oben) h\u00e4tte jetzt die Nummer 502.  Mit close [0] bekommt man nun den jeweils letzten Kurs, der gerade vom Datenanbieter an AgenaTrader \u00fcbermittelt wurde. Alle Werte des Bars (high [0], low [0]\u2026) k\u00f6nnen sich solange ver\u00e4ndern, bis der Bar fertig ausgebildet ist und ein neuer Bar begonnen hat. Nur Open[0] \u00e4ndert sich auch in diesem Fall nicht mehr.",
            "title": "Funktionsweise"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#eigenschaften",
            "text": "",
            "title": "Eigenschaften"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#eigenschaften-von-bars",
            "text": "\"Bars\" steht f\u00fcr eine Liste aller Bars (Kerzen) in einem Chart (siehe  Funktionsweise ,  Bars ).  Bars ( public  IBars Bars) kann direkt in einem Script verwendet werden und entspricht in diesem Fall BarsArray [0] (siehe Bars.GetNextSessionTimeSpan).  Eigenschaften werden immer mit einem Punkt hinter dem Objekt (in diesem Falle Bars, der Liste der Kerzen) angegeben.  Bars.Count  Bars.CurrentSessionBeginTime  Bars.CurrentSessionEndTime  Bars.GetBar  Bars.GetBarIndex  Bars.GetBarsAgo  Bars.GetByIndex  Bars.GetClose  Bars.GetHigh  Bars.GetLow  Bars.GetNextSessionTimeSpan  Bars.GetOpen  Bars.GetSessionBegin  Bars.GetTime  Bars.GetVolume  Bars.Instrument  Bars.IsEod  Bars.IsFalling  Bars.IsFirstBarInSession  Bars.IsGrowing  Bars.IsIntraday  Bars.IsNtb  Bars.SessionBreak  Bars.LastBarCompleteness  Bars.NextSessionBeginTime  Bars.NextSessionEndTime  Bars.TailBottom  Bars.TailTop  Bars.TicksCountForLastBar  Bars.TicksCountInTotal  Bars.TimeFrame  BarsCountForSession  IsProcessingBarIndexLast  Innerhalb von  OnCalculate()   k\u00f6nnen alle Eigenschaften verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Funktion  OnCalculate()  von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden. Falls diese Eigenschaften ausserhalb von  OnCalculate()   verwendet werden, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit  if  (Bars !=  null ) ausgef\u00fchrt werden.",
            "title": "Eigenschaften von Bars"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barscount",
            "text": "",
            "title": "Bars.Count"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung",
            "text": "Bars.Count liefert die Anzahl der Bars in einer Datenreihe.  Siehe auch weitere  Eigenschaften  von Bars.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert",
            "text": "Typ int Anzahl der Bars",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung",
            "text": "Bars.Count",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen",
            "text": "Der Wert von  ProcessingBarIndex  kann immer nur kleiner oder gleich Bars.Count - 1 sein.  Wenn in AgenaTrader angegeben wurde, wieviel Bars in einen Chart geladen werden sollen, entspricht der Wert von Bars.Count genau dieser Einstellung. Im Beispiel unten w\u00fcrde Bars.Count 500 liefern.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel",
            "text": "Print (\"Es stehen insgesamt\" + Bars.Count + \"Bars zur Verf\u00fcgung.\");",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barscurrentsessionbegintime",
            "text": "",
            "title": "Bars.CurrentSessionBeginTime"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_1",
            "text": "Bars.CurrentSessionBeginTime  liefert das Datum und die Uhrzeit des Beginns der aktuell laufenden Handelssitzung.  Datum und Uhrzeit f\u00fcr den Beginn der aktuellen Handelssitzung werden auch dann korrekt angegeben, wenn die Funktion von einem Bar in der Vergangenheit aufgerufen wird.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_1",
            "text": "Typ DateTime",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_1",
            "text": "Bars.GetSessionBegin",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_1",
            "text": "Die Uhrzeit des zur\u00fcckgegebenen Wertes entspricht der im MarketEscort angegebenen Startzeit der Handelssitzung des jeweiligen Handelsplatzes. Der f\u00fcr den Wert verwendete Handelsplatz wird im Instrumet Escort eingestellt und kann in AgenaSript mit der Funktion  Instrument.Exchange  ermittelt.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_1",
            "text": "Print(\"Die laufende Handelssitzung hat um  \" + Bars.CurrentSessionBeginTime );",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barscurrentsessionendtime",
            "text": "",
            "title": "Bars.CurrentSessionEndTime"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_2",
            "text": "Bars.CurrentSessionEndTime  liefert das Datum und die Uhrzeit f\u00fcr das Ende der aktuell laufenden Handelssitzung.\nDatum und Uhrzeit f\u00fcr das Ende der aktuellen Handelssitzung werden auch dann korrekt angegeben, wenn die Funktion von einem Bar in der Vergangenheit aufgerufen wird.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_1",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_2",
            "text": "Typ DateTime",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_2",
            "text": "Bars.GetSessionEnd",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_2",
            "text": "Die Uhrzeit des zur\u00fcckgegebenen Wertes entspricht der im MarketEscort angegebenen Endezeit der Handelssitzung des jeweiligen Handelsplatzes. Der f\u00fcr den Wert verwendete Handelsplatz wird im Instrumet Escort eingestellt und kann in AgenaSript mit der Funktion   Instrument.Exchange  ermittelt werden.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_2",
            "text": "Print(\"Die laufende Handelssitzung endet um \" + Bars.CurrentSessionEndTime);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsgetbar",
            "text": "",
            "title": "Bars.GetBar"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_3",
            "text": "Bars.GetBar liefert den ersten Bars (vom \u00e4ltesten zum j\u00fcngsten), der dem \u00fcbergebenen Datum bzw. der Uhrzeit entspricht.  Siehe auch  Bars.GetBarsAgo ,  Bars.GetByIndex ,  Bars.GetBarIndex .",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_2",
            "text": "Typ DateTime",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_3",
            "text": "Typ IBar Bar-Objekt, des dem Zeitstempel entsprichenden Bars  bei Zeitstempel \u00e4lter als der \u00e4lteste Bar: 0 (Null)\nbei Zeitstempel j\u00fcnger als der letzte Bar: Index des letzten Bars",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_3",
            "text": "Bars.GetBar(DateTime time)",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_3",
            "text": "zur Indizierung von Bars siehe  Funktionsweise ,  Bars  zur Benutzung von DateTime siehe  http://msdn.microsoft.com/de-de/library/system.datetime.aspx",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_3",
            "text": "Print (\"Der Schlusskurs f\u00fcr den 01.03.2012 um 18:00:00 Uhr war \" + Bars.GetBar(new DateTime(2012, 01, 03, 18, 0, 0)).Close);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsgetbarindex",
            "text": "",
            "title": "Bars.GetBarIndex"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_4",
            "text": "Bars.GetBarIndex liefert den Index eines Bars. \u00dcbergeben werden kann der Methode entweder ein Bar-Objekt oder ein DateTime-Objekt.  Siehe  Bars.GetBar ,  Bars.GetBarsAgo ,  Bars.GetByIndex .",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_3",
            "text": "Typ IBar bar\noder\nTyp DateTime",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_4",
            "text": "Typ int der zu dem \u00fcbergebenen Bar-Objekt bzw. dem \u00fcbergebenen DateTime-Objekt geh\u00f6rende Bar-Index",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_4",
            "text": "Bars.GetBarIndex (IBar bar)\nBars.GetBarIndex (DateTime dt)",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_4",
            "text": "zur Indizierung von Bars siehe  Funktionsweise ,  Bars",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_4",
            "text": "int barsAgo = 5;\nIBar bar = Bars.GetBar(Time[barsAgo]);\nPrint(barsAgo + \" und \" + Bars.GetBarIndex(bar) + \" sind in diesem Beispiel gleich.\");",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsgetbarsago",
            "text": "",
            "title": "Bars.GetBarsAgo"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_5",
            "text": "Bars.GetBarsAgo liefert den Index des ersten Bars (vom \u00e4ltesten zum j\u00fcngsten), der dem \u00fcbergebenen Datum bzw. der Uhrzeit entspricht.  Siehe auch::  Bars.GetBar ,  Bars.GetByIndex ,  Bars.GetBarIndex .",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_4",
            "text": "Typ DateTime",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_5",
            "text": "Typ int Index des Bars, der dem Zeitstempel als erstes entspricht.  bei Zeitstempel \u00e4lter als der \u00e4lteste Bar: 0 (Null)\nbei Zeitstempel j\u00fcnger als der letzte Bar: Index des letzten Bars",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_5",
            "text": "Bars.GetBarsAgo(DateTime time)",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_5",
            "text": "zur Indizierung von Bars siehe  Funktionsweise ,  Bars  zur Benutzung von DateTime siehe   http://msdn.microsoft.com/de-de/library/system.datetime.aspx",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_5",
            "text": "Print(\"Der Bar f\u00fcr den 01.03.2012 um 18:00:00 Uhr hat den Index\" + Bars.GetBarsAgo(new DateTime(2012, 01, 03, 18, 0, 0)));",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsgetbyindex",
            "text": "",
            "title": "Bars.GetByIndex"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_6",
            "text": "Bars.GetByIndex liefert das zu einem \u00fcbergebenen Index geh\u00f6rende Bar-Objekt.  Siehe  Bars.GetBar ,  Bars.GetBarsAgo ,  Bars.GetBarIndex .",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_5",
            "text": "Typ int Index",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_6",
            "text": "Typ IBar Bar-Objekt zu dem \u00fcbergebenen Index",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_6",
            "text": "Bars.GetByIndex (int Index)",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_6",
            "text": "zur Indizierung von Bars siehe  Funktionsweise ,  Bars",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_6",
            "text": "Print(Close[0] + \" und \" + Bars.GetByIndex(ProcessingBarIndex).Close + \" sind in diesem Beispiel gleich.\");",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsgetclose",
            "text": "Bars.GetClose(int index) \u2013 siehe  Bars.GetOpen .",
            "title": "Bars.GetClose"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsgethigh",
            "text": "Bars.GetHigh(int index) \u2013 siehe  Bars.GetOpen .",
            "title": "Bars.GetHigh"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsgetlow",
            "text": "Bars.GetLow(int index) \u2013 siehe  Bars.GetOpen .",
            "title": "Bars.GetLow"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsgetnextsessiontimespan",
            "text": "",
            "title": "Bars.GetNextSessionTimeSpan"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_7",
            "text": "Bars.GetNextSessionTimeSpan liefert jeweils Datum und Uhrzeit von Beginn und Ende der n\u00e4chsten Handelssitzung.  Siehe  Bars.CurrentSessionBeginTime ,  Bars.CurrentSessionEndTime ,  Bars.NextSessionBeginTime ,  Bars.NextSessionEndTime .",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_6",
            "text": "DateTime  time  Datum bzw. Uhrzeit, f\u00fcr die die Daten der folgenden Handelssitzung gesucht werden    iBars  bars  Barobjekt, f\u00fcr das die Daten der folgenden Handelssitzung gesucht werden    int  barsago  Anzahl der Tage in der Vergangenheit, f\u00fcr die die Daten der folgenden Handelssitzung gesucht werden",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_7",
            "text": "DateTime sessionBegin\nDateTime sessionEnd  Hinweis: \nDas Datum von Beginn und Ende sind jeweils f\u00fcr eine Handelssitzung zusammengeh\u00f6rend. Wenn das \u00fcbergebene Datum dem Ende-Datum der aktuellen Handelssitzung entspricht, kann das zur\u00fcckgegebene Datum f\u00fcr den Beginn der Handelssitzung bereits in der Vergangenheit liegen.\nEs wird in diesem Fall nicht das Datum der n\u00e4chstfolgenden Handelssitzung zur\u00fcckgegeben.",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_7",
            "text": "Bars.GetNextSessionTimeSpan(Bars bars, int barsAgo, out DateTime sessionBegin, out DateTime sessionEnd)\nBars.GetNextSessionTimeSpan(DateTime time, out DateTime sessionBegin, out DateTime sessionEnd)",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_7",
            "text": "Die beiden Signaturen liefern nicht notwendigerweise auch die gleichen Ergebnisse.\nBei Verwendung der Bar-Signatur wird der ubergebene Bar daraufhin untersucht, zu welchem Session-Template er geh\u00f6rt. Beginn und Ende der n\u00e4chsten Session werden dann diesem Template entnommen.  Bei Verwendung der Zeit-Signatur wierden Datum und Uhrzeit des \u00fcbergebenen Bars genutzt, um die Daten der aktuellen und damit der folgenden Session zu berechnen.  Wenn bei Verwendung der Zeit-Signatur ein Zeitstempel \u00fcbergeben wird, der exakt einer Beginn bzw. Endezeit einer Session entspricht, werden Beginn und Ende der davorliegenden Session zur\u00fcckgegeben, d.h. der Zeitstempel wird als \"in der Session enthalten\" angesehen, selbst wenn der fragliche Bar bereits in einer neuen Session enthalten ist. Um dieses Verhaten sicher auszuschlie\u00dfen, ist die Verwendung der Bar-Signatur empfohlen.  zur Benutzung von DateTime siehe  http://msdn.microsoft.com/de-de/library/system.datetime.aspx",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_7",
            "text": "DateTime sessionBegin;\nDateTime sessionEnd;\nprotected override void OnCalculate()\n{\nBars.GetNextSessionTimeSpan(Bars, 0, out sessionBegin, out sessionEnd);\nPrint(\"Session Start: \" + sessionBegin + \" Session End: \" + sessionEnd);\n}",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsgetopen",
            "text": "",
            "title": "Bars.GetOpen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_8",
            "text": "Die folgenden Methoden sind aus Gr\u00fcnden der Kompatibilit\u00e4t vorhanden.   Bars.GetOpen(int index) liefert das Open des mit <index> referenzierten Bars.  Bars.GetHigh(int index) liefert das High des mit <index> referenzierten Bars..  Bars.GetLow(int index) liefert das Low des mit <index> referenzierten Bars.  Bars.GetClose(int index) liefert das Close des mit <index> referenzierten Bars.  Bars.GetTime(int index) liefert das Zeitstempel des mit <index> referenzierten Bars.  Bars.GetVolume(int index) liefert das Volumen des mit <index> referenzierten Bars.   Achtung : Die Indizierung weicht von der sonst verwendeten  Indexing ,  Bars  ab.\nHier beginnt die Indizierung mit 0 am \u00e4ltesten Bar (links im Chart) und endet mit dem j\u00fcngsten Bar rechts im Chart  (=Bars.Count-1).  Die Indizierungen k\u00f6nnen leicht (in beiden Richtungen!) wie folgt umgerechnet werden:  private int Convert(int idx)\n{\nreturn Math.Max(0,Bars.Count-idx-1-(CalculateOnClosedBar?1:0));\n}",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_7",
            "text": "int index (0 .. Bars.Count-1)",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_8",
            "text": "Typ double f\u00fcr GetOpen, GetHigh, GetLow, GetClose und GetVolume  Typ DateTime f\u00fcr GetTime",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsgetsessionbegin",
            "text": "",
            "title": "Bars.GetSessionBegin"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_9",
            "text": "Bars.GetSessionBegin liefert das Datum und die Uhrzeit des Beginns einer bestimmten Handelssitzung.\nDatum und Uhrzeit f\u00fcr den Beginn der aktuellen Handelssitzung werden auch dann korrekt angegeben, wenn die Funktion von einem Bar in der Vergangenheit aufgerufen wird.\nSiehe auch weitere  Eigenschaften  von Bars.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_8",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_9",
            "text": "Typ DateTime",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_8",
            "text": "Bars.GetSessionBegin(DateTime dt)",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_8",
            "text": "Die Uhrzeit des zur\u00fcckgegebenen Wertes entspricht der im MarketEscort angegebenen Startzeit der Handelssitzung des jeweiligen Handelsplatzes. Der f\u00fcr den Wert verwendete Handelsplatz wird im Instrumet Escort eingestellt und kann in AgenaSript mit der Funktion Instrument.Exchange ermittelt werden.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_8",
            "text": "Print(\"Die Handelssitzung am 25.03.2015 hat um \"+ Bars.GetSessionBegin(new DateTime(2015, 03, 25)) + \" begonnen.\");\n}",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsgettime",
            "text": "Bars.GetTime(int index) \u2013 siehe  Bars.GetOpen .",
            "title": "Bars.GetTime"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsgetvolume",
            "text": "Bars.GetVolume(int index) \u2013 siehe  Bars.GetOpen .",
            "title": "Bars.GetVolume"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsinstrument",
            "text": "",
            "title": "Bars.Instrument"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_10",
            "text": "Bars.Instrument liefert ein Instrument-Objekt, f\u00fcr das im Chart dargestellte Handelsinstrument.  Siehe auch weitere  Eigenschaften  von Bars.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_9",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_10",
            "text": "Typ Instrument",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_9",
            "text": "Bars.Instrument",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_9",
            "text": "F\u00fcr weitere Informationen zu Handelsinstrumenten siehe unter   Instrument .",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_9",
            "text": "// beide Ausgaben liefern das gleiche Ergebnis\nPrint(\"Das aktuell dargestellte Handelsinstrument hat das Symbol \" + Bars.Instrument);\nInstrument i = Bars.Instrument;\nPrint(\"Das aktuell dargestellte Handelsinstrument hat das Symbol \" + i.Symbol);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsiseod",
            "text": "",
            "title": "Bars.IsEod"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_11",
            "text": "Mit Bars.IsEod kann \u00fcberpr\u00fcft werden, ob es sich um End-of-Day-Bars handelt.  Siehe auch weitere  Eigenschaften  von Bars.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_10",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_11",
            "text": "Typ bool",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_10",
            "text": "Bars.IsEod",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#more-information",
            "text": "Innerhalb von   OnCalculate()  kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden.  Falls diese Eigenschaft ausserhalb von  OnCalculate ()verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit  if (bars! = Null) ausgef\u00fchrt werden.",
            "title": "More Information"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_10",
            "text": "Print(\"Die Bars sind Eod: \" + Bars.IsEod);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsisfalling",
            "text": "",
            "title": "Bars.IsFalling"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_12",
            "text": "Bar-Eigenschaften, die verwendet werden, wenn Bar herunterf\u00e4llt.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_11",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_12",
            "text": "keine",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_11",
            "text": "Bars[0].IsFalling;",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsisfirstbarinsession",
            "text": "",
            "title": "Bars.IsFirstBarInSession"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_13",
            "text": "Mit Bars.IsFirstBarInSession kann festgestellt werden, ob der aktuelle Bar der erste Bar einer Handelssitzung ist.  Siehe auch weitere   Eigenschaften  von Bars.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_13",
            "text": "Typ bool  true : Der Bar ist der erste Bar einer Handelssitzung false : Der Bar ist nicht der erste Bar einer Handelssitzung",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_11",
            "text": "Bars.IsFirstBarInSession",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_10",
            "text": "Innerhalb von  OnCalculate()  kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden.\nFalls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null) ausgef\u00fchrt werden.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_12",
            "text": "if (Bars.IsFirstBarInSession)\nPrint (\"Die aktuelle Handelsitzung hat um\" + Time [0]);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsisgrowing",
            "text": "",
            "title": "Bars.isGrowing"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_14",
            "text": "Bar-Eigenschaften verwendet, wenn Bar aufw\u00e4chst.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_12",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_14",
            "text": "keine",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_13",
            "text": "Bars[0].isGrowing;",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsisintraday",
            "text": "",
            "title": "Bars.IsIntraday"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_15",
            "text": "Mit Bars.IsIntraday kann \u00fcberpr\u00fcft werden, ob es sich um reine Intraday-Bars handelt. Entweder mit Ber\u00fccksichtigung von Ticks - Bars.IsIntraday.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_15",
            "text": "bool  Er gibt \"true\" zur\u00fcck, wenn TimeFrame intra-day (z. B. 1 min, 15 min, 1 h usw.) und \"false\" in anderen F\u00e4llen ist.",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_12",
            "text": "Bars.IsIntraday",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_14",
            "text": "if(Bars.IsIntraday) {\n    Print(\"TimeFrame is Intraday.\");\n} else {\n    Print(\"TimeFrame is not Intraday.\");\n}",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsisntb",
            "text": "",
            "title": "Bars.IsNtb"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_16",
            "text": "Mit Bars.IsNtb kann \u00fcberpr\u00fcft werden, ob es sich um Not-Time-Based-Bars handelt. Bei Ntb-Bars handelt es sich beispielsweise um Point & Figure oder Renko Charts.\nSiehe auch weitere   Eigenschaften  von Bars.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_13",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_16",
            "text": "Typ bool",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_13",
            "text": "Bars.IsNtb",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_11",
            "text": "Innerhalb von  OnCalculate()  kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden.\nFalls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null) ausgef\u00fchrt werden.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_15",
            "text": "Print(\"Die angezeigten Bars sind Ntb:\" + Bars.IsNtb);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsissessionbreak",
            "text": "",
            "title": "Bars.IsSessionBreak"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_17",
            "text": "Mit Bars.IsSessionBreak kann ermittelt werden, ob die Bars innerhalb der laufenden Handelssitzung in den im Marktplatz-Escort definierten Handelspausen liegen.  Siehe auch weitere  Eigenschaften  von Bars.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_14",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_17",
            "text": "Typ bool",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_14",
            "text": "Bars.IsSessionBreak",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_12",
            "text": "",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_16",
            "text": "if (Bars.IsSessionBreak)\n{\nPrint(\"Die B\u00f6rse Xetra hat gerade eine Handelspause.\");\n}",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barslastbarcompleteness",
            "text": "",
            "title": "Bars.LastBarCompleteness"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_18",
            "text": "Bars.LastBarCompleteness liefert einen Wert, der angibt, zu wieviel Prozent ein Bar bereits fertiggestellt ist. Ein Bar in der Zeiteinheit 10 Minuten ist z.B. nach 5 Minuten genau zu 50% fertig.  F\u00fcr nicht-zeitbasierte Chartarten (Kagi, LineBreak, Renko, Range, P&F usw.) und w\u00e4hrend eines Backtests liefert die Eigenschaft immer eine 0.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_18",
            "text": "double  als Prozentwert, d.h. f\u00fcr 30% wird 0.3 zur\u00fcckgegeben-",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_15",
            "text": "Bars.LastBarCompleteness",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_13",
            "text": "Innerhalb von  OnCalculate()  kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden.  Falls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null) ausgef\u00fchrt werden.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_17",
            "text": "// Ein 60 Min. Chart wird intraday beobachtet.\n// Jeweils 5 Min. bevor der aktuelle Bar schlie\u00dft,\n// soll ein akustisches Signal ausgegeben werden.\n// 55 Min. entsprechen 92%\n\nbool remind = false;\nprotected override void OnCalculate()\n{\nif (FirstTickOfBar) remind = true;\nif (remind && Bars.LastBarCompleteness >= 0.92)\n{\nremind = false;\nPlaySound(\"Alert1\");\n}\n}",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsnextsessionbegintime",
            "text": "",
            "title": "Bars.NextSessionBeginTime"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_19",
            "text": "Bars.NextSessionBeginTime liefert das Datum und die Uhrzeit des Beginns der auf die aktuell laufende Handelssitzung folgenden Sitzung.\nDatum und Uhrzeit f\u00fcr den Beginn der n\u00e4chsten Handelssitzung werden auch dann korrekt angegeben, wenn die Funktion von einem Bar in der Vergangenheit aufgerufen wird.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_15",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_19",
            "text": "Typ DateTime",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_16",
            "text": "Bars.GetSessionNextBegin",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_14",
            "text": "Die Uhrzeit des zur\u00fcckgegebenen Wertes entspricht der im MarketEscort angegebenen Startzeit der Handelssitzung des jeweiligen Handelsplatzes. Der f\u00fcr den Wert verwendete Handelsplatz wird im Instrumet Escort eingestellt und kann in AgenaSript mit der Funktion  Instrument.Exchange  ermittelt werden.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_18",
            "text": "Print(\"Die n\u00e4chste Handelssitzung beginnt um \" + Bars.NextSessionBeginTime);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barsnextsessionendtime",
            "text": "",
            "title": "Bars.NextSessionEndTime"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_20",
            "text": "Bars.NextSessionEndTime liefert das Datum und die Uhrzeit f\u00fcr das Ende der auf die aktuell laufende Handelssitzung folgenden Sitzung.\nDatum und Uhrzeit f\u00fcr das Ende der n\u00e4chsten Handelssitzung werden auch dann korrekt angegeben, wenn die Funktion von einem Bar in der Vergangenheit aufgerufen wird.\nSiehe auch weitere   Eigenschaften  von Bars.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_16",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_20",
            "text": "Typ DateTime",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_17",
            "text": "Bars.GetSessionNextEnd",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_15",
            "text": "Die Uhrzeit des zur\u00fcckgegebenen Wertes entspricht der im MarketEscort angegebenen Endezeit der Handelssitzung des jeweiligen Handelsplatzes. Der f\u00fcr den Wert verwendete Handelsplatz wird im Instrumet Escort eingestellt und kann in AgenaSript mit der Funktion  Instrument.Exchange  ermittelt werden.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_19",
            "text": "Print(\"Die n\u00e4chste Handelssitzung endet um \" + Bars.NextSessionEndTime);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barstailbottom",
            "text": "",
            "title": "Bars.TailBottom"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_21",
            "text": "Mit dieser Eigenschaft ist es m\u00f6glich die H\u00f6he des unteren Dochtes der Kerze zu ermitteln.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_17",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_21",
            "text": "keine",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_18",
            "text": "Bars[0].TailBottom;",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_20",
            "text": "Print(\"Die H\u00f6he des unteren Dochtes ist: \" + Bars.TailBottom);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barstailtop",
            "text": "",
            "title": "Bars.TailTop"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_22",
            "text": "Mit dieser Eigenschaft ist es m\u00f6glich die H\u00f6he des oberen Dochtes der Kerze zu ermitteln.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_18",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_22",
            "text": "keine",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_19",
            "text": "Bars[0].TailTop;",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_21",
            "text": "Print(\"Die H\u00f6he des oberen Dochtes ist: \" + Bars.TailTop);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barstickscountforlastbar",
            "text": "",
            "title": "Bars.TicksCountForLastBar"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_23",
            "text": "Bars.TicksCountForLastBar liefert die Gesamtanzahl der in einem Bar enthaltenen Ticks.  Siehe auch weitere  Eigenschaften  von Bars.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_19",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_23",
            "text": "Typ int",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_20",
            "text": "Bars.TicksCountForLastBar",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_16",
            "text": "Innerhalb von  OnCalculate()  kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden.  Falls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit  if  (Bars !=  null ) ausgef\u00fchrt werden.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_22",
            "text": "Print(\"Der aktuelle Bar besteht aus \" + Bars.TicksCountForLastBar + \" Ticks.\");",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barstickscountintotal",
            "text": "",
            "title": "Bars.TicksCountInTotal"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_24",
            "text": "Bars.TicksCountInTotal  liefert die Gesamtzahl aller Ticks von dem Moment an, von dem die Funktion aufgerufen wird.  Siehe auch weitere   Eigenschaften  von Bars.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_20",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_24",
            "text": "Typ int",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_21",
            "text": "Bars.TicksCountInTotal",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_17",
            "text": "Der Datentyp int hat einen positiven Wertebereich von 2147483647. Wenn 10 Ticks je Sekunde angenommen werden, gibt es auch nach 2 Handelsmonaten bei einem 24h-Handel noch kein \u00dcberlauf.  Innerhalb von  OnCalculate() kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden.  Falls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit  if  (Bars !=  null ) ausgef\u00fchrt werden.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_23",
            "text": "//Anwendung in einem 30 Minuten Chart\nPrint(\"Die Gesamtanzahl der gelieferten Ticks in diesem Wert betr\u00e4gt \" + Bars.TicksCountInTotal);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barstimeframe",
            "text": "",
            "title": "Bars.TimeFrame"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_25",
            "text": "Bars.TimeFrame liefert ein TimeFrame-Objekt, das Informationen zum aktuell verwendeten Zeiteinheit enth\u00e4lt.  Siehe auch weitere  Eigenschaften  von Bars.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_21",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_25",
            "text": "Typ ITimeFrame",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_22",
            "text": "Bars.TimeFrame",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_18",
            "text": "F\u00fcr weitere Informationen zum TimeFrame-Objekt siehe unter  TimeFrame .  Innerhalb von  OnCalculate()  kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden.  Falls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit   if  (Bars !=  null ) ausgef\u00fchrt werden.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_24",
            "text": "//Anwendung in einem 30 Minuten Chart\nTimeFrame tf = (TimeFrame) Bars.TimeFrame;\nPrint(Bars.TimeFrame); //liefert \"30 Min\"\nPrint(tf.Periodicity); // liefert \"Minute\"\nPrint(tf.PeriodicityValue); // liefert \"30\"",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#barscountforsession",
            "text": "",
            "title": "BarsCountForSession"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_26",
            "text": "Bars.BarsCountForSession liefert die Anzahl der Bars, die seit dem Beginn der aktuellen Handelssitzung entstanden sind.  Siehe auch weitere  Eigenschaften  von Bars.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_26",
            "text": "Typ int Anzahl der Bars  Ein Wert von -1 deutet auf ein Problem bei der Ermittlung des Sessionbeginns hin.",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_23",
            "text": "Bars.BarsCountForSession",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_19",
            "text": "Innerhalb von  OnCalculate()  kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden.  Falls diese Eigenschaft ausserhalb von OnBarUpdate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit   if  (Bars!=  null )  ausgef\u00fchrt werden.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_25",
            "text": "Print (\"Seit dem Start der letzten Handelssitzung sind\" + Bars.BarsCountForSession + \"Bars entstanden.\");",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#processingbarindexlast",
            "text": "",
            "title": "ProcessingBarIndexLast"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_27",
            "text": "Gibt an, ob der aktuelle Bar zuletzt berechnet wurde.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_22",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_27",
            "text": "Typ bool",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_24",
            "text": "ProcessingBarIndexLast",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_20",
            "text": "Verwendet f\u00fcr komplizierte Berechnung auf einem letzten Bar",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_26",
            "text": "protected override void OnCalculate()\n        {\n            base.OnCalculate();\n            if (!IsProcessingBarIndexLast)\n                return;\n            bool isUpdated;\n}",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#collections",
            "text": "",
            "title": "Collections"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#chartdrawings",
            "text": "",
            "title": "ChartDrawings"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_28",
            "text": "ChartDrawings  ist eine Collection, die alle Zeichenobjekte im Chart enth\u00e4lt. In ChartDrawings werden sowohl dem Chart manuell hinzugef\u00fcgte Zeichenobjekte, als auch von einem Script gezeichnete Objekte aufgenommen.  Der Index f\u00fcr ChartDrawings ist der eindeutige Name der Zeichenobjekte (string tag).",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_25",
            "text": "ChartDrawings [string tag]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiele",
            "text": "Hinweis:   Um die Interface-Definitionen nutzen zu k\u00f6nnen, mu\u00df in den Using-Anweisungen  using AgenaTrader.Plugins;\n// Anzahl der Zeichenobjekte auf dem Chart und deren Tags ausgeben\nPrint(\"Auf dem Chart befinden sich  \" + ChartDrawings.Count + \" Zeichenobjekte\");\nforeach (IDrawObject draw in ChartDrawings) Print(draw.Tag);\n//Eine schwarze Trendlinie zeichnen ...\nAddChartLine(\"MyLine\", true, 10, Close[10], 0, Close[0], Color.Black, DashStyle.Solid, 3);\n/ ... und die Farbe auf Rot \u00e4ndern\nITrendLine line = (ITrendLine) ChartDrawings[\"MyLine\"];\nif (line != null) line.Pen.Color = Color.Red;\n// alle vertikalen Linien in Chart auf Linienst\u00e4rke 3 setzen,\n// und nicht verschiebbar und nicht editierbar machen\nforeach (IDrawObject draw in ChartDrawings)\nif (draw is IVerticalLine)\n{\nIVerticalLine vline = (IVerticalLine) draw;\nvline.IsLocked = true;\nvline.Editable = false;\nvline.Pen.Width = 3;\n}",
            "title": "Beispiele"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#inseries",
            "text": "",
            "title": "InSeries"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_29",
            "text": "InSeries ist ein   DatenSerien  Objekt, in dem die Eingangsdaten f\u00fcr einen Indikator bzw. eine Strategie enthalten sind.  Wird ein Indikator ohne explizite Angabe von Eingangsdaten aufgerufen, wird immer der Schlusskurs (Close) der aktuell im Chart geladenen Kursdaten verwendet.  Bei einem Aufruf von SMA(20) wird der gl. Durchschnitt auf die Schlusskurse der aktuellen Chart-Kursdaten berechnet (dies entspricht SMA(Close, 20).  InSeries[0] = Close[0].  Bei dem Aufruf von SMA(High, 20) werden die H\u00f6chstkurse der geladenen Daten f\u00fcr die Berechnung des gl. Durchschnitts verwendet.  InSeries[0] = High[0].  So kann jede beliebige Datenreihe als Input f\u00fcr einen Indikator verwendet werden.  double  d =  RSI ( SMA (20), 14, 3)[0]; berechnet beispielsweise den 14-Perioden-RSI \u00fcber die SMA(20) Werte als Eingangsdatenreihe.\nInSeries[0] = SMA(20)[0].",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_26",
            "text": "InSeries\nInSeries[int barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiele_1",
            "text": "Print(\"Die Eingangsdaten f\u00fcr den Indikator sind \" + InSeries[0]);",
            "title": "Beispiele"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#lines",
            "text": "",
            "title": "Lines"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_30",
            "text": "Lines ist eine Collection, die die   LevelLine  Objekte eines Indikators enth\u00e4lt.  Wenn einem Indikator mit der  Add()  Methode ein Line-Objekt hinzugef\u00fcgt wird, wird dieses automatisch der Collection Lines hinzugef\u00fcgt.  Die Reihenfolge der Add-Befehle bestimmt dabei auch die Sortierung in Lines. Der erste Aufruf von Add() erzeugt Lines[0], der n\u00e4chste Lines[1] usw.  Siehe auch  OutputDescriptor .",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_27",
            "text": "Lines[int index]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiele_2",
            "text": "// Add \"using System.Drawing.Drawing2D;\" for DashStyle\nprotected override void OnInit()\n{\nAdd(new LevelLine(Color.Blue, 70, \"Upper\")); // gespeichert in Lines[0]\nAdd(new LevelLine(Color.Blue, 30, \"Lower\")); // gespeichert in Lines[1]\n}\nprotected override void OnCalculate()\n{\n// Wenn RSI \u00fcber 70, Eigenschaften der Linie \u00e4ndern\nif (RSI(14 ,3) >= 70)\n{\nLines[0].Width = 3;\nLines[0].Color = Color.Red;\nLines[0].DashStyle = DashStyle.Dot;\n}\nelse\n{\nLines[0].Width = 1;\nLines[0].Color = Color.Blue;\nLines[0].DashStyle = DashStyle.Solid;\n}\n}",
            "title": "Beispiele"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#plotcolors",
            "text": "",
            "title": "PlotColors"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_31",
            "text": "PlotColors ist eine Collection, die die ColorSeries aller Plot-Objekte enth\u00e4lt.  Wenn einem Indikator mit der  Add()  Methode ein Plot hinzugef\u00fcgt wird, wird automatisch auch ein ColorSeries-Objekt erzeugt und der Collection PlotColors hinzugef\u00fcgt.  Die Reihenfolge der Add-Befehle bestimmt dabei auch die Sortierung in PlotColors. Der erste Aufruf von Add() erzeugt PlotColors[0], der n\u00e4chste PlotColors[1] usw.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_28",
            "text": "PlotColors[int PlotIndex][int barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_21",
            "text": "Informationen zur Klasse Collection: http://msdn.microsoft.com/en-us/library/ybcx56wz%28v=vs.80%29.aspx",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_27",
            "text": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing AgenaTrader.API;\nnamespace AgenaTrader.UserCode\n{\n[Description(\"PlotColor Demo\")]\npublic class PlotColorsDemo : UserIndicator\n{\npublic DataSeries SMA20 { get {return Outputs[0];} }\npublic DataSeries SMA50 { get {return Outputs[1];} }\npublic DataSeries SMA100 { get {return Outputs[2];} }\nprivate Pen pen;\nprotected override void OnInit()\n{\n// Linienst\u00e4rke (Width) auf 4 einstellen\npen = new Pen(Color.Empty, 4);\n // Dem Chart drei Plots mit der def. Linienst\u00e4rke hinzuf\u00fcgen\nAdd(new OnPaint(pen, OutputSeriesDisplayStyle.LevelLine, \"SMA20\" )); //attached to PlotColors[0]\nAdd(new OnPaint(pen, OutputSeriesDisplayStyle.LevelLine, \"SMA50\" )); //attached to PlotColors[1]\nAdd(new OnPaint(pen, OutputSeriesDisplayStyle.LevelLine, \"SMA100\")); //attached to PlotColors[2]\nIsOverlay = true;\n}\nprotected override void OnCalculate()\n{\n // Den drei Plots Werte zuweisen\nSMA20.Set (SMA(20) [0]);\nSMA50.Set (SMA(50) [0]);\nSMA100.Set(SMA(100)[0]);\n// Farben je nach Kursverlauf \u00e4ndern\nif (IsSerieRising(Close))\n{\nPlotColors[0][0] = Color.LightGreen;\nPlotColors[1][0] = Color.Green;\nPlotColors[2][0] = Color.DarkGreen;\n}\nelse if (IsSerieFalling(Close))\n{\nPlotColors[0][0] = Color.LightSalmon;\nPlotColors[1][0] = Color.Red;\nPlotColors[2][0] = Color.DarkRed;\n}\nelse\n{\nPlotColors[0][0] = Color.LightGray;\nPlotColors[1][0] = Color.Gray;\nPlotColors[2][0] = Color.DarkGray;\n}\n}\n}\n}",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#outputdescriptor",
            "text": "",
            "title": "OutputDescriptor"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_32",
            "text": "OutputDescriptor ist eine Collection, die die Plot-Objekte eines Indikators enth\u00e4lt.  Wenn einem Indikator mit der Add()-Methode ein Plot-Objekt hinzugef\u00fcgt wird, wird dieses automatisch der Collection Plots hinzugef\u00fcgt.  Die Reihenfolge der Add-Befehle bestimmt dabei auch die Sortierung in Plots. Der erste Aufruf von Add() erzeugt OutputDescriptor\n[0], der n\u00e4chste OutputDescriptor[1]\\ usw.  Siehe auch  Lines .",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_29",
            "text": "OutputDescriptor[int index]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiele_3",
            "text": "protected override void OnInit()\n{\nAdd(new OnPaint(Color.Blue, \"MySMA 20\")); // saved to OutputDescriptor[0]\n}\nprotected override void OnCalculate()\n{\nValue.Set(SMA(20)[0]);\n// Wenn Kurs \u00fcber SMA, Plot gr\u00fcn f\u00e4rben, sonst rot\nif (Close[0] > SMA(20)[0])\n    OutputDescriptor[0].PlotColor = Color.Green;\nelse\n    OutputDescriptor[0].PlotColor = Color.Red;\n}",
            "title": "Beispiele"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#values",
            "text": "",
            "title": "Values"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_33",
            "text": "Values ist eine Collection, die die DataSeries-Objekte eines Indikators enth\u00e4lt.  Wenn einem Indikator mit der Add()-Methode ein Plot hinzugef\u00fcgt wird, wird automatisch auch ein Value-Objekt erzeugt und der Collection Values hinzugef\u00fcgt.  Die Reihenfolge der Add-Befehle bestimmt dabei auch die Sortierung in Values. Der erste Aufruf von Add() erzeugt Values[0], der n\u00e4chste Values[1] usw.  Value  ist immer identisch mit Values[0].",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_30",
            "text": "Outputs[int index]\nOutputs[int index][int barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_22",
            "text": "Die f\u00fcr eine Collection bekannten Methoden Set(), Reset() und Count() sind auf Value bzw. Values anwendbar.  Informationen zur Klasse Collection: http://msdn.microsoft.com/en-us/library/ybcx56wz%28v=vs.80%29.aspx",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_28",
            "text": "// \u00dcberp\u00fcfung des zweiten Indikatorwertes (d.h. der sekund\u00e4ren DatenSerie)\n// von vor einem Bar\n// und in Abh\u00e4ngigkeit davon Setzen des aktuellen Indikatorwertes\nif (Outputs[1][1] < High[0] - Low[0])\nValue.Set(High[0] - Low[0]);\nelse\nValue.Set(High[0] - Close[0]);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#data-series",
            "text": "",
            "title": "Data Series"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_34",
            "text": "Datenserien werden in AgenaTrader zum einen unterschieden in die frei f\u00fcr die eigene Programmierung verwendbaren Datenserien zum Speichern von Werten unterschiedlicher Datentypen und zum anderen in die in AgenaTrader fest integrierten Datenserien, die die Kursdaten der einzelnen Bars enthalten. Die letzteren werden hier vorgestellt.\nDas Konzept von Datenserien wird sehr konsequent und durchg\u00e4ngig verfolgt. Alle Kursdaten der einzelnen Bars sind in Datenserien organisiert.\nFolgende Datenserien sind verf\u00fcgbar:  Open   Opens  High   Highs  Low   Lows  Close   Closes  Median   Medians  Typical   Typicals  Weighted   Weighteds  Time   Times  TimeFrame   TimeFrames  Volume   Volumes",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#open",
            "text": "",
            "title": "Open"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_35",
            "text": "Open ist eine  DataSeries  vom Typ  DataSeries ,  in der die historischen Er\u00f6ffnungskurse gespeichert sind.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_23",
            "text": "BarsAgo Indexwert (s.  Bars )",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_31",
            "text": "Open\nOpen[int barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_23",
            "text": "Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft   CalculateOnClosedBar .",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_29",
            "text": "// Er\u00f6ffnungskurs der aktuellen Periode\nPrint(Time[0] + \" \" + Open[0]);\n// Er\u00f6ffnungskurs des Bars von vor 5 Perioden\nPrint(Time[5] + \" \" + Open[5]);\n// aktueller Wert f\u00fcr den SMA 14 \u00fcber die Er\u00f6ffnungskurse (gerundet)\nPrint(\"SMA(14) calculated using the opening prices: \" + Instrument.Round2TickSize(SMA(Open, 14)[0]));",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#opens",
            "text": "",
            "title": "Opens"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_36",
            "text": "Opens ist ein Array von Datenserien, welches alle Open-Datenserien enth\u00e4lt.  Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.  Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird.  Mit  [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]  enth\u00e4lt das Array 3 Eintr\u00e4ge:  Opens[0] die Open-Dataseries der Chart-Zeiteinheit\nOpens[1] die Open-Dataseries aller Bars auf Tagesbasis\nOpens[2] die Open-Dataseries aller Bars auf Wochenbasis.  Opens[0][0] entspricht Open[0].  Siehe auch  MultiBars",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_24",
            "text": "barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries (s.  Bars )\nbarSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_32",
            "text": "Opens[int barSeriesIndex]\nOpens[int barSeriesIndex][int barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_24",
            "text": "Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft  CalculateOnClosedBar .",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_30",
            "text": "Siehe Beispiel unter  Multibars .",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#high",
            "text": "",
            "title": "High"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#description",
            "text": "High ist eine  DataSeries  vom Typ  DataSeries , in der die historischen H\u00f6chstkurse gespeichert sind.",
            "title": "Description"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_25",
            "text": "barsAgo Indexwert (s.  Bars )",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_33",
            "text": "High\nHigh[int barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_25",
            "text": "Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft   CalculateOnClosedBar .",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_31",
            "text": "//H\u00f6chstkurs der aktuellen Periode\nPrint(Time[0] + \" \" + High[0]);\n// H\u00f6chstkurs des Bars von vor 5 Perioden\nPrint(Time[5] + \" \" + High[5]);\n// aktueller Wert f\u00fcr den SMA 14 \u00fcber die H\u00f6chstkurse (gerundet)\nPrint(\"SMA(14) Calculated using the high prices: \" + Instrument.Round2TickSize(SMA(High, 14)[0]));",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#highs",
            "text": "",
            "title": "Highs"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_37",
            "text": "Highs ist ein Array von [ DataSeries ][1] welches alle High-Datenserien enth\u00e4lt.  Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.  Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird  Mit  [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]  enth\u00e4lt das Array 3 Eintr\u00e4ge.  Highs[0] die High-Dataseries der Chart-Zeiteinheit\nHighs[1] die High-Dataseries aller Bars auf Tagesbasis\nHighs[2] die High-Dataseries aller Bars auf Wochenbasis.  Highs[0][0] entspricht High[0].  Siehe auch  MultiBars .",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_26",
            "text": "barsAgo  Indexwert der einzelnen Bars innerhalb der Dataseries (s.  Bars )\nbarSeriesIndex  Indexwert der unterschiedlichen Zeiteinheiten",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_34",
            "text": "Highs[int barSeriesIndex]\nHighs[int barSeriesIndex][int barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_26",
            "text": "Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft  CalculateOnClosedBar .",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_32",
            "text": "Siehe Beispiel unter   Multibars .",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#low",
            "text": "",
            "title": "Low"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_38",
            "text": "Low ist eine  DataSeries  vom Typ  DataSeries ,  in der die historischen Tiefstkurse gespeichert sind.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_27",
            "text": "barsAgo Indexwert (s.  Bars )",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_35",
            "text": "Low\nLow[int barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_27",
            "text": "Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft  CalculateOnClosedBar .",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_33",
            "text": "// Tiefstkurs der aktuellen Periode\nPrint(Time[0] + \" \" + Low[0]);\n// Tiefstkurs des Bars von vor 5 Perioden\nPrint(Time[5] + \" \" + Low[5]);\n// aktueller Wert f\u00fcr den SMA 14 \u00fcber die Tiefstkurse (gerundet)\nPrint(\"SMA(14) calculated using the high prices: \" + Instrument.Round2TickSize(SMA(Low, 14)[0]));",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#lows",
            "text": "",
            "title": "Lows"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_39",
            "text": "Lows ist ein Array von [ DataSeries ][1] welches alle  Low -Datenserien enth\u00e4lt.  Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.  Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird.  Mit  [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]   enth\u00e4lt das Array 3 Eintr\u00e4ge.  Lows[0] die Low-Dataseries der Chart-Zeiteinheit\nLows[1] die Low-Dataseries aller Bars auf Tagesbasis\nLows[2] die Low-Dataseries aller Bars auf Wochenbasis.  Lows[0][0] entspricht Low[0].  Siehe auch  MultiBars .",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_28",
            "text": "barsAgo  Indexwert der einzelnen Bars innerhalb der Dataseries\nbarSeriesIndex  Indexwert der unterschiedlichen Zeiteinheiten",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_36",
            "text": "Lows[int barSeriesIndex]\nLows[int barSeriesIndex][int barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_28",
            "text": "Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft  CalculateOnClosedBar .",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_34",
            "text": "Siehe Beispiel unter  Multibars .",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#close",
            "text": "",
            "title": "Close"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_40",
            "text": "Close ist eine  DataSeries  vom Typ  DataSeries , in der die historischen Schlusskurse gespeichert sind.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_29",
            "text": "barsAgo Indexwert (s.  Bars )",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_37",
            "text": "Close\nClose[int barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_29",
            "text": "Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft  CalculateOnClosedBar .  Indikatoren werden standardm\u00e4\u00dfig \u00fcber die Schlusskurse berechnet. Die Angabe der Input-Serie kann weggelassen werden (siehe Beispiel unten).",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_35",
            "text": "// Schlusskurs der aktuellen Periode\nPrint(Time[0] + \" \" + Close[0]);\n// Schlusskurs des Bars von vor 5 Perioden\nPrint(Time[5] + \" \" + Close[5]);\n// aktueller Wert f\u00fcr den SMA 14 \u00fcber die Schlusskurse (gerundet)\nPrint(\"SMA(14) calculated using the closing prices: \" + Instrument.Round2TickSize(SMA(Close, 14)[0]));\n// Close kann auch weggelassen werden, da es per Default verwendet wird.\nPrint(\"SMA(14) calculated using the closing prices: \" + Instrument.Round2TickSize(SMA(14)[0]));",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#closes",
            "text": "",
            "title": "Closes"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_41",
            "text": "Closes ist ein Array von [ DataSeries ][1] welches alle  Low -Datenserien enth\u00e4lt.  Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.  Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird.  Mit  [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]  enth\u00e4lt das Array 3 Eintr\u00e4ge.  Closes[0] die Close-Dataseries der Chart-Zeiteinheit\nCloses[1] die Close-Dataseries aller Bars auf Tagesbasis\nCloses[2] die Close-Dataseries aller Bars auf Wochenbasis.  Closes[0][0] entspricht Close[0].  Siehe auch  MultiBars .",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_30",
            "text": "barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries\nbarSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_38",
            "text": "Closes[int barSeriesIndex]\nCloses[int barSeriesIndex][int barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_30",
            "text": "Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft  CalculateOnClosedBar .",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_36",
            "text": "Siehe Beispiel unter  Multibars .",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#median",
            "text": "",
            "title": "Median"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_42",
            "text": "Median ist eine  DataSeries  vom Typ  DataSeries in der die historischen Median-Werte gespeichert sind.  Der Median-Preis eines Bars ergibt sich aus (High + Low) / 2.  Siehe auch  Typical  und  Weighted .",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_31",
            "text": "barsAgo Indexwert (s.  Bars )",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_39",
            "text": "Median\nMedian[int barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_31",
            "text": "Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft  CalculateOnClosedBar .  Informationen zu Median, Typical und Weighted: http://blog.nobletrading.com/2009/12/median-price-typical-price-weighted.html",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_37",
            "text": "// Median-Preis der aktuellen Periode\nPrint(Time[0] + \" \" + Median[0]);\n// Median-Preis des Bars von vor 5 Perioden\nPrint(Time[5] + \" \" + Median[5]);\n// aktueller Wert f\u00fcr den SMA 14 \u00fcber die Median-Preise (gerundet)\nPrint(\"SMA(14) calculated using the median prices: \" + Instrument.Round2TickSize(SMA(Median, 14)[0]));",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#medians",
            "text": "",
            "title": "Medians"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_43",
            "text": "Medians ist ein Array von  [ DataSeries ][1] welches alle  Median -Datenserien enth\u00e4lt.  Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.  Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird.  Mit  [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]   enth\u00e4lt das Array 3 Eintr\u00e4ge.  Medians[0] die Median-Dataseries der Chart-Zeiteinheit\nMedians[1] die Median-Dataseries aller Bars auf Tagesbasis\nMedians[2] die Median-Dataseries aller Bars auf Wochenbasis.  Medians[0][0]entspricht Medians[0].  Siehe auch  MultiBars .",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_32",
            "text": "barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries\nbarSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_40",
            "text": "Medians[int barSeriesIndex]\nMedians[int barSeriesIndex][int barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_32",
            "text": "Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft   CalculateOnClosedBar .  Informationen zu Median, Typical und Weighted:  http://www.investopedia.com/terms/m/median.asp",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_38",
            "text": "Siehe Beispiel unter  Multibars .",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#typical",
            "text": "",
            "title": "Typical"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_44",
            "text": "Typical ist eine  DataSeries  vom Typ  DataSeries in der die historischen Typical-Werte gespeichert sind.  Der Typical-Preis eines Bars ergibt sich aus (High + Low + Close) / 3.  Siehe auch  Median  und  Weighted .",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_33",
            "text": "barsAgo Indexwert (s.  Bars )",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_41",
            "text": "Typical\nTypical[int barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_33",
            "text": "Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft   CalculateOnClosedBar .  Informationen zu Median, Typical und Weighted:  https://technicianapp.com/resources/typical-price/",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_39",
            "text": "// Typical-Preis der aktuellen Periode\nPrint(Time[0] + \" \" + Typical[0]);\n// Typical-Preis des Bars von vor 5 Perioden\nPrint(Time[5] + \" \" + Typical[5]);\n// aktueller Wert f\u00fcr den SMA 14 \u00fcber die Typical-Preise (gerundet)\nPrint(\"SMA(14) calculated using the typical price: \" + Instrument.Round2TickSize(SMA(Typical, 14)[0]));",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#typicals",
            "text": "",
            "title": "Typicals"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_45",
            "text": "Typicals ist ein Array von  Datenserien , welches alle   Typical -Datenserien enth\u00e4lt.  Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.  Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird.  Mit  [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]  enth\u00e4lt das Array 3 Eintr\u00e4ge.  Typicals[0] die Typical-Dataseries der Chart-Zeiteinheit\nTypicals[1] die Typical-Dataseries aller Bars auf Tagesbasis\nTypicals[2] die Typical-Dataseries aller Bars auf Wochenbasis.  Typicals[0][0] entspricht Typicals[0].  Siehe auch  MultiBars .",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_34",
            "text": "barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries\nbarSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_42",
            "text": "Typicals[int barSeriesIndex]\nTypicals[int barSeriesIndex][int barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_34",
            "text": "Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft   CalculateOnClosedBar .",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_40",
            "text": "Siehe Beispiel unter   Multibars .",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weighted",
            "text": "",
            "title": "Weighted"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_46",
            "text": "Weighted ist eine  DataSeries  vom Typ  DataSeries , in der die historischen Weighted-Werte gespeichert.  Der Weighted-Preis eines Bars ergibt sich aus (high + low + 2*close) / gewichtet auf den Schlusskurs.  Siehe auch  Median  und  Typical .",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_35",
            "text": "barsAgo Indexwert (s.  Bars )",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_43",
            "text": "Weighted[int barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_35",
            "text": "Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft   CalculateOnClosedBar .  Informationen zu Median, Typical und Weighted:  http://www.stock-trading-infocentre.com/pivot-points.html",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_41",
            "text": "// Weighted-Preis der aktuellen Periode\nPrint(Time[0] + \" \" + Weighted[0]);\n// Weighted-Preis des Bars von vor 5 Perioden\nPrint(Time[5] + \" \" + Weighted[5]);\n// aktueller Wert f\u00fcr den SMA 14 \u00fcber die Weighted-Preise (gerundet)\nPrint(\"SMA(14) calculated using the weighted price: \" + Instrument.Round2TickSize(SMA(Weighted, 14)[0]));",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weighteds",
            "text": "",
            "title": "Weighteds"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_47",
            "text": "Weighteds ist ein Array von  [ DataSeries ][1] welches alle  Weighted -Datenserien enth\u00e4lt.  Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.  Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird.  Mit  [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]    enth\u00e4lt das Array 3 Eintr\u00e4ge.  Weighteds[0] die Weighted-Dataseries der Chart-Zeiteinheit\nWeighteds[1] die Weighted-Dataseries aller Bars auf Tagesbasis\nWeighteds[2] die Weighted-Dataseries aller Bars auf Wochenbasis  Weighteds[0][0] entspricht Weighteds[0].  Siehe auch   MultiBars .",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_36",
            "text": "barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries\nbarSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_44",
            "text": "Weighteds[int barSeriesIndex]\nWeighteds[int barSeriesIndex][int barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_36",
            "text": "Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft  CalculateOnClosedBar .",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_42",
            "text": "Siehe Beispiel unter  Multibars .",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#time",
            "text": "",
            "title": "Time"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_48",
            "text": "Time ist eine  DataSeries  vom Typ  DateTimeSeries , in der die Zeitstempel der einzelnen Bars gespeichert sind.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_37",
            "text": "barsAgo Indexwert (s.  Bars )",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_45",
            "text": "Time\nTime[int barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_37",
            "text": "Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft   CalculateOnClosedBar .",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_43",
            "text": "// Zeitstempel der aktuellen Periode\nPrint(Time[0]);\n// Zeitstempel des Bars von vor 5 Perioden\nPrint(Time[5]);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#times",
            "text": "",
            "title": "Times"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_49",
            "text": "Times ist ein Array von  DataSeries  welches alle  Time -Datenserien enth\u00e4lt.  Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.\nEin neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird.  Mit  [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]    enth\u00e4lt das Array 3 Eintr\u00e4ge.  Times[0] die Time-Dataseries der Chart-Zeiteinheit\nTimes[1] die Time-Dataseries aller Bars auf Tagesbasis\nTimes[2] die Time-Dataseries der Chart-Zeiteinheit  Times[0][0] entspricht Times[0].  Siehe auch   MultiBars .",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_38",
            "text": "barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries\nbarSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_46",
            "text": "Times[int barSeriesIndex]\nTimes[int barSeriesIndex][int barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_38",
            "text": "Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft  CalculateOnClosedBar .",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_44",
            "text": "Siehe Beispiel unter  Multibars .",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#volume",
            "text": "",
            "title": "Volume"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_50",
            "text": "Volume ist eine  DataSeries  vom Typ  DataSeries ,  in der die historischen Ums\u00e4tze gespeichert sind.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_39",
            "text": "barsAgo Indexwert (s.  Bars )",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_47",
            "text": "Volume  Volume[ int  barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_39",
            "text": "Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft  CalculateOnClosedBar .  Der vom Indikator  VOL()  zur\u00fcckgelieferte Wert ist identisch mit dem hier beschriebenen Volumen.\nZ.B. liefert Vol()[3]  den gleichen Wert wie Volume[3].",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_45",
            "text": "// Volumen der aktuellen Periode\nPrint(Time[0] + \" \" + Volume[0]);\n// Volumen des Bars von vor 5 Perioden\nPrint(Time[5] + \" \" + Volume[5]);\n// aktueller Wert f\u00fcr den SMA 14 \u00fcber das Volumen (gerundet)\nPrint(\"SMA(14) berechnet \u00fcber das Volumen: \" + Instrument.Round2TickSize(SMA(Volume, 14)[0]));",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#volumes",
            "text": "",
            "title": "Volumes"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_51",
            "text": "Volumes ist ein Array von  DataSeries  welches alle  Volume -Datenserien enth\u00e4lt.  Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.  Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird.  Mit  [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]    enth\u00e4lt das Array 3 Eintr\u00e4ge.  Volumes[0] die Volume-Dataseries der Chart-Zeiteinheit\nVolumes[1] die Volume-Dataseries aller Bars auf Tagesbasis\nVolumes[2] die Volume-Dataseries aller Bars auf Wochenbasis.  Volumes[0][0] entspricht Volumes[0].  Siehe auch  MultiBars .",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_40",
            "text": "barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries  barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_48",
            "text": "Volumes[int barSeriesIndex]\nVolumes[int barSeriesIndex][int barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_40",
            "text": "Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft   CalculateOnClosedBar .",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_46",
            "text": "Siehe Beispiel unter   Multibars .",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#timeframe",
            "text": "",
            "title": "TimeFrame"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_52",
            "text": "TimeFrame ist ein Zeitrahmenobjekt. Diese Einstellung/Men\u00fcpunkt wird verwendet, um die aktuelle Zeiteinheit zu lesen, nicht um sie zu festzulegen",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_49",
            "text": "TimeFrame",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#timeframes",
            "text": "",
            "title": "TimeFrames"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_53",
            "text": "TimeFrames ist ein Array von TimeFrame-Objekten, welches f\u00fcr jedes Bar-Objekt ein separates TimeFrame-Objekt  enth\u00e4lt.  Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.  Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird.  Mit  [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]  enth\u00e4lt das Array 3 Eintr\u00e4ge:  TimeFrames [0] TimeFrame der prim\u00e4ren Datenserie (Chart-Zeiteinheit)\nTimeFrames [1]  Print (TimeFrames[1]);  // liefert \"1 Day\"\nTimeFrames [2]  Print (TimeFrames[2]); // liefert \"1 Week\"  TimeFrames [0] entspricht  TimeFrame .  Siehe auch  MultiBars .",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_41",
            "text": "barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_50",
            "text": "TimeFrames [int barSeriesIndex]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_47",
            "text": "if (ProcessingBarSeriesIndex == 0 && ProcessingBarIndex == 0)\nfor (int i = BarsArray.Count-1; i >= 0; i--)\nPrint(\"The Indicator \" + this.Name + \" uses Bars of the Timeframe \" + TimeFrames[i]);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#instruments",
            "text": "\"Instrument\" bezeichnet einen handelbaren Wert, wie z.B. eine Aktie, einen ETF, einen Future, einen CFD usw.  Ein Instrument hat viele Eigenschaften, die in einem selbst erstellten AgenaScript verwendet werden k\u00f6nnen.  Instrument.Compare  Instrument.Currency  Instrument.Digits  Instrument.ETF  Instrument.Exchange  Instrument.Expiry  Instrument.GetCurrencyFactor  Instrument.InstrumentType  Instrument.MainSector  Instrument.Margin  Instrument.Name  Instrument.PointValue  Instrument.Round2TickSize  Instrument.Symbol  Instrument.TickSize  Innerhalb von   OnCalculate()  k\u00f6nnen diese Eigenschaften verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen.\nSobald die Funktion   OnCalculate()   von AgenaScript aufgerufen wird, ist immer auch ein Instrument-Objekt vorhanden. Falls diese Eigenschafte ausserhalb von  OnCalculate() , verwendet werden, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit  if  (Bars !=  null )",
            "title": "Instruments"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#instrumentcompare",
            "text": "",
            "title": "Instrument.Compare"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_54",
            "text": "Die Funktion Instrument.Compare vergleicht 2 Kursdaten unter Ber\u00fccksichtigung der richtigen Anzahl Nachkommastellen. Die kleinstm\u00f6gliche Preis\u00e4nderung wird durch den Wert TickSize angegeben. Diese Funktion vereinfacht den sonst etwas aufw\u00e4ndigeren Vergleich mit Hilfe von Floating-Point-Operationen.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_42",
            "text": "double value1\ndouble value2",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_28",
            "text": "Typ int  1 - Kurs1 ist gr\u00f6\u00dfer als Kurs2\n-1 - Kurs1 ist kleiner als Kurs2\n 0 - Kurs1 und Kurs2 sind gleich",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_51",
            "text": "Instrument.Compare(double Value1, double Value2)",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_41",
            "text": "Be aware this function compares prices based on TickSize.  If the ticksize of your instrument is 0.01 these prices will be rounded and compared on 2 decimal digits. If you want a regular comparation of two numbers, you should use the operator \"greater than\" (>) or the operator \"smaller than\" (<).  More infomation about  math.round()  Wenn TickSize z.B. 0,00001 ist, wie bei FX-Werten \u00fcblich, dann liefert  Compare(2, 1.99999) eine 1, d.h. 2 ist gr\u00f6\u00dfer als 1.99999\nCompare(2, 2.000001)    eine 0, d.h. die Kurse sind gleich\nCompare(2, 1.999999)    eine 0, d.h. die Kurse sind gleich\nCompare(2, 2.00001) eine -1, d.h. 2 ist kleiner als 2.00001.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_48",
            "text": "Print(Instrument.Compare(2, 1.999999));",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#instrumentcurrency",
            "text": "",
            "title": "Instrument.Currency"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_55",
            "text": "Instrument.Currency liefert ein Currencies-Objekt zur\u00fcck, das die jeweilige W\u00e4hrung beinhaltet, in der das Instrument gehandelt wird.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_43",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_29",
            "text": "eine Konstante vom Typ public enum Currencies",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_52",
            "text": "Instrument.Currency",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_42",
            "text": "\u00dcbliche W\u00e4hrungen sind z.B. AUD, CAD, EUR, GBP, JPY oder USD.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_49",
            "text": "Print(Instrument.Name + \"wird in  \" + Instrument.Currency + \" gehandelt\".);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#instrumentdigits",
            "text": "",
            "title": "Instrument.Digits"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_56",
            "text": "Instrument.Digits liefert die Anzahl der Nachkommastellen, mit denen der Kurs des Instrument notiert wird.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_44",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_30",
            "text": "int Digits",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_53",
            "text": "Instrument.Digits",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_43",
            "text": "Aktie werden \u00fcblicherweise mit 2 Stellen nach dem Komma gehandelt. Bei Forex sind es je nach Datenanbieter 4 oder 5 Stellen.  Die Funktion findet u.a. Verwendung f\u00fcr das Formatieren von Ausgaben oder zur Rundung von Kursdaten. Siehe auch  TickSize  und  Instrument.Round2Ticks ,  Instrument.Round2TickSize .  Ausf\u00fchrliche Anleitung zum:  Formatieren von Zahlen. .",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_50",
            "text": "Print(\"Der Kurs von  \" +Instrument.Name + \" wird mit einer Genauigkeit von\" + Instrument.Digits +\" Nachkommastellen angegeben.\");",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#instrumentetf",
            "text": "",
            "title": "Instrument.ETF"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_57",
            "text": "Instrument.ETF dient der Unterscheidung zwischen einer Aktie und einem ETF. Dies ist notwendig, da ETF's von den B\u00f6rsen auch als \"Stock\" (dt. Aktie) angesehen werden..",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_45",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_31",
            "text": "Typ bool",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_54",
            "text": "Instrument.ETF",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_44",
            "text": "Was ist ein ETF?  Wikipedia:  http://de.wikipedia.org/wiki/Exchange-traded_fund",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_51",
            "text": "if (Instrument.InstrumentType == InstrumentType.Stock)\nif (Instrument.ETF)\nPrint(\"Der Wert ist ein Exchange-traded Fund.\");\nelse\nPrint(\"Der Wert ist eine Aktie.\");",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#instrumentexchange",
            "text": "",
            "title": "Instrument.Exchange"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_58",
            "text": "Instrument.Exchange (Exchange = dt. B\u00f6rse) liefert die Bezeichnung des B\u00f6rsenhandelsplatzes f\u00fcr das aktuelle Instrument.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_46",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_32",
            "text": "ein Exchange-Objekt vom Typ public enum Exchanges",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_55",
            "text": "Instrument.Exchange",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_45",
            "text": "\u00dcbersicht B\u00f6rsenhandelspl\u00e4tze",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_52",
            "text": "Print(\"Das Instrument \" + Instrument.Name +\"  wird an der B\u00f6rse \" + Instrument.Exchange + \" gehandelt.\");",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#instrumentexpiry",
            "text": "",
            "title": "Instrument.Expiry"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_59",
            "text": "Instrument.Expiry gibt das Datum (Monat und Jahr) des Ablauf eines Finanzinstrumentes an. Nur derivative Handelsinstrumente, wie Optionen oder Futures besitzen ein Ablaufdatum, das sog. Verfallsdatum.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_47",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_33",
            "text": "Typ DateTime  F\u00fcr Instrumente ohne Verfallsdatum wird Instrument.Expiry auf DateTime.MaxValue (= 31.12.9999 23.59:59) gesetzt.",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_56",
            "text": "Instrument.Expiry",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_46",
            "text": "Das Verfallsdatum (Expiry) ist auch im Instrument Escort ersichtlich:",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_53",
            "text": "Print(\"Das Instrument \" + Instrument.Name +\" verf\u00e4llt am \" + Instrument.Expiry);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#instrumentgetcurrencyfactor",
            "text": "",
            "title": "Instrument.GetCurrencyFactor"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_60",
            "text": "Instrument.GetCurrencyFactor liefert einen Umrechnungsfaktor zur\u00fcck, mit dessen Hilfe man den Kurs eines Instruments in die W\u00e4hrung des Accounts umrechnen kann.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_48",
            "text": "Typ Currencies",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_34",
            "text": "ein double",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_57",
            "text": "Instrument.GetCurrencyFactor(Currencies)",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_47",
            "text": "\u00dcbliche W\u00e4hrungen sind z.B. AUD, CAD, EUR, GBP, JPY oder USD.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_54",
            "text": "Protected override void OnCalculate()\n{\n   double currFactor = Instrument.GetCurrencyFactor(Account.Currency);\n   Print(Close[0] + \" in \" + Instrument.Currency.ToString() + \" = \" + (Close[0] * currFactor) + \" in \" + Account.Currency.ToString());\n}",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#instrumentinstrumenttype",
            "text": "",
            "title": "Instrument.InstrumentType"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_61",
            "text": "Instrument.InstrumentType liefert ein Typ-Objekt des Handelsinstrumentes.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_49",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_35",
            "text": "Objekt vom Typ public enum InstrumentType",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_58",
            "text": "Instrument.InstrumentType",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_48",
            "text": "M\u00f6gliche Werte sind: Future, Stock, Index, Currency, Option, CFD und Unknown.\nEinen Typ ETF gibt es nicht. ETF's sind vom Typ Stock, siehe Instrument.ETF .  Der Instrument-Typ ist auch im Instrument Escort ersichtlich:",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_55",
            "text": "Print(\"Das Instrument  \" + Instrument.Name + \"  ist vom Typ \" + Instrument.InstrumentType);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#instrumentmainsector",
            "text": "",
            "title": "Instrument.MainSector"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_62",
            "text": "Instrument.MainSector liefert den Hauptsektor des Handelsinstrumentes zur\u00fcck.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_50",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_36",
            "text": "String",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_59",
            "text": "Instrument.MainSector",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_49",
            "text": "Der  Hauptsektor ist auch im Instrument Escort ersichtlich:",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_56",
            "text": "Print(\"Das Instrument \" + Instrument.Name + \" ist im Sektor \" + Instrument.MainSector + \" t\u00e4tig.\");",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#instrumentmargin",
            "text": "",
            "title": "Instrument.Margin"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_63",
            "text": "Instrument.Margin liefert die erforderliche Margin des Handelsinstrumentes zur\u00fcck.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_51",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_37",
            "text": "int",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_60",
            "text": "Instrument.Margin",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_50",
            "text": "Margin ist auch im Instrument Escort ersichtlich:",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_57",
            "text": "Print(\"Das Instrument\" + Instrument.Name + \" hat eine Margin von  \" + Instrument.Margin);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#instrumentname",
            "text": "",
            "title": "Instrument.Name"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_64",
            "text": "Instrument.Name liefert die Bezeichnung des Handelsinstrumentes.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_52",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_38",
            "text": "Typ string",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_61",
            "text": "Instrument.Name",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_51",
            "text": "Der Instrument Name ist auch im Instrument Escort ersichtlich:",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_58",
            "text": "Print(\"Das aktuell im Chart geladene Instrument hei\u00dft \" + Instrument.Name);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#instrumentpointvalue",
            "text": "",
            "title": "Instrument.PointValue"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_65",
            "text": "Instrument.PointValue liefert den Geldwert f\u00fcr die Bewegung eines Instrumentes von einem vollen Punkt.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_53",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_39",
            "text": "Typ double - Punktwert",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_62",
            "text": "Instrument.PointValue",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_52",
            "text": "Beispiele verschieder Punktwerte   (je St\u00fcck, CDF, Futurekontrakt, Lot usw.)  Aktie: im .allg. 1,00 Euro bzw. 1,00 USD.\nEUR/USD: 100,000 USD\nDax-Future: 25,00 Euro  Tickwert  Der Tickwert ergibt sich, wenn man den Punktwert mit der TickGr\u00f6\u00dfe (TickSize) multipliziert.  z.B. hat der E-mini S&P 500 einen Punktwert von $ 50. Die TickSize betr\u00e4gt 0,25. Es braucht also eine Bewegung von 4 Ticks f\u00fcr einen vollen Punkt.\nAus 50 * 0,25 = 50 / 4 ergibt sich ein Tickwert von 12,50 $/ je Tick.  Der Punktwert ist auch im Instrument Escort ersichtlich:",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_59",
            "text": "Print(\"Wenn \" + Instrument.Name + \" einen vollen Punkt steigt, entspricht dies dem Gegenwert von  \" + Instrument.PointValue + \" \" + Instrument.Currency);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#instrumentround2ticksize",
            "text": "",
            "title": "Instrument.Round2TickSize"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_66",
            "text": "Die Funktion Instrument.Round2TickSize rundet einen \u00fcbergebenen Kurswert auf den kleinstm\u00f6glichen Wert, der durch die Tickgr\u00f6\u00dfe (TickSize) des Instrumentes teilbar ist.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_54",
            "text": "double - Kurswert",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_40",
            "text": "double",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_63",
            "text": "Instrument.Round2TickSize(double MarketPrice)",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_53",
            "text": "Die Anzahl der Nachkommastellen, auf die gerundet wird, ist je nach Instrument unterschiedlich.\nIst das Instrument eine Aktie, wird auf 2 Nachkommastellen gerundet, bei einem Forex-Wert auf 4 bzw. 5 Nachkommastellen.  Siehe auch   TickSize  und  Instrument.Digits .  Beispiele f\u00fcr professionelle   Formatting ,  Formatting of Numbers .",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_60",
            "text": "double Price = 12.3456789;\nPrint(Price + \"  gerundet auf einen f\u00fcr \" + Instrument.Name + \" g\u00fcltigen Kurs ist \" + Instrument.Round2TickSize(Price));",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#instrumentsymbol",
            "text": "",
            "title": "Instrument.Symbol"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_67",
            "text": "Instrument.Symbol liefert das Symbol, unter welchem das Handelsinstrument in AgenaTrader eindeutig identifizierbar ist. Anhand des Symbols werden die Mappings zu den verschiedenen Datenanbietern und Brokern verwaltet.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_55",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_41",
            "text": "Typ string",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_64",
            "text": "Instrument.Symbol",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_54",
            "text": "Mit dem Symbol werden gleiche Aktion an verschiedenen B\u00f6rsenpl\u00e4tzen unterschieden. Das Symbol BMW.DE ist z.B. die BMW-Aktie an der Xetra, BMW.CFD ist der CFD auf die BMW-Aktie.  Das Instrument Symbol ist auch im Instrument Escort ersichtlich:",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_61",
            "text": "Print(\"Das aktuell im Chart geladene Instrument hat das Symbol  \" + Instrument.Symbol);",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#instrumentticksize",
            "text": "",
            "title": "Instrument.TickSize"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_68",
            "text": "Die Tickgr\u00f6\u00dfe oder TickSize ist die kleinste m\u00f6gliche Einheit um die sich ein Finanzinstrument bewegen kann. Dies ist umgangssprachlich 1 Tick.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_56",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#ruckgabewert_42",
            "text": "double",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_65",
            "text": "Instrument.TickSize oder vereinfacht TickSize",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_55",
            "text": "Das Schl\u00fcsselwort  TickSize  entspricht Instrument.TickSize. Beide Aufrufe liefern identische Werte und sind gegeneinander austauschbar.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiele_4",
            "text": "Aktie:  0,01\nES-Future: 0,25\nEUR/USD: 0,00001  Siehe auch  Instrument.PointValue  und  Instrument.Digits .  Beispiele f\u00fcr professionelle   Formatting ,  Formatting of Numbers .",
            "title": "Beispiele"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_62",
            "text": "Print(\"Der Kurs von \" + Instrument.Name + \"  kann sich minimal um  \" + Instrument.TickSize + \" Punkt(e) ver\u00e4ndern.\");",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#multibars",
            "text": "",
            "title": "Multibars"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_69",
            "text": "Einem Indikator bzw. eine Strategie liegt immer die gleiche Zeiteinheit zugrunde, wie diejenige, in der der Chart angezeigt wird. Wird z.B. ein SMA(14) in einem 5-Minuten-Chart dargestellt, wird der gleitende Durchschnitt \u00fcber die 14 letzten 5-Minuten-Bars berechnet. Auf einem Tageschart w\u00fcrden entsprechend die Schlusskurse der letzten 14 Tage zur Berechnung herangezogen werden.  Das gleiche Prinzip gilt f\u00fcr selbst entwickelte Indikatoren. In einem 5-Minuten-Chart w\u00fcrde die Methode  OnCalculate()   f\u00fcr jeden 5-Minuten-Bar aufgerufen werden.\nMit Multibars ist es au\u00dferdem m\u00f6glich, Daten eines anderen Instrumentes zu laden.",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_63",
            "text": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Linq;\nusing System.Xml;\nusing System.Xml.Serialization;\nusing AgenaTrader.API;\nusing AgenaTrader.Custom;\nusing AgenaTrader.Plugins;\nusing AgenaTrader.Helper;\nnamespace AgenaTrader.UserCode\n{\n    [Description(\"Multibar Demo\")]\n    // Der Indikator ben\u00f6tigt Tages- und Wochendaten\n    [TimeFrameRequirements(\"1 Day\", \"1 Week\")]\n    public class MultiBarDemo : UserIndicator\n    {\n        private static readonly TimeFrame TF_Day = new TimeFrame(DatafeedHistoryPeriodicity.Day, 1);\n        private static readonly TimeFrame TF_Week = new TimeFrame(DatafeedHistoryPeriodicity.Week, 1);\n\n        protected override void OnBarsRequirements()\n        {\n            Add(TF_Day);\n            Add(TF_Week);\n        }\n\n        protected override void OnInit()\n        {\n            CalculateOnClosedBar = true;\n        }\n        protected override void OnCalculate()\n        {\n            // aktueller Wert f\u00fcr den SMA 14 auf Tagesbasis\n            Print(\"TF0: \" + SMA(Closes[0], 14)[0]);\n            // The current value for the SMA 14 in a daily timeframe\n            Print(\"TF1: \" + SMA(Closes[1], 14)[0]);\n             // aktueller Wert f\u00fcr den SMA 14 auf Wochenbasis\n            Print(\"TF2: \" + SMA(Closes[2], 14)[0]);\n        }\n    }\n}",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-hinweise",
            "text": "Bei Verwendung weiterer Zeiteinheiten wird den Arrays  Opens ,  Highs ,  Lows ,  Closes ,  Medians ,  Typicals ,  Weighteds ,  Times  und  Volumes   ein weiterer Eintrag mit den jeweiligen Datenserien der Bars der neuen Zeiteinheit hinzugef\u00fcgt. Die Indizierung erfolgt in der Reihenfolge des Hinzuf\u00fcgens der Zeiteinheiten.\nCloses[0][0] entspricht Close[0].\nCloses[1][0] entspricht dem aktuellen Schlusskurs der Tagesdatenreihe.\nCloses[2][0] entspricht dem aktuellen Schlusskurs der Wochendatenreihe.  \"Closes\"kann in den Beispielen selbstverst\u00e4ndlich auch durch Opens, Highs, Lows usw. ersetzt werden.  Siehe auch  ProcessingBarIndexes ,  ProcessingBarSeriesIndex ,  TimeFrames ,  TimeFrameRequirements .  Es gibt noch eine weitere Schreibweise f\u00fcr Multbars:  // unter Variablendeklaration wird die Variable TF_Day definiert\nprivate static readonly TimeFrame TF_Day = new TimeFrame(DatafeedHistoryPeriodicity.Day, 1);\nprivate static readonly TimeFrame TF_Week = new TimeFrame(DatafeedHistoryPeriodicity.Week, 1);\n// Die folgende Anweisung ist identisch mit double d = Closes[1][0];\ndouble d = MultiBars.GetBarsItem(TF_Day).Close[0];\n//  Die folgende Anweisung ist identisch mit double w = Closes[2][0];\ndouble w = MultiBars.GetBarsItem(TF_Week).Close[0];",
            "title": "Weitere Hinweise"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#processingbarindexes",
            "text": "",
            "title": "ProcessingBarIndexes"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beschreibung_70",
            "text": "CurrentBars ist ein Array von int-Werten, welches f\u00fcr jedes Bar-Objekt die Nummer von  ProcessingBarIndex  enth\u00e4lt.  Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.  Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird.  Mit  [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))]  enth\u00e4lt das Array 3 Eintr\u00e4ge:  ProcessingBarIndexes[0] ProcessingBarIndexes der prim\u00e4ren Datenserie (Chart-Zeiteinheit)\nProcessingBarIndexes[1] ProcessingBarIndexes f\u00fcr die Tagesbars\nProcessingBarIndexes[2] ProcessingBarIndexes f\u00fcr die Wochenbars.  ProcessingBarIndexes[0] entspricht  ProcessingBarIndex .  Siehe auch  MultiBars .",
            "title": "Beschreibung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_57",
            "text": "barSeriesIndex  Indexwert der unterschiedlichen Zeiteinheiten",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_66",
            "text": "ProcessingBarIndexes[int barSeriesIndex]",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_64",
            "text": "//Sicherstellen, dass mind. 20 Bars geladen sind\nfor (int i=0; i<ProcessingBarIndexes.Count; i++)\nif (ProcessingBarIndexes[i] < 20) return;",
            "title": "Beispiel"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#processingbarseriesindex",
            "text": "",
            "title": "ProcessingBarSeriesIndex"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#description_1",
            "text": "In einem Multibar-Script, d.h. in einem Indikator (bzw. einer Strategie), der mit mehreren Zeiteinheiten arbeitet, sind mehrere Bars-Objekte vorhanden. Die Methode OnCalculate() wird f\u00fcr jeden Bar im Script aufgerufen. Um Ereignisse bestimmter Datenreihen in die Berechnung einzubeziehen bzw. auszublenden ist BarsInProgress zu verwenden.  ProcessingBarSeriesIndex ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten.\nMit  [TimeFrameRequirements(\"1 Day\", \"1 Week\")]  werden 2 weitere Zeiteinheiten zur prim\u00e4ren Chart-Zeiteinheit hinzugef\u00fcgt.  Wenn OnCalculate() von der prim\u00e4ren Datenreihe aufgerufen wird, ist ProcessingBarSeriesIndex=0. Wird OnCalculate() von den Tagesbars aufgerufen, ist ProcessingBarSeriesIndex=1, bei den Wochendaten hat BarsInProgress den Wert 2.  Siehe auch  Multibars  and  ProcessingBarIndexes .",
            "title": "Description"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#parameter_58",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#verwendung_67",
            "text": "ProcessingBarSeriesIndex",
            "title": "Verwendung"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#weitere-informationen_56",
            "text": "In einem Script, welches nur auf der prim\u00e4ren Zeiteinheit arbeitet, hat BarsInProgress immer den Wert 0.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/umgang_mit_bars_und_instrumenten/#beispiel_65",
            "text": "// Arbeitsweise veranschaulichen\n// ggf. CalculateOnBarClose=false setzen\nPrint(Time[0] + \" \" + ProcessingBarSeriesIndex);\n// Berechnungen nur f\u00fcr die Chart-Zeiteinheit\nprotected override void OnCalculate()\n{\nif (ProcessingBarSeriesIndex > 0) return;\n// Logik f\u00fcr prim\u00e4re Datenreihe\n}",
            "title": "Beispiel"
        },
        {
            "location": "/ereignisse/",
            "text": "Ereignisse\n\n\nAgenaTrader ist nach der Definition der Softwaretechnik eine ereignisorientierte Applikation.\n\n\nDie Programmierung in AgenaTrader mit Methoden des Application Programming Interface (\nAPI\n) beruht initial auf dem \n\u00dcberschreiben\n von vordefinierten Routinen zur Ereignisbehandlung.\n\n\nFolgende Methoden k\u00f6nnen verwendet, d.h. \u00fcberschrieben werden:\n\n\n\n\nOnBrokerConnect()\n\n\nOnBrokerDisconnect()\n\n\nOnCalculate()\n\n\nOnChartPanelMouseDown()\n\n\nOnChartPanelMouseMove()\n\n\nOnDispose()\n\n\nOnLevel1()\n\n\nOnLevel2()\n\n\nOnOrderChanged()\n\n\nOnOrderExecution()\n\n\nOnStart()\n\n\nOnStop()\n\n\n\n\nOnBrokerConnect()\n\n\nBeschreibung\n\n\nDie Methode OnBrokerConnect() wird jedesmal dann aufgerufen, wenn die Verbindung zum Broker hergestellt wurde.\n\n\nMit Hilfe von OnBrokerConnect() besteht die M\u00f6glichkeit, bei einem Verbindungsabbruch mit dem Broker, die bestehenden bzw. noch offenen Orders wieder der Strategie zuzuordnen und somit von dieser wieder verwalten zu lassen\n\n\nSiehe auch weitere Methoden zur Ereignisbehandlung unter \nEreignisse\n.\n\n\nParameter\n\n\nkeine\n\n\nVerwendung\n\n\nprotected override void OnBrokerConnect()\n\n\n\n\nBeispiel\n\n\nprivate IOrder _takeProfit = null;\nprivate IOrder _trailingStop = null;\n\n\nprotected override void OnBrokerConnect()\n{\n   if (Trade != null && Trade.PositionType != PositionType.Flat)\n   {\n       _takeProfit = Orders.FirstOrDefault(o => o.Name == this.GetType().Name && o.OrderType ==OrderType.Limit);\n       _trailingStop = Orders.FirstOrDefault(o => o.Name == this.GetType().Name && o.OrderType ==OrderType.Stop);\n   }\n}\n\n\n\n\n\nOnBrokerDisconnect()\n\n\nBeschreibung\n\n\nDie Methode OnBrokerDisconnect() wird jedesmal dann aufgerufen, wenn die Verbindung zum Broker unterbrochen wurde.\n\n\nSiehe auch weitere Methoden zur Ereignisbehandlung unter \nEreignisse\n.\n\n\nParameter\n\n\nEin Objekt vom Typ  \nTradingDatafeedChangedEventArgs\n\n\nVerwendung\n\n\nprotected override void OnBrokerDisconnect(TradingDatafeedChangedEventArgs e)\n\n\n\n\nBeispiel\n\n\nprotected override void OnBrokerDisconnect(TradingDatafeedChangedEventArgs e)\n{\n   if (e.Connected)\n       Print(\"Die Verbindung zum Broker wird getrennt.\");\n   else\n       Print(\"Die Verbindung zum Broker wurde getrennt.\");\n}\n\n\n\n\nOnCalculate()\n\n\nBeschreibung\n\n\nDie Methode OnCalculate() wird immer dann aufgerufen, wenn sich ein Bar \u00e4ndert. Abh\u00e4ngig von der Variablen  \nCalculateOnClosedBar\n,wird sie entweder bei jedem hereinkommenden Tick oder erst nach Fertigstellung eines Bars aufgerufen.\nOnCalculate ist die wichtigste Methode, die im Normalfall auch den gr\u00f6\u00dften Teil des Codes selbsterstellter Indikatoren bzw. Strategien enth\u00e4lt.\nDie Bearbeitung beginnt mit dem \u00e4ltesten Bar und l\u00e4uft bis zum j\u00fcngsten Bar im Chart. Der \u00e4lteste Bar erh\u00e4lt dabei die Nummer 0. Es wird fortlaufend weiter nummeriert. Auf diese Nummerierung kann \u00fcber die Variable ProcessingBarIndex zugegriffen werden, siehe Beispiel unten.\n\n\nAchtung:\n\n\nDiese Nummerierung unterscheidet sich vom BarIndex, siehe \nBars\n.\n\n\nMore information can be found here: \nEreignisse\n.\n\n\nParameter\n\n\nkeiner\n\n\nVerwendung\n\n\nprotected override void OnCalculate()\n\n\n\n\nBeispiel\n\n\nprotected override void OnCalculate()\n{\n    Print(\"Aufruf von OnBarUpdate f\u00fcr Bar Nr. \" + ProcessingBarIndex + \" von \" +Time[0]);\n}\n\n\n\n\nOnChartPanelMouseDown()\n\n\nBeschreibung\n\n\nIn einem Indikator, oder einer Strategie, kann die aktuelle Position der Maus ausgewertet und verarbeitet werden. Daf\u00fcr ist es notwendig, dass man einen EventHandler als Methode programmiert und diese Methode anschlie\u00dfend dem Event ChartControl.ChartPanelMouseDown hinzuf\u00fcgt.\n\n\nAchtung!\n\n\nEs ist wichtig, den EventHandler innerhalb der OnDispose() Methode wieder aus dem Event zu entfernen, da sonst der EventHandler selbst dann noch ausgef\u00fchrt wird, wenn der Indikator aus dem Chart entfernt wurde!\n\n\nBeispiel\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Linq;\nusing System.Xml;\nusing System.Xml.Serialization;\nusing AgenaTrader.API;\nusing AgenaTrader.Custom;\nusing AgenaTrader.Plugins;\nusing AgenaTrader.Helper;\n\n\nnamespace AgenaTrader.UserCode\n{\n       public class ChartPanelMouseDown : UserIndicator\n       {\n               protected override void OnInit()\n               {\n                       IsOverlay = true;\n               }\n\n               protected override void OnStart()\n               {\n                       // Add event listener\n                       if (Chart != null)\n                               Chart.ChartPanelMouseDown += OnChartPanelMouseDown;\n               }\n\n\n               protected override void OnDispose()\n               {\n                       // Remove event listener\n                       if (Chart != null)\n                               Chart.ChartPanelMouseDown -= OnChartPanelMouseDown;\n               }\n\n\n               private void OnChartPanelMouseDown(object sender,System.Windows.Forms.MouseEventArgs e)\n               {\n                       Print(\"X = {0}, Y = {1}\", Chart.GetDateTimeByX(e.X),Chart.GetPriceByY(e.Y));\n               }\n       }\n}\n\n\n\n\nOnChartPanelMouseMove()\n\n\nBeschreibung\n\n\nIn einem Indikator, oder einer Strategie, kann die aktuelle Position der Maus ausgewertet und verarbeitet werden. Daf\u00fcr ist es notwendig, dass man einen EventHandler als Methode programmiert und diese Methode anschlie\u00dfend dem Event  Chart.ChartPanelMouseMove hinzuf\u00fcgt.\n\n\nAchtung!\n\n\nEs ist wichtig, den EventHandler innerhalb der OnDispose() Methode wieder aus dem Event zu entfernen, da sonst der EventHandler selbst dann noch ausgef\u00fchrt wird, wenn der Indikator aus dem Chart entfernt wurde!\n\n\nBeispiel\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Linq;\nusing System.Xml;\nusing System.Xml.Serialization;\nusing AgenaTrader.API;\nusing AgenaTrader.Custom;\nusing AgenaTrader.Plugins;\nusing AgenaTrader.Helper;\n\n\nnamespace AgenaTrader.UserCode\n{\n    public class ChartPanelMouseMove : UserIndicator\n    {\n        protected override void OnInit()\n        {\n            IsOverlay = true;\n        }\n\n        protected override void OnStart()\n        {\n            // Add event listener\n            if (Chart != null)\n                Chart.ChartPanelMouseMove += OnChartPanelMouseMove;\n        }\n\n        protected override void OnDispose()\n        {\n            // Remove event listener\n            if (Chart != null)\n                Chart.ChartPanelMouseMove -= OnChartPanelMouseMove;\n        }\n\n        private void OnChartPanelMouseMove(object sender, System.Windows.Forms.MouseEventArgs e)\n        {\n            Print(\"X = {0}, Y = {1}\", Chart.GetDateTimeByX(e.X), Chart.GetPriceByY(e.Y));\n        }\n    }\n}\n\n\n\n\nOnDispose()\n\n\nBeschreibung\n\n\nDie Methode  OnDispose() kann \u00fcberschrieben werden, um alle im Script verwendeten Ressourcen wieder freizugeben.\n\n\nSiehe auch \nOnInit()\n und \nOnStart()\n.\n\n\nSiehe auch weitere Methoden zur Ereignisbehandlung unter \nEreignisse\n.\n\n\nParameter\n\n\nkeiner\n\n\nVerwendung\n\n\nprotected override void OnDispose()\n\n\n\n\nWeitere Informationen\n\n\nAchtung:\n\n\nBitte \u00fcberschreiben Sie nicht die Dispose() Methode, da diese erst sehr viel sp\u00e4ter aufgerufen werden kann. Ressourcen bleiben zu lange erhalten und k\u00f6nnen zu unerwartetem und unvorhersehbarem Verhalten der gesamten Anwendung f\u00fchren.\n\n\nBeispiel\n\n\nprotected override void OnDispose()\n{\n    if (Window != null)\n    {\n        Window.Dispose();\n        Window = null;\n    }\n}\n\n\n\n\nOnLevel1()\n\n\nBeschreibung\n\n\nDie Methode OnLevel1() wird bei jeder \u00c4nderung in den Level-I-Daten aufgerufen, d.h. bei einer \u00c4nderung des Bid-Preises, Ask-Preises, des Bid-Volumens, des Ask-Volumens und nat\u00fcrlich des Last-Preises nachdem ein realer Umsatz stattfand.\nIn a multibar indicator, the ProcessingBarSeriesIndex die jeweilige Datenreihe ermittelt werden, f\u00fcr die OnLevel1() aufgerufen wurde.\n\n\nOnLevel1() wird nicht f\u00fcr historische Daten aufgerufen\nSiehe auch weitere Methoden zur Ereignisbehandlung unter \nEreignisse\n.\n\n\nHinweis zu Daten von Yahoo (YFeed)\n\n\nDas Feld \"LastPrice\" entspricht - wie gewohnt - je nach letztem Handelsumsatz entweder dem \"BidPrice\" oder dem \"AskPrice\".\n\n\nDas Feld \"MarketDataType\" ist immer \"Last\".\n\n\nDie Felder \"Volumen\", \"BidSize\" und \"AskSize\" sind immer 0.\n\n\nVerwendung\n\n\nprotected override void OnLevel1(Level1Args e)\n\n\n\n\nParameter\n\n\n[*Level1Args*] e\n\n\n\n\nBeispiel\n\n\nprotected override void OnLevel1(Level1Args e)\n{\n    Print(\"AskPrice \"+e.AskPrice);\n    Print(\"AskSize \"+e.AskSize);\n    Print(\"BidPrice \"+e.BidPrice);\n    Print(\"BidSize \"+e.BidSize);\n    Print(\"Instrument \"+e.Instrument);\n    Print(\"LastPrice \"+e.LastPrice);\n    Print(\"MarketDataType \"+e.MarketDataType);\n    Print(\"Price \"+e.Price);\n    Print(\"Time \"+e.Time);\n    Print(\"Volume \"+e.Volume);\n}\n\n\n\n\nOnLevel2()\n\n\nBeschreibung\n\n\nDie Methode OnLevel2() wird bei jeder \u00c4nderung in den Level-II-Daten (Markttiefe) aufgerufen.\nIn einem Multibar-Indikator kann mit  ProcessingBarSeriesIndex die jeweilige Datenreihe ermittelt werden, f\u00fcr die OnMarketDepth() aufgerufen wurde.\nOnLevel2 wird nicht f\u00fcr historische Daten aufgerufen.\n\n\nSiehe auch weitere Methoden zur Ereignisbehandlung unter \nEreignisse\n.\n\n\nVerwendung\n\n\nprotected override void OnLevel2(Level2Args e)\n\n\n\n\nParameter\n\n\nEin Objekt von \nLevel2Args\n\n\nBeispiel\n\n\nprotected override void OnLevel2(Level2Args e)\n{\n    // Ausgabe des jeweils aktuellen Ask-Kurses\n    if (e.MarketDataType == MarketDataType.Bit)\n        Print(\"The current bit is \" + e.Price );\n}\n\n\n\n\nOnOrderChanged()\n\n\nBeschreibung\n\n\nDie Methode OnOrderChanged()  wird jedesmal dann aufgerufen, wenn sich der Status einer durch eine Strategie verwaltete Order \u00e4ndert. Ene Status\u00e4nderung kann dabei durch die \u00c4nderung des Volumens, des Preises oder des Status an der B\u00f6rse (von working zu filled) ausgel\u00f6st werden. Es ist sichergestellt, dass diese Methode f\u00fcr alle Ereignisse in der korrekten Reihenfolge aufgerufen wird.\n\n\nWichtiger Hinweis:\n\n\nWenn eine Strategie durch Orderausf\u00fchrungen gesteuert werden soll, ist es ratsamer,  OnOrderExecution() anstelle von OnOrderChanged() zu verwenden.  Es kann sonst zu Problemen bei Teilausf\u00fchrungen kommen..\n\n\nSiehe auch weitere Methoden zur Ereignisbehandlung unter \nEreignisse\n.\n\n\nParameter\n\n\nEin Order-Objekt vom Type IOrder\n\n\nVerwendung\n\n\nprotected override void OnOrderChanged(IOrder order)\n\n\n\n\nBeispiel\n\n\nprivate IOrder entry = null;\nprotected override void OnCalculate()\n{\n    if (CrossAbove(EMA(14), SMA(50), 1) && IsSerieRising(ADX(20)))\n        entry = OpenLong(\"EMACrossesSMA\");\n\n    if (entry != null && entry == order)\n    {\n        if (order.OrderState == OrderState.Filled)\n        {\n        PlaySound(\"OrderFilled.wav\");\n        entryOrder = null;\n        }\n    }\n}\nprotected override void OnOrderChanged(IOrder order)\n{\n\n}\n\n\n\n\nOnOrderExecution()\n\n\nBeschreibung\n\n\nDie Methode OnOrderExecution() wird jedesmal dann aufgerufen, wenn eine Order ausgef\u00fchrt (filled) wurde oder sich der Status einer durch eine Strategie verwaltete Order \u00e4ndert. Ene Status\u00e4nderung kann dabei durch die \u00c4nderung des Volumens, des Preises oder des Status an der B\u00f6rse (von working zu filled) ausgel\u00f6st werden. Es ist sichergestellt, dass diese Methode f\u00fcr alle Ereignisse in der korrekten Reihenfolge aufgerufen wird.\n\n\nOnOrderExecution() wird immer nach \nOnOrderChanged()\n aufgerufen.\n\n\nSiehe auch weitere Methoden zur Ereignisbehandlung unter \nEreignisse\n.\n\n\nParameter\n\n\nEin execution-Objekt vom Type  \nIExecution\n\n\nVerwendung\n\n\nprotected override void OnOrderExecution(IExecution execution)\n\n\n\n\nBeispiel\n\n\nprivate IOrder entry = null;\nprotected override void OnCalculate()\n{\n    if (CrossAbove(EMA(14), SMA(50), 1) && IsSerieRising(ADX(20)))\n            entry = OpenLong(\"EMACrossesSMA\");\n}\nprotected override void OnOrderExecution(IExecution execution)\n{\n    // Beispiel\n    if (entry != null && execution.Order == entry)\n    {\n        Print(execution.Price.ToString());\n    Print(execution.Order.OrderState.ToString());\n    }\n}\n\n\n\n\nOnStart()\n\n\nBeschreibung\n\n\nDie Methode OnStart() kann \u00fcberschrieben werden, um eigene Variablen zu initialisieren, Lizenzchecks auszuf\u00fchren, UserForms aufzurufen usw.\nOnStart() wird nur einmal am Beginn des Scrips nach \nOnInit()\n und vor \nOnCalculate()\n aufgerufen.\n\n\nSiehe auch \nOnDispose()\n.\n\n\nSiehe auch weitere Methoden zur Ereignisbehandlung unter \nEreignisse\n.\n\n\nParameter\n\n\nkeiner\n\n\nVerwendung\n\n\nprotected override void OnStart()\n\n\n\n\nBeispiel\n\n\nprivate myForm Window;\nprotected override void OnStart()\n{\n    if (Chart != null)\n    {\n    Window = new myForm();\n    Window.Show();\n    }\n}\n\n\n\n\nOnStop()\n\n\nBeschreibung\n\n\nDie OnStop()-Methode wird aufgerufen, sobald ein Script beendet wird. Dies kann z.B. vorkommen, wenn ein Indikator vom Chart entfernt wurde oder eine Spalte mit einem Indikator / einer gescripteten Condition vom Scanner entfernt wurde. \n\n\nSiehe auch \nOnDispose()\n.\n\n\nSiehe auch weitere Methoden zur Ereignisbehandlung unter \nEreignisse\n.\n\n\nParameter\n\n\nkeiner\n\n\nVerwendung\n\n\nprotected override void OnStop()\n\n\n\n\nBeispiel\n\n\nprotected override void OnStop()\n{\n    Log(\"Stop: \" + this.ToString() + \" | \" + Instrument.Symbol, InfoLogLevel.Info); \n}",
            "title": "Ereignisse"
        },
        {
            "location": "/ereignisse/#ereignisse",
            "text": "AgenaTrader ist nach der Definition der Softwaretechnik eine ereignisorientierte Applikation.  Die Programmierung in AgenaTrader mit Methoden des Application Programming Interface ( API ) beruht initial auf dem  \u00dcberschreiben  von vordefinierten Routinen zur Ereignisbehandlung.  Folgende Methoden k\u00f6nnen verwendet, d.h. \u00fcberschrieben werden:   OnBrokerConnect()  OnBrokerDisconnect()  OnCalculate()  OnChartPanelMouseDown()  OnChartPanelMouseMove()  OnDispose()  OnLevel1()  OnLevel2()  OnOrderChanged()  OnOrderExecution()  OnStart()  OnStop()",
            "title": "Ereignisse"
        },
        {
            "location": "/ereignisse/#onbrokerconnect",
            "text": "",
            "title": "OnBrokerConnect()"
        },
        {
            "location": "/ereignisse/#beschreibung",
            "text": "Die Methode OnBrokerConnect() wird jedesmal dann aufgerufen, wenn die Verbindung zum Broker hergestellt wurde.  Mit Hilfe von OnBrokerConnect() besteht die M\u00f6glichkeit, bei einem Verbindungsabbruch mit dem Broker, die bestehenden bzw. noch offenen Orders wieder der Strategie zuzuordnen und somit von dieser wieder verwalten zu lassen  Siehe auch weitere Methoden zur Ereignisbehandlung unter  Ereignisse .",
            "title": "Beschreibung"
        },
        {
            "location": "/ereignisse/#parameter",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/ereignisse/#verwendung",
            "text": "protected override void OnBrokerConnect()",
            "title": "Verwendung"
        },
        {
            "location": "/ereignisse/#beispiel",
            "text": "private IOrder _takeProfit = null;\nprivate IOrder _trailingStop = null;\n\n\nprotected override void OnBrokerConnect()\n{\n   if (Trade != null && Trade.PositionType != PositionType.Flat)\n   {\n       _takeProfit = Orders.FirstOrDefault(o => o.Name == this.GetType().Name && o.OrderType ==OrderType.Limit);\n       _trailingStop = Orders.FirstOrDefault(o => o.Name == this.GetType().Name && o.OrderType ==OrderType.Stop);\n   }\n}",
            "title": "Beispiel"
        },
        {
            "location": "/ereignisse/#onbrokerdisconnect",
            "text": "",
            "title": "OnBrokerDisconnect()"
        },
        {
            "location": "/ereignisse/#beschreibung_1",
            "text": "Die Methode OnBrokerDisconnect() wird jedesmal dann aufgerufen, wenn die Verbindung zum Broker unterbrochen wurde.  Siehe auch weitere Methoden zur Ereignisbehandlung unter  Ereignisse .",
            "title": "Beschreibung"
        },
        {
            "location": "/ereignisse/#parameter_1",
            "text": "Ein Objekt vom Typ   TradingDatafeedChangedEventArgs",
            "title": "Parameter"
        },
        {
            "location": "/ereignisse/#verwendung_1",
            "text": "protected override void OnBrokerDisconnect(TradingDatafeedChangedEventArgs e)",
            "title": "Verwendung"
        },
        {
            "location": "/ereignisse/#beispiel_1",
            "text": "protected override void OnBrokerDisconnect(TradingDatafeedChangedEventArgs e)\n{\n   if (e.Connected)\n       Print(\"Die Verbindung zum Broker wird getrennt.\");\n   else\n       Print(\"Die Verbindung zum Broker wurde getrennt.\");\n}",
            "title": "Beispiel"
        },
        {
            "location": "/ereignisse/#oncalculate",
            "text": "",
            "title": "OnCalculate()"
        },
        {
            "location": "/ereignisse/#beschreibung_2",
            "text": "Die Methode OnCalculate() wird immer dann aufgerufen, wenn sich ein Bar \u00e4ndert. Abh\u00e4ngig von der Variablen   CalculateOnClosedBar ,wird sie entweder bei jedem hereinkommenden Tick oder erst nach Fertigstellung eines Bars aufgerufen.\nOnCalculate ist die wichtigste Methode, die im Normalfall auch den gr\u00f6\u00dften Teil des Codes selbsterstellter Indikatoren bzw. Strategien enth\u00e4lt.\nDie Bearbeitung beginnt mit dem \u00e4ltesten Bar und l\u00e4uft bis zum j\u00fcngsten Bar im Chart. Der \u00e4lteste Bar erh\u00e4lt dabei die Nummer 0. Es wird fortlaufend weiter nummeriert. Auf diese Nummerierung kann \u00fcber die Variable ProcessingBarIndex zugegriffen werden, siehe Beispiel unten.  Achtung:  Diese Nummerierung unterscheidet sich vom BarIndex, siehe  Bars .  More information can be found here:  Ereignisse .",
            "title": "Beschreibung"
        },
        {
            "location": "/ereignisse/#parameter_2",
            "text": "keiner",
            "title": "Parameter"
        },
        {
            "location": "/ereignisse/#verwendung_2",
            "text": "protected override void OnCalculate()",
            "title": "Verwendung"
        },
        {
            "location": "/ereignisse/#beispiel_2",
            "text": "protected override void OnCalculate()\n{\n    Print(\"Aufruf von OnBarUpdate f\u00fcr Bar Nr. \" + ProcessingBarIndex + \" von \" +Time[0]);\n}",
            "title": "Beispiel"
        },
        {
            "location": "/ereignisse/#onchartpanelmousedown",
            "text": "",
            "title": "OnChartPanelMouseDown()"
        },
        {
            "location": "/ereignisse/#beschreibung_3",
            "text": "In einem Indikator, oder einer Strategie, kann die aktuelle Position der Maus ausgewertet und verarbeitet werden. Daf\u00fcr ist es notwendig, dass man einen EventHandler als Methode programmiert und diese Methode anschlie\u00dfend dem Event ChartControl.ChartPanelMouseDown hinzuf\u00fcgt.",
            "title": "Beschreibung"
        },
        {
            "location": "/ereignisse/#achtung",
            "text": "Es ist wichtig, den EventHandler innerhalb der OnDispose() Methode wieder aus dem Event zu entfernen, da sonst der EventHandler selbst dann noch ausgef\u00fchrt wird, wenn der Indikator aus dem Chart entfernt wurde!",
            "title": "Achtung!"
        },
        {
            "location": "/ereignisse/#beispiel_3",
            "text": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Linq;\nusing System.Xml;\nusing System.Xml.Serialization;\nusing AgenaTrader.API;\nusing AgenaTrader.Custom;\nusing AgenaTrader.Plugins;\nusing AgenaTrader.Helper;\n\n\nnamespace AgenaTrader.UserCode\n{\n       public class ChartPanelMouseDown : UserIndicator\n       {\n               protected override void OnInit()\n               {\n                       IsOverlay = true;\n               }\n\n               protected override void OnStart()\n               {\n                       // Add event listener\n                       if (Chart != null)\n                               Chart.ChartPanelMouseDown += OnChartPanelMouseDown;\n               }\n\n\n               protected override void OnDispose()\n               {\n                       // Remove event listener\n                       if (Chart != null)\n                               Chart.ChartPanelMouseDown -= OnChartPanelMouseDown;\n               }\n\n\n               private void OnChartPanelMouseDown(object sender,System.Windows.Forms.MouseEventArgs e)\n               {\n                       Print(\"X = {0}, Y = {1}\", Chart.GetDateTimeByX(e.X),Chart.GetPriceByY(e.Y));\n               }\n       }\n}",
            "title": "Beispiel"
        },
        {
            "location": "/ereignisse/#onchartpanelmousemove",
            "text": "",
            "title": "OnChartPanelMouseMove()"
        },
        {
            "location": "/ereignisse/#beschreibung_4",
            "text": "In einem Indikator, oder einer Strategie, kann die aktuelle Position der Maus ausgewertet und verarbeitet werden. Daf\u00fcr ist es notwendig, dass man einen EventHandler als Methode programmiert und diese Methode anschlie\u00dfend dem Event  Chart.ChartPanelMouseMove hinzuf\u00fcgt.",
            "title": "Beschreibung"
        },
        {
            "location": "/ereignisse/#achtung_1",
            "text": "Es ist wichtig, den EventHandler innerhalb der OnDispose() Methode wieder aus dem Event zu entfernen, da sonst der EventHandler selbst dann noch ausgef\u00fchrt wird, wenn der Indikator aus dem Chart entfernt wurde!",
            "title": "Achtung!"
        },
        {
            "location": "/ereignisse/#beispiel_4",
            "text": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Linq;\nusing System.Xml;\nusing System.Xml.Serialization;\nusing AgenaTrader.API;\nusing AgenaTrader.Custom;\nusing AgenaTrader.Plugins;\nusing AgenaTrader.Helper;\n\n\nnamespace AgenaTrader.UserCode\n{\n    public class ChartPanelMouseMove : UserIndicator\n    {\n        protected override void OnInit()\n        {\n            IsOverlay = true;\n        }\n\n        protected override void OnStart()\n        {\n            // Add event listener\n            if (Chart != null)\n                Chart.ChartPanelMouseMove += OnChartPanelMouseMove;\n        }\n\n        protected override void OnDispose()\n        {\n            // Remove event listener\n            if (Chart != null)\n                Chart.ChartPanelMouseMove -= OnChartPanelMouseMove;\n        }\n\n        private void OnChartPanelMouseMove(object sender, System.Windows.Forms.MouseEventArgs e)\n        {\n            Print(\"X = {0}, Y = {1}\", Chart.GetDateTimeByX(e.X), Chart.GetPriceByY(e.Y));\n        }\n    }\n}",
            "title": "Beispiel"
        },
        {
            "location": "/ereignisse/#ondispose",
            "text": "",
            "title": "OnDispose()"
        },
        {
            "location": "/ereignisse/#beschreibung_5",
            "text": "Die Methode  OnDispose() kann \u00fcberschrieben werden, um alle im Script verwendeten Ressourcen wieder freizugeben.  Siehe auch  OnInit()  und  OnStart() .  Siehe auch weitere Methoden zur Ereignisbehandlung unter  Ereignisse .",
            "title": "Beschreibung"
        },
        {
            "location": "/ereignisse/#parameter_3",
            "text": "keiner",
            "title": "Parameter"
        },
        {
            "location": "/ereignisse/#verwendung_3",
            "text": "protected override void OnDispose()",
            "title": "Verwendung"
        },
        {
            "location": "/ereignisse/#weitere-informationen",
            "text": "Achtung:  Bitte \u00fcberschreiben Sie nicht die Dispose() Methode, da diese erst sehr viel sp\u00e4ter aufgerufen werden kann. Ressourcen bleiben zu lange erhalten und k\u00f6nnen zu unerwartetem und unvorhersehbarem Verhalten der gesamten Anwendung f\u00fchren.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/ereignisse/#beispiel_5",
            "text": "protected override void OnDispose()\n{\n    if (Window != null)\n    {\n        Window.Dispose();\n        Window = null;\n    }\n}",
            "title": "Beispiel"
        },
        {
            "location": "/ereignisse/#onlevel1",
            "text": "",
            "title": "OnLevel1()"
        },
        {
            "location": "/ereignisse/#beschreibung_6",
            "text": "Die Methode OnLevel1() wird bei jeder \u00c4nderung in den Level-I-Daten aufgerufen, d.h. bei einer \u00c4nderung des Bid-Preises, Ask-Preises, des Bid-Volumens, des Ask-Volumens und nat\u00fcrlich des Last-Preises nachdem ein realer Umsatz stattfand.\nIn a multibar indicator, the ProcessingBarSeriesIndex die jeweilige Datenreihe ermittelt werden, f\u00fcr die OnLevel1() aufgerufen wurde.  OnLevel1() wird nicht f\u00fcr historische Daten aufgerufen\nSiehe auch weitere Methoden zur Ereignisbehandlung unter  Ereignisse .  Hinweis zu Daten von Yahoo (YFeed)  Das Feld \"LastPrice\" entspricht - wie gewohnt - je nach letztem Handelsumsatz entweder dem \"BidPrice\" oder dem \"AskPrice\".  Das Feld \"MarketDataType\" ist immer \"Last\".  Die Felder \"Volumen\", \"BidSize\" und \"AskSize\" sind immer 0.",
            "title": "Beschreibung"
        },
        {
            "location": "/ereignisse/#verwendung_4",
            "text": "protected override void OnLevel1(Level1Args e)",
            "title": "Verwendung"
        },
        {
            "location": "/ereignisse/#parameter_4",
            "text": "[*Level1Args*] e",
            "title": "Parameter"
        },
        {
            "location": "/ereignisse/#beispiel_6",
            "text": "protected override void OnLevel1(Level1Args e)\n{\n    Print(\"AskPrice \"+e.AskPrice);\n    Print(\"AskSize \"+e.AskSize);\n    Print(\"BidPrice \"+e.BidPrice);\n    Print(\"BidSize \"+e.BidSize);\n    Print(\"Instrument \"+e.Instrument);\n    Print(\"LastPrice \"+e.LastPrice);\n    Print(\"MarketDataType \"+e.MarketDataType);\n    Print(\"Price \"+e.Price);\n    Print(\"Time \"+e.Time);\n    Print(\"Volume \"+e.Volume);\n}",
            "title": "Beispiel"
        },
        {
            "location": "/ereignisse/#onlevel2",
            "text": "",
            "title": "OnLevel2()"
        },
        {
            "location": "/ereignisse/#beschreibung_7",
            "text": "Die Methode OnLevel2() wird bei jeder \u00c4nderung in den Level-II-Daten (Markttiefe) aufgerufen.\nIn einem Multibar-Indikator kann mit  ProcessingBarSeriesIndex die jeweilige Datenreihe ermittelt werden, f\u00fcr die OnMarketDepth() aufgerufen wurde.\nOnLevel2 wird nicht f\u00fcr historische Daten aufgerufen.  Siehe auch weitere Methoden zur Ereignisbehandlung unter  Ereignisse .",
            "title": "Beschreibung"
        },
        {
            "location": "/ereignisse/#verwendung_5",
            "text": "protected override void OnLevel2(Level2Args e)",
            "title": "Verwendung"
        },
        {
            "location": "/ereignisse/#parameter_5",
            "text": "Ein Objekt von  Level2Args",
            "title": "Parameter"
        },
        {
            "location": "/ereignisse/#beispiel_7",
            "text": "protected override void OnLevel2(Level2Args e)\n{\n    // Ausgabe des jeweils aktuellen Ask-Kurses\n    if (e.MarketDataType == MarketDataType.Bit)\n        Print(\"The current bit is \" + e.Price );\n}",
            "title": "Beispiel"
        },
        {
            "location": "/ereignisse/#onorderchanged",
            "text": "",
            "title": "OnOrderChanged()"
        },
        {
            "location": "/ereignisse/#beschreibung_8",
            "text": "Die Methode OnOrderChanged()  wird jedesmal dann aufgerufen, wenn sich der Status einer durch eine Strategie verwaltete Order \u00e4ndert. Ene Status\u00e4nderung kann dabei durch die \u00c4nderung des Volumens, des Preises oder des Status an der B\u00f6rse (von working zu filled) ausgel\u00f6st werden. Es ist sichergestellt, dass diese Methode f\u00fcr alle Ereignisse in der korrekten Reihenfolge aufgerufen wird.  Wichtiger Hinweis:  Wenn eine Strategie durch Orderausf\u00fchrungen gesteuert werden soll, ist es ratsamer,  OnOrderExecution() anstelle von OnOrderChanged() zu verwenden.  Es kann sonst zu Problemen bei Teilausf\u00fchrungen kommen..  Siehe auch weitere Methoden zur Ereignisbehandlung unter  Ereignisse .",
            "title": "Beschreibung"
        },
        {
            "location": "/ereignisse/#parameter_6",
            "text": "Ein Order-Objekt vom Type IOrder",
            "title": "Parameter"
        },
        {
            "location": "/ereignisse/#verwendung_6",
            "text": "protected override void OnOrderChanged(IOrder order)",
            "title": "Verwendung"
        },
        {
            "location": "/ereignisse/#beispiel_8",
            "text": "private IOrder entry = null;\nprotected override void OnCalculate()\n{\n    if (CrossAbove(EMA(14), SMA(50), 1) && IsSerieRising(ADX(20)))\n        entry = OpenLong(\"EMACrossesSMA\");\n\n    if (entry != null && entry == order)\n    {\n        if (order.OrderState == OrderState.Filled)\n        {\n        PlaySound(\"OrderFilled.wav\");\n        entryOrder = null;\n        }\n    }\n}\nprotected override void OnOrderChanged(IOrder order)\n{\n\n}",
            "title": "Beispiel"
        },
        {
            "location": "/ereignisse/#onorderexecution",
            "text": "",
            "title": "OnOrderExecution()"
        },
        {
            "location": "/ereignisse/#beschreibung_9",
            "text": "Die Methode OnOrderExecution() wird jedesmal dann aufgerufen, wenn eine Order ausgef\u00fchrt (filled) wurde oder sich der Status einer durch eine Strategie verwaltete Order \u00e4ndert. Ene Status\u00e4nderung kann dabei durch die \u00c4nderung des Volumens, des Preises oder des Status an der B\u00f6rse (von working zu filled) ausgel\u00f6st werden. Es ist sichergestellt, dass diese Methode f\u00fcr alle Ereignisse in der korrekten Reihenfolge aufgerufen wird.  OnOrderExecution() wird immer nach  OnOrderChanged()  aufgerufen.  Siehe auch weitere Methoden zur Ereignisbehandlung unter  Ereignisse .",
            "title": "Beschreibung"
        },
        {
            "location": "/ereignisse/#parameter_7",
            "text": "Ein execution-Objekt vom Type   IExecution",
            "title": "Parameter"
        },
        {
            "location": "/ereignisse/#verwendung_7",
            "text": "protected override void OnOrderExecution(IExecution execution)",
            "title": "Verwendung"
        },
        {
            "location": "/ereignisse/#beispiel_9",
            "text": "private IOrder entry = null;\nprotected override void OnCalculate()\n{\n    if (CrossAbove(EMA(14), SMA(50), 1) && IsSerieRising(ADX(20)))\n            entry = OpenLong(\"EMACrossesSMA\");\n}\nprotected override void OnOrderExecution(IExecution execution)\n{\n    // Beispiel\n    if (entry != null && execution.Order == entry)\n    {\n        Print(execution.Price.ToString());\n    Print(execution.Order.OrderState.ToString());\n    }\n}",
            "title": "Beispiel"
        },
        {
            "location": "/ereignisse/#onstart",
            "text": "",
            "title": "OnStart()"
        },
        {
            "location": "/ereignisse/#beschreibung_10",
            "text": "Die Methode OnStart() kann \u00fcberschrieben werden, um eigene Variablen zu initialisieren, Lizenzchecks auszuf\u00fchren, UserForms aufzurufen usw.\nOnStart() wird nur einmal am Beginn des Scrips nach  OnInit()  und vor  OnCalculate()  aufgerufen.  Siehe auch  OnDispose() .  Siehe auch weitere Methoden zur Ereignisbehandlung unter  Ereignisse .",
            "title": "Beschreibung"
        },
        {
            "location": "/ereignisse/#parameter_8",
            "text": "keiner",
            "title": "Parameter"
        },
        {
            "location": "/ereignisse/#verwendung_8",
            "text": "protected override void OnStart()",
            "title": "Verwendung"
        },
        {
            "location": "/ereignisse/#beispiel_10",
            "text": "private myForm Window;\nprotected override void OnStart()\n{\n    if (Chart != null)\n    {\n    Window = new myForm();\n    Window.Show();\n    }\n}",
            "title": "Beispiel"
        },
        {
            "location": "/ereignisse/#onstop",
            "text": "",
            "title": "OnStop()"
        },
        {
            "location": "/ereignisse/#beschreibung_11",
            "text": "Die OnStop()-Methode wird aufgerufen, sobald ein Script beendet wird. Dies kann z.B. vorkommen, wenn ein Indikator vom Chart entfernt wurde oder eine Spalte mit einem Indikator / einer gescripteten Condition vom Scanner entfernt wurde.   Siehe auch  OnDispose() .  Siehe auch weitere Methoden zur Ereignisbehandlung unter  Ereignisse .",
            "title": "Beschreibung"
        },
        {
            "location": "/ereignisse/#parameter_9",
            "text": "keiner",
            "title": "Parameter"
        },
        {
            "location": "/ereignisse/#verwendung_9",
            "text": "protected override void OnStop()",
            "title": "Verwendung"
        },
        {
            "location": "/ereignisse/#beispiel_11",
            "text": "protected override void OnStop()\n{\n    Log(\"Stop: \" + this.ToString() + \" | \" + Instrument.Symbol, InfoLogLevel.Info); \n}",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/",
            "text": "Strategieprogrammierung\n\n\nAccount\n\n\nBeschreibung\n\n\nAccount ist ein Objekt, welches Informationen zu dem Konto enth\u00e4lt, mit dem die aktuelle Strategie arbeitet.\n\n\nDie einzelnen Eigenschaften sind:\n\n\n\n\n\n\nAccount.AccountConnection\n\n    Name der verwendeten Brokerverbindung (der Name, der unter Kontoverbindungen vergeben wurde).\n\n\n\n\n\n\nAccount.AccountType\n\n    Art des Kontos (Livokonto, Simkonto usw.)\n\n\n\n\n\n\nAccount.Broker\n\n    Bezeichnung des Brokers\n\n\n\n\n\n\nAccount.BuyingPower\n\n    Der Kontostand unter Ber\u00fccksichtigung des vom Broker gew\u00e4hrten Hebels.(IB hebelt das Kontoguthaben z.B. aktuell mit 4. Ein Guthaben von 10.000 Euro hat so eine \"Kaufkraft\" von 40.000 Euro.\n\n\n\n\n\n\nAccount.CashValue\n\n    Betrag (double)\n\n\n\n\n\n\nAccount.Currency\n\n    W\u00e4hrung, in der das Konto gef\u00fchrt wird\n\n\n\n\n\n\nAccount.ExcessEquity\n\n    \u00dcberschuss\n\n\n\n\n\n\nAccount.InitialMargin\n\n    Initial Margin (abh. vom jeweiligen Broker, double)\n\n\n\n\n\n\nAccount.InstrumentType\n\n    Art des Handelsinstrumentes (Typ AgenaTrader.Plugins.InstrumentTypes)\n\n\n\n\n\n\nAccount.IsDemo\n\n    true, wenn es sich um ein Demokonto handelt\n\n\n\n\n\n\nAccount.Name\n\n    Name des Kontos (i.d.R. mit Account. AccountConnection identisch)\n\n\n\n\n\n\nAccount.OverNightMargin\n\n    \u00dcbernacht-Margin (abh. vom jeweiligen Broker, double)\n\n\n\n\n\n\nAccount.RealizedProfitLoss\n\n    realisierter Gewinn bzw. Verlust (double)\n\n\n\n\n\n\nBeispiel\n\n\nPrint(\"AccountConnection \" + Account.AccountConnection);\nPrint(\"AccountType \" + Account.AccountType);\nPrint(\"Broker \" + Account.Broker);\nPrint(\"BuyingPower \" + Account.BuyingPower);\nPrint(\"CashValue \" + Account.CashValue);\nPrint(\"Currency \" + Account.Currency);\nPrint(\"ExcessEquity \" + Account.ExcessEquity);\nPrint(\"InitialMargin \" + Account.InitialMargin);\nPrint(\"InstrumentTypes \" + Account.InstrumentTypes);\nPrint(\"IsDemo \" + Account.IsDemo);\nPrint(\"Name \" + Account.Name);\nPrint(\"OverNightMargin \" + Account.OverNightMargin);\nPrint(\"RealizedProfitLoss \" + Account.RealizedProfitLoss);\n\n\n\n\nBarsCountFromTradeClose()\n\n\nBeschreibung\n\n\nDie Eigenschaft  \"BarsCountFromTradeClose\" liefert die Anzahl der Bars, die seit dem letzten Ausstieg (Exit) aus dem Markt vergangen sind.\n\n\nVerwendung\n\n\nBarsCountFromTradeClose()\nBarsCountFromTradeClose(string strategyName)\n\n\n\n\nF\u00fcr Multibar-Strategieen\n\n\nBarsCountFromTradeClose(int multibarSeriesIndex, string strategyName, int exitsAgo)\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstrategyName\n\n\nDer Signalname (string), der in einer Ausstiegsmethode zur eindeutigen Kennzeichnung des Ausstiegs vergeben wurde\n\n\n\n\n\n\nmultibarSeriesIndex\n\n\nF\u00fcr *\nMultibar*\nMultiBars\n Strategieen. Index der Datenreihe, f\u00fcr die die Ausstiegsorder ausgef\u00fchrt wurde. Siehe \nProcessingBarSeriesIndex\n.\n\n\n\n\n\n\nexitsAgo\n\n\nAnzahl der in der Vergangenheit liegenden Ausstiege. Eine 0 (Null) an dieser Stelle liefert die Anzahl der Bars, die sich nach dem letzten Ausstieg ausgebildet haben.\n\n\n\n\n\n\n\n\nBeispiel\n\n\nPrint(\"Der letzte Ausstieg liegt \" + BarsCountFromTradeClose() + \" Bars zur\u00fcck.\");\n\n\n\n\nBarsCountFromTradeOpen()\n\n\nBeschreibung\n\n\nDie Eigenschaft \"BarsCountFromTradeOpen\"  liefert die Anzahl der Bars, die seit dem letzten Einstieg (Entry) in den Markt vergangen sind.\n\n\nVerwendung\n\n\nBarsCountFromTradeOpen()\nBarsCountFromTradeOpen(string strategyName)\n\n\n\n\nF\u00fcr Multibar-Strategieen\n\n\nBarsCountFromTradeOpen(int multibarSeriesIndex, string strategyName, int entriesAgo)\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstrategyName\n\n\nDer Signalname (string), der in einer Einstiegsmethode zur eindeutigen Kennzeichnung des Einstiegs vergeben wurde.\n\n\n\n\n\n\nmultibarSeriesIndex\n\n\nF\u00fcr *\nMultibar*\n, \nMultiBars\n Strategieen.Index der Datenreihe, f\u00fcr die die Einstiegsorder ausgef\u00fchrt wurde. Siehe \nProcessingBarSeriesIndex\n, \nProcessingBarSeriesIndex\n.\n\n\n\n\n\n\nentriesAgo\n\n\nAnzahl der in der Vergangenheit liegenden Einstiege. Eine 0 (Null) an dieser Stelle liefert die Anzahl der Bars, die sich nach dem letzten Einstieg ausgebildet haben.\n\n\n\n\n\n\n\n\nBeispiel\n\n\nPrint(\"Der letzte Einstieg liegt \" + BarsCountFromTradeOpen() + \" Bars zur\u00fcck.\");\n\n\n\n\nCancelAllOrders()\n\n\nBeschreibung\n\n\nCancelAllOrders  l\u00f6scht alle Oders (cancel), die von der Strategie verwaltet werden.\nEs wird ein Cancel-Request an den Broker verschickt. Ob eine Oder dort wirklich gel\u00f6scht wird, kann nicht garantiert werden. Es kann vorkommen, dass eine Order eine Teilausf\u00fchrung erhalten hat, ehe sie gel\u00f6scht wird. Es ist daher ratsam, den jeweils aktuellen Status einer Order mit \nOnOrderChanged()\n zu kontrollieren.\n\n\nVerwendung\n\n\nCancelAllOrders()\n\n\n\n\nParameter\n\n\nkein Parameter\n\n\nBeispiel\n\n\nprotected override void OnCalculate()\n{\n   if (BarsCountFromTradeOpen() >= 30)\n       CancelAllOrders();\n}\n\n\n\n\nOrder.Cancel()\n\n\nBeschreibung\n\n\nCancel order l\u00f6scht eine Oder (cancel).\n\n\nEs wird ein Cancel-Request an den Broker verschickt. Ob eine Oder dort wirklich gel\u00f6scht wird, kann nicht garantiert werden. Es kann vorkommen, dass eine Order eine Teilausf\u00fchrung erhalten hat, ehe sie gel\u00f6scht wird. Es ist daher ratsam, den jeweils aktuellen Status einer Order mit \nOnOrderChanged()\n zu kontrollieren.\n\n\nVerwendung\n\n\nOrder.Cancel(IOrder order)\n\n\n\n\nParameter\n\n\nEin order-Objekt vom Typ IOrder\n\n\nBeispiel\n\n\nprivate IOrder entryOrder = null;\nprivate int barNumber = 0;\nprotected override void OnCalculate()\n{\n   // An das Hoch des aktuellen Bars einen Einstiegsstop legen\n    if (entryOrder == null)\n    {\n        entryOrder = OpenLongStop(High[0], \"stop long\");\n        barNumber = ProcessingBarIndex;\n    }\n    // Nach 3 Bars die Order l\u00f6schen\n    if (Position.PositionType == PositionType.Flat &&\n    ProcessingBarIndex > barNumber + 3)\n        Order.Cancel(entryOrder);\n}\n\n\n\n\nCreateIfDoneGroup()\n\n\nBeschreibung\n\n\nWenn zwei Orders \u00fcber eine CreateIfDoneGroup miteinander verkn\u00fcpft werden, so bedeutet dies, dass wenn die eine Order ausgef\u00fchrt wurde, die zweite verbundene Order aktiviert wird.\n\n\nVerwendung\n\n\nCreateIfDoneGroup(IEnumerable<IOrder> orders)\n\n\n\n\nParameter\n\n\nEin order-Objekt vom Typ IOrder als List\n\n\nBeispiel\n\n\nprivate IOrder oopenlong = null;\nprivate IOrder osubmitbuy = null;\n\n\nprotected override void OnInit()\n{\n   IsAutoConfirmOrder = false;\n}\n\n\nprotected override void OnCalculate()\n{\n\n oopenlong =  SubmitOrder(new StrategyOrderParameters\n                {\n                    Direction = OrderDirection.Buy,\n                    Type = OrderType.Market,\n                    Quantity = DefaultOrderQuantity,\n                    SignalName = \"strategyName\",\n                });\n\nosubmitbuy =  SubmitOrder(new StrategyOrderParameters\n                {\n                    Direction = OrderDirection.Sell,\n                    Type = OrderType.Stop,\n                    Quantity = DefaultOrderQuantity,\n            StopPrice = Close[0] * 1.1,\n                    SignalName = \"strategyName\",\n                });\n\n   CreateIfDoneGroup(new List<IOrder> { oopenlong, osubmitbuy });\n\n   oopenlong.ConfirmOrder();\n}\n\n\n\n\n\nCreateOCOGroup()\n\n\nBeschreibung\n\n\nWenn zwei Orders \u00fcber eine CreateOCOGroup miteinander verkn\u00fcpft werden, so bedeutet dies, dass sobald die eine Order ausgef\u00fchrt wurde, die zweite verbundene Order gel\u00f6scht wird.\n\n\nVerwendung\n\n\nCreateOCOGroup(IEnumerable<IOrder> orders)\n\n\n\n\nParameter\n\n\nEin order-Objekt vom Typ IOrder als List\n\n\nBeispiel\n\n\nprivate IOrder oopenlong = null;\nprivate IOrder oEnterShort = null;\n\n\nprotected override void OnInit()\n{\n   IsAutoConfirmOrder = false;\n}\n\n\nprotected override void OnCalculate()\n{\n\noopenlong =  SubmitOrder(new StrategyOrderParameters\n                {\n                    Direction = OrderDirection.Buy,\n                    Type = OrderType.Stop,\n                    Quantity = DefaultOrderQuantity,\n            StopPrice = Close[0] * 1.1,\n                    SignalName = \"strategyName\",\n                });\n\n\noEnterShort =  SubmitOrder(new StrategyOrderParameters\n                {\n                    Direction = OrderDirection.Sell,\n                    Type = OrderType.Stop,\n                    Quantity = DefaultOrderQuantity,\n            StopPrice = Close[0] * -1.1,\n                    SignalName = \"strategyName\",\n                });\n\n\n\n   CreateOCOGroup(new List<IOrder> { oopenlong, oEnterShort });\n\n   oopenlong.ConfirmOrder();\n   oEnterShort.ConfirmOrder();\n}\n\n\n\n\nCreateOROGroup()\n\n\nBeschreibung\n\n\nWenn zwei Orders \u00fcber eine CreateOROGroup miteinander verkn\u00fcpft werden, so bedeutet dies, dass sobald die eine Order ausgef\u00fchrt wurde, die Ordergr\u00f6\u00dfe der zweiten Order um das Ordervolumen der ersten Order reduziert wird.\n\n\nVerwendung\n\n\nCreateOROGroup(IEnumerable<IOrder> orders)\n\n\n\n\nParameter\n\n\nEin order-Objekt vom Typ IOrder\n\n\nBeispiel\n\n\nprivate IOrder oStopLong = null;\nprivate IOrder oLimitLong = null;\n\n\nprotected override void OnInit()\n{\n   IsAutoConfirmOrder = false;\n}\n\n\nprotected override void OnCalculate()\n{\n\n   oStopLong =  SubmitOrder(new StrategyOrderParameters\n                {\n                    Direction = OrderDirection.Buy,\n                    Type = OrderType.Stop,\n                    Quantity = DefaultOrderQuantity,\n            StopPrice = Close[0] * -1.1,\n                    SignalName = \"strategyName\",\n                });\n\n\n\n\n   oLimitLong =  SubmitOrder(new StrategyOrderParameters\n                {\n                    Direction = OrderDirection.Buy,\n                    Type = OrderType.Limit,\n                    Quantity = DefaultOrderQuantity*0.5,\n            Price = Close[0] * 1.1,\n                    SignalName = \"strategyName\",\n                });\n\n   CreateOROGroup(new List<IOrder> { oLimitLong, oStopLong });\n}\n\n\n\n\nDataSeriesConfigurable\n\n\nDefaultOrderQuantity\n\n\nBeschreibung\n\n\nDefaultQuantity legt die in einer Strategie zu verwendende St\u00fcckzahl fest. DefaultQuantity wird in der \nOnInit()\n-Methode angegeben.\n\n\nVerwendung\n\n\nReplaceOrder(IOrder iOrder, int quantity, double limitPrice, double stopPrice)\n\n\n\n\nParameter\n\n\nein int-Wert, der die St\u00fcckzahn (Aktien, Kontrakte usw.) enth\u00e4lt\n\n\nBeispiel\n\n\nprotected override void OnInit()\n{\nDefaultOrderQuantity = 100;\n}\n\n\n\n\nEntriesPerDirection\n\n\nBeschreibung\n\n\nDie Eigenschaft EntriesPerDirection legt die maximal erlaubte Anzahl von Einstiegen in eine Richtung (long bzw. short) fest.\n\n\nOb dabei der Name des Einstiegssignals ber\u00fccksichtigt werden soll oder nicht festgelegt.\n\n\nEntriesPerDirection wird in der \nOnInit()\n -Methode angegeben.\n\n\nVerwendung\n\n\nEntriesPerDirection\n\n\nParameter\n\n\nein int-Wert f\u00fcr die max. erlaubte Anzahl von Einstiegen in eine Richtung\n\n\nBeispiel\n\n\n// Beispiel 1\n// Wenn eine der beiden Einstiegsbedingungen zutrifft und eine Long-Position er\u00f6ffnet wird,\n// wird das jeweils andere Einstiegssignal ignoriert\nprotected override void OnInit()\n{\nEntriesPerDirection = 1;\n\n}\n\nprotected override void OnCalculate()\n{\n    if (CrossAbove(EMA(14), SMA(50), 1) && IsSerieRising(ADX(20)))\n        OpenLong(\"SMA cross entry\");\n}\n\n// Beispiel 2\n// Es wird f\u00fcr jedes unterschiedlich benannte Einstiegssignal eine Long-Position er\u00f6ffnet\n\n\nprotected override void OnCalculate()\n{\n    if (CrossAbove(EMA(14), SMA(50), 1) && IsSerieRising(ADX(20)))\n        OpenLong(\"EMACrossesSMA\");\n    else if (CrossAbove (MACD(2,2,5), 0, 1))\n        OpenLong(\"MACDCross\");\n}\n\n\n\n\nExcludeTradeHistoryInBacktest\n\n\nCloseLongTrade()\n\n\nBeschreibung\n\n\nCloseLongTrade  erzeugt eine Sell-Order um eine Long Position zu schlie\u00dfen (zu verkaufen).\n\n\nSiehe auch: \nSubmitOrder()\n, \nCloseShortTrade()\n\n\nVerwendung\n\n\nSiehe \nStrategyOrderParameters\n\n\nParameter\n\n\nSiehe \nStrategyOrderParameters\n\n\nReturn Value\n\n\nein order-Objekt vom Typ IOrder\n\n\nBeispiel\n\n\nvar order = CloseLongTrade(new StrategyOrderParameters\n{\n    Type = OrderType.Market\n});\n\n\n\n\nExitOnClose\n\n\nExitOnCloseSeconds\n\n\nCloseShortTrade()\n\n\nBeschreibung\n\n\nCloseShortTrade  erzeugt eine Buy-to-Cover Order um eine Short Position zu schlie\u00dfen (zu kaufen).\n\n\nSiehe auch: \nSubmitOrder()\n, \nCloselongTrade()\n\n\nVerwendung\n\n\nSiehe \nStrategyOrderParameters\n\n\nParameter\n\n\nSiehe \nStrategyOrderParameters\n\n\nR\u00fcckgabewert\n\n\nein order-Objekt vom Typ IOrder\n\n\nExample\n\n\nvar order = CloseShortTrade(new StrategyOrderParameters\n{\n    Type = OrderType.Stop,\n    Quantity = quantity,\n    StopPrice = price\n});\n\n\n\n\nAccount.GetValue()\n\n\nBeschreibung\n\n\nAccount.GetValue() liefert Informationen \u00fcber das Konto, f\u00fcr das die Strategie ausgef\u00fchrt wird.\n\n\nSiehe auch  \nGetProfitLoss()\n.\n\n\nVerwendung\n\n\nAccount.GetValue(AccountItem accountItem)\n\n\n\n\nParameter\n\n\nM\u00f6gliche Werte f\u00fcr accountItem sind\n\n\nAccountItem.BuyingPower\n\n\nAccountItem.CashValue\n\n\nAccountItem.RealizedProfitLoss\n\n\nR\u00fcckgabewert\n\n\nein double-Wert f\u00fcr das jeweilige AccountItem, F\u00fcr historische Bars wird eine 0 (Null) zur\u00fcckgegeben.\n\n\nBeispiel\n\n\nPrint(\"The current account cash value is \" + Account.GetValue(AccountItem.CashValue));\nPrint(\"The current account cash value with the leverage provided by the broker is \" + Account.GetValue(AccountItem.BuyingPower));\nPrint(\"The current P/L already realized is \" + Account.GetValue(AccountItem.RealizedProfitLoss));\n\n\n\n\nGetEntries()\n\n\nBeschreibung\n\n\nDiese Datenserie wird f\u00fcr Conditions verwendet und zeigt mehrfache Einstiegspreise f\u00fcr Einstiegsorders an.\n\n\nVerwendung\n\n\n\u00dcberladung von programmierten Conditions f\u00fcr eine Short und Long Signal Anzeige.\n\n\nParameter\n\n\nNone\n\n\nR\u00fcckgabewert\n\n\nint\n\n\nBeispiel\n\n\npublic class MyTestEntry : UserScriptedCondition\n    {\n\n        double _percentage = 100;\n\n        protected override void Initialize()\n        {\n            IsEntry = true;\n            IsStop = false;\n            IsTarget= false;\n            Add(new OutputDescriptor(Color.FromKnownColor(KnownColor.Black), \"Occurred\"));\n            Add(new OutputDescriptor(Color.FromArgb(255, 118, 222, 90), \"Entry1\"));\n            Add(new OutputDescriptor(Color.FromArgb(255, 118, 222, 90), \"Entry2\"));\n            Add(new OutputDescriptor(Color.FromArgb(255, 118, 222, 90), \"Entry3\"));\n            Overlay = true;\n            CalculateOnBarClose = true;\n        }\n\n        protected override void OnBarUpdate()\n        {\n\n            Calculate();\n\n        }\n\n        public override void Recalculate()\n        {\n            Calculate();\n        }\n\n        private void Calculate ()\n        {\n\n            if (TradeDirection == PositionType.Long)\n            {\n                Entry1.Set(Close[0] + 0.5);\n                Entry2.Set(Close[0] + 1);\n                Entry3.Set(Close[0] + 1.5);\n            }\n            else\n            {\n                Entry1.Set(Close[0] - 0.5);\n                Entry2.Set(Close[0] - 1);\n                Entry3.Set(Close[0] - 1.5);\n            }\n        }\n\n        #region Properties\n\n        [Browsable(false)]\n        [XmlIgnore()]\n        public DataSeries Occurred\n        {\n            get { return Values[0]; }\n        }\n\n        [Browsable(false)]\n        [XmlIgnore()]\n        public DataSeries Entry1\n        {\n            get { return Values[1]; }\n        }\n\n        [Browsable(false)]\n        [XmlIgnore()]\n        public DataSeries Entry2\n        {\n            get { return Values[2]; }\n        }\n\n        [Browsable(false)]\n        [XmlIgnore()]\n        public DataSeries Entry3\n        {\n            get { return Values[3]; }\n        }\n\n        public override IList<DataSeries> GetEntrys()\n        {\n            return new[] { Entry1, Entry2, Entry3 };\n\n\n\n\n\nGetProfitLoss()\n\n\nBeschreibung\n\n\nGetProfitLoss() liefert den aktuell unrealisierten Gewinn bzw. Verlust einer laufenden Position.\n\n\nSiehe auch \nAccount.GetValue()\n.\n\n\nUsage\n\n\nGetProfitLoss(int pLType);\n\n\n\n\nVerwendung\n\n\nM\u00f6gliche Werte f\u00fcr pLType sind\n\n\n0 - Amount, P/L als W\u00e4hrungsbetrag\n\n\n1 - Percent, P/L in Prozent\n\n\n2 \u2013 Risk, P/L in Van Tharp R-Multiples  \nwww.vantharp.com\n\n\n3 \u2013 P/L in Ticks\n\n\nR\u00fcckgabewert\n\n\nein double-Wert f\u00fcr den unrealisierten Gewinn bzw. Verlust\n\n\nBeispiel\n\n\nPrint(\"The current risk for the strategy \" + this.Name + \" is \" + GetProfitLoss(1) + \" \" + Instrument.Currency);\nPrint(\"This equals \"+ string.Format( \"{0:F1} R.\", GetProfitLoss(3)));\n\n\n\n\nGetProfitLossAmount()\n\n\nBeschreibung\n\n\nGetProfitLossAmount() liefert den aktuell unrealisierten Gewinn bzw. Verlust einer laufenden Position als W\u00e4hrungsbetrag.\n\n\nSiehe auch \nAccount.GetValue()\n.\n\n\nVerwendung\n\n\nGetProfitLossAmount(double profitLoss);\n\n\n\n\nParameter\n\n\nEin Objekt vom Typ double\n\n\nR\u00fcckgabewert\n\n\nein double-Wert f\u00fcr den unrealisierten Gewinn bzw. Verlust\n\n\nBeispiel\n\n\nPrint(\"the current P&L \" + this.Name + \" is \" + GetProfitLossAmount(Position.OpenProfitLoss) + \" \" + Instrument.Currency);\n\n\n\n\nGetProfitLossRisk()\n\n\nBeschreibung\n\n\nGetProfitLossRisk() liefert den aktuell unrealisierten Gewinn bzw. Verlust einer laufenden Position in R-Multiplen.\n\n\nSiehe auch  \nAccount.GetValue()\n.\n\n\nVerwendung\n\n\nGetProfitLossRisk();\n\n\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nein double-Wert f\u00fcr denie R-Multiple\n\n\nBeispiel\n\n\nPrint(\"the current P&L \" + this.Name + \" is \" + string.Format( \"{0:F1} R.\", GetProfitLossRisk()));\n\n\n\n\nGetScriptedCondition()\n\n\nBeschreibung\n\n\nMit dieser Methode k\u00f6nnen Benutzer zwischen Skripte zu kommunizieren.\n\n\nIsAutoConfirmOrder\n\n\nBeschreibung\n\n\nIsAutoConfirmOrder legt fest ob Orders automatisch aktiviert werden. IsAutoConfirmOrder wird in der  \nOnInit()\n-Methode angegeben.\n\n\nIst IsAutoConfirmOrder = true, dann werden Orders automatisch aktiviert (Default). Wenn IsAutoConfirmOrder der Wert false zugewiesen wurde, dann muss die entsprechende Order mit order. \nConfirmOrder()\n aktiviert werden.\n\n\nParameter\n\n\nein bool-Wert\n\n\nBeispiel\n\n\nprotected override void OnInit()\n{\n   IsAutoConfirmOrder = false;\n}\n\n\n\n\nOrder\n\n\nBeschreibung\n\n\nIOrder ist ein Objekt, welches Informationen zu einer Order enth\u00e4lt, die aktuell von einer Strategie verwaltet wird.\n\n\nDie einzelnen Eigenschaften sind:\n\n\n\n\n\n\nAction\n    \nEine der vier m\u00f6glichen Aktionen:\n\n\n\n\nOrderDirection.Buy\n\n\nOrderDirection.Sell\n\n\n\n\n\n\n\n\nAveragePrice\n\n    \nDer durchschnittliche Kauf- bzw. Verkaufspreis einer Position. Bei Positionen ohne Teilausf\u00fchrungen entspricht dies dem Einstiegskurs.\n\n\n\n\n\n\nFilledQuantity\n\n    Bei Teilausf\u00fchrungen ist Filled kleiner als Quantity\n\n\n\n\n\n\nLimitPrice\n\n\n\n\n\n\nName\n\n \u00a0 \u00a0Der eindeutige SignalName  \n\n\n\n\n\n\nOrderId\n\n    Die eindeutige OrderId\n\n\n\n\n\n\nOrderMode\n\n    Eines der drei m\u00f6glichen Optionen:\n\n\n\n\nOrderMode.Direct\n\n\nOrderMode.Dynamic\n\n\nOrderMode.Synthetic\n\n\n\n\n\n\n\n\nOrderState\n\n    Hiermit kann der aktuelle Zustand der Order abgefragt werden (siehe  \nOnOrderExecution\n und \nOnOrderChanged\n)\n\n\n\n\nOrderState.Accepted\n\n\nOrderState.Cancelled\n\n\nOrderState.CancelRejected\n\n\nOrderState.FilledQuantity\n\n\nOrderState.PartFilled\n\n\nOrderState.PendingCancel\n\n\nOrderState.PendingReplace\n\n\nOrderState.PendingSubmit\n\n\nOrderState.Rejected\n\n\nOrderState.ReplaceRejected\n\n\nOrderState.Unknown\n\n\nOrderState.Working\n\n\n\n\n\n\n\n\nOrderType\n\n    M\u00f6gliche Orderarten:\n\n\n\n\nOrderType.Limit\n\n\nOrderType.Market\n\n\nOrderType.Stop\n\n\nOrderType.StopLimit\n\n\n\n\n\n\n\n\nQuantity\n\n    Die zu ordernde St\u00fcckzahl\n\n\n\n\n\n\nStopPrice\n\n\n\n\n\n\nTimestamp\n\n    Zeitstempel\n\n\n\n\n\n\nTimeFrame\n\n    Der TimeFrame, der f\u00fcr die Order g\u00fcltig ist.\n\n\n\n\n\n\nTimeFrame\n\n\n\n\n\n\nM\u00f6gliche Methoden:\n\n\n\n\n\n\norder Order.Cancel()\n\n    L\u00f6scht die Order\n\n\n\n\n\n\norder.ConfirmOrder()\n\n    Best\u00e4tig die Order. Diese Methode muss ausgef\u00fchrt werden, wenn IsAutoConfirmOrder auf false gesetzt wird und man die Order dennoch automatisch ausf\u00fchren m\u00f6chte. Dies ist z. B. dann der Fall, wenn eine OCO- oder IfDone-Verk\u00fcpfung hergestellt werden soll.\n\n\n\n\n\n\nPerformance\n\n\nBeschreibung\n\n\nPerformance ist ein Objekt, welches Informationen zu allen Trades enth\u00e4lt, die von einer Strategie generiert wurden.\n\n\nEs gibt mehrere Listen, in denen die Trades eingeordnet sind. Mit Hilfe dieser Listen ist es leicht, weitere Performance-Auswertungen zu erstellen.\n\n\nSiehe Performance-Kennzahlen.\n\n\nDie einzelnen Listen sind:\n\n\n\n\n\n\nPerformance.AllTrades\n\n    Ist ein  \nTrade\n Collection Objekt, das alle von einer Strategie generierten Trades enth\u00e4lt.\n\n\n\n\n\n\nPerformance.LongTrades\n\n    Ist ein \nTrade\n Collection Objekt, das alle von einer Strategie generierten Long-Trades enth\u00e4lt.\n\n\n\n\n\n\nPerformance.ShortTrades\n\n    Ist ein \nTrade\n Collection Objekt, das alle von einer Strategie generierten ShortTrades enth\u00e4lt.\n\n\n\n\n\n\nPerformance.WinningTrades\n\n    Ist ein \nTrade\n Collection Objekt, das alle von einer Strategie generierten Gewinntrades enth\u00e4lt.\n\n\n\n\n\n\nPerformance.LosingTrades\n\n    Ist ein \nTrade\n Collection Objekt, das alle von einer Strategie generierten Verlusttrades enth\u00e4lt.\n\n\n\n\n\n\nBeispiel\n\n\n// beim Verlassen der Strategie eine Auswertung erstellen\nprotected override void OnDispose()\n{\nPrint(\"Performance evaluation of the strategy : \" + this.Name);\nPrint(\"----------------------------------------------------\");\nPrint(\"Amount of all trades: \" + Performance.AllTrades.Count);\nPrint(\"Amount of winning trades: \" + Performance.WinningTrades.Count);\nPrint(\"Amount of all loss trades: \" + Performance.LosingTrades.Count);\nPrint(\"Amount of all long trades: \" + Performance.LongTrades.Count);\nPrint(\"Amount of short trades: \" + Performance.ShortTrades.Count);\nPrint(\"Result: \" + Account.RealizedProfitLoss + \" \" + Account.Currency);\n}\n\n\n\n\nPosition\n\n\nBeschreibung\n\n\nPosition ist ein Objekt, welches Informationen zu einer Position enth\u00e4lt, die aktuell von einer Strategie verwaltet wird.\n\n\nDie einzelnen Eigenschaften sind:\n\n\n\n\n\n\nPosition.AvgPrice\n\n    Der durchschnittliche Kauf- bzw. Verkaufspreis einer Position.\n    Bei Positionen ohne Teilausf\u00fchrungen entspricht dies dem Einstiegskurs.\n\n\n\n\n\n\nPosition.CreatedDateTime\n\n    Datum und Uhrzeit der Positionser\u00f6ffnung.\n\n\n\n\n\n\nPosition.Instrument\n\n    Das Handelsinstrument, in welchem die Position besteht.\n    siehe auch \nInstruments\n.\n\n\n\n\n\n\nPosition.PositionType\n\n    Eines der drei m\u00f6glichen Positionierungen im Markt:\n\n\n\n\nPositionType.Flat\n\n\nPositionType.Long\n\n\nPositionType.Short\n\n\n\n\n\n\n\n\nPosition.OpenProfitLoss\n\n    Der aktuell noch unrealisierte Gewinn bzw. Verlust.\n    siehe auch \nGetProfitLoss()\n.\n\n\n\n\n\n\nPosition.ProfitCurrency\n\n    Gewinn (bzw. Verlust) ausgewiesen als W\u00e4hrungsbetrag.\n\n\n\n\n\n\nPosition.ProfitPercent\n\n    Gewinn (bzw. Verlust) ausgewiesen in Prozent.\n\n\n\n\n\n\nPosition.ProfitPoints\n\n    Gewinn (bzw. Verlust) ausgewiesen in Punkten bzw. Pips.\n\n\n\n\n\n\nPosition.Quantity\n\n    St\u00fcckzahl der Aktien, Kontrakte, CFD's o.\u00e4. in der Position.\n\n\n\n\n\n\nBeispiel\n\n\nif (Position.PositionType != PositionType.Flat)\n{\nPrint(\"Average price \" + Position.AvgPrice);\nPrint(\"Opening time \" + Position.CreatedDateTime);\nPrint(\"Instrument \" + Position.Instrument);\nPrint(\"Current positioning \" + Position.PositionType);\nPrint(\"Unrealized P/L \" + Position.OpenProfitLoss);\nPrint(\"P/L (currency) \" + Position.ProfitCurrency);\nPrint(\"P/L (in percent) \" + Position.ProfitPercent);\nPrint(\"P/L (in points) \" + Position.ProfitPoints);\nPrint(\"Pieces \" + Position.Quantity);\n}\n\n\n\n\nPositionType\n\n\nSiehe \nPosition.PositionType\n.\n\n\nTraceOrders\n\n\nBeschreibung\n\n\nDie Eigenschaft TraceOrders ist sehr n\u00fctzlich, um Orders, die von Strategien generiert werden, nachzuverfolgen.\nTraceOrders wird in der \nOnInit()\n Methode angegeben.\n\n\nWenn TraceOrders eingeschaltet ist, werden f\u00fcr jede Order die folgenden Werte im OutputWindow ausgegeben:\n\n\n\n\nInstrument\n\n\nTime frame\n\n\nAction\n\n\nType\n\n\nLimit price\n\n\nStop price\n\n\nQuantity\n\n\nName\n\n\n\n\nDiese Informationen sind z.B. bei der Erstellung von Strategien und f\u00fcr das Debugging sehr n\u00fctzlich.\n\n\nVerwendung\n\n\nTraceOrders\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\ntrue\n Tracing ist aktuell eingeschaltet\n\nfalse\n Tracing ist abgeschaltet\n\n\nBeispiel\n\n\nprotected override void OnInit()\n{\nClearTraceWindow();\nTraceOrders = true;\n}\n\n\n\n\nQuantity\n\n\nsiehe unter \nPosition.Quantity\n, \nPosition.PositionType\n.\n\n\nReplaceOrder()\n\n\nBeschreibung\n\n\nChangeOrder \u00e4ndert eine Order.\n\n\nVerwendung\n\n\nReplaceOrder(IOrder iOrder, int quantity, double limitPrice, double stopPrice)\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\niOrder\n\n\nein Order -Objekt vom Typ IOrder\n\n\n\n\n\n\nquantity\n\n\nzu ordernde St\u00fcckzahl\n\n\n\n\n\n\nlimitPrice\n\n\nLimitpreis. Wenn nicht ben\u00f6tigt, auf 0 setzen\n\n\n\n\n\n\nstopPrice\n\n\nStoppreis. Wenn nicht ben\u00f6tigt, auf 0 setzen\n\n\n\n\n\n\n\n\nBeispiel\n\n\nprivate IOrder stopOrder = null;\nprotected override void OnCalculate()\n{\n // Wenn die Position 10 Ticks im Gewinn liegt, Stopp auf Einstand anheben\nif (stopOrder != null\n    && Close[0] >= Position.AvgPrice + (10 * TickSize)\n        && stopOrder.StopPrice < Position.AvgPrice)\nReplaceOrder(stopOrder, stopOrder.Quantity, stopOrder.LimitPrice, Position.AvgPrice);\n}\n\n\n\n\nSetUpProfitTarget()\n\n\nBeschreibung\n\n\nSerzeugt sofort nach Ausf\u00fchrung einer Einstiegsorder eine Profit Target-Order um eine laufende Position zu einem bestimmten Kurs im Gewinn zu schlie\u00dfen. Die Order wird direkt an den Broker \u00fcbergeben und ist sofort im Markt wirksam.\nWenn das Gewinnziel statisch ist, kann SetUpProfitTarget() in der OnInit() Methode angegeben werden.\n\n\nSiehe auch  \nSetUpStopLoss()\n, \nSetUpTrailStop()\n.\n\n\nVerwendung\n\n\nSetUpProfitTarget(double currency)\nSetUpProfitTarget(CalculationMode mode, double value)\nSetUpProfitTarget(string fromEntry signal, CalculationMode mode, double value)\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncurrency\n\n\nGibt das Gewinnziel in einer W\u00e4hrung an, z.B. 500,- Euro.\n\n\n\n\n\n\nmode\n\n\nM\u00f6gliche Werte sind: CalculationMode.Percent (Angabe in Prozent); CalculationMode.Price (Angabe  als Kurswert); CalculationMode.Ticks (Angabe in Ticks bzw. Pips)\n\n\n\n\n\n\nvalue\n\n\nEin Wert, der den Abstand zwischen Einstiegskurs und Gewinnziel angibt. Die Angabe bezieht sich abh\u00e4ngig von \"mode\" auf einen Geldbetrag, eine Prozentangabe bzw. auf eine Angabe in Ticks.\n\n\n\n\n\n\nfromEntry signal\n\n\nDer Name eines Einstiegssignals, f\u00fcr das eine Profit Target-Order generiert werden soll. Die St\u00fcckzahl wird nur aus der angegebenen Einstiegsorder \u00fcbernommen.\n\n\n\n\n\n\n\n\nBeispiel\n\n\nprotected override void OnInit()\n{\n// Erzeugt eine Profit Target-Order 10 Ticks \u00fcber Einstand\nSetUpProfitTarget(CalculationMode.Ticks, 20);\n}\n\n\n\n\nSetUpStopLoss()\n\n\nBeschreibung\n\n\nSet up stop loss erzeugt sofort nach Ausf\u00fchrung einer Einstiegsorder eine StopLoss-Order um eine laufende Position zu einem bestimmten Kurs zu schlie\u00dfen. Die Order wird direkt an den Broker \u00fcbergeben und ist sofort im Markt wirksam (wenn sie nicht simuliert wird, s.u.).\n\n\nWenn der StopLoss-Kurs statisch ist, kann SetUpStopLoss() in der OnInit() Methode angegeben werden.\n\n\nSiehe auch \nSetUpProfitTarget()\n, \nSetUpTrailStop()\n.\n\n\nVerwendung\n\n\nSetUpStopLoss(double currency)\nSetUpStopLoss(double currency, bool simulated)\nSetUpStopLoss(CalculationMode mode, double value)\nSetUpStopLoss(string fromEntry signal, CalculationMode mode, double value, bool simulated)\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncurrency\n\n\nGibt den StopLoss-Abstand zum Einstiegskurs (=Risiko) in einer W\u00e4hrung an, z.B. 500,- Euro.\n\n\n\n\n\n\nmode\n\n\nM\u00f6gliche Werte sind:  CalculationMode.Percent ( Angabe in Prozent); CalculationMode.Price (Angabe als Kurswert);\n\n\n\n\n\n\nCalculationMode.Ticks (Angabe in Ticks bzw. Pips)\n\n\n\n\n\n\n\n\nsimulated\n\n\nWenn \"simulated\" auf \"true\" gesetzt ist, wird die Stoporder erst dann live (als Marketorder) zum Broker \u00fcbermittelt, wenn der Kurs sie erstmals \"ber\u00fchrt\" hat (d.h wenn sie ausgel\u00f6st werden w\u00fcrde wenn sie im Markt gelegen h\u00e4tte).\n\n\n\n\n\n\nvalue\n\n\nEin Wert, der den Abstand zwischen Einstiegskurs und Stoppkurs angibt. Die Angabe bezieht sich abh\u00e4ngig von \"mode\" auf einen Geldbetrag, eine Prozentangabe bzw. auf eine Angabe in Ticks.\n\n\n\n\n\n\nfromEntry signal\n\n\nDer Name eines Einstiegssignals, f\u00fcr das eine Stoporder generiert werden soll. Die St\u00fcckzahl wird nur aus der angegebenen Einstiegsorder \u00fcbernommen.\n\n\n\n\n\n\n\n\nBeispiel\n\n\nprotected override void OnInit()\n{\n// Sets profitTarget 15 Ticks \u00fcber dem Markt\nSetUpStopLoss(\"MACDEntry\", CalculationMode.Ticks, 15, true);\n}\n\n\n\n\nSetUpTrailStop()\n\n\nBeschreibung\n\n\nSetTrailStop() erzeugt sofort nach Ausf\u00fchrung einer Einstiegsorder eine Trail Stop-Order um eine laufende Position zun\u00e4chst im Verlust zu sch\u00fctzen bzw. nach dem BreakEven den Gewinn zu sichern.\n\n\nDie Order wird direkt an den Broker \u00fcbergeben und ist sofort im Markt wirksam (wenn sie nicht simuliert wird, s.u.).\n\n\nWenn der StopLoss-Kurs und der Offset-Wert statisch ist, kann  SetUpTrailStop() in der OnInit() Methode angegeben werden.\n\n\nSollte SetUpTrailStop() in der \nOnCalculate()\n Methode verwendet werden, um sie dynamisch dem Kursverlauf anpassen zu k\u00f6nnen, ist darauf zu achten, die Parameter vor einer weiteren (neuen) Position auf die gew\u00fcnschten Initialwerte zur\u00fcckzusetzten, da die zuletzt gesetzten Werte ansonsten auch f\u00fcr die neue Position wirksam sind.\n\n\nFunktionsweise:\n\n\nAngenommen es ist  SetUpTrailStop(CalculationMode.Ticks, 30) gesetzt:\n\n\nIn einer Long-Position wird der Stop nun 30 Ticks vom jeweils letzten erreichten Hoch entfernt gesetzt. Macht der Markt ein neues Hoch, wird der Stop angepasst. Der Stop wird jedoch nicht mehr nach unten ver\u00e4ndert.\n\n\nIn einer Shortposition ist das Verhalten analog vom erreichten tiefsten Tief ausgehend.\n\n\nHinweise:\n\n\nEs ist nicht m\u00f6glich, in einer Strategie f\u00fcr ein und dieselbe SetUpStopLoss und SetUpTrailStop gleichzeitig zu verwenden. Es wird immer SetUpStopLoss() der Vorrang einger\u00e4umt\n\n\nEs ist aber m\u00f6glich, in einer Strategie beide Varianten parallel zu verwenden, wenn sie auf unterschiedliche Einstiegssignale referenzieren\n\n\nBei Teilausf\u00fchrungen einer einzelnen Order wird f\u00fcr jede Teilposition ein separater Trailing Stop angelegt.\n\n\nWird zus\u00e4tzlich zu SetUpProfitTarget() auch SetUpTrailStop(), verwendet, werden beide Orders automatisch OCO-verkn\u00fcpft (OCO = one cancels the other)\n\n\nEs wird immer eine Stop-Market oder erzeugt, keine Stop-Limit-Order.\n\n\nWird die Position innerhalb der Strategie von einer anderen Ausstiegsorder geschlossen, so wird die Trailing-Stoporder automatisch gel\u00f6scht.\n\n\nSiehe auch \nSetUpStopLoss()\n, \nSetUpProfitTarget()\n.\n\n\nVerwendung\n\n\nSetUpTrailStop(double currency)\nSetUpTrailStop(double currency, bool simulated)\nSetUpTrailStop(CalculationMode mode, double value)\nSetUpTrailStop(string fromEntry signal, CalculationMode mode, double value, bool simulated)\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncurrency\n\n\nGibt den StopLoss-Abstand zum Einstiegskurs (=Risiko) in einer W\u00e4hrung an, z.B. 500,- Euro.\n\n\n\n\n\n\nmode\n\n\nM\u00f6gliche Werte sind:  CalculationMode.Percent;  CalculationMode.Ticks\n\n\n\n\n\n\nsimulated\n\n\nWenn \"simulated\" auf \"true\" gesetzt ist, wird die Trail-Stoporder erst dann live (als Marketorder) zum Broker \u00fcbermittelt, wenn der Kurs sie erstmals \"ber\u00fchrt\" hat (d.h wenn sie ausgel\u00f6st werden w\u00fcrde wenn sie im Markt gelegen h\u00e4tte).\n\n\n\n\n\n\nvalue\n\n\nEin Wert, der den Abstand zwischen Einstiegskurs und Stoppkurs angibt. Die Angabe bezieht sich abh\u00e4ngig von \"mode\" auf einen Geldbetrag, eine Prozentangabe bzw. auf eine Angabe in Ticks.\n\n\n\n\n\n\nfromEntry signal\n\n\nDer Name eines Einstiegssignals, f\u00fcr das eine Trail-Stoporder generiert werden soll. Die St\u00fcckzahl wird nur aus der angegebenen Einstiegsorder \u00fcbernommen.\n\n\n\n\n\n\n\n\nBeispiel\n\n\nprotected override void OnInit()\n{\n// Setzt einen Trailing Stop von 30 Ticks\n    SetUpTrailStop(CalculationMode.Price, Low[0]);\n}\n\n\n\n\nStrategyOrderParameters\n\n\nBeschreibung\n\n\nDiese Klasse aggregiert alle Eigenschaften, die zum \u00dcbergeben der Bestellung ben\u00f6tigt werden.\n\n\nSiehe \nSubmitOrder()\n, \nCloseLongTrade()\n, \nCloseShortTrade()\n.\n\n\nVerwendung\n\n\npublic class StrategyOrderParameters\n    {\n        public OrderDirection Direction { get; set; }\n        public OrderMode Mode { get; set; } = OrderMode.Direct;\n        public OrderType Type { get; set; }\n        public bool LiveUntilCancelled { get; set; }\n        public int Quantity { get; set; }\n        public double Price { get; set; }\n        public double StopPrice { get; set; }\n        public string SignalName { get; set; } = String.Empty;\n        public IInstrument Instrument { get; set; }\n        public ITimeFrame TimeFrame { get; set; }\n        public string FromEntrySignal { get; set; } = String.Empty;\n    }\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOrderDirection\n\n\nM\u00f6gliche Werte sind: OrderDirection.Buy Kauforder zum Long-Einstieg; OrderDirection.Sell Verkaufsorder zum Schlie\u00dfen einer Long-Position;\n\n\n\n\n\n\nOrderMode\n\n\nOne of three possible positions in the market: Direct, Dynamic, Synthetic\n\n\n\n\n\n\nOrderType\n\n\nM\u00f6gliche Werte sind: OrderType.Limit, OrderType.Market, OrderType.Stop, OrderType.StopLimit\n\n\n\n\n\n\nLiveUntilCancelled\n\n\nDie Order wird nicht am Ende des Bars gel\u00f6scht, sondern bleibt so lange aktiv, bis sie mit \nOrder.Cancel\n  gel\u00f6scht wird, bzw. bis ihre Ablaufzeit (siehe \nTimeInForce\n) erreicht ist.\n\n\n\n\n\n\nQuantity\n\n\nSt\u00fcckzahl\n\n\n\n\n\n\nPrice\n\n\nLimit-Kurs. Die Angabe einer 0 (Null) bedeutet, dass dieser Parameter irrelevant ist.\n\n\n\n\n\n\nStopPrice\n\n\nStop-Kurs. Die Angabe einer 0 (Null) bedeutet, dass dieser Parameter irrelevant ist\n\n\n\n\n\n\nSignalName\n\n\nEin eindeutiger Signalname (string)\n\n\n\n\n\n\nInstrument\n\n\nDas Handelsinstrument, in welchem die Position besteht.\n\n\n\n\n\n\nTimeFrame\n\n\nT Der TimeFrame, der f\u00fcr die Order g\u00fcltig ist.\n\n\n\n\n\n\nFromEntrySignal\n\n\nDer Name eines Einstiegssignals, f\u00fcr das eine Trail-Stoporder generiert werden soll. Die St\u00fcckzahl wird nur aus der angegebenen Einstiegsorder \u00fcbernommen.\n\n\n\n\n\n\n\n\nSubmitOrder()\n\n\nBeschreibung\n\n\nSubmitOrder erzeugt eine benutzerdefinierte Order. F\u00fcr diese Order wird kein Stop und kein Limit in den Markt gelegt. Alle Kontrollmechanismen von AgenaTrader sind f\u00fcr diese Orderart abgeschaltet. Der Nutzer ist f\u00fcr die Verwaltung, Stop, Target und f\u00fcr die Behandlung von Teilausf\u00fchrungen selbst verantwortlich und kann sich ein Ordermanagement nach seinen eigenen W\u00fcnschen selbst erstellen.\n\n\nSiehe auch  \nOnOrderChanged()\n, \nOnOrderExecution()\n.\n\n\nVerwendung\n\n\nSiehe \nStrategyOrderParameters\n\n\nParameter\n\n\nSiehe \nStrategyOrderParameters\n                   \n\n\nR\u00fcckgabewert\n\n\nan order object of the type \"IOrder\"\n\n\nBeispiel\n\n\n// Limit Long order\nSubmit Limit Buy\nvar order = SubmitOrder(new StrategyOrderParameters\n                {\n                    Direction = OrderDirection.Buy,\n                    Type = OrderType.Limit,\n                    Mode = orderMode,\n                    Price = limitPrice,\n                    Quantity = quantity,\n                    SignalName = entryName,\n                    Instrument = Instrument,\n                    TimeFrame = TimeFrame,\n                    LiveUntilCancelled = true\n                });\n\n// Short Market order\nSubmit Sell Market\nvar order = SubmitOrder(new StrategyOrderParameters\n            {\n                Direction = OrderDirection.Sell,\n                Type = OrderType.Market,\n                Mode = ordermode,\n                Quantity = quantity,\n                SignalName = entryName,\n                Instrument = Instrument,\n                TimeFrame = TimeFrame\n            });\n\n\n\n\nTimeInForce\n\n\nBeschreibung\n\n\nDie Eigenschaft TimeInForce bestimmt die G\u00fcltigkeitsdauer einer Order. Die G\u00fcltigkeitsdauer ist davon abh\u00e4ngig, welche Werte von einem Broker akzeptiert werden.\n\n\nTimeInForce wird in der \nOnInit()\n Methode angegeben.\n\n\nM\u00f6gliche Werte sind:\nTimeInForce.day\nTimeInForce.loc\nTimeInForce.gtc (GTC = good till canceled)\nTimeInForce.gtd\n\n\nDefault:\n TimeInForce.GTC\n\n\nVerwendung\n\n\nTimeInForce\n\n\nBeispiel\n\n\nprotected override void OnInit()\n{\nTimeInForce = TimeInForce.Day;\n}\n\n\n\n\nTrade\n\n\nBeschreibung\n\n\nTrade ist ein Objekt, welches Informationen zu einem Trade enth\u00e4lt, der von einer Strategie ausgef\u00fchrt wurde bzw. der aktuell l\u00e4uft.\n\n\nDie einzelnen Eigenschaften sind:\n\n\n\n\n\n\nTrade.AvgPrice\n\n    durchschnittlicher Einstiegskurs\n\n\n\n\n\n\nTrade.ClosedProfitLoss\n\n    bereits realisierter Gewinn bzw. Verlust\n\n\n\n\n\n\nTrade.Commission\n\n    Geb\u00fchren (Kommissionen)\n\n\n\n\n\n\nTrade.CreatedDateTime\n\n    Zeitpunkt der Er\u00f6ffnung eines Trades\n\n\n\n\n\n\nTrade.EntryReason\n\n    Bezeichnung des Einstiegssignals\n    bei Strategien: Name der Strategie\n\n\n\n\n\n\nTrade.ExitDateTime\n\n    Zeitpunkt, an dem der Trade geschlossen wurde\n\n\n\n\n\n\nTrade.ExitPrice\n\n    Ausstiegskurs\n\n\n\n\n\n\nTrade.ExitReason\n\n    Bezeichnung des Ausstiegssignals\n    bei Strategien: Name der Strategie\n\n\n\n\n\n\nTrade.Instrument\n\n    Bezeichnung des Handelsinstrumentes\n\n\n\n\n\n\nTrade.PositionType\n\n    Positionierung im Markt\n\n\n\n\nPositionType.Flat\n\n\nPositionType.Long\n\n\nPositionType.Short\n\n\n\n\n\n\n\n\nTrade.OpenProfitLoss\n\n    noch unrealisierter Gewinn bzw. Verlust in einer laufenden Position\n\n\n\n\n\n\nTrade.ProfitCurrency\n\n    Gewinn bzw. Verlust in der W\u00e4hrung, in der das Handelskonto gef\u00fchrt wird\n\n\n\n\n\n\nTrade.ProfitLoss\n\n    Gewinn bzw. Verlust\n\n\n\n\n\n\nTrade.ProfitPercent\n\n    Gewinn bzw. Verlust in Prozent\n\n\n\n\n\n\nTrade.ProfitPercentWithCommission\n\n    Gewinn bzw. Verlust in Prozent mit Geb\u00fchren\n\n\n\n\n\n\nTrade.ProfitPoints\n\n    Gewinn bzw. Verlust in Punkten bzw. Pips\n\n\n\n\n\n\nTrade.Quantity\n\n    St\u00fcckzahl von Aktien, CFD, Kontrakten usw.\n\n\n\n\n\n\nTrade.TimeFrame\n\n    Zeiteinheit, in der der Trade er\u00f6ffnet wurde\n\n\n\n\n\n\nTrade.Url\n\n    URL zum Snapshot des Charts zum Zeitpunkt der Er\u00f6ffnung\n\n\n\n\n\n\nBeispiel\n\n\nprotected override void OnDispose()\n{\n  if (Performance.AllTrades.Count < 1) return;\n  foreach (ITrade trade in Performance.AllTrades)\n  {\n    Print(\"Trade #\"+trade.Id);\n    Print(\"--------------------------------------------\");\n    Print(\"Durchschnittspreis \" + trade.AvgPrice);\n    Print(\"realisierter G/V \" + trade.ClosedProfitLoss);\n    Print(\"Geb\u00fchren \" + trade.Commission);\n    Print(\"Zeitpunkt Einstieg \" + trade.CreatedDateTime);\n    Print(\"Bezeichnung Einst \" + trade.EntryReason);\n    Print(\"Zeitpunkt Ausstieg  \" + trade.ExitDateTime);\n    Print(\"Ausstiegskurs  \" + trade.ExitPrice);\n    Print(\"Bezeichnung Ausstieg  \" + trade.ExitReason);\n    Print(\"Instrument \" + trade.Instrument);\n    Print(\"Positionierung \" + trade.PositionType);\n    Print(\"unrealisierter G/V \" + trade.OpenProfitLoss);\n    Print(\"G/V (W\u00e4hrung) \" + trade.ProfitCurrency);\n    Print(\"G/V \" + trade.ProfitLoss);\n    Print(\"G/V (in Prozent) \" + trade.ProfitPercent);\n    Print(\"G/V (in % mit Geb\u00fchren)\" + trade.ProfitPercentWithCommission);\n    Print(\"GV (in Punkten) \" + trade.ProfitPoints);\n    Print(\"St\u00fcckzahl \" + trade.Quantity);\n    Print(\"Zeiteinheit \" + trade.TimeFrame);\n    Print(\"URL zum Snapshot \" + trade.Url);\n  }\n}\n\n\n\n\nUnmanaged\n\n\nBacktesting and Optimization\n\n\nPerformance Characteristics\n\n\nUnter Performance-Kennzahlen werden verschiedene Kennzahlen verstanden, die jeweils f\u00fcr eine Liste von Trades berechnet werden k\u00f6nnen. Die Trades k\u00f6nnen von einer Strategie in Realtime generiert worden sein oder von einem Backtestlauf stammen.\n\n\nEs stehen folgende Listen zur Verf\u00fcgung:\n\n\n\n\nalle trades\n\n\nalle long trades\n\n\nalle short trades\n\n\nalle winning trades\n\n\nalle losing trades\n\n\n\n\nSiehe hierzu  \nPerformance\n.\n\n\nDie einzelnen Kennzahlen sind:\n\n\nAvgEtd\n\nder durchschnittliche DrawDown am Ende eines Trades (avg end trade drawdown)\n<TradeCollection>.TradesPerformance.<TradesPerformanceValues>.AvgEtd\n\n\nPrint(\"Average ETD of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.AvgEtd);\n\n\n\n\nAvgMae\n\nder durchschnittliche max. Kursr\u00fcckgang nach den Einstiegen (avg maximum adverse excursion)\n<TradeCollection>.TradesPerformance.<TradesPerformanceValues>.AvgMae\n\n\nPrint(\"Average MAE of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.AvgMae);\n\n\n\n\nAvgMfe\n\nder durchschnittliche max Kursanstieg im Verlauf der Trades (avg maximum favorable excursion)\n<TradeCollection>.TradesPerformance.<TradesPerformanceValues>.AvgMfe\n\n\nPrint(\"Average MFE of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.AvgMfe);\n\n\n\n\nAvgProfit\n\nder durchschnittliche Gewinn \u00fcber alle Trades (avg profit)\n<TradeCollection>.TradesPerformance.<TradesPerformanceValues>.AvgProfit\n\n\nPrint(\"Average profit of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.AvgProfit);\n\n\n\n\nCumProfit\n\nder Gesamtgewinn \u00fcber alle Trades\n<TradeCollection>.TradesPerformance.<TradesPerformanceValues>.CumProfit\n\n\nPrint(\"Average cumulative profit of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.CumProfit);\n\n\n\n\nDrawDown\n\nder DrawDown \u00fcber alle Trades\n<TradeCollection>.TradesPerformance.<TradesPerformanceValues>.DrawDow\n\n\nPrint(\"Drawdown of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.DrawDown);\n\n\n\n\nLargestLoser\n\nder gr\u00f6\u00dfte Verlust\n<TradeCollection>.TradesPerformance.<TradesPerformanceValues>.LargestLoser\n\n\nPrint(\"Largest loss of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.LargestLoser);\n\n\n\n\nLargestWinner\n\nder gr\u00f6\u00dfte Gewinn\n<TradeCollection>.TradesPerformance.<TradesPerformanceValues>.LargestWinner\n\n\nPrint(\"Largest win of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.LargestWinner);\n\n\n\n\nProfitPerMonth\n\nhochgerechneter Gewinn/Verlust im Monat (auch in Prozent)\n<TradeCollection>.TradesPerformance.<TradesPerformanceValues>.ProfitPerMonth\n\n\nPrint(\"Profit per month of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.ProfitPerMonth);\n\n\n\n\nStdDev\n\ndie Standardabweichung der Gewinne bzw. Verluste. Hier k\u00f6nnen Ausrei\u00dfer erkannt werden. Je besser ein Handelssystem ist, desto kleiner ist die Standardabweichung und desto h\u00f6her ist die Erwartung von Gewinnen.\n\n\nAlle Kennzahlen sind double-Werte.",
            "title": "Strategieprogrammierung"
        },
        {
            "location": "/strategieprogrammierung/#strategieprogrammierung",
            "text": "",
            "title": "Strategieprogrammierung"
        },
        {
            "location": "/strategieprogrammierung/#account",
            "text": "",
            "title": "Account"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung",
            "text": "Account ist ein Objekt, welches Informationen zu dem Konto enth\u00e4lt, mit dem die aktuelle Strategie arbeitet.  Die einzelnen Eigenschaften sind:    Account.AccountConnection \n    Name der verwendeten Brokerverbindung (der Name, der unter Kontoverbindungen vergeben wurde).    Account.AccountType \n    Art des Kontos (Livokonto, Simkonto usw.)    Account.Broker \n    Bezeichnung des Brokers    Account.BuyingPower \n    Der Kontostand unter Ber\u00fccksichtigung des vom Broker gew\u00e4hrten Hebels.(IB hebelt das Kontoguthaben z.B. aktuell mit 4. Ein Guthaben von 10.000 Euro hat so eine \"Kaufkraft\" von 40.000 Euro.    Account.CashValue \n    Betrag (double)    Account.Currency \n    W\u00e4hrung, in der das Konto gef\u00fchrt wird    Account.ExcessEquity \n    \u00dcberschuss    Account.InitialMargin \n    Initial Margin (abh. vom jeweiligen Broker, double)    Account.InstrumentType \n    Art des Handelsinstrumentes (Typ AgenaTrader.Plugins.InstrumentTypes)    Account.IsDemo \n    true, wenn es sich um ein Demokonto handelt    Account.Name \n    Name des Kontos (i.d.R. mit Account. AccountConnection identisch)    Account.OverNightMargin \n    \u00dcbernacht-Margin (abh. vom jeweiligen Broker, double)    Account.RealizedProfitLoss \n    realisierter Gewinn bzw. Verlust (double)",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#beispiel",
            "text": "Print(\"AccountConnection \" + Account.AccountConnection);\nPrint(\"AccountType \" + Account.AccountType);\nPrint(\"Broker \" + Account.Broker);\nPrint(\"BuyingPower \" + Account.BuyingPower);\nPrint(\"CashValue \" + Account.CashValue);\nPrint(\"Currency \" + Account.Currency);\nPrint(\"ExcessEquity \" + Account.ExcessEquity);\nPrint(\"InitialMargin \" + Account.InitialMargin);\nPrint(\"InstrumentTypes \" + Account.InstrumentTypes);\nPrint(\"IsDemo \" + Account.IsDemo);\nPrint(\"Name \" + Account.Name);\nPrint(\"OverNightMargin \" + Account.OverNightMargin);\nPrint(\"RealizedProfitLoss \" + Account.RealizedProfitLoss);",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#barscountfromtradeclose",
            "text": "",
            "title": "BarsCountFromTradeClose()"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_1",
            "text": "Die Eigenschaft  \"BarsCountFromTradeClose\" liefert die Anzahl der Bars, die seit dem letzten Ausstieg (Exit) aus dem Markt vergangen sind.",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung",
            "text": "BarsCountFromTradeClose()\nBarsCountFromTradeClose(string strategyName)  F\u00fcr Multibar-Strategieen  BarsCountFromTradeClose(int multibarSeriesIndex, string strategyName, int exitsAgo)",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter",
            "text": "strategyName  Der Signalname (string), der in einer Ausstiegsmethode zur eindeutigen Kennzeichnung des Ausstiegs vergeben wurde    multibarSeriesIndex  F\u00fcr * Multibar* MultiBars  Strategieen. Index der Datenreihe, f\u00fcr die die Ausstiegsorder ausgef\u00fchrt wurde. Siehe  ProcessingBarSeriesIndex .    exitsAgo  Anzahl der in der Vergangenheit liegenden Ausstiege. Eine 0 (Null) an dieser Stelle liefert die Anzahl der Bars, die sich nach dem letzten Ausstieg ausgebildet haben.",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_1",
            "text": "Print(\"Der letzte Ausstieg liegt \" + BarsCountFromTradeClose() + \" Bars zur\u00fcck.\");",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#barscountfromtradeopen",
            "text": "",
            "title": "BarsCountFromTradeOpen()"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_2",
            "text": "Die Eigenschaft \"BarsCountFromTradeOpen\"  liefert die Anzahl der Bars, die seit dem letzten Einstieg (Entry) in den Markt vergangen sind.",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_1",
            "text": "BarsCountFromTradeOpen()\nBarsCountFromTradeOpen(string strategyName)  F\u00fcr Multibar-Strategieen  BarsCountFromTradeOpen(int multibarSeriesIndex, string strategyName, int entriesAgo)",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_1",
            "text": "strategyName  Der Signalname (string), der in einer Einstiegsmethode zur eindeutigen Kennzeichnung des Einstiegs vergeben wurde.    multibarSeriesIndex  F\u00fcr * Multibar* ,  MultiBars  Strategieen.Index der Datenreihe, f\u00fcr die die Einstiegsorder ausgef\u00fchrt wurde. Siehe  ProcessingBarSeriesIndex ,  ProcessingBarSeriesIndex .    entriesAgo  Anzahl der in der Vergangenheit liegenden Einstiege. Eine 0 (Null) an dieser Stelle liefert die Anzahl der Bars, die sich nach dem letzten Einstieg ausgebildet haben.",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_2",
            "text": "Print(\"Der letzte Einstieg liegt \" + BarsCountFromTradeOpen() + \" Bars zur\u00fcck.\");",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#cancelallorders",
            "text": "",
            "title": "CancelAllOrders()"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_3",
            "text": "CancelAllOrders  l\u00f6scht alle Oders (cancel), die von der Strategie verwaltet werden.\nEs wird ein Cancel-Request an den Broker verschickt. Ob eine Oder dort wirklich gel\u00f6scht wird, kann nicht garantiert werden. Es kann vorkommen, dass eine Order eine Teilausf\u00fchrung erhalten hat, ehe sie gel\u00f6scht wird. Es ist daher ratsam, den jeweils aktuellen Status einer Order mit  OnOrderChanged()  zu kontrollieren.",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_2",
            "text": "CancelAllOrders()",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_2",
            "text": "kein Parameter",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_3",
            "text": "protected override void OnCalculate()\n{\n   if (BarsCountFromTradeOpen() >= 30)\n       CancelAllOrders();\n}",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#ordercancel",
            "text": "",
            "title": "Order.Cancel()"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_4",
            "text": "Cancel order l\u00f6scht eine Oder (cancel).  Es wird ein Cancel-Request an den Broker verschickt. Ob eine Oder dort wirklich gel\u00f6scht wird, kann nicht garantiert werden. Es kann vorkommen, dass eine Order eine Teilausf\u00fchrung erhalten hat, ehe sie gel\u00f6scht wird. Es ist daher ratsam, den jeweils aktuellen Status einer Order mit  OnOrderChanged()  zu kontrollieren.",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_3",
            "text": "Order.Cancel(IOrder order)",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_3",
            "text": "Ein order-Objekt vom Typ IOrder",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_4",
            "text": "private IOrder entryOrder = null;\nprivate int barNumber = 0;\nprotected override void OnCalculate()\n{\n   // An das Hoch des aktuellen Bars einen Einstiegsstop legen\n    if (entryOrder == null)\n    {\n        entryOrder = OpenLongStop(High[0], \"stop long\");\n        barNumber = ProcessingBarIndex;\n    }\n    // Nach 3 Bars die Order l\u00f6schen\n    if (Position.PositionType == PositionType.Flat &&\n    ProcessingBarIndex > barNumber + 3)\n        Order.Cancel(entryOrder);\n}",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#createifdonegroup",
            "text": "",
            "title": "CreateIfDoneGroup()"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_5",
            "text": "Wenn zwei Orders \u00fcber eine CreateIfDoneGroup miteinander verkn\u00fcpft werden, so bedeutet dies, dass wenn die eine Order ausgef\u00fchrt wurde, die zweite verbundene Order aktiviert wird.",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_4",
            "text": "CreateIfDoneGroup(IEnumerable<IOrder> orders)",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_4",
            "text": "Ein order-Objekt vom Typ IOrder als List",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_5",
            "text": "private IOrder oopenlong = null;\nprivate IOrder osubmitbuy = null;\n\n\nprotected override void OnInit()\n{\n   IsAutoConfirmOrder = false;\n}\n\n\nprotected override void OnCalculate()\n{\n\n oopenlong =  SubmitOrder(new StrategyOrderParameters\n                {\n                    Direction = OrderDirection.Buy,\n                    Type = OrderType.Market,\n                    Quantity = DefaultOrderQuantity,\n                    SignalName = \"strategyName\",\n                });\n\nosubmitbuy =  SubmitOrder(new StrategyOrderParameters\n                {\n                    Direction = OrderDirection.Sell,\n                    Type = OrderType.Stop,\n                    Quantity = DefaultOrderQuantity,\n            StopPrice = Close[0] * 1.1,\n                    SignalName = \"strategyName\",\n                });\n\n   CreateIfDoneGroup(new List<IOrder> { oopenlong, osubmitbuy });\n\n   oopenlong.ConfirmOrder();\n}",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#createocogroup",
            "text": "",
            "title": "CreateOCOGroup()"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_6",
            "text": "Wenn zwei Orders \u00fcber eine CreateOCOGroup miteinander verkn\u00fcpft werden, so bedeutet dies, dass sobald die eine Order ausgef\u00fchrt wurde, die zweite verbundene Order gel\u00f6scht wird.",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_5",
            "text": "CreateOCOGroup(IEnumerable<IOrder> orders)",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_5",
            "text": "Ein order-Objekt vom Typ IOrder als List",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_6",
            "text": "private IOrder oopenlong = null;\nprivate IOrder oEnterShort = null;\n\n\nprotected override void OnInit()\n{\n   IsAutoConfirmOrder = false;\n}\n\n\nprotected override void OnCalculate()\n{\n\noopenlong =  SubmitOrder(new StrategyOrderParameters\n                {\n                    Direction = OrderDirection.Buy,\n                    Type = OrderType.Stop,\n                    Quantity = DefaultOrderQuantity,\n            StopPrice = Close[0] * 1.1,\n                    SignalName = \"strategyName\",\n                });\n\n\noEnterShort =  SubmitOrder(new StrategyOrderParameters\n                {\n                    Direction = OrderDirection.Sell,\n                    Type = OrderType.Stop,\n                    Quantity = DefaultOrderQuantity,\n            StopPrice = Close[0] * -1.1,\n                    SignalName = \"strategyName\",\n                });\n\n\n\n   CreateOCOGroup(new List<IOrder> { oopenlong, oEnterShort });\n\n   oopenlong.ConfirmOrder();\n   oEnterShort.ConfirmOrder();\n}",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#createorogroup",
            "text": "",
            "title": "CreateOROGroup()"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_7",
            "text": "Wenn zwei Orders \u00fcber eine CreateOROGroup miteinander verkn\u00fcpft werden, so bedeutet dies, dass sobald die eine Order ausgef\u00fchrt wurde, die Ordergr\u00f6\u00dfe der zweiten Order um das Ordervolumen der ersten Order reduziert wird.",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_6",
            "text": "CreateOROGroup(IEnumerable<IOrder> orders)",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_6",
            "text": "Ein order-Objekt vom Typ IOrder",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_7",
            "text": "private IOrder oStopLong = null;\nprivate IOrder oLimitLong = null;\n\n\nprotected override void OnInit()\n{\n   IsAutoConfirmOrder = false;\n}\n\n\nprotected override void OnCalculate()\n{\n\n   oStopLong =  SubmitOrder(new StrategyOrderParameters\n                {\n                    Direction = OrderDirection.Buy,\n                    Type = OrderType.Stop,\n                    Quantity = DefaultOrderQuantity,\n            StopPrice = Close[0] * -1.1,\n                    SignalName = \"strategyName\",\n                });\n\n\n\n\n   oLimitLong =  SubmitOrder(new StrategyOrderParameters\n                {\n                    Direction = OrderDirection.Buy,\n                    Type = OrderType.Limit,\n                    Quantity = DefaultOrderQuantity*0.5,\n            Price = Close[0] * 1.1,\n                    SignalName = \"strategyName\",\n                });\n\n   CreateOROGroup(new List<IOrder> { oLimitLong, oStopLong });\n}",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#dataseriesconfigurable",
            "text": "",
            "title": "DataSeriesConfigurable"
        },
        {
            "location": "/strategieprogrammierung/#defaultorderquantity",
            "text": "",
            "title": "DefaultOrderQuantity"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_8",
            "text": "DefaultQuantity legt die in einer Strategie zu verwendende St\u00fcckzahl fest. DefaultQuantity wird in der  OnInit() -Methode angegeben.",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_7",
            "text": "ReplaceOrder(IOrder iOrder, int quantity, double limitPrice, double stopPrice)",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_7",
            "text": "ein int-Wert, der die St\u00fcckzahn (Aktien, Kontrakte usw.) enth\u00e4lt",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_8",
            "text": "protected override void OnInit()\n{\nDefaultOrderQuantity = 100;\n}",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#entriesperdirection",
            "text": "",
            "title": "EntriesPerDirection"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_9",
            "text": "Die Eigenschaft EntriesPerDirection legt die maximal erlaubte Anzahl von Einstiegen in eine Richtung (long bzw. short) fest.  Ob dabei der Name des Einstiegssignals ber\u00fccksichtigt werden soll oder nicht festgelegt.  EntriesPerDirection wird in der  OnInit()  -Methode angegeben.",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_8",
            "text": "EntriesPerDirection",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_8",
            "text": "ein int-Wert f\u00fcr die max. erlaubte Anzahl von Einstiegen in eine Richtung",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_9",
            "text": "// Beispiel 1\n// Wenn eine der beiden Einstiegsbedingungen zutrifft und eine Long-Position er\u00f6ffnet wird,\n// wird das jeweils andere Einstiegssignal ignoriert\nprotected override void OnInit()\n{\nEntriesPerDirection = 1;\n\n}\n\nprotected override void OnCalculate()\n{\n    if (CrossAbove(EMA(14), SMA(50), 1) && IsSerieRising(ADX(20)))\n        OpenLong(\"SMA cross entry\");\n}\n\n// Beispiel 2\n// Es wird f\u00fcr jedes unterschiedlich benannte Einstiegssignal eine Long-Position er\u00f6ffnet\n\n\nprotected override void OnCalculate()\n{\n    if (CrossAbove(EMA(14), SMA(50), 1) && IsSerieRising(ADX(20)))\n        OpenLong(\"EMACrossesSMA\");\n    else if (CrossAbove (MACD(2,2,5), 0, 1))\n        OpenLong(\"MACDCross\");\n}",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#excludetradehistoryinbacktest",
            "text": "",
            "title": "ExcludeTradeHistoryInBacktest"
        },
        {
            "location": "/strategieprogrammierung/#closelongtrade",
            "text": "",
            "title": "CloseLongTrade()"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_10",
            "text": "CloseLongTrade  erzeugt eine Sell-Order um eine Long Position zu schlie\u00dfen (zu verkaufen).  Siehe auch:  SubmitOrder() ,  CloseShortTrade()",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_9",
            "text": "Siehe  StrategyOrderParameters",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_9",
            "text": "Siehe  StrategyOrderParameters",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#return-value",
            "text": "ein order-Objekt vom Typ IOrder",
            "title": "Return Value"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_10",
            "text": "var order = CloseLongTrade(new StrategyOrderParameters\n{\n    Type = OrderType.Market\n});",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#exitonclose",
            "text": "",
            "title": "ExitOnClose"
        },
        {
            "location": "/strategieprogrammierung/#exitoncloseseconds",
            "text": "",
            "title": "ExitOnCloseSeconds"
        },
        {
            "location": "/strategieprogrammierung/#closeshorttrade",
            "text": "",
            "title": "CloseShortTrade()"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_11",
            "text": "CloseShortTrade  erzeugt eine Buy-to-Cover Order um eine Short Position zu schlie\u00dfen (zu kaufen).  Siehe auch:  SubmitOrder() ,  CloselongTrade()",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_10",
            "text": "Siehe  StrategyOrderParameters",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_10",
            "text": "Siehe  StrategyOrderParameters",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#ruckgabewert",
            "text": "ein order-Objekt vom Typ IOrder",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/strategieprogrammierung/#example",
            "text": "var order = CloseShortTrade(new StrategyOrderParameters\n{\n    Type = OrderType.Stop,\n    Quantity = quantity,\n    StopPrice = price\n});",
            "title": "Example"
        },
        {
            "location": "/strategieprogrammierung/#accountgetvalue",
            "text": "",
            "title": "Account.GetValue()"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_12",
            "text": "Account.GetValue() liefert Informationen \u00fcber das Konto, f\u00fcr das die Strategie ausgef\u00fchrt wird.  Siehe auch   GetProfitLoss() .",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_11",
            "text": "Account.GetValue(AccountItem accountItem)",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_11",
            "text": "M\u00f6gliche Werte f\u00fcr accountItem sind  AccountItem.BuyingPower  AccountItem.CashValue  AccountItem.RealizedProfitLoss",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#ruckgabewert_1",
            "text": "ein double-Wert f\u00fcr das jeweilige AccountItem, F\u00fcr historische Bars wird eine 0 (Null) zur\u00fcckgegeben.",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_11",
            "text": "Print(\"The current account cash value is \" + Account.GetValue(AccountItem.CashValue));\nPrint(\"The current account cash value with the leverage provided by the broker is \" + Account.GetValue(AccountItem.BuyingPower));\nPrint(\"The current P/L already realized is \" + Account.GetValue(AccountItem.RealizedProfitLoss));",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#getentries",
            "text": "",
            "title": "GetEntries()"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_13",
            "text": "Diese Datenserie wird f\u00fcr Conditions verwendet und zeigt mehrfache Einstiegspreise f\u00fcr Einstiegsorders an.",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_12",
            "text": "\u00dcberladung von programmierten Conditions f\u00fcr eine Short und Long Signal Anzeige.",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_12",
            "text": "None",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#ruckgabewert_2",
            "text": "int",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_12",
            "text": "public class MyTestEntry : UserScriptedCondition\n    {\n\n        double _percentage = 100;\n\n        protected override void Initialize()\n        {\n            IsEntry = true;\n            IsStop = false;\n            IsTarget= false;\n            Add(new OutputDescriptor(Color.FromKnownColor(KnownColor.Black), \"Occurred\"));\n            Add(new OutputDescriptor(Color.FromArgb(255, 118, 222, 90), \"Entry1\"));\n            Add(new OutputDescriptor(Color.FromArgb(255, 118, 222, 90), \"Entry2\"));\n            Add(new OutputDescriptor(Color.FromArgb(255, 118, 222, 90), \"Entry3\"));\n            Overlay = true;\n            CalculateOnBarClose = true;\n        }\n\n        protected override void OnBarUpdate()\n        {\n\n            Calculate();\n\n        }\n\n        public override void Recalculate()\n        {\n            Calculate();\n        }\n\n        private void Calculate ()\n        {\n\n            if (TradeDirection == PositionType.Long)\n            {\n                Entry1.Set(Close[0] + 0.5);\n                Entry2.Set(Close[0] + 1);\n                Entry3.Set(Close[0] + 1.5);\n            }\n            else\n            {\n                Entry1.Set(Close[0] - 0.5);\n                Entry2.Set(Close[0] - 1);\n                Entry3.Set(Close[0] - 1.5);\n            }\n        }\n\n        #region Properties\n\n        [Browsable(false)]\n        [XmlIgnore()]\n        public DataSeries Occurred\n        {\n            get { return Values[0]; }\n        }\n\n        [Browsable(false)]\n        [XmlIgnore()]\n        public DataSeries Entry1\n        {\n            get { return Values[1]; }\n        }\n\n        [Browsable(false)]\n        [XmlIgnore()]\n        public DataSeries Entry2\n        {\n            get { return Values[2]; }\n        }\n\n        [Browsable(false)]\n        [XmlIgnore()]\n        public DataSeries Entry3\n        {\n            get { return Values[3]; }\n        }\n\n        public override IList<DataSeries> GetEntrys()\n        {\n            return new[] { Entry1, Entry2, Entry3 };",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#getprofitloss",
            "text": "",
            "title": "GetProfitLoss()"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_14",
            "text": "GetProfitLoss() liefert den aktuell unrealisierten Gewinn bzw. Verlust einer laufenden Position.  Siehe auch  Account.GetValue() .",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#usage",
            "text": "GetProfitLoss(int pLType);",
            "title": "Usage"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_13",
            "text": "M\u00f6gliche Werte f\u00fcr pLType sind  0 - Amount, P/L als W\u00e4hrungsbetrag  1 - Percent, P/L in Prozent  2 \u2013 Risk, P/L in Van Tharp R-Multiples   www.vantharp.com  3 \u2013 P/L in Ticks",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#ruckgabewert_3",
            "text": "ein double-Wert f\u00fcr den unrealisierten Gewinn bzw. Verlust",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_13",
            "text": "Print(\"The current risk for the strategy \" + this.Name + \" is \" + GetProfitLoss(1) + \" \" + Instrument.Currency);\nPrint(\"This equals \"+ string.Format( \"{0:F1} R.\", GetProfitLoss(3)));",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#getprofitlossamount",
            "text": "",
            "title": "GetProfitLossAmount()"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_15",
            "text": "GetProfitLossAmount() liefert den aktuell unrealisierten Gewinn bzw. Verlust einer laufenden Position als W\u00e4hrungsbetrag.  Siehe auch  Account.GetValue() .",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_14",
            "text": "GetProfitLossAmount(double profitLoss);",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_13",
            "text": "Ein Objekt vom Typ double",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#ruckgabewert_4",
            "text": "ein double-Wert f\u00fcr den unrealisierten Gewinn bzw. Verlust",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_14",
            "text": "Print(\"the current P&L \" + this.Name + \" is \" + GetProfitLossAmount(Position.OpenProfitLoss) + \" \" + Instrument.Currency);",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#getprofitlossrisk",
            "text": "",
            "title": "GetProfitLossRisk()"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_16",
            "text": "GetProfitLossRisk() liefert den aktuell unrealisierten Gewinn bzw. Verlust einer laufenden Position in R-Multiplen.  Siehe auch   Account.GetValue() .",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_15",
            "text": "GetProfitLossRisk();",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_14",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#ruckgabewert_5",
            "text": "ein double-Wert f\u00fcr denie R-Multiple",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_15",
            "text": "Print(\"the current P&L \" + this.Name + \" is \" + string.Format( \"{0:F1} R.\", GetProfitLossRisk()));",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#getscriptedcondition",
            "text": "",
            "title": "GetScriptedCondition()"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_17",
            "text": "Mit dieser Methode k\u00f6nnen Benutzer zwischen Skripte zu kommunizieren.",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#isautoconfirmorder",
            "text": "",
            "title": "IsAutoConfirmOrder"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_18",
            "text": "IsAutoConfirmOrder legt fest ob Orders automatisch aktiviert werden. IsAutoConfirmOrder wird in der   OnInit() -Methode angegeben.  Ist IsAutoConfirmOrder = true, dann werden Orders automatisch aktiviert (Default). Wenn IsAutoConfirmOrder der Wert false zugewiesen wurde, dann muss die entsprechende Order mit order.  ConfirmOrder()  aktiviert werden.",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_15",
            "text": "ein bool-Wert",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_16",
            "text": "protected override void OnInit()\n{\n   IsAutoConfirmOrder = false;\n}",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#order",
            "text": "",
            "title": "Order"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_19",
            "text": "IOrder ist ein Objekt, welches Informationen zu einer Order enth\u00e4lt, die aktuell von einer Strategie verwaltet wird.  Die einzelnen Eigenschaften sind:    Action\n     Eine der vier m\u00f6glichen Aktionen:   OrderDirection.Buy  OrderDirection.Sell     AveragePrice \n     Der durchschnittliche Kauf- bzw. Verkaufspreis einer Position. Bei Positionen ohne Teilausf\u00fchrungen entspricht dies dem Einstiegskurs.    FilledQuantity \n    Bei Teilausf\u00fchrungen ist Filled kleiner als Quantity    LimitPrice    Name \n \u00a0 \u00a0Der eindeutige SignalName      OrderId \n    Die eindeutige OrderId    OrderMode \n    Eines der drei m\u00f6glichen Optionen:   OrderMode.Direct  OrderMode.Dynamic  OrderMode.Synthetic     OrderState \n    Hiermit kann der aktuelle Zustand der Order abgefragt werden (siehe   OnOrderExecution  und  OnOrderChanged )   OrderState.Accepted  OrderState.Cancelled  OrderState.CancelRejected  OrderState.FilledQuantity  OrderState.PartFilled  OrderState.PendingCancel  OrderState.PendingReplace  OrderState.PendingSubmit  OrderState.Rejected  OrderState.ReplaceRejected  OrderState.Unknown  OrderState.Working     OrderType \n    M\u00f6gliche Orderarten:   OrderType.Limit  OrderType.Market  OrderType.Stop  OrderType.StopLimit     Quantity \n    Die zu ordernde St\u00fcckzahl    StopPrice    Timestamp \n    Zeitstempel    TimeFrame \n    Der TimeFrame, der f\u00fcr die Order g\u00fcltig ist.    TimeFrame    M\u00f6gliche Methoden:    order Order.Cancel() \n    L\u00f6scht die Order    order.ConfirmOrder() \n    Best\u00e4tig die Order. Diese Methode muss ausgef\u00fchrt werden, wenn IsAutoConfirmOrder auf false gesetzt wird und man die Order dennoch automatisch ausf\u00fchren m\u00f6chte. Dies ist z. B. dann der Fall, wenn eine OCO- oder IfDone-Verk\u00fcpfung hergestellt werden soll.",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#performance",
            "text": "",
            "title": "Performance"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_20",
            "text": "Performance ist ein Objekt, welches Informationen zu allen Trades enth\u00e4lt, die von einer Strategie generiert wurden.  Es gibt mehrere Listen, in denen die Trades eingeordnet sind. Mit Hilfe dieser Listen ist es leicht, weitere Performance-Auswertungen zu erstellen.  Siehe Performance-Kennzahlen.  Die einzelnen Listen sind:    Performance.AllTrades \n    Ist ein   Trade  Collection Objekt, das alle von einer Strategie generierten Trades enth\u00e4lt.    Performance.LongTrades \n    Ist ein  Trade  Collection Objekt, das alle von einer Strategie generierten Long-Trades enth\u00e4lt.    Performance.ShortTrades \n    Ist ein  Trade  Collection Objekt, das alle von einer Strategie generierten ShortTrades enth\u00e4lt.    Performance.WinningTrades \n    Ist ein  Trade  Collection Objekt, das alle von einer Strategie generierten Gewinntrades enth\u00e4lt.    Performance.LosingTrades \n    Ist ein  Trade  Collection Objekt, das alle von einer Strategie generierten Verlusttrades enth\u00e4lt.",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_17",
            "text": "// beim Verlassen der Strategie eine Auswertung erstellen\nprotected override void OnDispose()\n{\nPrint(\"Performance evaluation of the strategy : \" + this.Name);\nPrint(\"----------------------------------------------------\");\nPrint(\"Amount of all trades: \" + Performance.AllTrades.Count);\nPrint(\"Amount of winning trades: \" + Performance.WinningTrades.Count);\nPrint(\"Amount of all loss trades: \" + Performance.LosingTrades.Count);\nPrint(\"Amount of all long trades: \" + Performance.LongTrades.Count);\nPrint(\"Amount of short trades: \" + Performance.ShortTrades.Count);\nPrint(\"Result: \" + Account.RealizedProfitLoss + \" \" + Account.Currency);\n}",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#position",
            "text": "",
            "title": "Position"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_21",
            "text": "Position ist ein Objekt, welches Informationen zu einer Position enth\u00e4lt, die aktuell von einer Strategie verwaltet wird.  Die einzelnen Eigenschaften sind:    Position.AvgPrice \n    Der durchschnittliche Kauf- bzw. Verkaufspreis einer Position.\n    Bei Positionen ohne Teilausf\u00fchrungen entspricht dies dem Einstiegskurs.    Position.CreatedDateTime \n    Datum und Uhrzeit der Positionser\u00f6ffnung.    Position.Instrument \n    Das Handelsinstrument, in welchem die Position besteht.\n    siehe auch  Instruments .    Position.PositionType \n    Eines der drei m\u00f6glichen Positionierungen im Markt:   PositionType.Flat  PositionType.Long  PositionType.Short     Position.OpenProfitLoss \n    Der aktuell noch unrealisierte Gewinn bzw. Verlust.\n    siehe auch  GetProfitLoss() .    Position.ProfitCurrency \n    Gewinn (bzw. Verlust) ausgewiesen als W\u00e4hrungsbetrag.    Position.ProfitPercent \n    Gewinn (bzw. Verlust) ausgewiesen in Prozent.    Position.ProfitPoints \n    Gewinn (bzw. Verlust) ausgewiesen in Punkten bzw. Pips.    Position.Quantity \n    St\u00fcckzahl der Aktien, Kontrakte, CFD's o.\u00e4. in der Position.",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_18",
            "text": "if (Position.PositionType != PositionType.Flat)\n{\nPrint(\"Average price \" + Position.AvgPrice);\nPrint(\"Opening time \" + Position.CreatedDateTime);\nPrint(\"Instrument \" + Position.Instrument);\nPrint(\"Current positioning \" + Position.PositionType);\nPrint(\"Unrealized P/L \" + Position.OpenProfitLoss);\nPrint(\"P/L (currency) \" + Position.ProfitCurrency);\nPrint(\"P/L (in percent) \" + Position.ProfitPercent);\nPrint(\"P/L (in points) \" + Position.ProfitPoints);\nPrint(\"Pieces \" + Position.Quantity);\n}",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#positiontype",
            "text": "Siehe  Position.PositionType .",
            "title": "PositionType"
        },
        {
            "location": "/strategieprogrammierung/#traceorders",
            "text": "",
            "title": "TraceOrders"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_22",
            "text": "Die Eigenschaft TraceOrders ist sehr n\u00fctzlich, um Orders, die von Strategien generiert werden, nachzuverfolgen.\nTraceOrders wird in der  OnInit()  Methode angegeben.  Wenn TraceOrders eingeschaltet ist, werden f\u00fcr jede Order die folgenden Werte im OutputWindow ausgegeben:   Instrument  Time frame  Action  Type  Limit price  Stop price  Quantity  Name   Diese Informationen sind z.B. bei der Erstellung von Strategien und f\u00fcr das Debugging sehr n\u00fctzlich.",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_16",
            "text": "TraceOrders",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_16",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#ruckgabewert_6",
            "text": "true  Tracing ist aktuell eingeschaltet false  Tracing ist abgeschaltet",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_19",
            "text": "protected override void OnInit()\n{\nClearTraceWindow();\nTraceOrders = true;\n}",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#quantity",
            "text": "siehe unter  Position.Quantity ,  Position.PositionType .",
            "title": "Quantity"
        },
        {
            "location": "/strategieprogrammierung/#replaceorder",
            "text": "",
            "title": "ReplaceOrder()"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_23",
            "text": "ChangeOrder \u00e4ndert eine Order.",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_17",
            "text": "ReplaceOrder(IOrder iOrder, int quantity, double limitPrice, double stopPrice)",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_17",
            "text": "iOrder  ein Order -Objekt vom Typ IOrder    quantity  zu ordernde St\u00fcckzahl    limitPrice  Limitpreis. Wenn nicht ben\u00f6tigt, auf 0 setzen    stopPrice  Stoppreis. Wenn nicht ben\u00f6tigt, auf 0 setzen",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_20",
            "text": "private IOrder stopOrder = null;\nprotected override void OnCalculate()\n{\n // Wenn die Position 10 Ticks im Gewinn liegt, Stopp auf Einstand anheben\nif (stopOrder != null\n    && Close[0] >= Position.AvgPrice + (10 * TickSize)\n        && stopOrder.StopPrice < Position.AvgPrice)\nReplaceOrder(stopOrder, stopOrder.Quantity, stopOrder.LimitPrice, Position.AvgPrice);\n}",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#setupprofittarget",
            "text": "",
            "title": "SetUpProfitTarget()"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_24",
            "text": "Serzeugt sofort nach Ausf\u00fchrung einer Einstiegsorder eine Profit Target-Order um eine laufende Position zu einem bestimmten Kurs im Gewinn zu schlie\u00dfen. Die Order wird direkt an den Broker \u00fcbergeben und ist sofort im Markt wirksam.\nWenn das Gewinnziel statisch ist, kann SetUpProfitTarget() in der OnInit() Methode angegeben werden.  Siehe auch   SetUpStopLoss() ,  SetUpTrailStop() .",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_18",
            "text": "SetUpProfitTarget(double currency)\nSetUpProfitTarget(CalculationMode mode, double value)\nSetUpProfitTarget(string fromEntry signal, CalculationMode mode, double value)",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_18",
            "text": "currency  Gibt das Gewinnziel in einer W\u00e4hrung an, z.B. 500,- Euro.    mode  M\u00f6gliche Werte sind: CalculationMode.Percent (Angabe in Prozent); CalculationMode.Price (Angabe  als Kurswert); CalculationMode.Ticks (Angabe in Ticks bzw. Pips)    value  Ein Wert, der den Abstand zwischen Einstiegskurs und Gewinnziel angibt. Die Angabe bezieht sich abh\u00e4ngig von \"mode\" auf einen Geldbetrag, eine Prozentangabe bzw. auf eine Angabe in Ticks.    fromEntry signal  Der Name eines Einstiegssignals, f\u00fcr das eine Profit Target-Order generiert werden soll. Die St\u00fcckzahl wird nur aus der angegebenen Einstiegsorder \u00fcbernommen.",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_21",
            "text": "protected override void OnInit()\n{\n// Erzeugt eine Profit Target-Order 10 Ticks \u00fcber Einstand\nSetUpProfitTarget(CalculationMode.Ticks, 20);\n}",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#setupstoploss",
            "text": "",
            "title": "SetUpStopLoss()"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_25",
            "text": "Set up stop loss erzeugt sofort nach Ausf\u00fchrung einer Einstiegsorder eine StopLoss-Order um eine laufende Position zu einem bestimmten Kurs zu schlie\u00dfen. Die Order wird direkt an den Broker \u00fcbergeben und ist sofort im Markt wirksam (wenn sie nicht simuliert wird, s.u.).  Wenn der StopLoss-Kurs statisch ist, kann SetUpStopLoss() in der OnInit() Methode angegeben werden.  Siehe auch  SetUpProfitTarget() ,  SetUpTrailStop() .",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_19",
            "text": "SetUpStopLoss(double currency)\nSetUpStopLoss(double currency, bool simulated)\nSetUpStopLoss(CalculationMode mode, double value)\nSetUpStopLoss(string fromEntry signal, CalculationMode mode, double value, bool simulated)",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_19",
            "text": "currency  Gibt den StopLoss-Abstand zum Einstiegskurs (=Risiko) in einer W\u00e4hrung an, z.B. 500,- Euro.    mode  M\u00f6gliche Werte sind:  CalculationMode.Percent ( Angabe in Prozent); CalculationMode.Price (Angabe als Kurswert);    CalculationMode.Ticks (Angabe in Ticks bzw. Pips)     simulated  Wenn \"simulated\" auf \"true\" gesetzt ist, wird die Stoporder erst dann live (als Marketorder) zum Broker \u00fcbermittelt, wenn der Kurs sie erstmals \"ber\u00fchrt\" hat (d.h wenn sie ausgel\u00f6st werden w\u00fcrde wenn sie im Markt gelegen h\u00e4tte).    value  Ein Wert, der den Abstand zwischen Einstiegskurs und Stoppkurs angibt. Die Angabe bezieht sich abh\u00e4ngig von \"mode\" auf einen Geldbetrag, eine Prozentangabe bzw. auf eine Angabe in Ticks.    fromEntry signal  Der Name eines Einstiegssignals, f\u00fcr das eine Stoporder generiert werden soll. Die St\u00fcckzahl wird nur aus der angegebenen Einstiegsorder \u00fcbernommen.",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_22",
            "text": "protected override void OnInit()\n{\n// Sets profitTarget 15 Ticks \u00fcber dem Markt\nSetUpStopLoss(\"MACDEntry\", CalculationMode.Ticks, 15, true);\n}",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#setuptrailstop",
            "text": "",
            "title": "SetUpTrailStop()"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_26",
            "text": "SetTrailStop() erzeugt sofort nach Ausf\u00fchrung einer Einstiegsorder eine Trail Stop-Order um eine laufende Position zun\u00e4chst im Verlust zu sch\u00fctzen bzw. nach dem BreakEven den Gewinn zu sichern.  Die Order wird direkt an den Broker \u00fcbergeben und ist sofort im Markt wirksam (wenn sie nicht simuliert wird, s.u.).  Wenn der StopLoss-Kurs und der Offset-Wert statisch ist, kann  SetUpTrailStop() in der OnInit() Methode angegeben werden.  Sollte SetUpTrailStop() in der  OnCalculate()  Methode verwendet werden, um sie dynamisch dem Kursverlauf anpassen zu k\u00f6nnen, ist darauf zu achten, die Parameter vor einer weiteren (neuen) Position auf die gew\u00fcnschten Initialwerte zur\u00fcckzusetzten, da die zuletzt gesetzten Werte ansonsten auch f\u00fcr die neue Position wirksam sind.  Funktionsweise:  Angenommen es ist  SetUpTrailStop(CalculationMode.Ticks, 30) gesetzt:  In einer Long-Position wird der Stop nun 30 Ticks vom jeweils letzten erreichten Hoch entfernt gesetzt. Macht der Markt ein neues Hoch, wird der Stop angepasst. Der Stop wird jedoch nicht mehr nach unten ver\u00e4ndert.  In einer Shortposition ist das Verhalten analog vom erreichten tiefsten Tief ausgehend.  Hinweise:  Es ist nicht m\u00f6glich, in einer Strategie f\u00fcr ein und dieselbe SetUpStopLoss und SetUpTrailStop gleichzeitig zu verwenden. Es wird immer SetUpStopLoss() der Vorrang einger\u00e4umt  Es ist aber m\u00f6glich, in einer Strategie beide Varianten parallel zu verwenden, wenn sie auf unterschiedliche Einstiegssignale referenzieren  Bei Teilausf\u00fchrungen einer einzelnen Order wird f\u00fcr jede Teilposition ein separater Trailing Stop angelegt.  Wird zus\u00e4tzlich zu SetUpProfitTarget() auch SetUpTrailStop(), verwendet, werden beide Orders automatisch OCO-verkn\u00fcpft (OCO = one cancels the other)  Es wird immer eine Stop-Market oder erzeugt, keine Stop-Limit-Order.  Wird die Position innerhalb der Strategie von einer anderen Ausstiegsorder geschlossen, so wird die Trailing-Stoporder automatisch gel\u00f6scht.  Siehe auch  SetUpStopLoss() ,  SetUpProfitTarget() .",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_20",
            "text": "SetUpTrailStop(double currency)\nSetUpTrailStop(double currency, bool simulated)\nSetUpTrailStop(CalculationMode mode, double value)\nSetUpTrailStop(string fromEntry signal, CalculationMode mode, double value, bool simulated)",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_20",
            "text": "currency  Gibt den StopLoss-Abstand zum Einstiegskurs (=Risiko) in einer W\u00e4hrung an, z.B. 500,- Euro.    mode  M\u00f6gliche Werte sind:  CalculationMode.Percent;  CalculationMode.Ticks    simulated  Wenn \"simulated\" auf \"true\" gesetzt ist, wird die Trail-Stoporder erst dann live (als Marketorder) zum Broker \u00fcbermittelt, wenn der Kurs sie erstmals \"ber\u00fchrt\" hat (d.h wenn sie ausgel\u00f6st werden w\u00fcrde wenn sie im Markt gelegen h\u00e4tte).    value  Ein Wert, der den Abstand zwischen Einstiegskurs und Stoppkurs angibt. Die Angabe bezieht sich abh\u00e4ngig von \"mode\" auf einen Geldbetrag, eine Prozentangabe bzw. auf eine Angabe in Ticks.    fromEntry signal  Der Name eines Einstiegssignals, f\u00fcr das eine Trail-Stoporder generiert werden soll. Die St\u00fcckzahl wird nur aus der angegebenen Einstiegsorder \u00fcbernommen.",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_23",
            "text": "protected override void OnInit()\n{\n// Setzt einen Trailing Stop von 30 Ticks\n    SetUpTrailStop(CalculationMode.Price, Low[0]);\n}",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#strategyorderparameters",
            "text": "",
            "title": "StrategyOrderParameters"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_27",
            "text": "Diese Klasse aggregiert alle Eigenschaften, die zum \u00dcbergeben der Bestellung ben\u00f6tigt werden.  Siehe  SubmitOrder() ,  CloseLongTrade() ,  CloseShortTrade() .",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_21",
            "text": "public class StrategyOrderParameters\n    {\n        public OrderDirection Direction { get; set; }\n        public OrderMode Mode { get; set; } = OrderMode.Direct;\n        public OrderType Type { get; set; }\n        public bool LiveUntilCancelled { get; set; }\n        public int Quantity { get; set; }\n        public double Price { get; set; }\n        public double StopPrice { get; set; }\n        public string SignalName { get; set; } = String.Empty;\n        public IInstrument Instrument { get; set; }\n        public ITimeFrame TimeFrame { get; set; }\n        public string FromEntrySignal { get; set; } = String.Empty;\n    }",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_21",
            "text": "OrderDirection  M\u00f6gliche Werte sind: OrderDirection.Buy Kauforder zum Long-Einstieg; OrderDirection.Sell Verkaufsorder zum Schlie\u00dfen einer Long-Position;    OrderMode  One of three possible positions in the market: Direct, Dynamic, Synthetic    OrderType  M\u00f6gliche Werte sind: OrderType.Limit, OrderType.Market, OrderType.Stop, OrderType.StopLimit    LiveUntilCancelled  Die Order wird nicht am Ende des Bars gel\u00f6scht, sondern bleibt so lange aktiv, bis sie mit  Order.Cancel   gel\u00f6scht wird, bzw. bis ihre Ablaufzeit (siehe  TimeInForce ) erreicht ist.    Quantity  St\u00fcckzahl    Price  Limit-Kurs. Die Angabe einer 0 (Null) bedeutet, dass dieser Parameter irrelevant ist.    StopPrice  Stop-Kurs. Die Angabe einer 0 (Null) bedeutet, dass dieser Parameter irrelevant ist    SignalName  Ein eindeutiger Signalname (string)    Instrument  Das Handelsinstrument, in welchem die Position besteht.    TimeFrame  T Der TimeFrame, der f\u00fcr die Order g\u00fcltig ist.    FromEntrySignal  Der Name eines Einstiegssignals, f\u00fcr das eine Trail-Stoporder generiert werden soll. Die St\u00fcckzahl wird nur aus der angegebenen Einstiegsorder \u00fcbernommen.",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#submitorder",
            "text": "",
            "title": "SubmitOrder()"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_28",
            "text": "SubmitOrder erzeugt eine benutzerdefinierte Order. F\u00fcr diese Order wird kein Stop und kein Limit in den Markt gelegt. Alle Kontrollmechanismen von AgenaTrader sind f\u00fcr diese Orderart abgeschaltet. Der Nutzer ist f\u00fcr die Verwaltung, Stop, Target und f\u00fcr die Behandlung von Teilausf\u00fchrungen selbst verantwortlich und kann sich ein Ordermanagement nach seinen eigenen W\u00fcnschen selbst erstellen.  Siehe auch   OnOrderChanged() ,  OnOrderExecution() .",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_22",
            "text": "Siehe  StrategyOrderParameters",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#parameter_22",
            "text": "Siehe  StrategyOrderParameters",
            "title": "Parameter"
        },
        {
            "location": "/strategieprogrammierung/#ruckgabewert_7",
            "text": "an order object of the type \"IOrder\"",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_24",
            "text": "// Limit Long order\nSubmit Limit Buy\nvar order = SubmitOrder(new StrategyOrderParameters\n                {\n                    Direction = OrderDirection.Buy,\n                    Type = OrderType.Limit,\n                    Mode = orderMode,\n                    Price = limitPrice,\n                    Quantity = quantity,\n                    SignalName = entryName,\n                    Instrument = Instrument,\n                    TimeFrame = TimeFrame,\n                    LiveUntilCancelled = true\n                });\n\n// Short Market order\nSubmit Sell Market\nvar order = SubmitOrder(new StrategyOrderParameters\n            {\n                Direction = OrderDirection.Sell,\n                Type = OrderType.Market,\n                Mode = ordermode,\n                Quantity = quantity,\n                SignalName = entryName,\n                Instrument = Instrument,\n                TimeFrame = TimeFrame\n            });",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#timeinforce",
            "text": "",
            "title": "TimeInForce"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_29",
            "text": "Die Eigenschaft TimeInForce bestimmt die G\u00fcltigkeitsdauer einer Order. Die G\u00fcltigkeitsdauer ist davon abh\u00e4ngig, welche Werte von einem Broker akzeptiert werden.  TimeInForce wird in der  OnInit()  Methode angegeben.  M\u00f6gliche Werte sind:\nTimeInForce.day\nTimeInForce.loc\nTimeInForce.gtc (GTC = good till canceled)\nTimeInForce.gtd  Default:  TimeInForce.GTC",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#verwendung_23",
            "text": "TimeInForce",
            "title": "Verwendung"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_25",
            "text": "protected override void OnInit()\n{\nTimeInForce = TimeInForce.Day;\n}",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#trade",
            "text": "",
            "title": "Trade"
        },
        {
            "location": "/strategieprogrammierung/#beschreibung_30",
            "text": "Trade ist ein Objekt, welches Informationen zu einem Trade enth\u00e4lt, der von einer Strategie ausgef\u00fchrt wurde bzw. der aktuell l\u00e4uft.  Die einzelnen Eigenschaften sind:    Trade.AvgPrice \n    durchschnittlicher Einstiegskurs    Trade.ClosedProfitLoss \n    bereits realisierter Gewinn bzw. Verlust    Trade.Commission \n    Geb\u00fchren (Kommissionen)    Trade.CreatedDateTime \n    Zeitpunkt der Er\u00f6ffnung eines Trades    Trade.EntryReason \n    Bezeichnung des Einstiegssignals\n    bei Strategien: Name der Strategie    Trade.ExitDateTime \n    Zeitpunkt, an dem der Trade geschlossen wurde    Trade.ExitPrice \n    Ausstiegskurs    Trade.ExitReason \n    Bezeichnung des Ausstiegssignals\n    bei Strategien: Name der Strategie    Trade.Instrument \n    Bezeichnung des Handelsinstrumentes    Trade.PositionType \n    Positionierung im Markt   PositionType.Flat  PositionType.Long  PositionType.Short     Trade.OpenProfitLoss \n    noch unrealisierter Gewinn bzw. Verlust in einer laufenden Position    Trade.ProfitCurrency \n    Gewinn bzw. Verlust in der W\u00e4hrung, in der das Handelskonto gef\u00fchrt wird    Trade.ProfitLoss \n    Gewinn bzw. Verlust    Trade.ProfitPercent \n    Gewinn bzw. Verlust in Prozent    Trade.ProfitPercentWithCommission \n    Gewinn bzw. Verlust in Prozent mit Geb\u00fchren    Trade.ProfitPoints \n    Gewinn bzw. Verlust in Punkten bzw. Pips    Trade.Quantity \n    St\u00fcckzahl von Aktien, CFD, Kontrakten usw.    Trade.TimeFrame \n    Zeiteinheit, in der der Trade er\u00f6ffnet wurde    Trade.Url \n    URL zum Snapshot des Charts zum Zeitpunkt der Er\u00f6ffnung",
            "title": "Beschreibung"
        },
        {
            "location": "/strategieprogrammierung/#beispiel_26",
            "text": "protected override void OnDispose()\n{\n  if (Performance.AllTrades.Count < 1) return;\n  foreach (ITrade trade in Performance.AllTrades)\n  {\n    Print(\"Trade #\"+trade.Id);\n    Print(\"--------------------------------------------\");\n    Print(\"Durchschnittspreis \" + trade.AvgPrice);\n    Print(\"realisierter G/V \" + trade.ClosedProfitLoss);\n    Print(\"Geb\u00fchren \" + trade.Commission);\n    Print(\"Zeitpunkt Einstieg \" + trade.CreatedDateTime);\n    Print(\"Bezeichnung Einst \" + trade.EntryReason);\n    Print(\"Zeitpunkt Ausstieg  \" + trade.ExitDateTime);\n    Print(\"Ausstiegskurs  \" + trade.ExitPrice);\n    Print(\"Bezeichnung Ausstieg  \" + trade.ExitReason);\n    Print(\"Instrument \" + trade.Instrument);\n    Print(\"Positionierung \" + trade.PositionType);\n    Print(\"unrealisierter G/V \" + trade.OpenProfitLoss);\n    Print(\"G/V (W\u00e4hrung) \" + trade.ProfitCurrency);\n    Print(\"G/V \" + trade.ProfitLoss);\n    Print(\"G/V (in Prozent) \" + trade.ProfitPercent);\n    Print(\"G/V (in % mit Geb\u00fchren)\" + trade.ProfitPercentWithCommission);\n    Print(\"GV (in Punkten) \" + trade.ProfitPoints);\n    Print(\"St\u00fcckzahl \" + trade.Quantity);\n    Print(\"Zeiteinheit \" + trade.TimeFrame);\n    Print(\"URL zum Snapshot \" + trade.Url);\n  }\n}",
            "title": "Beispiel"
        },
        {
            "location": "/strategieprogrammierung/#unmanaged",
            "text": "",
            "title": "Unmanaged"
        },
        {
            "location": "/strategieprogrammierung/#backtesting-and-optimization",
            "text": "",
            "title": "Backtesting and Optimization"
        },
        {
            "location": "/strategieprogrammierung/#performance-characteristics",
            "text": "Unter Performance-Kennzahlen werden verschiedene Kennzahlen verstanden, die jeweils f\u00fcr eine Liste von Trades berechnet werden k\u00f6nnen. Die Trades k\u00f6nnen von einer Strategie in Realtime generiert worden sein oder von einem Backtestlauf stammen.  Es stehen folgende Listen zur Verf\u00fcgung:   alle trades  alle long trades  alle short trades  alle winning trades  alle losing trades   Siehe hierzu   Performance .  Die einzelnen Kennzahlen sind:  AvgEtd \nder durchschnittliche DrawDown am Ende eines Trades (avg end trade drawdown)\n<TradeCollection>.TradesPerformance.<TradesPerformanceValues>.AvgEtd  Print(\"Average ETD of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.AvgEtd);  AvgMae \nder durchschnittliche max. Kursr\u00fcckgang nach den Einstiegen (avg maximum adverse excursion)\n<TradeCollection>.TradesPerformance.<TradesPerformanceValues>.AvgMae  Print(\"Average MAE of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.AvgMae);  AvgMfe \nder durchschnittliche max Kursanstieg im Verlauf der Trades (avg maximum favorable excursion)\n<TradeCollection>.TradesPerformance.<TradesPerformanceValues>.AvgMfe  Print(\"Average MFE of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.AvgMfe);  AvgProfit \nder durchschnittliche Gewinn \u00fcber alle Trades (avg profit)\n<TradeCollection>.TradesPerformance.<TradesPerformanceValues>.AvgProfit  Print(\"Average profit of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.AvgProfit);  CumProfit \nder Gesamtgewinn \u00fcber alle Trades\n<TradeCollection>.TradesPerformance.<TradesPerformanceValues>.CumProfit  Print(\"Average cumulative profit of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.CumProfit);  DrawDown \nder DrawDown \u00fcber alle Trades\n<TradeCollection>.TradesPerformance.<TradesPerformanceValues>.DrawDow  Print(\"Drawdown of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.DrawDown);  LargestLoser \nder gr\u00f6\u00dfte Verlust\n<TradeCollection>.TradesPerformance.<TradesPerformanceValues>.LargestLoser  Print(\"Largest loss of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.LargestLoser);  LargestWinner \nder gr\u00f6\u00dfte Gewinn\n<TradeCollection>.TradesPerformance.<TradesPerformanceValues>.LargestWinner  Print(\"Largest win of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.LargestWinner);  ProfitPerMonth \nhochgerechneter Gewinn/Verlust im Monat (auch in Prozent)\n<TradeCollection>.TradesPerformance.<TradesPerformanceValues>.ProfitPerMonth  Print(\"Profit per month of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.ProfitPerMonth);  StdDev \ndie Standardabweichung der Gewinne bzw. Verluste. Hier k\u00f6nnen Ausrei\u00dfer erkannt werden. Je besser ein Handelssystem ist, desto kleiner ist die Standardabweichung und desto h\u00f6her ist die Erwartung von Gewinnen.  Alle Kennzahlen sind double-Werte.",
            "title": "Performance Characteristics"
        },
        {
            "location": "/schluesselworte/",
            "text": "Schl\u00fcsselworte\n\n\nAdd()\n\n\nBeschreibung\n\n\nMit der Methode Add() werden dem Chart Plot - bzw. Line-Objekte  hinzugef\u00fcgt. Wenn mit Add() ein neues Plot-Objekt hinzugef\u00fcgt wird, wird automatisch auch eine Datenserie vom Typ DataSeries erzeugt, die diesem Plot zugeordnet ist. Auf diese Datenserie kann \u00fcber die Value-Collection zugegriffen werden.\nAdd() kann in der  OnInit() Methode und in der OnCalculate() Methode verwendet werden..\n\n\nParameter\n\n\nplot \u2013 ein \nOnPaint\n Objekt\nline \u2013 ein \nLevelLine\n Objekt\n\n\nVerwendung\n\n\nAdd(OnPaint plot)\nAdd(LevelLine line)\n\n\n\n\nBeispiel\n\n\n#region Usings\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Linq;\nusing System.Xml;\nusing System.Xml.Serialization;\nusing AgenaTrader.API;\nusing AgenaTrader.Custom;\nusing AgenaTrader.Plugins;\nusing AgenaTrader.Helper;\n#endregion\nnamespace AgenaTrader.UserCode\n{\n  [Description(\"Enter the description for the new custom indicator here\")]\n  public class MyIndicator : UserIndicator\n  {\n    protected override void OnInit()\n    {\n    // 2 blaue Linien in den Chart legen, eine bei 70 und eine bei 30\n    Add(new LevelLine(Color.Blue, 70, \"UpperLine\"));\n    Add(new LevelLine(Color.Blue, 30, \"LowerLine\"));\n\n   // 2 Plots hinzuf\u00fcgen\n    Add(new OnPaint(Color.Red, \"myFastSMA\"));\n    Add(new OnPaint(Color.Blue, \"mySlowSMA\"));\n    }\n\n    protected override void OnCalculate()\n    {\n   //Mit der Set-Methode wird der Wert f\u00fcr den aktuellen Bar zugewiesen.\n    FastSMA.Set( SMA(8)[0] ); // ist identisch mit Values[0].Set( SMA(8)[0] );\n    SlowSMA.Set( SMA(50)[0] );// ist identisch mit Values[1].Set( SMA(50)[0] );\n    }\n\n    / Hier werden 2 Datenserien zur Verf\u00fcgung gestellt.\n        // Zur Darstellung des Indikators auf dem Chart sind diese nicht notwendig.\n        // Mit Hilfe dieser Datenserien kann von anderen Indikatoren aus auf diesen Indikator\n        // zugegriffen werden.\n        // Z.B. mit double d = MeinIndikator.FastSMA[0] - MeinIndikator.SlowSMA[0];\n    [Browsable(false)]\n    [XmlIgnore()]\n    public DataSeries FastSMA\n    {\n      get { return Outputs[0]; }\n    }\n\n    [Browsable(false)]\n    [XmlIgnore()]\n    public DataSeries SlowSMA\n    {\n      get { return Outputs[1]; }\n    }\n  }\n}\n\n\n\n\nAllowRemovalOfChartDrawings\n\n\nBeschreibung\n\n\nAllowRemovalOfDrawObjects ist eine Eigenschaft von Indikatoren, die in der Methode \nOnInit()\n gesetzt werden kann..\n\n\nAllowRemovalOfChartDrawings = true\n\n\nZeichenobjekte (DrawObjects), die von einem Indikator bzw. einer Strategie in einen Chart gezeichnet wurden, k\u00f6nnen manuell aus dem Chart entfernt werden.\n\n\nAllowRemovalOfChartDrawings = false (default)\n\n\nZeichenobjekte (DrawObjects), die von einem Indikator bzw. einer Strategie in einen Chart gezeichnet wurden, k\u00f6nnen nicht manuell aus dem Chart entfernt werden. Sie werden erst dann vom Chart entfernt, wenn auch der Indikator bzw. die Strategie entfernt wird.\n\n\nDie Eigenschaft kann abgefragt werden, und liefert \"true\" bzw. \"false\".\n\n\nVerwendung\n\n\nAllowRemovalOfChartDrawings\n\n\n\n\nBeispiel\n\n\nprotected override void OnInit()\n{\nAdd(new OnPaint(Color.Red, \"MyPlot1\"));\n//DrawObjects k\u00f6nnen aus dem Chart manuell entfernt werden\nAllowRemovalOfChartDrawings = true;\n}\n\n\n\n\nAttribute\n\n\nAttribute sind Bestandteil der Programmiersprache C#. In eigenen AgenaScript-Indikatoren bzw. Strategien k\u00f6nnen Attribute genauso verwendet werden, wie es auch in C# selbst m\u00f6glich ist.\nInformationen \u00fcber Die Verwendung von Attributen finden Sie u.a. hier:\n\n\nhttp://msdn.microsoft.com/de-de/library/z0w1kczw%28v=vs.80%29.aspx\n\n\nDie in AgenaScript am h\u00e4ufigsten verwendeten Attribute sind:\n\n\n\n\nBrowsable\n\n\nCategory\n\n\nConditionalValue\n\n\nDescription\n\n\nDisplayName\n\n\nTimeFrameRequirements\n\n\nXmlIgnore\n\n\n\n\nBrowsable\n\n\nBrowsable ist ein  \nAttribute\n  in AgenaScript.\n\n\nIn AgenaScript werden \u00f6ffentliche Variablen (public variables) zum einen f\u00fcr die Eingabe von Parametern f\u00fcr Indikatoren genutzt (z.B. die Periode f\u00fcr einen SMA) und zum anderen f\u00fcr die Ausgabe von Ergebnissen einer Berechnung innerhalb eines Indikators (z.B. Datenserien).\nVariablen, die der Eingabe von Parametern dienen, m\u00fcssen im Eigenschaften-Dialog angezeigt werden. Datenserien hingegen nicht.\n\n\nEine public Variable, die mit dem Attribut Browsable=false gekennzeichnet wurde, wird nicht im Eigenschaftendialog von AgenaTrader angezeigt.\n\n\nStandardm\u00e4\u00dfig wird Browsable = true angenommen. Daher kann bei einer Variable, die einen Eingabeparameter beinhaltet, das Attribut Browsable auch weggelassen weren.\n\n\nBeispiel f\u00fcr einen Parameter:\n\n\nDer Parameter soll im Eigenschaftsfenster angezeigt und abgefragt werden. Daher ist \"Browsable = true\" zu setzen oder das Attribut kann entfallen.\n\n\n[Description(\"Numbers of bars used for calculations\")]\n[Category(\"InputParameter\")]\npublic int Period\n{\nget { return period; }\nset { period = Math.Max(1, value); }\n}\n\n\n\n\nBeispiel f\u00fcr eine Datenserie:\n\n\n[Browsable(false)]\n[DisplayName(\"Lower band\")]\n[XmlIgnore]\npublic DataSeries Lower\n{\nget { return Outputs[0]; }\n}\n\n\n\n\nCategory\n\n\nCategory ist ein \nAttribute\n in AgenaScript.\n\n\nDas Attribut Category gibt f\u00fcr einen Parameter an, unter welcher Kategorie im Eigenschaften-Dialog der Parameter erscheint.\n\n\nWenn das Attribut fehlt, wird standardm\u00e4\u00dfig die Kategorie \"InputParameter\" angenommen.\n\n\nDas folgende Beispiel erzeugt im Eigenschaften-Dialog die neue Kategorie \"My InputParameter\".\n\n\n[Category(\"My InputParameter\")]\n[DisplayName(\"Period number\")]\npublic double _period\n{\nget { return _period; }\nset { _period = value; }\n}\n\n\n\n\n\n\nCategory ist ein  \nAttribute\n in AgenaScript.\n\n\nDas Attribut Category gibt f\u00fcr einen Parameter an, unter welcher Kategorie im Eigenschaften-Dialog der Parameter erscheint.\n\n\nWenn das Attribut fehlt, wird standardm\u00e4\u00dfig die Kategorie \"InputParameter\" angenommen.\n\n\nDas folgende Beispiel erzeugt im Eigenschaften-Dialog die neue Kategorie \"My InputParameter\".\n\n\nnamespace AgenaTrader.UserCode\n{\n    [Description(\"Description what this indicator doing.\")]\n    [Category(\"My Package\")]\n    public class MyHolyGrail_Indicator : UserIndicator\n    {\n        /* your code here */\n    }\n}\n\n\n\n\nConditionalValue\n\n\nConditionalValue ist ein \nAttribute\n in AgenaScript.\n\n\nNormalerweise werden im ConditionEscort f\u00fcr Vergleiche die von Indikatoren bereitgestellten Datenserien (DataSeries) benutzt. Beispielsweise wird gepr\u00fcft, ob ein gleitender Durchschnitt \u00fcber oder unter einem bestimmten Kurswert liegt.\nEin Indikator kann aber auch Werte als Ergebnis haben, die keine Datenserien sind, also z.B. Werte vom Typ int, double, char, boolean, string usw.\n\n\nUm diese Werte im Scanner oder im Condition-Escort nutzen zu k\u00f6nnen, m\u00fcssen sie mit dem Attribut \"ConditionalValue\" gekennzeichnet sein.\n\n\n[Browsable(false)]\n[XmlIgnore]\n[ConditionalValue]\npublic int PublicVariable\n{\nget\n{\nUpdate();\nreturn _internVariable;\n}\n}\n\n\n\n\nDescription\n\n\nDescription ist ein  \nAttribute\n in AgenaScript.\n\n\nDas Attribute Description wird In AgenaScript f\u00fcr die Klasse und f\u00fcr public-Variablen verwendet.\n\n\nAls Attribut der Klasse ist der Text eine Beschreibung der Funktion des gesamten Indikators (bzw. der Strategie usw.)\n\n\n[Description(\"Displays the tick count of a bar.\")]\npublic class TickCounter : UserIndicator\n{\n\n\n\n\nAs an attribute of a public variable, the text is a description of the function of the parameter.\n\n\n[Description(\"Number of standard deviations\")]\n[DisplayName(\"# of std. dev.\")]\npublic double NumStdDev\n{\nget { return numStdDev; }\nset { numStdDev = Math.Max(0, value); }\n}\n}\n\n\n\n\nDie Beschreibungen werden jeweils im Eigenschaften-Dialog angezeigt.\n\n\nDisplayName\n\n\nDisplayName ist ein \nAttribute\n in AgenaScript.\n\n\nDas Attribute DisplayName legt den Text fest, der im Eigenschaften-Dialog f\u00fcr den Parameter verwendet werden soll.\n\n\nWird dieses Attribut nicht angegeben, wird der Name der public Variable verwendet.\n\n\n[Description(\"Number of standard deviations\")]\n[DisplayName(\"# of std. dev.\")]\npublic double NumStdDev\n{\nget { return numStdDev; }\nset { numStdDev = Math.Max(0, value); }\n}\n\n\n\n\nTimeFrameRequirements\n\n\nTimeFrameRequirements ist ein \nAttribute\n in AgenaScript.\n\n\nSollen in einem AgenaScript Daten verschiedener Zeiteinheiten verwendet werden, ist der Klasse das Attribut \"TimeFrameRequirements\" voranzustellen. Es k\u00f6nnen hier auch mehrere Zeiteinheiten angegeben werden:\n\n\n[TimeFrameRequirements(\"1 day\")]\n[TimeFrameRequirements(\"15 minutes\", \"1 day\", \"1 week\")]\n\n\n\n\nEs werden immer so viele Daten der anderen Zeiteinheit(en) bereitgestellt, wie auch Kerzen im Chart geladen sind.\nSind in einem 5 Minuten-Chart beispielsweise 500 Kerzen geladen, werden auch 500 Kerzen einer anderen Zeiteinheit geladen.\nIm Beispiel oben also 500 Tageskerzen bzw. im 2. Beispiel 500 15-Minuen-Kerzen, 500 Tageskerzen und 500 Wochenkerzen.\nDie Datenmengen k\u00f6nnen schnell sehr gro\u00df werden. Das Attribut ist daher mit Umsicht zu verwenden.\n\n\nsiehe auch \nMultiBars\n.\n\n\nWichtig:\n\n\nWenn in einer Klasse ein anderer Indikator verwendet wird, der seinerseits eine (oder mehrere) sekund\u00e4re Zeiteinheit(en) erfordert, mu\u00df f\u00fcr die aufrufende Klasse ebenfalls das Attribut \"TimeFrameRequirements\" angegeben werden. Ein Beispiel hierzu siehe unter \nGetDayBar\n.\n\n\nXMLIgnore\n\n\nXML ignore st ein \nAttribute\n in AgenaScript.\n\n\nAgenaTrader speichert in einem Template u.a. auch alle Parameter-Einstellungen eines Indikators. Die Template-Files liegen im XML-Format vor. Um zu verhindern, dass ein Parameter als Teil eines Templates gespeichert wird, kann das Attribut \"XmlIgnore\" angegeben werden.\n\n\nUm Parameter in einem XML-File speichern zu k\u00f6nnen, m\u00fcssen die Werte zuvor serialisiert werden. In den meisten F\u00e4llen, d.h. f\u00fcr alle g\u00e4ngigen Variablentypen geschieht dies durch AgenaTrader automatisch. Selbst definierte Datentypen k\u00f6nnen jedoch nicht automatisch serialisiert werden. Der Programmierer mu\u00df selbst f\u00fcr die korrekte Serialisierung sorgen.\n\n\nIm Beispiel werden Farbe und Schriftart als Parameter eines Indikators verwendet. In AgenaTrader existieren f\u00fcr die Serialisierung von Farb- und Schriftart-Informationen 2 Methoden (TextColorSerialize und TextFontSerialize), die die Serialisierung \u00fcbernehmen. Die beiden Parameter \"TextColor\" und \"TextFont\" sind daher mit dem Attribute \"XmlIgnore\" zu kennzeichnen.\n\n\nprivate Color _textColor = Color.Blue;\nprivate Font _textFont = new Font(\"Arial\", 12, FontStyle.Bold);\n[XmlIgnore]\n[Description(\"Textcolor\")]\npublic Color TextColor\n{\nget { return _textColor; }\nset { _textColor = value; }\n}\n[Browsable(false)]\npublic string TextColorSerialize\n{\nget { return SerializableColor.ToString(_textColor); }\nset { _textColor = SerializableColor.FromString(value); }\n}\n[XmlIgnore()]\n[Description(\"TextFont\")]\npublic Font TextFont\n{\nget { return _textFont; }\nset { _textFont = value; }\n}\n[Browsable(false)]\npublic string TextFontSerialize\n{\nget { return SerializableFont.ToString(_textFont); }\nset { _textFont = SerializableFont.FromString(value); }\n}\n\n\n\n\nCalculateOnClosedBar\n\n\nBeschreibung\n\n\nDie Eigenschaft \"CalculateOnClosedBar\" legt fest, f\u00fcr welche Ereignisse AgenaTrader die Methode  OnCalculate() aufrufen soll.\n\n\nCalculateOnClosedBar = true\n\n\n\n\nOnCalculate()\n  wird aufgerufen, wenn ein Bar beendet ist, und der n\u00e4chste hereinkommende Tick einen neuen Bar entstehen l\u00e4\u00dft.\n\n\nCalculateOnClosedBar = false\n\n\n\n\nOnCalculate() wird f\u00fcr jeden neu hereinkommenden Tick aufgerufen.\nAchtung bei \u00e4lterer Hardware: dies f\u00fchrt bei sehr liquiden Werten zu einer erh\u00f6hten Rechnerbelastung.\nDie Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false).\nCalculateOnClosedBar  kann sowohl in OnInit() aals auch in OnCalculate() eingesetzt werden..\nOnCalculate wird f\u00fcr historische Daten immer nur f\u00fcr den Schlusskurs eines jeden Bars aufgerufen, auch wenn CalculateOnClosedBar=false gesetzt ist.\nWird ein Indikator von einem anderen Indikator aufgerufen, so wird die Eigenschaft  CalculateOnClosedBar des aufgerufenen Indikators vom aufrufenden Indikator \u00fcberschrieben.\n\n\nVerwendung\n\n\nCalculateOnClosedBar\n\n\nWeitere Informationen\n\n\nSiehe auch die Beschreibung zu \nBars\n.\n\n\nBeispiel\n\n\nprotected override void OnInit()\n{\n//Indikatorberechnung nur, wenn ein Bar fertig ausgepr\u00e4gt ist\nCalculateOnClosedBar = true;\n}\n\n\n\n\nChart\n\n\nChart  ist ein Objekt, \u00fcber welches der lesende Zugriff auf verschiedene Eigenschaften des Charts m\u00f6glich ist.\n\n\nDie wichtigsten Eigenschaften sind:\n\n\n\n\nChartFontColor, BackColor\n\n\nUpColor, DownColor\n\n\nFont\n\n\nBarMarginLeft, BarMarginRight\n\n\nBarSpace, BarWidth\n\n\nBarsPainted\n\n\nFirstBarPainted, LastBarPainted\n\n\nBarsVisible\n\n\nFirstBarVisible, LastBarVisible\n\n\nGetXByBarIdx, GetYByValue\n\n\n\n\nZur Verwendung der wichtigsten Eigenschaften von Chart siehe Beispiel \nPlotSample\n.\n\n\nBarsPainted und BarsVisible:\n\n\nBarsPainted enth\u00e4lt die Anzahl der Bars, die ein Chart von seinem linken Rand zu seinem rechten Rand mit der momentanen Breite der\n\n\nKerzen und dem Abstand der Kerzen zueinander anzeigen \nk\u00f6nnte\n.\n\n\nBarsVisible enth\u00e4lt die Anzahl der Bars, die tats\u00e4chlich zu sehen sind.\n\n\nFirstBarPainted und FirstBarVisible:\n\n\nFirstBarPainted enth\u00e4lt die Nummer des Bars, der am linken Rand des Charts angezeigt werden \nw\u00fcrde\n.\n\n\nFirstBarVisible  enth\u00e4lt die Nummer des Bars, der tats\u00e4chlich als erster Bar links im Chart angezeigt wird.\n\n\nBeispiel: der Chart ist so verschoben, dass der erste Bar des Charts erst in der Mitte des Charts angezeigt wird.\n\n\nFirstBarPainted w\u00e4re in diesem Fall negativ.\n\n\nFirstBarVisible  w\u00e4re 0.\n\n\nLastBarPainted und LastBarVisible:\n\n\nLastBarPainted enth\u00e4lt die Nummer des Bars, der am rechten Rand des Charts angezeigt werden \nw\u00fcrde\n.\n\n\nLastBarVisible  enth\u00e4lt die Nummer des Bars, der tats\u00e4chlich als letzter Bar rechts im Chart angezeigt wird.\n\n\nBeispiel: der Chart ist so verschoben, dass der letzte Bar des Charts bereits in der Mitte des Charts angezeigt wird.\n\n\nLastBarPainted w\u00e4re in diesem Fall gr\u00f6\u00dfer als Bars.Count.\n\n\nLastBarVisible w\u00e4re in Bars.Count -1.\n\n\nClearTraceWindow()\n\n\nBeschreibung\n\n\nDie Methode ClearTraceWindow() leert das Output-Fenster. Die Methode kann sowohl in OnInit() als auch in OnCalculate() eingesetzt werden.\nDas OutputWindow beinhaltet alle Ausgaben, die mit dem \nPrint()\n -Befehl erstellt wurden.\nDer Einsatz des OutputWindows ist eine sehr gute M\u00f6glichkeit f\u00fcr Code-Debugging.\n\n\nVerwendung\n\n\nClearTraceWindow()\n\n\n\n\nParameter\n\n\nkeiner\n\n\nR\u00fcckgabewert\n\n\nkeiner\n\n\nBeispiel\n\n\nprotected override void OnInit()\n{\n//Inhalt des OutputWindow l\u00f6schen\nClearTraceWindow();\n}\n\n\n\n\nColors\n\n\nIn AgenaSript stehen die folgenden Befehle f\u00fcr Farbfestlegungen bzw. -\u00e4nderungen im Chart zur Verf\u00fcgung:\n\n\nBackColor\n Hintergrundfarbe des Kurs-Charts\n\n\nBackColorAll\n Hintergrundfarbe des Kurs-Charts und aller Indikator-Panels\n\n\nBackColorAllSeries\n\n\nBackColorSeries\n\n\nChart.UpColor Farbe f\u00fcr Up Ticks (Up Bars)\nChart.DownColor Farbe f\u00fcr Down Ticks (Down Bars)\n\n\nF\u00fcr jeden Bar werden seine Farben in folgenden Dataserien gespeichert. Wird in diese Datenserien geschrieben, \u00e4ndern sich die Farben des referenzierten Bars.\n\n\nBarColor\n Farbe eines Bars\n\n\nBarColorSeries\n\n\nCandleOutlineColor\n\n\nCandleOutlineColorSeries\n\n\nBackColor\n\n\nBeschreibung\n\n\nBackColor \u00e4ndert die Hintergrundfarbe eines Bars bzw. gibt die aktuelle Hintergrundfarbe eines Bars zur\u00fcck.\n\n\nSiehe auch \nColors\n, \nBarColor\n, \nBackColor\n, \nBackColorAll\n, \nBarColorSeries\n, \nBackColorAll\n, \nCandleOutlineColor\n.\n\n\nParameter\n\n\nein Color-Objekt vom Typ  public struct Color\n\n\nVerwendung\n\n\nBackColor\n\n\nBeispiele\n\n\n// immer montags Bar-Hintergrundfarbe auf Blau \u00e4ndern\nif (Time[0].DayOfWeek == DayOfWeek.Monday)\nBackColor = Color.Blue;\n\n\n\n\n\n\n// \u00c4ndern der Bar-Hintergrundfarbe in Abh\u00e4ngigkeit von einem gl. Durchschnitt\n// Kurs \u00fcber SMA(14) --> Gr\u00fcn\n// Kurs unter SMA(14) --> Maroon\nBackColor = SMA(14)[0] >= Close[0] ? Color.Maroon : Color.LimeGreen;\n\n\n\n\n\n\nBackColorAll\n\n\nBeschreibung\n\n\nBackColorAll \u00e4ndert die Hintergrundfarbe eines Bars im Chartfenster und in allen Subcharts bzw. gibt die aktuelle Hintergrundfarbe eines Bars zur\u00fcck.\nSiehe auch \nColors\n, \nBarColor\n, \nBackColor\n, \nBackColorAll\n, \nBarColorSeries\n, \nBackColorAll\n, \nCandleOutlineColor\n.\n\n\nParameter\n\n\nein Color-Objekt vom Typ  public struct Color\n\n\nVerwendung\n\n\nBackColorAll\n\n\nBeispiel\n\n\n// immer montags Bar-Hintergrundfarbe auf Blau \u00e4ndern\nif (Time[0].DayOfWeek == DayOfWeek.Monday)\nBackColorAll = Color.Blue;\n\n\n\n\n\n\nBackColorAllSeries\n\n\nBeschreibung\n\n\nBackColorAllSeries ist eine Datenserie, die f\u00fcr jeden Bar die Hintergrundfarbe speichert. Im Unterschied zu BackColorSeries wird die Hinterrundfarbe der Subcharts mit ber\u00fccksichtigt.\n\n\nSiehe auch \nColors\n, \nBarColor\n, \nBackColor\n, \nBackColorAll\n, \nBarColorSeries\n, \nBackColorAll\n, \nCandleOutlineColor\n.\n\n\nParameter\n\n\nein Color-Objekt vom Typ  public struct Color\n\n\nint barsAgo\n\n\nVerwendung\n\n\nBackColorAllSeries\nBackColorAllSeries[int barsAgo]\n\n\n\n\nBei Verwendung der Methode mit einem Index [int barsAgo] wird die Hintergrundfarbe f\u00fcr den referenzierten Bar ge\u00e4ndert bzw. ausgegeben.\n\n\nBeispiel\n\n\nsiehe \nBackColorSeries\n.\n\n\nBackColorSeries\n\n\nBeschreibung\n\n\nBackColorSeries ist eine Datenserie, die f\u00fcr jeden Bar die Hintergrundfarbe speichert. Soll die Hintergrundfarbe von Subcharts mit ber\u00fccksichtigt werden, ist \"BackColorAllSeries\" zu verwenden.\n\n\nSiehe auch \nColors\n, \nBarColor\n, \nBackColor\n, \nBackColorAll\n, \nBarColorSeries\n, \nBackColorAll\n, \nCandleOutlineColor\n.\n\n\nParameter\n\n\nein Color-Objekt vom Typ  public struct Color\n\n\nint barsAgo\n\n\nVerwendung\n\n\nBackColorSeries\nBackColorSeries[int barsAgo]\n\n\n\n\nei Verwendung der Methode mit einem Index [\nint\n barsAgo]  wird die Hintergrundfarbe f\u00fcr den referenzierten Bar ge\u00e4ndert bzw. ausgegeben.\n\n\nBeispiele\n\n\n// Welche Hintergrundfarbe hat der aktuelle Bar? (im ARGB-Format)\nPrint (BackColorSeries[0]);\n// Hintergrundfarbe des aktuellen Bars auf Blau setzen\n// Dies ist identisch mit BackColor = Color.Blue\nBackColorSeries[3] = Color.Blue;\n// Hintergrundfarbe des vorhergehenden Bars auf Gr\u00fcn setzen\nBackColorSeries[1] = Color.Green;\n\n\n\n\nBarColor\n\n\nBeschreibung\n\n\nBarColor \u00e4ndert die Farbe eines Bars\n\n\nSiehe auch \nColors\n, \nBarColor\n, \nBackColor\n, \nBackColorAll\n, \nBarColorSeries\n, \nBackColorAll\n, \nCandleOutlineColor\n.\n\n\nParameter\n\n\nein Color-Objekt vom Typ  public struct Color\n\n\nVerwendung\n\n\nBarColor\n\n\nBeispiel\n\n\n// Wenn der Schlusskurs \u00fcber dem SMA(14) liegt, den Bar orange einf\u00e4rben\nif (Close[0] > SMA(14)[0]) BarColor = Color.Orange;\n\n\n\n\n\n\nBarColorSeries\n\n\nBeschreibung\n\n\nBarColorSeries ist eine Datenserie, die f\u00fcr jeden Bar die Farbe speichert.\n\n\nSiehe auch\nColors\n, \nBarColor\n, \nBackColor\n, \nBackColorAll\n, \nBarColorSeries\n, \nBackColorAll\n, \nCandleOutlineColor\n.\n\n\nParameter\n\n\nein Color-Objekt vom Typ  public struct Color\n\n\nint barsAgo\n\n\nVerwendung\n\n\nBarColorSeries\n\n\nBarColorSeries[\nint\n barsAgo]\n\n\nBei Verwendung der Methode mit einem Index [int barsAgo] wird die Farbe f\u00fcr den referenzierten Bar ge\u00e4ndert bzw. ausgegeben.\n\n\nAchtung: Es wird nur die Farbe eines Bars zur\u00fcckgegeben, dessen Farbe vorher explizit ver\u00e4ndert wurde. In allen anderen F\u00e4llen wird Color.Empty zur\u00fcckgegeben.\n\n\nBeispiel\n\n\nprotected override void OnCalculate()\n{\nif (ProcessingBarIndex == Bars.Count-1-(CalculateOnClosedBar?1:0))\n{\n// Farbe des aktuellen Bars auf Blau setzen\n// Dies ist identisch mit BarColor = Color.Blue\nBarColorSeries[0] = Color.Blue;\n// Farbe des vorhergehenden Bars auf Gr\u00fcn setzen\nBarColorSeries[1] = Color.Orange;\n// Farbe des 3. Bars auf Gelb setzen\nBarColorSeries[2] = Color.Yellow;\n}\n}\n\n\n\n\n\n\nCandleOutlineColor\n\n\nBeschreibung\n\n\nCandleOutlineColor \u00e4ndert die Randfarbe (incl. \"Dochte\" und \"Lunte\") eines Bars.\n\n\nWenn die Farbe eines Bars mit BarColor ge\u00e4ndert wird, und die Umrandung des Bars wurde nicht mit CandleOutlineColor ver\u00e4ndert, wird die Randfarbe auf die Farbe des Bars angepasst.\n\n\nSiehe auch\nColors\n, \nBarColor\n, \nBackColor\n, \nBackColorAll\n, \nBarColorSeries\n, \nBackColorAll\n, \nCandleOutlineColor\n.\n\n\nParameter\n\n\nein Color-Objekt vom Typ  public struct Color\n\n\nVerwendung\n\n\nCandleOutlineColor\n\n\nBeispiel\n\n\nif (SMA(14)[0] > SMA(200)[0])\nCandleOutlineColor = Color.LimeGreen;\nelse\nCandleOutlineColor = Color.Red;\n\n\n\n\n\n\nCandleOutlineColorSeries\n\n\nBeschreibung\n\n\nCandleOutlineColorSeries ist eine Datenserie, die f\u00fcr jeden Bar die Randfarbe speichert.\n\n\nSiehe auch \nColors\n, \nBarColor\n, \nBackColor\n, \nBackColorAll\n, \nBarColorSeries\n, \nBackColorAll\n, \nCandleOutlineColor\n.\n\n\nParameter\n\n\nein Color-Objekt vom Typ  public struct Color\nint barsAgo\n\n\nVerwendung\n\n\nCandleOutlineColorSeries\nCandleOutlineColorSeries[int barsAgo]\n\n\n\n\nBei Verwendung der Methode mit einem Index  [\nint\n barsAgo] wird die Randfarbe f\u00fcr den referenzierten Bar ausgegeben.\n\n\nAchtung: Es wird nur die RandFarbe eines Bars zur\u00fcckgegeben, dessen Randfarbe vorher explizit ver\u00e4ndert wurde. In allen anderen F\u00e4llen wird Color.Empty zur\u00fcckgegeben.\n\n\nBeispiel\n\n\n// Randfarbe des aktuellen Bars auf Blau setzen\nCandleOutlineColorSeries[0] = Color.Blue;\n// Randfarbe auf Chart-default zur\u00fccksetzen\nCandleOutlineColorSeries[0] = Color.Empty;\n\n\n\n\nCrossAbove()\n\n\nBeschreibung\n\n\nMit der Methode CrossAbove() kann gepr\u00fcft werden, ob es innerhalb einer festgelegten Anzahl von Perioden eine \u00dcberkreuzung zweier Werte von unten nach oben gab. Die Werte k\u00f6nnen dabei der Kurs, ein Indikator, jede beliebige Datenserie oder ein fester Wert sein.\n\n\nSiehe auch \nCrossAbove()\n, \nCrossBelow()\n, \nIsSerieRising()\n, \nIsSerieFalling()\n.\n\n\nVerwendung\n\n\nCrossAbove(IDataSeries series1, double value, int lookBackPeriod)\nCrossAbove(IDataSeries series1, IDataSeries series2, int lookBackPeriod)\n\n\n\n\nR\u00fcckgabewert\n\n\ntrue\n eine \u00dcberkreuzung hat stattgefunden\n\nfalse\n eine \u00dcberkreuzung hat nicht stattgefunden\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlookBackPeriod\n\n\nAnzahl der Bars innerhalb derer nach dem Aufterten einer \u00dcberkreuzung gesucht wird\n\n\n\n\n\n\nseries1 und series2\n\n\neine Datenserie, wie z.B. ein Indikator, Close, High o.\u00e4\n\n\n\n\n\n\nvalue\n\n\nein fester Wert vom Typ double\n\n\n\n\n\n\n\n\nBeispiele\n\n\n// Hinweis ausgeben, wenn der SMA(20) \u00fcber SMA(50) kreuzt\nif (CrossAbove(SMA(20), SMA(50), 1))\nPrint(\"SMA(20) has risen above SMA(50)!\");\n// Hinweis ausgeben, wenn der SMA(20) \u00fcber den Wert 40 steigt\nif (CrossAbove(SMA(20), 40, 1))\nPrint(\"SMA(20) has risen above 40!\");\n// Hinweis auf Long-Einstieg ausgeben, wenn innerhalb der letzten 5 Bars\n// der SMA(20) \u00fcber SMA(50) kreuzt und der Kurs innerhalb des letzten Bars gestiegen ist\nif (CrossAbove(SMA(20), SMA(50), 1) && Close[0] > Close[1])\nPrint(\"Long entry !!!\");\n\n\n\n\nCrossBelow()\n\n\nBeschreibung\n\n\nMit der Methode CrossBelow() kann gepr\u00fcft werden, ob es innerhalb einer festgelegten Anzahl von Perioden eine \u00dcberkreuzung zweier Werte von oben nach unten gab. Die Werte k\u00f6nnen dabei der Kurs, ein Indikator, jede beliebige Datenserie oder ein fester Wert sein.\n\n\nSiehe auch \nCrossAbove()\n, \nCrossBelow()\n, \nIsSerieRising()\n, \nIsSerieFalling()\n.\n\n\nVerwendung\n\n\nCrossBelow(IDataSeries series1, double value, int lookBackPeriod)\nCrossBelow(IDataSeries series1, IDataSeries series2, int lookBackPeriod)\n\n\n\n\nR\u00fcckgabewert\n\n\ntrue\n eine \u00dcberkreuzung hat stattgefunden\n\nfalse\n eine \u00dcberkreuzung hat nicht stattgefunden\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlookBackPeriod\n\n\nAnzahl der Bars innerhalb derer nach dem Aufterten einer \u00dcberkreuzung gesucht wird\n\n\n\n\n\n\nseries1 und series2\n\n\neine Datenserie, wie z.B. ein Indikator, Close, High o\n\n\n\n\n\n\nvalue\n\n\nein fester Wert vom Typ double\n\n\n\n\n\n\n\n\nBeispiele\n\n\n// Hinweis ausgeben, wenn der SMA(20) unter SMA(50) kreuzt\nif (CrossBelow(SMA(20), SMA(50), 1))\nPrint(\"SMA(20) has fallen below SMA(50)!\");\n// Hinweis ausgeben, wenn der SMA(20) unter den Wert 40 f\u00e4llt\nif (CrossBelow(SMA(20), 40, 1))\nPrint(\"SMA(20) has fallen below 40!\");\n// Hinweis auf Short-Einstieg ausgeben, wenn innerhalb der letzten 5 Bars\n// der SMA(20) unter SMA(50) kreuzt und der Kurs innerhalb des letzten Bars gefallen ist.\nif (CrossBelow(SMA(20), SMA(50), 1) && Close[1] > Close[0])\nPrint(\"Short entry !!!\");\n\n\n\n\nDatafeedHistoryPeriodicity\n\n\nBeschreibung\n\n\nDatafeedHistoryPeriodicity ist ein Datentyp.\n\n\nDefinition\n\n\npublic enum DatafeedHistoryPeriodicity\n-   DatafeedHistoryPeriodicity.Tick\n-   DatafeedHistoryPeriodicity.Second\n-   DatafeedHistoryPeriodicity.Minute\n-   DatafeedHistoryPeriodicity.Hour\n-   DatafeedHistoryPeriodicity.Day\n-   DatafeedHistoryPeriodicity.Week\n-   DatafeedHistoryPeriodicity.Month\n-   DatafeedHistoryPeriodicity.Volume\n-   DatafeedHistoryPeriodicity.Range\n-   DatafeedHistoryPeriodicity.Quarter\n-   DatafeedHistoryPeriodicity.Year\n-   DatafeedHistoryPeriodicity.HeikinAshi\n-   DatafeedHistoryPeriodicity.Renko\n-   DatafeedHistoryPeriodicity.LineBreak\n-   DatafeedHistoryPeriodicity.Kagi\n-   DatafeedHistoryPeriodicity.PointAndFigure\n-   DatafeedHistoryPeriodicity.Custom\n\n\nSiehe \nTimeFrame\n, \nTimeFrames\n.\n\n\nDataSeries\n\n\nBeschreibung\n\n\nDatenserien (DataSeries) sind eine sehr komfortable und sehr m\u00e4chtige M\u00f6glichkeit, zus\u00e4tzliche Werte f\u00fcr jeden einzelnen Bar zu speichern. Z.B. wird bei der Berechnung eines gleitenden Durchschnitts jedem Bar der f\u00fcr diesen Bar errechnete Wert zugeordnet.\nEine Datenserie ist ein Array, welches exakt so viele Elemente enth\u00e4lt, wie Bars im Chart angezeigt werden. AgenaTrader sorgt daf\u00fcr, dass die Datenserien zu jedem Zeitpunkt korrekt mit den Bars synchronisiert sind.\nDatenserien werden exakt so benutzt, wie z.B. die Serien Close oder Time. Sie k\u00f6nnen deshalb nat\u00fcrlich auch als Eingangsdaten (Input) f\u00fcr weitere Indikatoren verwendet werden.\nIn der Tabelle ist zu sehen, dass 4 neue Datenserien (farbig markiert) angelegt worden sind. Jede dieser Datenserien kann genau einen Wert eines speziellen Datentyps (int, bool, string, DateTime) je Bar aufnehmen. Die Indizierung mit barsAgo ist dabei identisch mit den vom System bereitgestellten Datenserien..\n\n\n\n\nIn AgenaTrader verwendbare Datenserien\n\n\nBoolSeries\n\n\nDataSeries\n\n\nDateTimeSeries\n\n\nFloatSeries\n\n\nIntSeries\n\n\nLongSeries\n\n\nStringSeries\n\n\nDar\u00fcberhinaus gibt es die Datenserie ColorSeries, die jedoch nur f\u00fcr interne Zwecke bestimmt ist und nicht direkt verwendet werden sollte.\nUm die Farbe von Plots zu \u00e4ndern, verwenden Sie bitte \nPlotColors\n.\n\n\nSet(), Reset() und ContainsValue()\n\n\nJede Datenserie verf\u00fcgt \u00fcber die Methoden  \nSet()\n, \nReset()\n und \nContainsValue()\n.\nMit Set(value) bzw. Set(int barsAgo, value) werden Werte in die Datenserie an der aktuellen Position bzw. an der Position \"barsAgo\" \u00fcbernommen.\nMit Reset() bzw. Reset(int barsAgo) kann an der aktuellen Position  bzw. an der Position \"barsAgo\" ein Wert aus der Datenserie gel\u00f6scht werden, d.h. an dieser Position existiert kein g\u00fcltiger Wert mehr.\nDie Programmierung mit Hilfe der Reset-Methode kann eine ansonsten sehr komplexe Logik sp\u00fcrbar vereinfachen.Insbesondere bei Bool-Serien, die nur true oder false enthalten k\u00f6nnen, ist diese Eigenschaft extrem hilfreich.\nMit ContainsValue() kann gepr\u00fcft werden, ob die Datenserie an einer bestimmten Position einen g\u00fcltigen Wert enth\u00e4lt.\n\n\nInformationen zu den einzelnen Datentypen\n\n\nhttp://msdn.microsoft.com/de-de/library/s1ax56ch%28v=vs.80%29.aspx\n\n\nBoolSeries\n\n\nBeschreibung\n\n\nBoolSeries ist eine Datenserie, die f\u00fcr jeden Bar einen boolschen Wert (true oder false) aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.\n\n\nNeue BoolSeries anlegen\n\n\nIm Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen:\n\n\n//Variablendeklaration\nprivate BoolSeries myBoolSeries;\n\n\n\n\nIn der Methode OnInit()dieser Variable eine neue Instanz von BoolSeries zuweisen:\n\n\nprotected override void OnInit()\n{\nmyBoolSeries = new BoolSeries(this);\nCalculateOnClosedBar = true;\n}\n\n\n\n\nWerte zuweisen\n\n\nDer Datenserie an aktueller Position einen Wert zuweisen:\n\n\nmyBoolSeries.Set(true);\n\n\n\n\nEinen Wert in der Vergangenheit in die Datenserie schreiben:\n\n\nmyBoolSeries.Set(int barsAgo, bool Value);\n\n\n\n\nWerte l\u00f6schen\n\n\nDen aktuellen Wert aus der Datenserie entfernen:\n\n\nmyBoolSeries.Reset();\n\n\n\n\nEinen Wert in der Vergangenheit aus der Datenserie entfernen:\n\n\nmyBoolSeries.Reset(int barsAgo);\n\n\n\n\nWerte auf G\u00fcltigkeit pr\u00fcfen\n\n\nmyBoolSeries.ContainsValue(int barsAgo);\n\n\n\n\nWert auslesen\n\n\nPrint (\"F\u00fcr den Bar von \" + Time[0] + \" ist der Wert der Datenserie: \" + myBoolSeries[0]);\n\n\n\n\nBeispiel\n\n\nprotected override void OnCalculate()\n{\nif (Close[0] > Open[0])\nmyBoolSeries.Set(true);\nelse\nmyBoolSeries.Set(false);\n}\n\n\n\n\nDataSeries\n\n\nBeschreibung\n\n\nDataSeries ist eine \nDataSeries\n die f\u00fcr jeden Bar einen double-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.\n\n\nDatenserien f\u00fcr double-Werte sind die f\u00fcr Indikatoren am h\u00e4ufigsten genutzen Datenserien.\n\n\nNeue DatenSerie anlegen\n\n\nIm Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen:\n\n\n//Variablendeklaration\nprivate DataSeries myDataSeries;\n\n\n\n\nIn der Methode OnInit()  dieser Variable eine neue Instanz von DataSeries zuweisen:\n\n\nprotected override void OnInit()\n{\nmyDataSeries = new DataSeries(this);\nCalculateOnClosedBar = true;\n}\n\n\n\n\nWerte zuweisen\n\n\nDer Datenserie an aktueller Position einen Wert zuweisen:\n\n\nmyDataSeries.Set(Bars[0].Close);\n\n\n\n\nEinen Wert in der Vergangenheit in die Datenserie schreiben:\n\n\nmyDataSeries.Set(int barsAgo, double Value);\n\n\n\n\nWerte l\u00f6schen\n\n\nDen aktuellen Wert aus der Datenserie entfernen:\n\n\nmyDataSeries.Reset();\n\n\n\n\nEinen Wert in der Vergangenheit aus der Datenserie entfernen:\n\n\nmyDataSeries.Reset(int barsAgo);\n\n\n\n\nWerte auf G\u00fcltigkeit pr\u00fcfen\n\n\nmyDataSeries.ContainsValue(int barsAgo);\n\n\n\n\nWert auslesen\n\n\nPrint (\"F\u00fcr den Bar von  \" + Time[0] + \"ist der Wert der Datenserie: \" + myDataSeries[0]);\n\n\n\n\nBeispiel\n\n\n//Speichert die Spanne zwischen dem Hoch und dem Tief eines Bars\nmyDataSeries.Set(Math.Abs(High[0]-Low[0]));\n\n\n\n\nDateTimeSeries\n\n\nBeschreibung\n\n\nDate time series  ist eine \nDataSeries\n die f\u00fcr jeden Bar einen DateTime-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.\n\n\nNeue DatenSerie anlegen\n\n\nIm Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen:\n\n\n//Variablendeklaration\nprivate DateTimeSeries myDataSeries;\n\n\n\n\nIn der Methode OnInit() dieser Variable eine neue Instanz von StringSeries zuweisen:\n\n\nprotected override void OnInit()\n{\nmyDataSeries = new DateTimeSeries(this);\nCalculateOnClosedBar = true;\n}\n\n\n\n\nWerte zuweisen\n\n\nDer Datenserie an aktueller Position einen Wert zuweisen:\n\n\nmyDataSeries.Set(DateTime Value);\n\n\n\n\nEinen Wert in der Vergangenheit in die Datenserie schreiben:\n\n\nmyDataSeries.Set(int barsAgo, DateTime Value);\n\n\n\n\nWerte l\u00f6schen\n\n\nDen aktuellen Wert aus der Datenserie entfernen:\n\n\nmyDataSeries.Reset();\n\n\n\n\nEinen Wert in der Vergangenheit aus der Datenserie entfernen:\n\n\nmyDataSeries.Reset(int barsAgo);\n\n\n\n\nWerte auf G\u00fcltigkeit pr\u00fcfen\n\n\nmyDataSeries.ContainsValue(int barsAgo);\n\n\n\n\nWert auslesen\n\n\nPrint (\"F\u00fcr den Bar von\" + Time[0] + \" ist der Wert der Datenserie: \" + myDataSeries[0]);\n\n\n\n\nBeispiel\n\n\n//Speichert einen Versatz von -6 Stunden (Eastern Time, New York) f\u00fcr eine Zeitzonenumrechnung\nmyDataSeries.Set(Time[0].AddHours(-6));\n\n\n\n\nFloatSeries\n\n\nBeschreibung\n\n\nFloatSeries ist eine Datenserie, die f\u00fcr jeden Bar einen Float-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.\n\n\nNeue DatenSerie anlegen\n\n\nIm Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen:\n\n\n//Variablendeklaration\nprivate FloatSeries myDataSeries;\n\n\n\n\nIn der Methode OnInit() dieser Variable eine neue Instanz von StringSeries zuweisen:\n\n\nprotected override void OnInit()\n{\nmyDatatSeries = new FloatSeries(this);\nCalculateOnClosedBar = true;\n}\n\n\n\n\nWerte zuweisen\n\n\nDer Datenserie an aktueller Position einen Wert zuweisen:\n\n\nmyDataSeries.Set(float Value);\n\n\n\n\nEinen Wert in der Vergangenheit in die Datenserie schreiben:\n\n\nmyDataSeries.Set(int barsAgo, float Value);\n\n\n\n\nWerte l\u00f6schen\n\n\nDen aktuellen Wert aus der Datenserie entfernen:\n\n\nmyDataSeries.Reset();\n\n\n\n\nEinen Wert in der Vergangenheit aus der Datenserie entfernen:\n\n\nmyDataSeries.Reset(int barsAgo);\n\n\n\n\nWerte auf G\u00fcltigkeit pr\u00fcfen\n\n\nmyDataSeries.ContainsValue(int barsAgo);\n\n\n\n\nWert auslesen\n\n\nPrint (\"F\u00fcr den Bar von\" + Time[0] + \" ist der Wert der Datenserie: \" + myDataSeries[0]);\n\n\n\n\nBeispiel\n\n\n//Speichert die Spanne zwischen dem Hoch und dem Tief eines Bars\nmyDataSeries.Set(Math.Abs((float) High[0] - (float) Low[0]));\n\n\n\n\nIntSeries\n\n\nBeschreibung\n\n\nIntSeries ist eine Datenserie, die f\u00fcr jeden Bar einen Integer-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.\n\n\nNeue DatenSerie anlegen\n\n\nIm Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen:\n\n\n//Variablendeklaration\nprivate IntSeries myDataSeries;\n\n\n\n\nIn der Methode OnInit() dieser Variable eine neue Instanz von StringSeries zuweisen:\n\n\nprotected override void OnInit()\n{\nmyDataSeries = new IntSeries(this);\nCalculateOnClosedBar = true;\n}\n\n\n\n\nWerte zuweisen\n\n\nDer Datenserie an aktueller Position einen Wert zuweisen:\n\n\nmyDataSeries.Set(int Value);\n\n\n\n\nEinen Wert in der Vergangenheit in die Datenserie schreiben:\n\n\nmyDataSeries.Set(int barsAgo, int Value);\n\n\n\n\nWerte l\u00f6schen\n\n\nDen aktuellen Wert aus der Datenserie entfernen:\n\n\nmyDataSeries.Reset();\n\n\n\n\nEinen Wert in der Vergangenheit aus der Datenserie entfernen:\n\n\nmyDataSeries.Reset(int barsAgo);\n\n\n\n\nWerte auf G\u00fcltigkeit pr\u00fcfen\n\n\nmyDataSeries.ContainsValue(int barsAgo);\n\n\n\n\nWert auslesen\n\n\nPrint (\"F\u00fcr den Bar von \" + Time[0] + \"ist der Wert der Datenserie\"+ myDataSeries[0]);\n\n\n\n\nBeispiel\n\n\n//Speichert f\u00fcr jeden Bar die Spanne in Ticks zwischen dem Hoch und dem Tief\nmyDataSeries.Set((int) ((High[0] - Low[0]) / TickSize));\n\n\n\n\nLongSeries\n\n\nBeschreibung\n\n\nLongSeries ist eine Datenserie, die f\u00fcr jeden Bar einen Integer-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.\n\n\nNeue DatenSerie anlegen\n\n\nIm Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen:\n\n\n//Variablendeklaration\nprivate LongSeries myDataSeries;\n\n\n\n\nIn der Methode OnInit() dieser Variable eine neue Instanz von LongSeries zuweisen:\n\n\nprotected override void OnInit()\n{\nmyDataSeries = new LongSeries(this);\nCalculateOnClosedBar = true;\n}\n\n\n\n\nWerte zuweisen\n\n\nDer Datenserie an aktueller Position einen Wert zuweisen:\n\n\nmyDataSeries.Set(long Value);\n\n\n\n\nEinen Wert in der Vergangenheit aus der Datenserie entfernen:\n\n\nmyDataSeries.Set(int barsAgo, long Value);\n\n\n\n\nWerte l\u00f6schen\n\n\nDen aktuellen Wert aus der Datenserie entfernen:\n\n\nmyDataSeries.Reset();\n\n\n\n\nEinen Wert in der Vergangenheit aus der Datenserie entfernen:\n\n\nmyDataSeries.Reset(int barsAgo);\n\n\n\n\nWerte auf G\u00fcltigkeit pr\u00fcfen\n\n\nmyDataSeries.ContainsValue(int barsAgo);\n\n\n\n\nWert auslesen\n\n\nPrint (\"F\u00fcr den Bar von \" + Time[0] + \"ist der Wert der Datenserie: \" + myDataSeries[0]);\n\n\n\n\nBeispiel\n\n\n//Speichert f\u00fcr jeden Bar die Spanne in Ticks zwischen dem Hoch und dem Tief\nmyDataSeries.Set((long) ((High[0] - Low[0]) / TickSize));\n\n\n\n\nStringSeries\n\n\nBeschreibung\n\n\nStringSeries ist eine Datenserie, die f\u00fcr jeden Bar einen String-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.\n\n\nNeue DatenSerie anlegen\n\n\nIm Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen:\n\n\n//Variablendeklaration\nprivate StringSeries myDataSeries;\n\n\n\n\nIn der Methode OnInit() dieser Variable eine neue Instanz von StringSeries zuweisen:\n\n\nprotected override void OnInit()\n{\nmyDataSeries = new StringSeries(this);\nCalculateOnClosedBar = true;\n}\n\n\n\n\nWerte zuweisen\n\n\nDer Datenserie an aktueller Position einen Wert zuweisen:\n\n\nmyDataSeries.Set(string Value);\n\n\n\n\nEinen Wert in der Vergangenheit in die Datenserie schreiben:\n\n\nmyDataSeries.Set(int barsAgo, string Value);\n\n\n\n\nWerte l\u00f6schen\n\n\nDen aktuellen Wert aus der Datenserie entfernen:\n\n\nmyDataSeries.Reset();\n\n\n\n\nEinen Wert in der Vergangenheit aus der Datenserie entfernen:\n\n\nmyDataSeries.Reset(int barsAgo);\n\n\n\n\nWerte auf G\u00fcltigkeit pr\u00fcfen\n\n\nmyDataSeries.ContainsValue(int barsAgo);\n\n\n\n\nWert auslesen\n\n\nPrint (\"F\u00fcr den Bar von \" + Time[0] + \"ist der Wert der Datenserie: \" + myDataSeries[0]);\n\n\n\n\nBeispiel\n\n\n//Speichert f\u00fcr jeden Bar den Wochentag (Montag, Dienstag ...)\nmyDataSeries.Set(string.Format(\"{0:dddd}\", Time[0]));\n\n\n\n\nDayOfWeek\n\n\nBeschreibung\n\n\n\"DayOfWeek\" gibt den zu einem DateTime-Wert, wie z.B. dem Zeitstempel eines Bars, geh\u00f6renden Wochentag aus.\n\n\nDar\u00fcberhinaus sind nat\u00fcrlich auch alle Methoden verwendbar, die in C# f\u00fcr DateTime-Objekte definiert sind, z.B. Day, Month, Year, Hour, Minute, Second, DayOfWeek usw.\n\n\nSiehe \nhttp://msdn.microsoft.com/de-de/library/03ybds8y.aspx\n\n\nDefinition\n\n\nEigenschaft DayOfWeek\n\n\npublic enum DayOfWeek\n-   DayOfWeek.Monday\n-   DayOfWeek.Tuesday\n-   DayOfWeek.Wednesday\n-   DayOfWeek.Thursday\n-   DayOfWeek.Friday\n-   DayOfWeek.Saturday\n-   DayOfWeek.Sunday\n\n\nBeispiele\n\n\n//Ausgabe des Wochentages f\u00fcr jeden Bar\nPrint(Time[0].DayOfWeek);\n//An einem Freitag keine Trades ausf\u00fchren\nif (Time[0].DayOfWeek == DayOfWeek.Friday)\nreturn;\n\n\n\n\nDisplacement\n\n\nBeschreibung\n\n\nMit der Angabe Displacement kann eine gezeichnete Indikatorlinie auf der Zeitachse (x-Achse) nach links bzw. rechts verschoben werden.\nDie Eigenschaft kann im Script abgefragt werden und liefert einen int-Wert.\n\n\nBlue line: Displacement = 0 (Original)\nRed line: Displacement = -5\nGreen line: Displacement = +5\n\n\n\n\nVerwendung\n\n\nDisplacement\n\n\nParameter\n\n\nint Offfset Anzahl Bars, um die der Indikator verschoben werden soll.\n\n\nBeispiel\n\n\nprotected override void OnInit()\n{\nAdd(new OnPaint(Color.Red, \"MyPlot1\"));\n//Displacement of the plot by one bar to the right\nDisplacement = 1;\n}\n\n\n\n\nEmail function\n\n\nBeschreibung\n\n\nOverride-Methode zum Senden von E-Mails.\n\n\nParameter\n\n\nkeine\n\n\nR\u00fcckgabewert\n\n\nstring\n\n\nVerwendung\n\n\nVerwendet f\u00fcr komplizierte Berechnung auf einem letzten Bar\n\n\nBeispiel\n\n\nprotected override void OnOrderExecution(IExecution execution)\n{\nif (execution.Order != null && execution.Order.OrderState == OrderState.Filled)\n{\nif (oEnter != null && execution.Name == oEnter.Name)\n{\n// Enter-Order gef\u00fcllt\nif (_sendMail) this.SendEmail(Core.AccountManager.Core.Settings.MailDefaultFromAddress, Core.PreferenceManager.DefaultEmailAddress,\nexecution.Instrument.Symbol + \" order \" + execution.Name + \" executed.\", \"The order for \" + execution.Instrument.Name + \" was executed. Invest: \" + (Trade.Quantity * Trade.AvgPrice).ToString(\"F2\"));\n}\nelse if (oTStop != null && execution.Name == oTStop.Name)\n{\nOrderStatus = 0; // Trend-Stopp-Order gef\u00fcllt\nif (_sendMail) this.SendEmail(Core.AccountManager.Core.Settings.MailDefaultFromAddress, Core.PreferenceManager.DefaultEmailAddress,\nexecution.Instrument.Symbol +\" order \" + execution.Name + \" executed.\",\nexecution.Instrument.Symbol +\" order \" + execution.Name + \" executed. Profit:\" + Trade.ClosedProfitLoss.ToString(\"F2\"));\n}\n}\n}\n\n\n\n\nFirstTickOfBar\n\n\nBeschreibung\n\n\nFirstTickOfBar ist eine Eigenschaft, vom Type bool, die immer dann \"true\" ergibt, wenn der aktuell hereinkommende Tick einem neuen Bar zugeordnet wird, dieser Tick also der erste Tick eines neuen Bars ist.\nDie Eigenschaft kann nur sinnvoll eingesetzt werden, wenn der Indikator bzw. die Startegie im Tick-by-Tick-Modus l\u00e4uft, d.h. wenn CalculateOnClosedBar = false gesetzt ist und der verwendete Datenfeed Realtime-Kurse liefert.\nBei Verwendung von EoD-Daten in einem Tageschart ist FirstTickOfBar f\u00fcr den letzten Bar immer true.\nFirstTickOfBar sollte nicht au\u00dferhalb der OnCalculate() Methode verwendet werden..\n\n\nsiehe auch \nBars.TicksCountForLastBar\n.\n\n\nVerwendung\n\n\nFirstTickOfBar\n\n\nBeispiel\n\n\n// Innerhalb einer Tick-By-Tick-Strategie einen Teil nur Bar-by-Bar ausf\u00fchren\nif (FirstTickOfBar)\n{\nif (CCI(20)[1] < -250)\nOpenLong();\nreturn;\n}\n\n\n\n\nFirstTickOfBarMtf\n\n\nBeschreibung\n\n\nFirstTickOfBarMtf ist die  \nmulti-time frame\n Variante von \nFirstTickOfBar\n.\n\n\nDie Einstellung von CalculateOnClosedBar wirkt sich nur auf die prim\u00e4re Zeiteinheit (Chart-Zeiteinheit) aus. Wenn jedoch mit multi-bars gearbeitet wird, werden die Ticks der sekund\u00e4ren Zeiteinheit(en) unabh\u00e4ngig von der Einstellung von CalculateOnClosedBar  immer Tick-by-Tick bereitgestellt.\nMit Hilfe von FirstTickOfBarMtf, ist es m\u00f6glich, festzustellen, wann in einer sekund\u00e4ren Zeiteinheit ein neuer Bar beginnt.   \n\n\nVerwendung\n\n\nFirstTickOfBarMtf(ProcessingBarSeriesIndex)\n\n\nParameter\n\n\nFirstTickOfBarMtf(ProcessingBarSeriesIndex).\n\n\nsiehe \nProcessingBarSeriesIndex\n.\n\n\nBeispiel\n\n\nif (FirstTickOfBarMtf(ProcessingBarSeriesIndex))\nPrint(\"A new bar has begun.\");\n\n\n\n\nGetCurrentAsk()\n\n\nBeschreibung\n\n\nDie Methode GetCurrentAsk() liefert den aktuellen Kurs auf der Ask-Seite des Orderbuchs. Wenn AgenaTrader keine Level1-Daten zur Verf\u00fcgung stehen, liefert die Funktion den Kurs des letzten Umsatzes.\n\n\nsiehe auch  \nGetCurrentBid()\n und \nOnLevel1()\n.\n\n\nVerwendung\n\n\nGetCurrentAsk()\n\n\nR\u00fcckgabewert\n\n\ndouble value\n\n\nParameter\n\n\nkeiner\n\n\nBeispiel\n\n\nWenn eine Einstiegsbedingung erf\u00fcllt ist, soll 1 Kontrakt zum aktuellen Ask-Kurs verkauft werden.\n\n\nprivate IOrder entryOrder = null;\nprotected override void OnCalculate()\n{\n// Einstiegsbedingung\nif (Close[0] < SMA(20)[0] && entryOrder == null)\n// Verkauf 1 Kontrakt zum aktuellen AskKurs\nentryOrder = SubmitOrder(0, OrderAction.SellShort, OrderType.Limit, 1, GetCurrentAsk(), 0, \"\", \"Enter short\");\n}\n\n\n\n\nGetCurrentAskVolume()\n\n\nBeschreibung\n\n\nDie Methode GetCurrentAskVolume() liefert das aktuelle Volumen auf der Ask-Seite des Orderbuchs. Diese Funktion ist nur lauff\u00e4hig, wenn der Datenanbieter Level2-Daten liefert.\n\n\nsiehe auch \nGetCurrentBidVolume()\n, \nGetCurrentBid()\n und \nOnLevel1()\n.\n\n\nVerwendung\n\n\nGetCurrentAskVolume()\n\n\nR\u00fcckgabewert\n\n\nLong  value\n\n\nParameter\n\n\nkeiner\n\n\nBeispiel\n\n\nprotected override void OnCalculate()\n{\n   if (GetCurrentAskVolume() < GetCurrentBidVolume())\n       Print(\"AskVolume {0} < BidVolume {1}\", GetCurrentAskVolume(), GetCurrentBidVolume());\n}\n\n\n\n\nGetCurrentBid()\n\n\nBeschreibung\n\n\nDie Methode GetCurrentBid() liefert den aktuellen Kurs auf der Bid-Seite des Orderbuchs. Wenn AgenaTrader keine Level1-Daten zur Verf\u00fcgung stehen, liefert die Funktion den Kurs des letzten Umsatzes.\n\n\nsiehe auch \nGetCurrentAsk()\n und \nOnLevel1()\n.\n\n\nVerwendung\n\n\nGetCurrentBid()\n\n\nR\u00fcckgabewert\n\n\ndouble value\n\n\nParameter\n\n\nkeiner\n\n\nBeispiel\n\n\nWenn eine Einstiegsbedingung erf\u00fcllt ist, soll 1 Kontrakt zum aktuellen Bid-Kurs gekauft werden.\n\n\nprivate IOrder entryOrder = null;\nprotected override void OnCalculate()\n{\n// Einstiegsbedingung\nif (Close[0] > SMA(20)[0] && entryOrder == null)\n// Kauf 1 Kontrakt zum aktuellen BidKurs\nentryOrder = SubmitOrder(0, OrderAction.Buy, OrderType.Limit, 1, GetCurrentBid(), 0, \"\", \"Enter long\");\n}\n\n\n\n\nGetCurrentBidVolume()\n\n\nBeschreibung\n\n\nDie Methode GetCurrentBidVolume() liefert das aktuelle Volumen auf der Bid-Seite des Orderbuchs. Diese Funktion ist nur lauff\u00e4hig, wenn der Datenanbieter Level2-Daten liefert.\n\n\nsiehe auch \nGetCurrentAskVolume\n, \nGetCurrentBid()\n und \nOnLevel1()\n.\n\n\nVerwendung\n\n\nGetCurrentBidVolume()\n\n\nR\u00fcckgabewert\n\n\nLong value\n\n\nParameter\n\n\nkeiner\n\n\nBeispiel\n\n\nprotected override void OnCalculate()\n{\n   if (GetCurrentAskVolume() < GetCurrentBidVolume())\n       Print(\"AskVolume {0} < BidVolume {1}\", GetCurrentAskVolume(), GetCurrentBidVolume());\n}\n\n\n\n\nGetCurrentPrice()\n\n\nBeschreibung\n\n\nDie Methode GetCurrentPrice() liefert den aktuellen Kurs (Latest). Wenn AgenaTrader keine Level1-Daten zur Verf\u00fcgung stehen, liefert die Funktion den Kurs des letzten Umsatzes.\n\n\nsiehe auch \nGetCurrentAsk\n, \nGetCurrentBid()\n und \nOnLevel1()\n.\n\n\nVerwendung\n\n\nGetCurrentPrice()\n\n\nR\u00fcckgabewert\n\n\nkeiner\n\n\nParameter\n\n\ndouble value\n\n\nBeispiel\n\n\nWenn eine Einstiegsbedingung erf\u00fcllt ist, soll 1 Kontrakt zum aktuellen Kurs gekauft werden.\n\n\nprivate IOrder entryOrder = null;\n\nprotected override void OnCalculate()\n{\n   // Einstiegsbedingung\n   if (Close[0] > SMA(20)[0] && entryOrder == null)\n       // Kauf 1 Kontrakt zum aktuellen BidKurs\n       entryOrder = SubmitOrder(0, OrderAction.Buy, OrderType.Limit, 1, GetCurrentPrice(), 0,\"\", \"Enter Long\");\n}\n\n\n\n\nGetCurrentSpread()\n\n\nBeschreibung\n\n\nDie Methode GetCurrentSpread() liefert den aktuellen Spread.\n\n\nsiehe auch \nGetCurrentAsk\n, \nGetCurrentBid()\n and \nOnLevel1()\n.\n\n\nVerwendung\n\n\nGetCurrentSpread()\n\n\nR\u00fcckgabewert\n\n\nkeiner\n\n\nParameter\n\n\ndouble\n\n\nBeispiel\n\n\nWenn eine Anfangsbedingung erf\u00fcllt ist, sollte ein Vertrag zum aktuellen Wechselkurs gekauft werden.\n\n\nprotected override void OnCalculate()\n{\n       Print(\"Der aktuelle Spread ist {0}\", GetCurrentSpread());\n}\n\n\n\n\nGetDayAsInt()\n\n\nBeschreibung\n\n\nGetDayAsIntist eine Methode, die sich speziell an unerfahrene Programmierer richtet, die mit der durchaus komplizierten .Net-DateTime-Struktur aus C# Schwierigkeiten haben.\nErfahrene Programmierer k\u00f6nnen die DateTime-Funktionen auch direkt verwenden.\n\n\nGetDayAsInt liefert eine int-Repr\u00e4sentation im Format yyyyMMdd.\n(yyyy = Jahr,  MM = Monat, dd = Tag)\n\n\nDie Zahl f\u00fcr den 13.08.2012 lautet damit 20120813.\n\n\nSiehe auch \nGetTimeAsInt\n.\n\n\nHilfe zu DateTime: \nhttp://msdn.microsoft.com/de-de/library/system.datetime.aspx\n\n\nVerwendung\n\n\nGetDayAsInt(DateTime time)\n\n\nBeispiele\n\n\n// Am 11. September besser keine Trades eingehen\nif (GetDayAsInt(Time[0]) = 20130911)\nreturn;\n\n\n\n\nGetSeriesHighestValue\n\n\nBeschreibung\n\n\nDie Methode GetSeriesHighestValue() sucht in einer vorgegebenen Anzahl von Perioden nach dem h\u00f6chsten Bar und gibt an, vor wievielen Bars dieser h\u00f6chste Bar zu finden ist\n\n\nSiehe auch \nGetSeriesLowestValue()\n.\n\n\nParameter\n\n\nperiod Anzahl von Bars, innerhalb derer gesucht werden soll\n\n\nseries Jede Datenserie, wie Close, High, Low usw.\n\n\nR\u00fcckgabewert\n\n\nint barsAgo Vor wievielen Bars trat das Hoch auf\n\n\n\n\nVerwendung\n\n\nGetSeriesHighestValue(IDataSeries series, int period)\n\n\n\n\nBeispiele\n\n\n// Vor wievielen Bars lag das h\u00f6chste Hoch der aktuellen Session?\nPrint(GetSeriesHighestValue(High, Bars.BarsCountForSession - 1));\n// Welchen Kurs hatte das bisher h\u00f6chste Open der aktuellen Session?\nPrint(\"The highest price for the session was: \" + Open[GetSeriesHighestValue(High, Bars.BarsCountForSession - 1)]);\n\n\n\n\nGetSeriesLowestValue\n\n\nBeschreibung\n\n\nDie Methode  GetSeriesLowestValue() sucht in einer vorgegebenen Anzahl von Perioden nach dem tiefsten Bar und gibt an, vor wievielen Bars dieser tiefste Bar zu finden ist.\n\n\nSiehe auch \nGetSeriesHighestValue()\n.\n\n\nParameter\n\n\nperiod Anzahl von Bars, innerhalb derer gesucht werden soll\n\n\nseries Jede Datenserie, wie Close, High, Low usw.\n\n\nR\u00fcckgabewert\n\n\nint\n barsAgo Vor wievielen Bars trat das Tief auf\n\n\nVerwendung\n\n\nGetSerieLowestValue(IDataSeries series, int period)\n\n\n\n\nBeispiele\n\n\n// Vor wievielen Bars lag das tiefste Tief der aktuellen Session?\nPrint(GetSeriesLowestValue(Low, Bars.BarsCountForSession - 1));\n// Welchen Kurs hatte das bisher tiefste Open der aktuellen Session?\nPrint(\"The lowest open price of the current session was: \" + Open[GetSeriesLowestValue(Low, Bars.BarsCountForSession - 1)]);\n\n\n\n\nGetTimeAsInt()\n\n\nBeschreibung\n\n\nGetTimeAsInt ist eine Methode, die sich speziell an unerfahrene Programmierer richtet, die mit der durchaus komplizierten .Net-DateTime-Struktur aus C# Schwierigkeiten haben.\nErfahrene Programmierer k\u00f6nnen die DateTime-Funktionen auch direkt verwenden..\n\n\nGetTimeAsInt liefert eine int-Repr\u00e4sentation im Format HHmmss.\n(HH = Stunde,  mm = Minute, ss = Sekunde)\n\n\nDie Uhrzeit 07:30 Uhr wird dargestellt als 73000 und 14:15:12 wird zu 141512.\n\n\nSiehe auch \nGetDayAsInt\n.\n\n\nHilfe zu DateTime: \nhttp://msdn.microsoft.com/de-de/library/system.datetime.aspx\n\n\nVerwendung\n\n\nGetTimeAsInt(DateTime time)\n\n\nBeispiele\n\n\n// Nur zwischen 08:15 Uhr und 16:35 Uhr Trades eingehen\nif (GetTimeAsInt(Time[0]) >= 81500 && GetTimeAsInt(Time[0]) <= 163500)\n{\n// irgendeine Handelslogic\n}\n\n\n\n\nHistorical\n\n\nBeschreibung\n\n\nMit Historical l\u00e4\u00dft sich \u00fcberpr\u00fcfen, ob AgenaScript mit historen Daten oder mit Real-Time-Daten arbeitet.\nSolange OnCalculate() f\u00fcr historische Daten aufgerufen wird, ist Historical = true, in dem Moment, in dem die Verarbeitung von Live-Daten beginnt, wird Historical = false.\nW\u00e4hrend ein Backtest ausgef\u00fchrt wird, ist Historical immer true.\n\n\nVerwendung\n\n\nHistorical\n\n\nR\u00fcckgabewert\n\n\ntrue\n bei Verarbeitung von historischen Daten\n\nfalse\n bei Verarbeitung von Real-Time-Daten\n\n\nBeispiele\n\n\nprotected override void OnCalculate()\n{\n// Nur f\u00fcr realtime-Daten ausf\u00fchren\nif (IsHistoricalMode) return;\n// irgendeine Handelslogik\n}\n\n\n\n\nInputPriceType\n\n\nBeschreibung\n\n\nDie Eigenschaft InputPriceType legt fest, welche Kursreihe bei der Berechnung in Indikatoren als Standard verwendet werden soll, wenn keine Datenreihe explizit angegeben ist.\nInputPriceType kann in der OnInit()-Methode stehen. Die Angabe hat dann f\u00fcr alle weiteren Berechnungen im Indikator G\u00fcltigkeit.\nSteht InputPriceType in OnCalculate(), gilt die \u00c4nderung der Eingangsdatenreihe ab der n\u00e4chsten Anweisung.\nJedes weitere Auftreten von InputPriceType wird ignoriert!\n\n\nSiehe auch  \nPriceType\n\n\nVerwendung\n\n\nInputPriceType\n\n\n\n\nBeispiel1\n\n\nprotected override void OnInit()\n{\nClearTraceWindow();\nInputPriceType = PriceType.Low;\n}\nprotected override void OnCalculate()\n{\n// Die Eingangsdatenreihe f\u00fcr den Indikator (Input) ist Low\nPrint(Low[0] + \" \" + InSeries[0] + \" \" + InputPriceType);\n}\n\n\n\n\nBeispiel2\n\n\nprotected override void OnCalculate()\n{\n// Diese Werte sind identisch,\n     // da standardm\u00e4\u00dfig Close als Inputdatenreihe verwendet wird\nPrint(SMA(20)[0] + \" \" + SMA(Close, 20)[0]);\nInputPriceType = PriceType.Low;\n// ab hier wird Low anstatt Close als Standard verwendet\n// Die beiden Werte sind identisch\nPrint(SMA(20)[0] + \" \" + SMA(Low, 20)[0]);\nInputPriceType = PriceType.High;\n// Diese Anweisung wird ignoriert.\n     // Es gilt weiterhin Input = Low !!!\n}\n\n\n\n\nInstrument\n\n\nBeschreibung\n\n\nMit Instrument werden Informationen zum Handelsinstrument (Aktie, Future etc.) bereitgestellt, f\u00fcr welches ein Indikator, eine Strategie usw. gerade l\u00e4uft.\n\n\nAusf\u00fchrliche Details finden sich unter \nInstruments\n.\n\n\nIsAddDrawingsToPricePanel\n\n\nBeschreibung\n\n\nDie Eigenschaft  \"IsAddDrawingsToPricePanel\" legt fest, in welchem Panel Zeichenobjekte gezeichnet werden.\n\n\nIsAddDrawingsToPricePanel = true (default)\n\n\n\n\nZeichenobjekte werden im Preischart gezeichnet\n\n\nIsAddDrawingsToPricePanel = false\n\n\n\n\nZeichenobjekte werden in dem Panel (Subchart) gezeichnet, das dem Indikator zugeordnet ist.\n\n\nIst der Indikator bereits dem Preischart zugeordnet (Overlay = true) ist diese Eigenschaft wirkungslos, d.h. es wird in diesem Fall kein neuer Subchart ge\u00f6ffnet.\n\n\nDie Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false)\n\n\nVerwendung\n\n\nIsAddDrawingsToPricePanel\n\n\nBeispiel\n\n\nprotected override void OnInit()\n{\n// Indikator in einem neuen Subchart zeichnen\nIsOverlay = false;\nAdd(new OnPaint(Color.Red, \"MyPlot1\"));\n// Zeichenobjekte im Preischart zeichnen\nIsAddDrawingsToPricePanel = true;\n}\nprotected override void OnCalculate()\n{\n// zeichnet im Preischart eine vertikale Linie am Bar von vor 5 Perioden\nAddChartVerticalLine(\"MyVerticalLine\", 5, Color.Black);\n}\n\n\n\n\nIsAutoAdjustableScale\n\n\nBeschreibung\n\n\nAuto scale is a property of indicators that can be set within the OnInit() method.\n\n\nIsAutoAdjustableScale = true (default)\n\n\n\n\nDie Preisachse (y-Achse) des Charts wird so eingestellt, dass alle Plots und Lines eines Indikators bzw. einer Strategie im Chart sichtbar sind.\n\n\nIsAutoAdjustableScale = false\n\n\n\n\nPlots und Lines eines Indikators bzw. einer Strategie werden nicht in die Skalierung der Preisachse (y-Achse) eines Charts mit einbezogen. Sie k\u00f6nnen auch ausserhalb des sichtbaren Chartbereichs liegen.\n\n\nDie Eigenschaft kann abgefragt werden, und liefert \"true\" bzw. \"false\".\n\n\nVerwendung\n\n\nIsAutoAdjustableScale\n\n\nBeispiel\n\n\nprotected override void OnInit()\n{\n//Chart so skalieren, dass alle Zeichenobjekte sichtbar sind\nIsAutoAdjustableScale = true;\n}\n\n\n\n\nIsOverlay\n\n\nBeschreibung\n\n\nDie Eigenschaft Overlay legt fest, ob die Indikatorausgaben, wie Plots und Linien, im Preischart \u00fcber die Kursbars gezeichnet werden oder ob ein neues separates Chartfenster unterhalb des Preischarts ge\u00f6ffnet wird.\n\n\nIsOverlay = true\n\n\n\n\nEs wird \u00fcber den Kurs gezeichnet (wie z.B. ein \nSMA\n)\n\n\nIsOverlay = false (default)\n\n\n\n\nEs wird ein separates Chartfenster ge\u00f6ffnet (wie z.B. ein \nRSI\n)\n\n\nDie Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false).\n\n\nVerwendung\n\n\nIsOverlay\n\n\nBeispiel\n\n\nprotected override void OnInit()\n{\nAdd(new OnPaint(Color.Red, \"MyPlot1\"));\n//Der Indikator soll in einem separaten Fenster dargestellt werden\nIsOverlay = false;\n}\n\n\n\n\nIsProcessingBarIndexLast\n\n\nDescription\n\n\nIndicates if current bar is last in calculation.\n\n\nParameter\n\n\nNone\n\n\nReturn value\n\n\nType bool\n\n\nUsage\n\n\nused for complicated calculation on a last bar\n\n\nExample\n\n\nprotected override void OnCalculate()\n{\n            base.OnCalculate();\n            if (!IsProcessingBarIndexLast)\n                return;\n            bool isUpdated;\n}\n\n\n\n\nIsSerieRising()\n\n\nBeschreibung\n\n\nMit der Methode IsSerieRising() kann gepr\u00fcft werden, ob eine \"ist steigend\"-Bedingung vorliegt, d.h. ob der aktuelle Wert gr\u00f6\u00dfer ist als der Wert des vorhergehenden Bars.\n\n\nSiehe auch \nCrossAbove()\n, \nCrossBelow()\n, \nIsSerieRising()\n, \nIsSerieFalling()\n.\n\n\nVerwendung\n\n\nIsSerieRising(IDataSeries series)\n\n\n\n\nR\u00fcckgabewert\n\n\ntrue\n wenn die Datenreihe steigt\n\nfalse\n wenn die Datenreihe nicht steigt\n\n\nParameter\n\n\nseries eine Datenserie, wie z.B. ein Indikator, Close, High o.\u00e4\n\n\nBeispiele\n\n\n// Pr\u00fcfen, ob der SMA(20) steigt\nif (IsSerieRising(SMA(20)))\nPrint(\"The SMA(20) is currently rising.\");\n\n\n\n\nIsSeriesFalling()\n\n\nBeschreibung\n\n\nMit der Methode  IsSeriesFalling() kann gepr\u00fcft werden, ob eine \"ist fallend\"-Bedingung vorliegt, d.h. ob der aktuelle Wert kleiner ist als der Wert des vorhergehenden Bars.\n\n\nSiehe auch  \nCrossAbove()\n, \nCrossBelow()\n, \nIsSerieRising()\n, \nIsSerieFalling()\n.\n\n\nVerwendung\n\n\nIsSerieFalling(IDataSeries series)\n\n\n\n\nR\u00fcckgabewert\n\n\ntrue\n wenn die Datenreihe f\u00e4llt\n\nfalse\n wenn die Datenreihe nicht f\u00e4llt\n\n\nParameter\n\n\nseries eine Datenserie, wie z.B. ein Indikator, Close, High o.\u00e4\n\n\nBeispiele\n\n\n// Pr\u00fcfen, ob der SMA(20) f\u00e4llt\nif (IsSerieFalling(SMA(20)))\nPrint(\"The SMA(20) is currently falling.\");\n\n\n\n\nIsShowChartVerticalGrid\n\n\nBeschreibung\n\n\nDie Eigenschaft IsShowChartVerticalGrid legt fest, ob in regelm\u00e4\u00dfigen Abst\u00e4nden vertikale Linien im Chart (das sog. vertikale Grid) angezeigt werden sollen.\n\n\nIsShowChartVerticalGrid = true (default)\n\n\nVertikale Gitternetzlinien werden im Chart angezeigt.\n\n\nIsShowChartVerticalGrid = false\n\n\nVertikale Gitternetzlinien werden nicht im Chart angezeigt.\n\n\nDie Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false).\n\n\nVerwendung\n\n\nIsShowChartVerticalGrid\n\n\nBeispiel\n\n\nprotected override void OnInit()\n{\nAdd(new OnPaint(Color.Red, \"MyPlot1\"));\n// Vertikale Gitternetzlinien sollen nicht im Chart angezeigt werden\nIsShowChartVerticalGrid = false;\n}\n\n\n\n\nIsShowInDataBox\n\n\nBeschreibung\n\n\nDie Eigenschaft  \"IsShowInDataBox\" gibt an, ob die Werte des Indikators (Datenserien) in der DataBox des Charts enthalten sein sollen oder nicht.\n\n\nDie Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false)\n\n\nIsShowInDataBox = true (default)\n\n\n\n\nDie Indikatorwerte werden in der DataBox angezeigt.\n\n\nIsShowInDataBox = false\n\n\n\n\nDie Indikatorwerte werden nicht in der DataBox angezeigt.\n\n\nIm Bild werden die Werte von 3 gleitenden Durchschnitten in der DataBox angezeigt.\n\n\n\n\nVerwendung\n\n\nIsShowInDataBox\n\n\nBeispiel\n\n\nprotected override void OnInit()\n{\nAdd(new OnPaint(Color.Red, \"MyPlot1\"));\n//Werte sollen nicht in der DataBox angezeigt werden\nIsShowInDataBox = false;\n}\n\n\n\n\nIsShowPriceMarkers\n\n\nBeschreibung\n\n\nDie Eigenschaft PaintPriceMarkers legt fest, ob f\u00fcr die Indikatorausgaben, am rechten Chartrand (in der Preisachse) die sog. PriceMarkers angezeigt werden sollen oder nicht. In manchen F\u00e4llen ist es sinnvoll, dies f\u00fcr eine bessere \u00dcbersicht im Chart auszuschalten.\n\nIsShowPriceMarkers = true (default)\n\n\nPriceMarkers werden in der Preisachse angezeigt.\n\n\nIsShowPriceMarkers = false\n\n\nPriceMarkers werden nicht in der Preisachse angezeigt.\n\n\nDie Eigenschaft kann imScript abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false).\n\n\nVerwendung\n\n\nIsShowPriceMarkers\n\n\nBeispiel\n\n\nprotected override void OnInit()\n{\nAdd(new OnPaint(Color.Red, \"MyPlot1\"));\n//IsShowPriceMarkers sollen nicht angezeigt werden\nIsShowPriceMarkers = false;\n}\n\n\n\n\nLevel1Args\n\n\nBeschreibung\n\n\nDer Datentyp MarketDataEventArgs repr\u00e4sentiert eine \u00c4nderung in den Level-I-Daten und wird als Parameter in der Funktion OnLevel1() verwendet.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAskSize\n\n\nDas aktuelle Ordervolumen auf der Ask-Seite.\n\n\n\n\n\n\nAskPrice\n\n\nDer aktuelle Ask-Kurs\n\n\n\n\n\n\nBidSize\n\n\nDas aktuelle Ordervolumen auf der Bid-Seite\n\n\n\n\n\n\nBidPrice\n\n\nDer aktuelle Bid-Kurs.\n\n\n\n\n\n\nInstrument\n\n\nEin Objekt des Types IInstrument, das das Handelsinstrument beinhaltet, f\u00fcr welches die Level-I-Daten geliefert werden. Siehe \nInstruments\n\n\n\n\n\n\nLastPrice\n\n\nDer letzte durch einen Umsatz entstandene Kurs\n\n\n\n\n\n\nMarketDataType\n\n\nM\u00f6gliche Werte sind: MarketDataType.Ask, MarketDataType.AskSize, MarketDataType.Bid, MarketDataType.BidSize, MarketDataType.Last, MarketDataType.Volume\n\n\n\n\n\n\nPrice\n\n\nTenth\u00e4lt den gleichen Wert wie LastPrice. Das Feld ist nur aus Kompatibilit\u00e4tsgr\u00fcnden vorhanden.\n\n\n\n\n\n\nTime\n\n\nEin DateTime-Wert, der den Zeitstempel der \u00c4nderung beinhaltet.\n\n\n\n\n\n\nVolume\n\n\nEin long-Wert, der das Volumen, d.h. den letzten realen Umsatz angiebt.\n\n\n\n\n\n\n\n\nBeispiel\n\n\nsiehe Beispiel unter \nOnLevel1()\n.\n\n\nLevel2Args\n\n\nBeschreibung\n\n\nDer Datentyp  Level2Args repr\u00e4sentiert eine \u00c4nderung in den Level-II-Daten (Markttiefe) und wird als Parameter in der Funktion OnLevel2() verwendet.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMarketDataType\n\n\nM\u00f6gliche Werte sind: MarketDataType.Ask, MarketDataType.Bid\n\n\n\n\n\n\nMarketMaker\n\n\nEin string-Wert, der die Market Maker ID enth\u00e4llt\n\n\n\n\n\n\nPosition\n\n\nEin int-Wert, der die Position innerhalb der Markttiefe angiebt\n\n\n\n\n\n\nOperation\n\n\nSteht f\u00fcr die Aktion, die durch die \u00c4nderung in einem Orderbuch ausgel\u00f6st wird.  M\u00f6gliche Werte sind: Operation.Insert, Operation.Remove, Operation.Update\n\n\n\n\n\n\nPrice\n\n\nEine double-Wert, der den jeweiligen Bid/Ask-Kurs\n\n\n\n\n\n\nTime\n\n\nEin DateTime-Wert, der den Zeitstempel der \u00c4nderung beinhaltet\n\n\n\n\n\n\nVolume\n\n\nEin long-Wert, der das Volumen angiebt\n\n\n\n\n\n\n\n\nBeispiel\n\n\nsiehe Beispiel unter \nOnLevel2()\n.\n\n\nLevelLine()\n\n\nBeschreibung\n\n\nEinA LevelLine object wird genutzt, um eine horizontale Linie in einen Chart zu zeichnen. \u00dcblicherweise sind dies obere und untere Triggerlinien wie z.B. beim RSI-Indikator die 70 und die 30 Linie.\nDiese hier beschriebenen Linien sind nicht zu verwechseln mit der Linie aus den Zeichenobjekten  (siehe \"AddChartHorizontalLine\").\nLevelLine objectwerden einem Indikator mit Hilfe der Add()-Methode hinzugef\u00fcgt und damit in die Lines-Collection aufgenommen.\n\n\nSiehe auch \nOnPaint\n.\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nColor\n\n\nLinienfarbe\n\n\n\n\n\n\nName\n\n\nBezeichnung\n\n\n\n\n\n\nPen\n\n\nein Pen-Objekt\n\n\n\n\n\n\nValue\n\n\nGibt an, bei welchem Wert auf der y-Achse (Preisachse) die Linie gezeichnet werden soll\n\n\n\n\n\n\n\n\nVerwendung\n\n\nLevelLine(Color color, double value, string name)\nLevelLine(Pen pen, double value, string name)\n\n\n\n\nWeitere Informationen\n\n\nInformationen zur Klasse Pen: \nhttp://msdn.microsoft.com/de-de/library/system.drawing.pen.aspx\n\n\nBeispiele\n\n\n// Beispiel 1\n// Eine Linie mit Standardwerten bei 70 in den Chart zeichnen\nAdd(new LevelLine(Color.Black, 70, \"Upper\"));\n// Beispiel 2\n// Eine Linie mit selbstdefinierten Werten in den Chart zeichnen\nprivate LevelLine line;\nprivate Pen pen;\nprotected override void OnInit()\n{\n// einen roten Stift mit der Linienst\u00e4rke 1 definieren\npen = new Pen(Color.Red, 1);\n// eine horizontale Linie bei 10 definieren\nline = new LevelLine(pen, 10, \"MyLine\");\n// die oben def. Linie dem Indikator hinzuf\u00fcgen\nAdd(line);\n}\n// Beispiel 3\n// Kurzform f\u00fcr die Linie aus Bespiel 2\nAdd(new LevelLine(new Pen(Color.Red, 1), 10, \"MyLine\"));\n\n\n\n\nLog()\n\n\nBeschreibung\n\n\nMit Log() ist es m\u00f6glich, Ausgaben in das LogFile (Log Tab) von AgenaTrader zu schreiben. Es werden 5 verschiedene LogLevel unterst\u00fctzt.\n\n\nHinweis: Ist der Log-Tab nicht sichtbar, kann er mit Tools-Log angezeigt werden.\n\n\nVerwendung\n\n\n**Log**(string message, LogLevel logLevel)\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nText (message)\n\n\n\n\n\n\nlogLevel\n\n\nM\u00f6gliche Werte sind: InfoLogLevel.Info, InfoLogLevel.Message, InfoLogLevel.Warning, InfoLogLevel.ShowAlert, InfoLogLevel.Error\n\n\n\n\n\n\n\n\nBeispiel\n\n\n//Tab protocol\nLog(\"Das ist eine Information.\", InfoLogLevel.Info); //white\nLog(\"Das ist eine Nachricht.\", InfoLogLevel.Message); // white\nLog(\"Das ist eine Warnung.\", InfoLogLevel.Warning); // blue\nLog(\"Das ist ein Alarm.\", InfoLogLevel.ShowAlert); //green\nLog(\"Das ist ein Fehler.\", InfoLogLevel.Error); // red\n//Tab messages\nLog(\"This is a message (messages).\", InfoLogLevel.Message); //white\n//PopUp & protocoll\nLog(\"This is an alert popup window.\", InfoLogLevel.ShowAlert); //green\n\n//Output-Tab:\n//InfoLogLevel.Message = send to Tab \"Messages\" not \"Log\"\n\n//Action:\n/*\nInfoLogLevel.Error: also the AT-Status-Line is red and flashes\nInfoLogLevel.ShowAlert: opens also a modeless messagebox\n*/\n\n/*\nSummary: * - InfoLogLevel.ShowAlert Color: green Tab: Log Action: modeless Messagebox * - InfoLogLevel.Warning Color: blue Tab: Log * - InfoLogLevel.Info Color: white Tab: Log * - InfoLogLevel.Error Color: red Tab: Log Action: AT-Status-Line: red + flashing (Error) * - InfoLogLevel.Message Color: white Tab: Messages\n*/\n\n\n\n\nCrossreference:\na crossreference to Print() and ShowAlert()\n\n\nOccurred\n\n\nBeschreibung\n\n\nDiese DataSeries werden unter Bedingungen verwendet und geben an, ob ein Signal aufgetreten ist(1-long, -1 short, 0- kein signal )\n\n\nParameter\n\n\nkeiner\n\n\nR\u00fcckgabewert\n\n\nInt\n\n\nVerwendung\n\n\nIm Skriptzustand f\u00fcr short, long, kein Signal\n\n\nBeispiel\n\n\nprotected override void OnCalculate()\n{\nif ( ProcessingBarIndex %2 == 0 )\nOccurred.Set(1); // Long\nelse if ( ProcessingBarIndex %3 == 0 )\nOccurred.Set(-1); // Short\nelse\nOccurred.Set(0);\n}\n\n\n\n\nOnBarsRequirements()\n\n\nBeschreibung\n\n\nDie OnBarsRequirements() Methode wird einmal zu Beginn einer Indikator- bzw. Strategieberechnung aufgerufen. Die Methode ist nur bei Verwendung von MultiBars notwendig.\nInnerhalb von InitRequirements werden keine weiteren Programmierbefehle ausgef\u00fchrt.\nF\u00fcr eigene Initialisierungen sind die MethodenOnInit() bzw. OnStart() zu verwenden.\n\n\nParameter\n\n\nkeiner\n\n\nR\u00fcckgabewert\n\n\nkeiner\n\n\nBeispiel\n\n\nprotected override void OnBarsRequirements()\n{\nAdd(DatafeedHistoryPeriodicity.Day, 1);\nAdd(DatafeedHistoryPeriodicity.Week, 1);\n}\n\n\n\n\nOnInit()\n\n\nBeschreibung\n\n\nDie OnInit()-Methode wird einmal zu Beginn einer Indikator- bzw. Strategieberechnung aufgerufen. Die Methode kann verwendet werden um Indikatoreigenschaften zu setzen, eigene Variablen zu initialisieren oder Plots hinzuzuf\u00fcgen.\n\n\nParameter\n\n\nkeiner\n\n\nR\u00fcckgabewert\n\n\nkeiner\n\n\nVerwendung\n\n\nprotected override void OnInit()\n\n\n\n\nwichtige Schl\u00fcsselworte\n\n\n\n\nAdd()\n\n\nAllowRemovalOfChartDrawings\n\n\nIsAutoScale\n\n\nRequiredBarsCount\n\n\nCalculateOnClosedBar\n\n\nClearTraceWindow\n\n\nDisplacement\n\n\nIsShowInDataBox\n\n\nIsAddDrawingsToPricePanel\n\n\nInputPriceType\n\n\nIsOverlay\n\n\nIsShowPriceMarkers\n\n\nIsShowChartVerticalGrid\n\n\n\n\nzus\u00e4tzlich f\u00fcr Strategien\n\n\n\n\nDefaultOrderQuantity\n\n\nEntriesPerDirection\n\n\nSetUpStopLoss()\n\n\nSetUpProfitTarget()\n\n\nSetUpTrailStop()\n\n\nTimeInForce\n\n\nTraceOrders\n\n\n\n\nWeitere Informationen\n\n\nAchtung:\n\nDie OnInit()-Methode wird nicht nur am Beginn einer Indikator- bzw. Strategieberechnung aufgerufen, sondern auch unerwartet z.B. wenn ein Chart neu geladen wird oder der Eigenschaftsdialog von Indikatoren ge\u00f6ffnet wird usw.\nEntwickler von eigenen AgenaScripts sollten diese Methode NICHT verwenden, um eigene Routinen laufen zu lassen, Forms zu \u00f6ffnen, Lizenzchecks auszuf\u00fchren u. dgl. mehr. Hierzu ist die Methode  OnStart() zu verwenden.\n\n\nBeispiel\n\n\nprotected override void OnInit()\n{\nAdd(new OnPaint(Color.Blue, \"myPlot\"));\nClearTraceWindow();\nIsAutoScale = false;\nIsOverlay = true;\nIsShowPriceMarkers = false;\nIsShowInDataBox = false;\nCalculateOnClosedBar = true;\n}\n\n\n\n\nOnPaint()\n\n\nBeschreibung\n\n\nEinOnPaint (drawing)wird genutzt, um einen Indikator in einem Chart graphisch darzustellen. Plot-Objekte werden einem Indikator mit Hilfe der Add()-Methode hinzugef\u00fcgt und damit in die Plots-Collection aufgenommen.\nSiehe auch  \nLevelLine\n.\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nColor\n\n\nZeichenfarbe\n\n\n\n\n\n\nPen\n\n\nein Pen-Objekt\n\n\n\n\n\n\nPlotStyle\n\n\nLinienart: PlotStyle.Bar, PlotStyle.Block, PlotStyle.Cross, PlotStyle.Dot, PlotStyle.Hash, PlotStyle.LevelLine, PlotStyle.Square, PlotStyle.TriangleDown, PlotStyle.TriangleUp\n\n\n\n\n\n\nName\n\n\nBezeichnung\n\n\n\n\n\n\n\n\nVerwendung\n\n\nOnPaint(Color color, string name)\nOnPaint(Pen pen, string name)\nOnPaint(Color color, PlotStyle plotStyle, string name)\nOnPaint(Pen pen, PlotStyle plotStyle, string name)\n\n\n\n\nWeitere Informationen\n\n\nInformationen zur Klasse Pen: \nhttp://msdn.microsoft.com/de-de/library/system.drawing.pen.aspx\n\n\nBeispiele\n\n\n// Beispiel 1\n// Plot mit Standardwerten (Linie mit Linienst\u00e4rke 1)\nAdd(new OnPaint(Color.Green, \"MyPlot\"));\n// Beispiel 2\n// benutzerdefinierte Werte f\u00fcr Pen und PlotStyle\nprivate OnPaint plot;\nprivate Pen pen;\nprotected override void OnInit()\n{\n// einen roten Stift mit der Linienst\u00e4rke 6 definieren\npen = new Pen(Color.Blue, 6);\n// eine Punkt-Linie mit dem dicken roten Stift von oben definieren\nplot = new OnPaint(pen, PlotStyle.Dot, \"MyPlot\");\n// den oben def. Plot als Darstellung f\u00fcr den Indikator verwenden\nAdd(plot);\n}\n// Beispiel 3\n// Kurzform von Beispiel 2\nprotected override void OnInit()\n{\nAdd(new OnPaint(new Pen(Color.Blue, 6), PlotStyle.Dot, \"MyPlot\"));\n}\n\n\n\n\nInputParameter()\n\n\nBeschreibung\n\n\nAttribut, das f\u00fcr die Anpassung der Indikatoren verwendet wird\n\n\nR\u00fcckgabewert\n\n\nkeiner\n\n\nParameter\n\n\nkeiner\n\n\nBeispiele\n\n\n[Description(\"Period for the medium mean average\")]\n[InputParameter]\n[DisplayName(\"MA Medium\")]\npublic int MA_Medium\n{\n    get \n    { \n        return _ma_medium; \n    }\n    set\n    {\n        _ma_medium = value;\n    }\n}\n\n\n\n\nPlaySound()\n\n\nBeschreibung\n\n\nDie Methode PlaySound() dient dazu, ein Wav-File abzuspielen.\n\n\nVerwendung\n\n\nPlaySound\n(wavFile)\n\n\nR\u00fcckgabewert\n\n\nkeiner\n\n\nParameter\n\n\nwavFile Dateiname der Wav-Datei zum Abspielen\n\n\nBeispiel\n\n\nusing System.IO;\nstring path = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);\nstring file = \"\\\\\\\\AgenaTrader\\\\\\\\Sounds\\\\\\\\Alert1.wav\";\nPlaySound(path + file);\n\n\n\n\nPlotMethod\n\n\nBeschreibung\n\n\nIn jedem Indikator kann die Plot-Methode \u00fcberschrieben werden um mit Mittlen der Graphics-Klasse (System.Drawing) dem Preis-Chart  eigene Grafiken hinzuzuf\u00fcgen (GDI+).\n\n\nSiehe \nhttp://msdn.microsoft.com/de-de/library/system.drawing.graphics.aspx\n.\n\n\nDas Objekt  \nChart\n bietet einige n\u00fctzliche Parameter.\n\n\nWeitere Beispiele: \nBar Numbering\n, \nPlotSample\n, \nChart Background Image\n.\n\n\nParameter\n\n\ngraphics Das graphics-Objekt des Preischarts (der sog. context)\n\n\nrectangle Die Gr\u00f6\u00dfe der Zeichenfl\u00e4che (Type public struct rectangle)\n\n\ndouble min Der kleinste Kurs in der y-Achse\n\n\ndouble max Der gr\u00f6\u00dfte Kurs in der y-Achse\n\n\nR\u00fcckgabewert\n\n\nkeiner\n\n\nVerwendung\n\n\npublic override void OnPaint(Graphics graphics, Rectangle r, double min, double max)\n\n\n\n\nBeispiel\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing AgenaTrader.API;\nusing AgenaTrader.Custom;\nusing AgenaTrader.Plugins;\nnamespace AgenaTrader.UserCode\n{\n[Description(\"Example for the usage of the plot method.\")]\npublic class PlotSample : UserIndicator\n{\nprivate StringFormat stringFormat = new StringFormat();\nprivate SolidBrush brush = new SolidBrush(Color.Black);\nprivate Font font = new Font(\"Arial\", 10);\nprotected override void OnInit()\n{\nIsChartOnlyIndicator = true;\nIsOverlay = true;\n}\nprotected override void OnCalculate()\n{}\nprotected override void OnDispose()\n{\nbrush.Dispose();\nstringFormat.Dispose();\n}\npublic override void OnPaint(Graphics graphics, Rectangle r, double min, double max)\n{\n// Ausfuellen eines Rechtecks\nSolidBrush tmpBrush = new SolidBrush(Color.LightGray);\ngraphics.FillRectangle(tmpBrush, new Rectangle (0, 0, 300, 300));\ntmpBrush.Dispose();\n// Zeichnen einer roten Linie von oben links nach unten recht\nPen pen = new Pen(Color.Red);\ngraphics.AddChartLine(pen, r.X, r.Y, r.X + r.Width, r.Y + r.Height);\n// Zeichnen einer roten Linie von unten links nach oben rechts\n// Verwenden von AnitAlias (Die Linie erscheint glatter)\n// Die aktuellen Einstellungen fuer die Glaettung werden gesichert\n // und nach dem Zeichnen wiederhergestellt\nSmoothingMode oldSmoothingMode = graphics.SmoothingMode; //Einstellung sichern\ngraphics.SmoothingMode = SmoothingMode.AntiAlias; // hohe Glaettung verwenden\ngraphics.AddChartLine(pen, r.X, r.Y + r.Height, r.X + r.Width, r.Y);\ngraphics.SmoothingMode = oldSmoothingMode; // Einstellungen wiederherstellen\npen.Dispose();\n// Text in die obere linke Ecke (Position 10,35) schreiben\nstringFormat.Alignment = StringAlignment.Near; // Text links ausrichten\nbrush.Color = Color.Blue;\ngraphics.DrawString(\"Hello world!\", font, brush, r.X + 10, r.Y + 35, stringFormat);\n// Text in die linke untere Ecke schreiben und eine Linie darum herumzeichnen\nbrush.Color = Color.Aquamarine;\ngraphics.FillRectangle(brush, r.X + 10, r.Y + r.Height - 20, 140, 19);\n// Aeussere Linie zeichnen\npen = new Pen(Color.Black);\ngraphics.AddChartRectangle(pen, r.X + 10, r.Y + r.Height - 20, 140, 19);\npen.Dispose();\n// Text schreiben\nbrush.Color = Color.Red;\ngraphics.DrawString(\"Here is bottom left!\", font, brush, r.X + 10, r.Y + r.Height - 20, stringFormat);\n}\n}\n}\n\n\n\n\nPriceType\n\n\nBeschreibung\n\n\nPriceType beschreibt die Art von Kursdaten.\n\n\nSiehe auch \nInputPriceType\n\n\nFolgende Werte stehen zur Verf\u00fcgung:\n-   PriceType.Close\n-   PriceType.High\n-   PriceType.Low\n-   PriceType.Median\n-   PriceType.Open\n-   PriceType.Typical\n-   PriceType.Volume\n-   PriceType.Weighted\n\n\nVerwendung\n\n\nPriceType\n\n\nBeispiel\n\n\nSiehe Beispiel unter \nInputPriceType\n\n\nPrint()\n\n\nBeschreibung\n\n\nDie Methode Print() schreibt Ausgaben in das AgenaTrader Output-Window.\nSiehe auch \nClearTraceWindow\n.\n\n\nVerwendung\n\n\nPrint(string message)\nPrint(bool value)\nPrint(double value)\nPrint(int value)\nPrint(DateTime value)\nPrint(string format, string message)\n\n\n\n\nParameter\n\n\nstring Text ein individueller Meldungstext\n\n\nR\u00fcckgabewert\n\n\nkeiner\n\n\nWeitere Informationen\n\n\nHinweise zum Formatieren von Ausgaben finden Sie unter \nFormatting numbers\n.\n\n\nHinweise zur String.Format()-Methode:  \nhttp://msdn.microsoft.com/de-de/library/fht0f5be%28v=vs.80%29.aspx\n\n\nBeispiel\n\n\n// \"Quick&Dirty\"-Formatierung einer Zahl mit 2 Nachkommastellen\nPrint(Close[0].ToString(\"0.00\"));\n// Wochentag aus dem Zeitstempel des Bars ausgeben\nPrint(string.Format(\"{0:dddd}\", Time[0]));\n// Ein zus\u00e4tzlicher Zeilenvorschub mit ESC-Sequenz\nPrint(\"One empty row afterwards \\\\n\");\n\n\n\n\nProcessingBarIndex\n\n\nBeschreibung\n\n\nProcessingBarIndex  ist eine Nummerierung von Bars, die in der Methode OnCalculate()  verwendet wird. Wenn in einem Chart z.B. 500 Bars dargestellt werden und auf diese ein Indikator berechnet werden soll, so beginnt AgenaTrader mit der Berechnung (also dem Aufruf von OnCalculate() bei dem \u00e4ltesten Bar. Dieser bekommt die Nummer 0. Ist die Berechnung f\u00fcr diesen Bar abgeschlossen, wird OnCalculate() f\u00fcr den n\u00e4chsten Bar aufgerufen. Dieser bekommt dann die Nummer 1 usw. bis zum letzten Bar, der die Nummer 499 bekommt.\n\n\nParameter\n\n\nkeiner\n\n\nR\u00fcckgabewert\n\n\nProcessingBarIndex ist eine Variable vom Typ int, die immer die Nummer des sich gerade in Bearbeitung befindenden Bars enth\u00e4lt.\n\n\nVerwendung\n\n\nProcessingBarIndex\n\n\nWeitere Informationen\n\n\nDie in der Methode  OnCalculate() verwendete Nummerierung mit ProcessingBarIndex unterscheidet sich vom \nBarindex\n und \nBars\n. Das Verst\u00e4ndnis dieses Unterschiedes ist sehr wichtig! Bitte das folgende genau lesen!\n\n\nProcessingBarIndex nummeriert fortlaufend vom \u00e4ltesten zum j\u00fcngsten Bar beginnend bei 0. Der Barindex ist f\u00fcr den j\u00fcngsten Bar immer 0. Im Beispiel unten steht Time[0] f\u00fcr den Zeitstempel des aktuellen Bars. Der Index des \u00e4ltesten Bars wird mit jedem neu hinzukommenden Damit wird eine logische Z\u00e4hlung f\u00fcr barsAgo m\u00f6glich. Der Zeitstempel f\u00fcr den Bar von vor 5 Perioden ist damit Time[5].\nBei Verwendung mehrerer Zeiteinheiten (multi-bars)in einem Indikator siehe ProcessingBarIndexes.\n\n\nBeispiel\n\n\nprotected override void OnCalculate()\n{\nPrint(\"Call of OnCalculate for bar nr. \" + ProcessingBarIndex + \" of \" + Time[0]);\n}\n\n\n\n\nRemoveChartDrawing()\n\n\nBeschreibung\n\n\nDie Methode RemoveChartDrawing() entfernt ein bestimmtes Zeichenobjekt vom Chart anhand einer eindeutigen Kennzeichnung (tag).\nSiehe auch \nRemoveChartDrawings()\n.\n\n\nVerwendung\n\n\nRemoveChartDrawings(string tag)\n\n\nR\u00fcckgabewert\n\n\nkeiner\n\n\nParameter\n\n\nstring tag Der Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\nBeispiel\n\n\nRemoveChartDrawings(\"Meine Linie\");\n\n\n\n\nRemoveChartDrawings()\n\n\nBeschreibung\n\n\nDie Methode RemoveDrawObjects() entfernt alle Zeichenobjekte vom Chart.\nSiehe auch \nRemoveChartDrawings()\n.\n\n\nVerwendung\n\n\nRemoveChartDrawings()\n\n\nR\u00fcckgabewert\n\n\nkeiner\n\n\nBeispiel\n\n\n//Alle Zeicheobjekte vom Chart l\u00f6schen\nRemoveChartDrawings();\n\n\n\n\nRequiredBarsCount\n\n\nBeschreibung\n\n\nDie Eigenschaft BarsRequired gibt an, wieviele historische Bars mindestens ben\u00f6tigt werden, damit ein Indikator bzw. eine Strategie erstmal die Methode OnCalculate() aufrufen und mit den Berechnungen beginnen kann. BarsRequired sollte in der OnInit() Methode angegeben werden.\nDie Einstellung sollte sorgf\u00e4ltig gew\u00e4hlt werden. Z.B. braucht man zur Berechnung eines gleitenden Durchschnittes \u00fcber 100 Tage auch mindestens 100 Tage historische Daten, damit das Ergebnis korrekt ist.\n\n\nDie Eigenschaft kann im Script abgefragt werden und liefert einen int-Wert.\n\n\nWenn OnBarUpdate erstmals aufgerufen wird, ist  ProcessingBarIndex property = 0, unabh\u00e4ngig vom Wert von RequiredBarsCount.\n\n\nVerwendung\n\n\nRequiredBarsCount\n\n\nBeispiel\n\n\nprotected override void OnInit()\n{\n//Der Indikator ben\u00f6tigt mindestens 50 Bars Historie\nRequiredBarsCount = 50;\n}\n\n\n\n\nShowAlert()\n\n\nBeschreibung\n\n\nMit der Methode  ShowAlert wird ein akustischer und/oder visueller Alarm erzeugt.\n\n\nVerwendung\n\n\nShowAlert(string message, bool showMessageBox, string soundLocation);\n//Aus Kompatibilit\u00e4tsgr\u00fcnden ist noch eine veraltete Signatur enthalten. Bei Nutzung dieses Aufrufvariante werden die Farbangaben und \"rearmSeconds\" ignoriert.\nShowAlert(string id, AlertPriority priority, string message, string soundLocation, int rearmSeconds, Color backColor, Color forColor);\n\n\n\n\nR\u00fcckgabewert\n\n\nkeiner\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nNachrichtentext, der im Messages-Tab angezeigt wird.\n\n\n\n\n\n\nsoundLocation\n\n\nName eines Sound-Files im *.wav Format. Ist kein Pfad angegeben, wird \"Eigene Dokumente\\AgenaTrader\\Sounds\" verwendet.\n\n\n\n\n\n\nshowMessageBox\n\n\nwenn true, wird zus\u00e4tzlich zum Sound eine Messagebox auf dem Bildschim angezeigt.\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// Hinweis ausgeben, wenn der SMA(20) unter SMA(50) kreuzt\nif (CrossBelow(SMA(20), SMA(50), 1))\nAlert(\"Check short signal!\", true, \"Alert4.wav\");\n\n\n\n\nUm Musikdateien in anderen Verzeichnissen wiederzugeben, muss der vollst\u00e4ndige Pfad angegeben werden, z.B.:\n\n\nstring pathOfSoundfile = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments)+@\"\\\\MyAlertSounds\\\\\";\nstring nameOfSoundFile = \"MyAlertSoundFile.wav\";\nAlert(\"Message text\", true, pathOfSoundfile + nameOfSoundFile);\n\n\n\n\nTickSize\n\n\nEin Tick ist die kleinst m\u00f6gliche Kurs\u00e4nderung eines Finanzinstruments an einer B\u00f6rse. Wenn die Handelspreise z.B. mit zwei Stellen nach dem Komma angegeben werden, betr\u00e4gt ein Tick 0,01. Im Forexhandel (W\u00e4hrungshandel) wird mit 4 bzw. 5 Stellen nach dem Komma gearbeitet. Ein Tick - der im Forexhandel als Pip bezeichnet wird - betr\u00e4gt dementsprechend 0,0001 bzw. 0,00001.\nDer Tickwert wird durch die B\u00f6rse fest vorgegeben und \u00e4ndert sich (in der Regel) nicht.\nSiehe auch \nInstrument.TickSize\n.\n\n\n\u00dcblicherweise wird heute ein Tick als Dezimalzahl angegeben. Historisch wurden besonders im amerikanischen Raum Aktien jedoch mit einer Tickgr\u00f6\u00dfe von 1/16 von einem Dollar notiert.\n\n\nBei Rohstoffen ist diese Notierung noch weit verbreitet. Der Corn-Future (ZC - Mais) wird genau wie Wheat (ZW - Weizen) in \u00bc US-Cent/bushel (entspricht 12,50 US-$ je Kontrakt) notiert.\n\n\nUS-Statsanleihen (T-Bonds) werden mit Tickgr\u00f6\u00dfen von 1/32 Punkten gehandelt, was 31,25 US-Dollar entspricht.\n\n\nDie Notierung erfolgt mit Hochkomma:\n149'00 entspricht genau 149,\n149'01 entspricht 149 1/32 (also 149,03125),\n149'31 enspricht 149 31/32 (149,96875),\ndanach folgt dann 150'00.\n\n\nIn sog. T-Bond-Intermonth Spreads werden die Notierungen in Vierteln von 1/32 angegeben, was dann einem Punktwert von $7.8125 per Kontrakt entspricht.\n\n\nDie Notierungen erfolgt mit Bindestrich:\n\n\n17-24 entspricht 17 24/32 Punkten,\n17-242 entspricht 17 24,25/32 Punkten,\n17-245 entspricht 17 24,5/32 Punkten und\n17-247 entspricht 17 24,75/32 Punkten.\nDie n\u00e4chste Notierung nach 17-247 ist 17-25, dann wieder 17-252, 17-255 usw.\nNach 17-317 folgt 18.\n\n\nDie Kontraktspezifikationen sind auf den Internetseiten der jeweiligen B\u00f6rsen ver\u00f6ffentlicht.\n\n\nCME: \nhttp://www.cmegroup.com\n under Products & Trading\nEurex (FDAX): \nhttp://www.eurexchange.com/exchange-en/products/idx/dax/17206/\n\n\nsiehe auch  \nInstrument.TickSize\n.\n\n\nTimeFrame\n\n\nsiehe \nBars.TimeFrame\n.\n\n\nBei Verwendung mehrerer Zeiteinheiten (\nMultibars\n) in einem Indikator siehe \nTimeFrames\n.\n\n\nUpdate()\n\n\nBeschreibung\n\n\nDie Methode Update() ruft die OnCalculateMethode einmal auf, um Indikatorwerte neu zu berechnen.\n\n\nUpdate() ist mit Vorsicht und nur von erfahrenen Programmierern zu verwenden.\n\n\nVerwendung\n\n\nUpdate()\n\n\n\n\nR\u00fcckgabewert\n\n\nkeiner\n\n\nParameter\n\n\nkeiner\n\n\nBeispiel\n\n\nDie Wirkung von Update l\u00e4\u00dft sich mit Hilfe von 2 Indikatoren veranschaulichen.\nDer erste Indikator \"Ind1\" nutzt eine public Variable aus Indikator \"Ind2\".\n\n\nCode von Ind1:\n\n\npublic class Ind1 : UserIndicator\n{\nprotected override void OnCalculate()\n{\nPrint( Ind2().MyPublicVariable );\n}\n}\n\n\n\n\nCode von Ind2:\n\n\nprivate double myPublicVariable = 0;\nprotected override void OnCalculate()\n{\nmyPublicVariable = 1;\n}\npublic double MyPublicVariable\n{\nget\n{\nUpdate();\nreturn myPublicVariable;\n}\n}\n\n\n\n\nOhne Update() - Falsch\n\nWenn Ind2 von Ind1 aufgerufen wird, wird die get-Methode von MyPublicVariable in Ind2 aufgerufen. Ohne Update() w\u00fcrde der Wert von myPublicVariable zur\u00fcckgegeben werden. In diesem Falle eine 0.\n\n\nMit Update() - Richtig\n\nDurch den Aufruf von Update() wird zun\u00e4chst OnBarUpdate() von Ind2 ausgef\u00fchrt. Damit wird myPublicVariable auf 1 gesetzt. Anschlie\u00dfend wird der Wert 1 an den aufrufenden Indikator Ind1 \u00fcbergeben.\n\n\nValue\n\n\nBeschreibung\n\n\nValue ist ein DataSeries-Objekt, welches die erste Datenserie eines Indikators enth\u00e4lt.\n\n\nBeim Aufruf der Add()-Methode wird automatisch ein Value-Objekt erzeugt und der Collection Values hinzugef\u00fcgt.\n\n\nValue ist identisch mit  Values[0].\n\n\nVerwendung\n\n\nValue\n\n\nValue[\nint\n barsAgo]\n\n\nWeitere Informationen\n\n\nDie f\u00fcr eine Collection bekannten Methoden Set(), Reset() und Count() sind auf Value anwendbar.\n\n\nBeispiel\n\n\nSiehe \nValues\n.",
            "title": "Schl\u00fcsselworte"
        },
        {
            "location": "/schluesselworte/#schlusselworte",
            "text": "",
            "title": "Schl\u00fcsselworte"
        },
        {
            "location": "/schluesselworte/#add",
            "text": "",
            "title": "Add()"
        },
        {
            "location": "/schluesselworte/#beschreibung",
            "text": "Mit der Methode Add() werden dem Chart Plot - bzw. Line-Objekte  hinzugef\u00fcgt. Wenn mit Add() ein neues Plot-Objekt hinzugef\u00fcgt wird, wird automatisch auch eine Datenserie vom Typ DataSeries erzeugt, die diesem Plot zugeordnet ist. Auf diese Datenserie kann \u00fcber die Value-Collection zugegriffen werden.\nAdd() kann in der  OnInit() Methode und in der OnCalculate() Methode verwendet werden..",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#parameter",
            "text": "plot \u2013 ein  OnPaint  Objekt\nline \u2013 ein  LevelLine  Objekt",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#verwendung",
            "text": "Add(OnPaint plot)\nAdd(LevelLine line)",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel",
            "text": "#region Usings\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Linq;\nusing System.Xml;\nusing System.Xml.Serialization;\nusing AgenaTrader.API;\nusing AgenaTrader.Custom;\nusing AgenaTrader.Plugins;\nusing AgenaTrader.Helper;\n#endregion\nnamespace AgenaTrader.UserCode\n{\n  [Description(\"Enter the description for the new custom indicator here\")]\n  public class MyIndicator : UserIndicator\n  {\n    protected override void OnInit()\n    {\n    // 2 blaue Linien in den Chart legen, eine bei 70 und eine bei 30\n    Add(new LevelLine(Color.Blue, 70, \"UpperLine\"));\n    Add(new LevelLine(Color.Blue, 30, \"LowerLine\"));\n\n   // 2 Plots hinzuf\u00fcgen\n    Add(new OnPaint(Color.Red, \"myFastSMA\"));\n    Add(new OnPaint(Color.Blue, \"mySlowSMA\"));\n    }\n\n    protected override void OnCalculate()\n    {\n   //Mit der Set-Methode wird der Wert f\u00fcr den aktuellen Bar zugewiesen.\n    FastSMA.Set( SMA(8)[0] ); // ist identisch mit Values[0].Set( SMA(8)[0] );\n    SlowSMA.Set( SMA(50)[0] );// ist identisch mit Values[1].Set( SMA(50)[0] );\n    }\n\n    / Hier werden 2 Datenserien zur Verf\u00fcgung gestellt.\n        // Zur Darstellung des Indikators auf dem Chart sind diese nicht notwendig.\n        // Mit Hilfe dieser Datenserien kann von anderen Indikatoren aus auf diesen Indikator\n        // zugegriffen werden.\n        // Z.B. mit double d = MeinIndikator.FastSMA[0] - MeinIndikator.SlowSMA[0];\n    [Browsable(false)]\n    [XmlIgnore()]\n    public DataSeries FastSMA\n    {\n      get { return Outputs[0]; }\n    }\n\n    [Browsable(false)]\n    [XmlIgnore()]\n    public DataSeries SlowSMA\n    {\n      get { return Outputs[1]; }\n    }\n  }\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#allowremovalofchartdrawings",
            "text": "",
            "title": "AllowRemovalOfChartDrawings"
        },
        {
            "location": "/schluesselworte/#beschreibung_1",
            "text": "AllowRemovalOfDrawObjects ist eine Eigenschaft von Indikatoren, die in der Methode  OnInit()  gesetzt werden kann..  AllowRemovalOfChartDrawings = true  Zeichenobjekte (DrawObjects), die von einem Indikator bzw. einer Strategie in einen Chart gezeichnet wurden, k\u00f6nnen manuell aus dem Chart entfernt werden.  AllowRemovalOfChartDrawings = false (default)  Zeichenobjekte (DrawObjects), die von einem Indikator bzw. einer Strategie in einen Chart gezeichnet wurden, k\u00f6nnen nicht manuell aus dem Chart entfernt werden. Sie werden erst dann vom Chart entfernt, wenn auch der Indikator bzw. die Strategie entfernt wird.  Die Eigenschaft kann abgefragt werden, und liefert \"true\" bzw. \"false\".",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_1",
            "text": "AllowRemovalOfChartDrawings",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel_1",
            "text": "protected override void OnInit()\n{\nAdd(new OnPaint(Color.Red, \"MyPlot1\"));\n//DrawObjects k\u00f6nnen aus dem Chart manuell entfernt werden\nAllowRemovalOfChartDrawings = true;\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#attribute",
            "text": "Attribute sind Bestandteil der Programmiersprache C#. In eigenen AgenaScript-Indikatoren bzw. Strategien k\u00f6nnen Attribute genauso verwendet werden, wie es auch in C# selbst m\u00f6glich ist.\nInformationen \u00fcber Die Verwendung von Attributen finden Sie u.a. hier:  http://msdn.microsoft.com/de-de/library/z0w1kczw%28v=vs.80%29.aspx  Die in AgenaScript am h\u00e4ufigsten verwendeten Attribute sind:   Browsable  Category  ConditionalValue  Description  DisplayName  TimeFrameRequirements  XmlIgnore",
            "title": "Attribute"
        },
        {
            "location": "/schluesselworte/#browsable",
            "text": "Browsable ist ein   Attribute   in AgenaScript.  In AgenaScript werden \u00f6ffentliche Variablen (public variables) zum einen f\u00fcr die Eingabe von Parametern f\u00fcr Indikatoren genutzt (z.B. die Periode f\u00fcr einen SMA) und zum anderen f\u00fcr die Ausgabe von Ergebnissen einer Berechnung innerhalb eines Indikators (z.B. Datenserien).\nVariablen, die der Eingabe von Parametern dienen, m\u00fcssen im Eigenschaften-Dialog angezeigt werden. Datenserien hingegen nicht.  Eine public Variable, die mit dem Attribut Browsable=false gekennzeichnet wurde, wird nicht im Eigenschaftendialog von AgenaTrader angezeigt.  Standardm\u00e4\u00dfig wird Browsable = true angenommen. Daher kann bei einer Variable, die einen Eingabeparameter beinhaltet, das Attribut Browsable auch weggelassen weren.  Beispiel f\u00fcr einen Parameter:  Der Parameter soll im Eigenschaftsfenster angezeigt und abgefragt werden. Daher ist \"Browsable = true\" zu setzen oder das Attribut kann entfallen.  [Description(\"Numbers of bars used for calculations\")]\n[Category(\"InputParameter\")]\npublic int Period\n{\nget { return period; }\nset { period = Math.Max(1, value); }\n}  Beispiel f\u00fcr eine Datenserie:  [Browsable(false)]\n[DisplayName(\"Lower band\")]\n[XmlIgnore]\npublic DataSeries Lower\n{\nget { return Outputs[0]; }\n}",
            "title": "Browsable"
        },
        {
            "location": "/schluesselworte/#category",
            "text": "Category ist ein  Attribute  in AgenaScript.  Das Attribut Category gibt f\u00fcr einen Parameter an, unter welcher Kategorie im Eigenschaften-Dialog der Parameter erscheint.  Wenn das Attribut fehlt, wird standardm\u00e4\u00dfig die Kategorie \"InputParameter\" angenommen.  Das folgende Beispiel erzeugt im Eigenschaften-Dialog die neue Kategorie \"My InputParameter\".  [Category(\"My InputParameter\")]\n[DisplayName(\"Period number\")]\npublic double _period\n{\nget { return _period; }\nset { _period = value; }\n}   Category ist ein   Attribute  in AgenaScript.  Das Attribut Category gibt f\u00fcr einen Parameter an, unter welcher Kategorie im Eigenschaften-Dialog der Parameter erscheint.  Wenn das Attribut fehlt, wird standardm\u00e4\u00dfig die Kategorie \"InputParameter\" angenommen.  Das folgende Beispiel erzeugt im Eigenschaften-Dialog die neue Kategorie \"My InputParameter\".  namespace AgenaTrader.UserCode\n{\n    [Description(\"Description what this indicator doing.\")]\n    [Category(\"My Package\")]\n    public class MyHolyGrail_Indicator : UserIndicator\n    {\n        /* your code here */\n    }\n}",
            "title": "Category"
        },
        {
            "location": "/schluesselworte/#conditionalvalue",
            "text": "ConditionalValue ist ein  Attribute  in AgenaScript.  Normalerweise werden im ConditionEscort f\u00fcr Vergleiche die von Indikatoren bereitgestellten Datenserien (DataSeries) benutzt. Beispielsweise wird gepr\u00fcft, ob ein gleitender Durchschnitt \u00fcber oder unter einem bestimmten Kurswert liegt.\nEin Indikator kann aber auch Werte als Ergebnis haben, die keine Datenserien sind, also z.B. Werte vom Typ int, double, char, boolean, string usw.  Um diese Werte im Scanner oder im Condition-Escort nutzen zu k\u00f6nnen, m\u00fcssen sie mit dem Attribut \"ConditionalValue\" gekennzeichnet sein.  [Browsable(false)]\n[XmlIgnore]\n[ConditionalValue]\npublic int PublicVariable\n{\nget\n{\nUpdate();\nreturn _internVariable;\n}\n}",
            "title": "ConditionalValue"
        },
        {
            "location": "/schluesselworte/#description",
            "text": "Description ist ein   Attribute  in AgenaScript.  Das Attribute Description wird In AgenaScript f\u00fcr die Klasse und f\u00fcr public-Variablen verwendet.  Als Attribut der Klasse ist der Text eine Beschreibung der Funktion des gesamten Indikators (bzw. der Strategie usw.)  [Description(\"Displays the tick count of a bar.\")]\npublic class TickCounter : UserIndicator\n{  As an attribute of a public variable, the text is a description of the function of the parameter.  [Description(\"Number of standard deviations\")]\n[DisplayName(\"# of std. dev.\")]\npublic double NumStdDev\n{\nget { return numStdDev; }\nset { numStdDev = Math.Max(0, value); }\n}\n}  Die Beschreibungen werden jeweils im Eigenschaften-Dialog angezeigt.",
            "title": "Description"
        },
        {
            "location": "/schluesselworte/#displayname",
            "text": "DisplayName ist ein  Attribute  in AgenaScript.  Das Attribute DisplayName legt den Text fest, der im Eigenschaften-Dialog f\u00fcr den Parameter verwendet werden soll.  Wird dieses Attribut nicht angegeben, wird der Name der public Variable verwendet.  [Description(\"Number of standard deviations\")]\n[DisplayName(\"# of std. dev.\")]\npublic double NumStdDev\n{\nget { return numStdDev; }\nset { numStdDev = Math.Max(0, value); }\n}",
            "title": "DisplayName"
        },
        {
            "location": "/schluesselworte/#timeframerequirements",
            "text": "TimeFrameRequirements ist ein  Attribute  in AgenaScript.  Sollen in einem AgenaScript Daten verschiedener Zeiteinheiten verwendet werden, ist der Klasse das Attribut \"TimeFrameRequirements\" voranzustellen. Es k\u00f6nnen hier auch mehrere Zeiteinheiten angegeben werden:  [TimeFrameRequirements(\"1 day\")]\n[TimeFrameRequirements(\"15 minutes\", \"1 day\", \"1 week\")]  Es werden immer so viele Daten der anderen Zeiteinheit(en) bereitgestellt, wie auch Kerzen im Chart geladen sind.\nSind in einem 5 Minuten-Chart beispielsweise 500 Kerzen geladen, werden auch 500 Kerzen einer anderen Zeiteinheit geladen.\nIm Beispiel oben also 500 Tageskerzen bzw. im 2. Beispiel 500 15-Minuen-Kerzen, 500 Tageskerzen und 500 Wochenkerzen.\nDie Datenmengen k\u00f6nnen schnell sehr gro\u00df werden. Das Attribut ist daher mit Umsicht zu verwenden.  siehe auch  MultiBars .  Wichtig:  Wenn in einer Klasse ein anderer Indikator verwendet wird, der seinerseits eine (oder mehrere) sekund\u00e4re Zeiteinheit(en) erfordert, mu\u00df f\u00fcr die aufrufende Klasse ebenfalls das Attribut \"TimeFrameRequirements\" angegeben werden. Ein Beispiel hierzu siehe unter  GetDayBar .",
            "title": "TimeFrameRequirements"
        },
        {
            "location": "/schluesselworte/#xmlignore",
            "text": "XML ignore st ein  Attribute  in AgenaScript.  AgenaTrader speichert in einem Template u.a. auch alle Parameter-Einstellungen eines Indikators. Die Template-Files liegen im XML-Format vor. Um zu verhindern, dass ein Parameter als Teil eines Templates gespeichert wird, kann das Attribut \"XmlIgnore\" angegeben werden.  Um Parameter in einem XML-File speichern zu k\u00f6nnen, m\u00fcssen die Werte zuvor serialisiert werden. In den meisten F\u00e4llen, d.h. f\u00fcr alle g\u00e4ngigen Variablentypen geschieht dies durch AgenaTrader automatisch. Selbst definierte Datentypen k\u00f6nnen jedoch nicht automatisch serialisiert werden. Der Programmierer mu\u00df selbst f\u00fcr die korrekte Serialisierung sorgen.  Im Beispiel werden Farbe und Schriftart als Parameter eines Indikators verwendet. In AgenaTrader existieren f\u00fcr die Serialisierung von Farb- und Schriftart-Informationen 2 Methoden (TextColorSerialize und TextFontSerialize), die die Serialisierung \u00fcbernehmen. Die beiden Parameter \"TextColor\" und \"TextFont\" sind daher mit dem Attribute \"XmlIgnore\" zu kennzeichnen.  private Color _textColor = Color.Blue;\nprivate Font _textFont = new Font(\"Arial\", 12, FontStyle.Bold);\n[XmlIgnore]\n[Description(\"Textcolor\")]\npublic Color TextColor\n{\nget { return _textColor; }\nset { _textColor = value; }\n}\n[Browsable(false)]\npublic string TextColorSerialize\n{\nget { return SerializableColor.ToString(_textColor); }\nset { _textColor = SerializableColor.FromString(value); }\n}\n[XmlIgnore()]\n[Description(\"TextFont\")]\npublic Font TextFont\n{\nget { return _textFont; }\nset { _textFont = value; }\n}\n[Browsable(false)]\npublic string TextFontSerialize\n{\nget { return SerializableFont.ToString(_textFont); }\nset { _textFont = SerializableFont.FromString(value); }\n}",
            "title": "XMLIgnore"
        },
        {
            "location": "/schluesselworte/#calculateonclosedbar",
            "text": "",
            "title": "CalculateOnClosedBar"
        },
        {
            "location": "/schluesselworte/#beschreibung_2",
            "text": "Die Eigenschaft \"CalculateOnClosedBar\" legt fest, f\u00fcr welche Ereignisse AgenaTrader die Methode  OnCalculate() aufrufen soll.  CalculateOnClosedBar = true  OnCalculate()   wird aufgerufen, wenn ein Bar beendet ist, und der n\u00e4chste hereinkommende Tick einen neuen Bar entstehen l\u00e4\u00dft.  CalculateOnClosedBar = false  OnCalculate() wird f\u00fcr jeden neu hereinkommenden Tick aufgerufen.\nAchtung bei \u00e4lterer Hardware: dies f\u00fchrt bei sehr liquiden Werten zu einer erh\u00f6hten Rechnerbelastung.\nDie Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false).\nCalculateOnClosedBar  kann sowohl in OnInit() aals auch in OnCalculate() eingesetzt werden..\nOnCalculate wird f\u00fcr historische Daten immer nur f\u00fcr den Schlusskurs eines jeden Bars aufgerufen, auch wenn CalculateOnClosedBar=false gesetzt ist.\nWird ein Indikator von einem anderen Indikator aufgerufen, so wird die Eigenschaft  CalculateOnClosedBar des aufgerufenen Indikators vom aufrufenden Indikator \u00fcberschrieben.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_2",
            "text": "CalculateOnClosedBar",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#weitere-informationen",
            "text": "Siehe auch die Beschreibung zu  Bars .",
            "title": "Weitere Informationen"
        },
        {
            "location": "/schluesselworte/#beispiel_2",
            "text": "protected override void OnInit()\n{\n//Indikatorberechnung nur, wenn ein Bar fertig ausgepr\u00e4gt ist\nCalculateOnClosedBar = true;\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#chart",
            "text": "Chart  ist ein Objekt, \u00fcber welches der lesende Zugriff auf verschiedene Eigenschaften des Charts m\u00f6glich ist.  Die wichtigsten Eigenschaften sind:   ChartFontColor, BackColor  UpColor, DownColor  Font  BarMarginLeft, BarMarginRight  BarSpace, BarWidth  BarsPainted  FirstBarPainted, LastBarPainted  BarsVisible  FirstBarVisible, LastBarVisible  GetXByBarIdx, GetYByValue   Zur Verwendung der wichtigsten Eigenschaften von Chart siehe Beispiel  PlotSample .  BarsPainted und BarsVisible:  BarsPainted enth\u00e4lt die Anzahl der Bars, die ein Chart von seinem linken Rand zu seinem rechten Rand mit der momentanen Breite der  Kerzen und dem Abstand der Kerzen zueinander anzeigen  k\u00f6nnte .  BarsVisible enth\u00e4lt die Anzahl der Bars, die tats\u00e4chlich zu sehen sind.  FirstBarPainted und FirstBarVisible:  FirstBarPainted enth\u00e4lt die Nummer des Bars, der am linken Rand des Charts angezeigt werden  w\u00fcrde .  FirstBarVisible  enth\u00e4lt die Nummer des Bars, der tats\u00e4chlich als erster Bar links im Chart angezeigt wird.  Beispiel: der Chart ist so verschoben, dass der erste Bar des Charts erst in der Mitte des Charts angezeigt wird.  FirstBarPainted w\u00e4re in diesem Fall negativ.  FirstBarVisible  w\u00e4re 0.  LastBarPainted und LastBarVisible:  LastBarPainted enth\u00e4lt die Nummer des Bars, der am rechten Rand des Charts angezeigt werden  w\u00fcrde .  LastBarVisible  enth\u00e4lt die Nummer des Bars, der tats\u00e4chlich als letzter Bar rechts im Chart angezeigt wird.  Beispiel: der Chart ist so verschoben, dass der letzte Bar des Charts bereits in der Mitte des Charts angezeigt wird.  LastBarPainted w\u00e4re in diesem Fall gr\u00f6\u00dfer als Bars.Count.  LastBarVisible w\u00e4re in Bars.Count -1.",
            "title": "Chart"
        },
        {
            "location": "/schluesselworte/#cleartracewindow",
            "text": "",
            "title": "ClearTraceWindow()"
        },
        {
            "location": "/schluesselworte/#beschreibung_3",
            "text": "Die Methode ClearTraceWindow() leert das Output-Fenster. Die Methode kann sowohl in OnInit() als auch in OnCalculate() eingesetzt werden.\nDas OutputWindow beinhaltet alle Ausgaben, die mit dem  Print()  -Befehl erstellt wurden.\nDer Einsatz des OutputWindows ist eine sehr gute M\u00f6glichkeit f\u00fcr Code-Debugging.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_3",
            "text": "ClearTraceWindow()",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#parameter_1",
            "text": "keiner",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#ruckgabewert",
            "text": "keiner",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#beispiel_3",
            "text": "protected override void OnInit()\n{\n//Inhalt des OutputWindow l\u00f6schen\nClearTraceWindow();\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#colors",
            "text": "In AgenaSript stehen die folgenden Befehle f\u00fcr Farbfestlegungen bzw. -\u00e4nderungen im Chart zur Verf\u00fcgung:  BackColor  Hintergrundfarbe des Kurs-Charts  BackColorAll  Hintergrundfarbe des Kurs-Charts und aller Indikator-Panels  BackColorAllSeries  BackColorSeries  Chart.UpColor Farbe f\u00fcr Up Ticks (Up Bars)\nChart.DownColor Farbe f\u00fcr Down Ticks (Down Bars)  F\u00fcr jeden Bar werden seine Farben in folgenden Dataserien gespeichert. Wird in diese Datenserien geschrieben, \u00e4ndern sich die Farben des referenzierten Bars.  BarColor  Farbe eines Bars  BarColorSeries  CandleOutlineColor  CandleOutlineColorSeries",
            "title": "Colors"
        },
        {
            "location": "/schluesselworte/#backcolor",
            "text": "",
            "title": "BackColor"
        },
        {
            "location": "/schluesselworte/#beschreibung_4",
            "text": "BackColor \u00e4ndert die Hintergrundfarbe eines Bars bzw. gibt die aktuelle Hintergrundfarbe eines Bars zur\u00fcck.  Siehe auch  Colors ,  BarColor ,  BackColor ,  BackColorAll ,  BarColorSeries ,  BackColorAll ,  CandleOutlineColor .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#parameter_2",
            "text": "ein Color-Objekt vom Typ  public struct Color",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#verwendung_4",
            "text": "BackColor",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiele",
            "text": "// immer montags Bar-Hintergrundfarbe auf Blau \u00e4ndern\nif (Time[0].DayOfWeek == DayOfWeek.Monday)\nBackColor = Color.Blue;   // \u00c4ndern der Bar-Hintergrundfarbe in Abh\u00e4ngigkeit von einem gl. Durchschnitt\n// Kurs \u00fcber SMA(14) --> Gr\u00fcn\n// Kurs unter SMA(14) --> Maroon\nBackColor = SMA(14)[0] >= Close[0] ? Color.Maroon : Color.LimeGreen;",
            "title": "Beispiele"
        },
        {
            "location": "/schluesselworte/#backcolorall",
            "text": "",
            "title": "BackColorAll"
        },
        {
            "location": "/schluesselworte/#beschreibung_5",
            "text": "BackColorAll \u00e4ndert die Hintergrundfarbe eines Bars im Chartfenster und in allen Subcharts bzw. gibt die aktuelle Hintergrundfarbe eines Bars zur\u00fcck.\nSiehe auch  Colors ,  BarColor ,  BackColor ,  BackColorAll ,  BarColorSeries ,  BackColorAll ,  CandleOutlineColor .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#parameter_3",
            "text": "ein Color-Objekt vom Typ  public struct Color",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#verwendung_5",
            "text": "BackColorAll",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel_4",
            "text": "// immer montags Bar-Hintergrundfarbe auf Blau \u00e4ndern\nif (Time[0].DayOfWeek == DayOfWeek.Monday)\nBackColorAll = Color.Blue;",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#backcolorallseries",
            "text": "",
            "title": "BackColorAllSeries"
        },
        {
            "location": "/schluesselworte/#beschreibung_6",
            "text": "BackColorAllSeries ist eine Datenserie, die f\u00fcr jeden Bar die Hintergrundfarbe speichert. Im Unterschied zu BackColorSeries wird die Hinterrundfarbe der Subcharts mit ber\u00fccksichtigt.  Siehe auch  Colors ,  BarColor ,  BackColor ,  BackColorAll ,  BarColorSeries ,  BackColorAll ,  CandleOutlineColor .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#parameter_4",
            "text": "ein Color-Objekt vom Typ  public struct Color  int barsAgo",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#verwendung_6",
            "text": "BackColorAllSeries\nBackColorAllSeries[int barsAgo]  Bei Verwendung der Methode mit einem Index [int barsAgo] wird die Hintergrundfarbe f\u00fcr den referenzierten Bar ge\u00e4ndert bzw. ausgegeben.",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel_5",
            "text": "siehe  BackColorSeries .",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#backcolorseries",
            "text": "",
            "title": "BackColorSeries"
        },
        {
            "location": "/schluesselworte/#beschreibung_7",
            "text": "BackColorSeries ist eine Datenserie, die f\u00fcr jeden Bar die Hintergrundfarbe speichert. Soll die Hintergrundfarbe von Subcharts mit ber\u00fccksichtigt werden, ist \"BackColorAllSeries\" zu verwenden.  Siehe auch  Colors ,  BarColor ,  BackColor ,  BackColorAll ,  BarColorSeries ,  BackColorAll ,  CandleOutlineColor .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#parameter_5",
            "text": "ein Color-Objekt vom Typ  public struct Color  int barsAgo",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#verwendung_7",
            "text": "BackColorSeries\nBackColorSeries[int barsAgo]  ei Verwendung der Methode mit einem Index [ int  barsAgo]  wird die Hintergrundfarbe f\u00fcr den referenzierten Bar ge\u00e4ndert bzw. ausgegeben.",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiele_1",
            "text": "// Welche Hintergrundfarbe hat der aktuelle Bar? (im ARGB-Format)\nPrint (BackColorSeries[0]);\n// Hintergrundfarbe des aktuellen Bars auf Blau setzen\n// Dies ist identisch mit BackColor = Color.Blue\nBackColorSeries[3] = Color.Blue;\n// Hintergrundfarbe des vorhergehenden Bars auf Gr\u00fcn setzen\nBackColorSeries[1] = Color.Green;",
            "title": "Beispiele"
        },
        {
            "location": "/schluesselworte/#barcolor",
            "text": "",
            "title": "BarColor"
        },
        {
            "location": "/schluesselworte/#beschreibung_8",
            "text": "BarColor \u00e4ndert die Farbe eines Bars  Siehe auch  Colors ,  BarColor ,  BackColor ,  BackColorAll ,  BarColorSeries ,  BackColorAll ,  CandleOutlineColor .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#parameter_6",
            "text": "ein Color-Objekt vom Typ  public struct Color",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#verwendung_8",
            "text": "BarColor",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel_6",
            "text": "// Wenn der Schlusskurs \u00fcber dem SMA(14) liegt, den Bar orange einf\u00e4rben\nif (Close[0] > SMA(14)[0]) BarColor = Color.Orange;",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#barcolorseries",
            "text": "",
            "title": "BarColorSeries"
        },
        {
            "location": "/schluesselworte/#beschreibung_9",
            "text": "BarColorSeries ist eine Datenserie, die f\u00fcr jeden Bar die Farbe speichert.  Siehe auch Colors ,  BarColor ,  BackColor ,  BackColorAll ,  BarColorSeries ,  BackColorAll ,  CandleOutlineColor .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#parameter_7",
            "text": "ein Color-Objekt vom Typ  public struct Color  int barsAgo",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#verwendung_9",
            "text": "BarColorSeries  BarColorSeries[ int  barsAgo]  Bei Verwendung der Methode mit einem Index [int barsAgo] wird die Farbe f\u00fcr den referenzierten Bar ge\u00e4ndert bzw. ausgegeben.  Achtung: Es wird nur die Farbe eines Bars zur\u00fcckgegeben, dessen Farbe vorher explizit ver\u00e4ndert wurde. In allen anderen F\u00e4llen wird Color.Empty zur\u00fcckgegeben.",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel_7",
            "text": "protected override void OnCalculate()\n{\nif (ProcessingBarIndex == Bars.Count-1-(CalculateOnClosedBar?1:0))\n{\n// Farbe des aktuellen Bars auf Blau setzen\n// Dies ist identisch mit BarColor = Color.Blue\nBarColorSeries[0] = Color.Blue;\n// Farbe des vorhergehenden Bars auf Gr\u00fcn setzen\nBarColorSeries[1] = Color.Orange;\n// Farbe des 3. Bars auf Gelb setzen\nBarColorSeries[2] = Color.Yellow;\n}\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#candleoutlinecolor",
            "text": "",
            "title": "CandleOutlineColor"
        },
        {
            "location": "/schluesselworte/#beschreibung_10",
            "text": "CandleOutlineColor \u00e4ndert die Randfarbe (incl. \"Dochte\" und \"Lunte\") eines Bars.  Wenn die Farbe eines Bars mit BarColor ge\u00e4ndert wird, und die Umrandung des Bars wurde nicht mit CandleOutlineColor ver\u00e4ndert, wird die Randfarbe auf die Farbe des Bars angepasst.  Siehe auch Colors ,  BarColor ,  BackColor ,  BackColorAll ,  BarColorSeries ,  BackColorAll ,  CandleOutlineColor .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#parameter_8",
            "text": "ein Color-Objekt vom Typ  public struct Color",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#verwendung_10",
            "text": "CandleOutlineColor",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel_8",
            "text": "if (SMA(14)[0] > SMA(200)[0])\nCandleOutlineColor = Color.LimeGreen;\nelse\nCandleOutlineColor = Color.Red;",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#candleoutlinecolorseries",
            "text": "",
            "title": "CandleOutlineColorSeries"
        },
        {
            "location": "/schluesselworte/#beschreibung_11",
            "text": "CandleOutlineColorSeries ist eine Datenserie, die f\u00fcr jeden Bar die Randfarbe speichert.  Siehe auch  Colors ,  BarColor ,  BackColor ,  BackColorAll ,  BarColorSeries ,  BackColorAll ,  CandleOutlineColor .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#parameter_9",
            "text": "ein Color-Objekt vom Typ  public struct Color\nint barsAgo",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#verwendung_11",
            "text": "CandleOutlineColorSeries\nCandleOutlineColorSeries[int barsAgo]  Bei Verwendung der Methode mit einem Index  [ int  barsAgo] wird die Randfarbe f\u00fcr den referenzierten Bar ausgegeben.  Achtung: Es wird nur die RandFarbe eines Bars zur\u00fcckgegeben, dessen Randfarbe vorher explizit ver\u00e4ndert wurde. In allen anderen F\u00e4llen wird Color.Empty zur\u00fcckgegeben.",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel_9",
            "text": "// Randfarbe des aktuellen Bars auf Blau setzen\nCandleOutlineColorSeries[0] = Color.Blue;\n// Randfarbe auf Chart-default zur\u00fccksetzen\nCandleOutlineColorSeries[0] = Color.Empty;",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#crossabove",
            "text": "",
            "title": "CrossAbove()"
        },
        {
            "location": "/schluesselworte/#beschreibung_12",
            "text": "Mit der Methode CrossAbove() kann gepr\u00fcft werden, ob es innerhalb einer festgelegten Anzahl von Perioden eine \u00dcberkreuzung zweier Werte von unten nach oben gab. Die Werte k\u00f6nnen dabei der Kurs, ein Indikator, jede beliebige Datenserie oder ein fester Wert sein.  Siehe auch  CrossAbove() ,  CrossBelow() ,  IsSerieRising() ,  IsSerieFalling() .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_12",
            "text": "CrossAbove(IDataSeries series1, double value, int lookBackPeriod)\nCrossAbove(IDataSeries series1, IDataSeries series2, int lookBackPeriod)",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_1",
            "text": "true  eine \u00dcberkreuzung hat stattgefunden false  eine \u00dcberkreuzung hat nicht stattgefunden",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#parameter_10",
            "text": "lookBackPeriod  Anzahl der Bars innerhalb derer nach dem Aufterten einer \u00dcberkreuzung gesucht wird    series1 und series2  eine Datenserie, wie z.B. ein Indikator, Close, High o.\u00e4    value  ein fester Wert vom Typ double",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#beispiele_2",
            "text": "// Hinweis ausgeben, wenn der SMA(20) \u00fcber SMA(50) kreuzt\nif (CrossAbove(SMA(20), SMA(50), 1))\nPrint(\"SMA(20) has risen above SMA(50)!\");\n// Hinweis ausgeben, wenn der SMA(20) \u00fcber den Wert 40 steigt\nif (CrossAbove(SMA(20), 40, 1))\nPrint(\"SMA(20) has risen above 40!\");\n// Hinweis auf Long-Einstieg ausgeben, wenn innerhalb der letzten 5 Bars\n// der SMA(20) \u00fcber SMA(50) kreuzt und der Kurs innerhalb des letzten Bars gestiegen ist\nif (CrossAbove(SMA(20), SMA(50), 1) && Close[0] > Close[1])\nPrint(\"Long entry !!!\");",
            "title": "Beispiele"
        },
        {
            "location": "/schluesselworte/#crossbelow",
            "text": "",
            "title": "CrossBelow()"
        },
        {
            "location": "/schluesselworte/#beschreibung_13",
            "text": "Mit der Methode CrossBelow() kann gepr\u00fcft werden, ob es innerhalb einer festgelegten Anzahl von Perioden eine \u00dcberkreuzung zweier Werte von oben nach unten gab. Die Werte k\u00f6nnen dabei der Kurs, ein Indikator, jede beliebige Datenserie oder ein fester Wert sein.  Siehe auch  CrossAbove() ,  CrossBelow() ,  IsSerieRising() ,  IsSerieFalling() .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_13",
            "text": "CrossBelow(IDataSeries series1, double value, int lookBackPeriod)\nCrossBelow(IDataSeries series1, IDataSeries series2, int lookBackPeriod)",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_2",
            "text": "true  eine \u00dcberkreuzung hat stattgefunden false  eine \u00dcberkreuzung hat nicht stattgefunden",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#parameter_11",
            "text": "lookBackPeriod  Anzahl der Bars innerhalb derer nach dem Aufterten einer \u00dcberkreuzung gesucht wird    series1 und series2  eine Datenserie, wie z.B. ein Indikator, Close, High o    value  ein fester Wert vom Typ double",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#beispiele_3",
            "text": "// Hinweis ausgeben, wenn der SMA(20) unter SMA(50) kreuzt\nif (CrossBelow(SMA(20), SMA(50), 1))\nPrint(\"SMA(20) has fallen below SMA(50)!\");\n// Hinweis ausgeben, wenn der SMA(20) unter den Wert 40 f\u00e4llt\nif (CrossBelow(SMA(20), 40, 1))\nPrint(\"SMA(20) has fallen below 40!\");\n// Hinweis auf Short-Einstieg ausgeben, wenn innerhalb der letzten 5 Bars\n// der SMA(20) unter SMA(50) kreuzt und der Kurs innerhalb des letzten Bars gefallen ist.\nif (CrossBelow(SMA(20), SMA(50), 1) && Close[1] > Close[0])\nPrint(\"Short entry !!!\");",
            "title": "Beispiele"
        },
        {
            "location": "/schluesselworte/#datafeedhistoryperiodicity",
            "text": "",
            "title": "DatafeedHistoryPeriodicity"
        },
        {
            "location": "/schluesselworte/#beschreibung_14",
            "text": "DatafeedHistoryPeriodicity ist ein Datentyp.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#definition",
            "text": "public enum DatafeedHistoryPeriodicity\n-   DatafeedHistoryPeriodicity.Tick\n-   DatafeedHistoryPeriodicity.Second\n-   DatafeedHistoryPeriodicity.Minute\n-   DatafeedHistoryPeriodicity.Hour\n-   DatafeedHistoryPeriodicity.Day\n-   DatafeedHistoryPeriodicity.Week\n-   DatafeedHistoryPeriodicity.Month\n-   DatafeedHistoryPeriodicity.Volume\n-   DatafeedHistoryPeriodicity.Range\n-   DatafeedHistoryPeriodicity.Quarter\n-   DatafeedHistoryPeriodicity.Year\n-   DatafeedHistoryPeriodicity.HeikinAshi\n-   DatafeedHistoryPeriodicity.Renko\n-   DatafeedHistoryPeriodicity.LineBreak\n-   DatafeedHistoryPeriodicity.Kagi\n-   DatafeedHistoryPeriodicity.PointAndFigure\n-   DatafeedHistoryPeriodicity.Custom  Siehe  TimeFrame ,  TimeFrames .",
            "title": "Definition"
        },
        {
            "location": "/schluesselworte/#dataseries",
            "text": "",
            "title": "DataSeries"
        },
        {
            "location": "/schluesselworte/#beschreibung_15",
            "text": "Datenserien (DataSeries) sind eine sehr komfortable und sehr m\u00e4chtige M\u00f6glichkeit, zus\u00e4tzliche Werte f\u00fcr jeden einzelnen Bar zu speichern. Z.B. wird bei der Berechnung eines gleitenden Durchschnitts jedem Bar der f\u00fcr diesen Bar errechnete Wert zugeordnet.\nEine Datenserie ist ein Array, welches exakt so viele Elemente enth\u00e4lt, wie Bars im Chart angezeigt werden. AgenaTrader sorgt daf\u00fcr, dass die Datenserien zu jedem Zeitpunkt korrekt mit den Bars synchronisiert sind.\nDatenserien werden exakt so benutzt, wie z.B. die Serien Close oder Time. Sie k\u00f6nnen deshalb nat\u00fcrlich auch als Eingangsdaten (Input) f\u00fcr weitere Indikatoren verwendet werden.\nIn der Tabelle ist zu sehen, dass 4 neue Datenserien (farbig markiert) angelegt worden sind. Jede dieser Datenserien kann genau einen Wert eines speziellen Datentyps (int, bool, string, DateTime) je Bar aufnehmen. Die Indizierung mit barsAgo ist dabei identisch mit den vom System bereitgestellten Datenserien..",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#in-agenatrader-verwendbare-datenserien",
            "text": "BoolSeries  DataSeries  DateTimeSeries  FloatSeries  IntSeries  LongSeries  StringSeries  Dar\u00fcberhinaus gibt es die Datenserie ColorSeries, die jedoch nur f\u00fcr interne Zwecke bestimmt ist und nicht direkt verwendet werden sollte.\nUm die Farbe von Plots zu \u00e4ndern, verwenden Sie bitte  PlotColors .",
            "title": "In AgenaTrader verwendbare Datenserien"
        },
        {
            "location": "/schluesselworte/#set-reset-und-containsvalue",
            "text": "Jede Datenserie verf\u00fcgt \u00fcber die Methoden   Set() ,  Reset()  und  ContainsValue() .\nMit Set(value) bzw. Set(int barsAgo, value) werden Werte in die Datenserie an der aktuellen Position bzw. an der Position \"barsAgo\" \u00fcbernommen.\nMit Reset() bzw. Reset(int barsAgo) kann an der aktuellen Position  bzw. an der Position \"barsAgo\" ein Wert aus der Datenserie gel\u00f6scht werden, d.h. an dieser Position existiert kein g\u00fcltiger Wert mehr.\nDie Programmierung mit Hilfe der Reset-Methode kann eine ansonsten sehr komplexe Logik sp\u00fcrbar vereinfachen.Insbesondere bei Bool-Serien, die nur true oder false enthalten k\u00f6nnen, ist diese Eigenschaft extrem hilfreich.\nMit ContainsValue() kann gepr\u00fcft werden, ob die Datenserie an einer bestimmten Position einen g\u00fcltigen Wert enth\u00e4lt.",
            "title": "Set(), Reset() und ContainsValue()"
        },
        {
            "location": "/schluesselworte/#informationen-zu-den-einzelnen-datentypen",
            "text": "http://msdn.microsoft.com/de-de/library/s1ax56ch%28v=vs.80%29.aspx",
            "title": "Informationen zu den einzelnen Datentypen"
        },
        {
            "location": "/schluesselworte/#boolseries",
            "text": "",
            "title": "BoolSeries"
        },
        {
            "location": "/schluesselworte/#beschreibung_16",
            "text": "BoolSeries ist eine Datenserie, die f\u00fcr jeden Bar einen boolschen Wert (true oder false) aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#neue-boolseries-anlegen",
            "text": "Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen:  //Variablendeklaration\nprivate BoolSeries myBoolSeries;  In der Methode OnInit()dieser Variable eine neue Instanz von BoolSeries zuweisen:  protected override void OnInit()\n{\nmyBoolSeries = new BoolSeries(this);\nCalculateOnClosedBar = true;\n}",
            "title": "Neue BoolSeries anlegen"
        },
        {
            "location": "/schluesselworte/#werte-zuweisen",
            "text": "Der Datenserie an aktueller Position einen Wert zuweisen:  myBoolSeries.Set(true);  Einen Wert in der Vergangenheit in die Datenserie schreiben:  myBoolSeries.Set(int barsAgo, bool Value);",
            "title": "Werte zuweisen"
        },
        {
            "location": "/schluesselworte/#werte-loschen",
            "text": "Den aktuellen Wert aus der Datenserie entfernen:  myBoolSeries.Reset();  Einen Wert in der Vergangenheit aus der Datenserie entfernen:  myBoolSeries.Reset(int barsAgo);",
            "title": "Werte l\u00f6schen"
        },
        {
            "location": "/schluesselworte/#werte-auf-gultigkeit-prufen",
            "text": "myBoolSeries.ContainsValue(int barsAgo);",
            "title": "Werte auf G\u00fcltigkeit pr\u00fcfen"
        },
        {
            "location": "/schluesselworte/#wert-auslesen",
            "text": "Print (\"F\u00fcr den Bar von \" + Time[0] + \" ist der Wert der Datenserie: \" + myBoolSeries[0]);",
            "title": "Wert auslesen"
        },
        {
            "location": "/schluesselworte/#beispiel_10",
            "text": "protected override void OnCalculate()\n{\nif (Close[0] > Open[0])\nmyBoolSeries.Set(true);\nelse\nmyBoolSeries.Set(false);\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#dataseries_1",
            "text": "",
            "title": "DataSeries"
        },
        {
            "location": "/schluesselworte/#beschreibung_17",
            "text": "DataSeries ist eine  DataSeries  die f\u00fcr jeden Bar einen double-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.  Datenserien f\u00fcr double-Werte sind die f\u00fcr Indikatoren am h\u00e4ufigsten genutzen Datenserien.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#neue-datenserie-anlegen",
            "text": "Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen:  //Variablendeklaration\nprivate DataSeries myDataSeries;  In der Methode OnInit()  dieser Variable eine neue Instanz von DataSeries zuweisen:  protected override void OnInit()\n{\nmyDataSeries = new DataSeries(this);\nCalculateOnClosedBar = true;\n}",
            "title": "Neue DatenSerie anlegen"
        },
        {
            "location": "/schluesselworte/#werte-zuweisen_1",
            "text": "Der Datenserie an aktueller Position einen Wert zuweisen:  myDataSeries.Set(Bars[0].Close);  Einen Wert in der Vergangenheit in die Datenserie schreiben:  myDataSeries.Set(int barsAgo, double Value);",
            "title": "Werte zuweisen"
        },
        {
            "location": "/schluesselworte/#werte-loschen_1",
            "text": "Den aktuellen Wert aus der Datenserie entfernen:  myDataSeries.Reset();  Einen Wert in der Vergangenheit aus der Datenserie entfernen:  myDataSeries.Reset(int barsAgo);",
            "title": "Werte l\u00f6schen"
        },
        {
            "location": "/schluesselworte/#werte-auf-gultigkeit-prufen_1",
            "text": "myDataSeries.ContainsValue(int barsAgo);",
            "title": "Werte auf G\u00fcltigkeit pr\u00fcfen"
        },
        {
            "location": "/schluesselworte/#wert-auslesen_1",
            "text": "Print (\"F\u00fcr den Bar von  \" + Time[0] + \"ist der Wert der Datenserie: \" + myDataSeries[0]);",
            "title": "Wert auslesen"
        },
        {
            "location": "/schluesselworte/#beispiel_11",
            "text": "//Speichert die Spanne zwischen dem Hoch und dem Tief eines Bars\nmyDataSeries.Set(Math.Abs(High[0]-Low[0]));",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#datetimeseries",
            "text": "",
            "title": "DateTimeSeries"
        },
        {
            "location": "/schluesselworte/#beschreibung_18",
            "text": "Date time series  ist eine  DataSeries  die f\u00fcr jeden Bar einen DateTime-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#neue-datenserie-anlegen_1",
            "text": "Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen:  //Variablendeklaration\nprivate DateTimeSeries myDataSeries;  In der Methode OnInit() dieser Variable eine neue Instanz von StringSeries zuweisen:  protected override void OnInit()\n{\nmyDataSeries = new DateTimeSeries(this);\nCalculateOnClosedBar = true;\n}",
            "title": "Neue DatenSerie anlegen"
        },
        {
            "location": "/schluesselworte/#werte-zuweisen_2",
            "text": "Der Datenserie an aktueller Position einen Wert zuweisen:  myDataSeries.Set(DateTime Value);  Einen Wert in der Vergangenheit in die Datenserie schreiben:  myDataSeries.Set(int barsAgo, DateTime Value);",
            "title": "Werte zuweisen"
        },
        {
            "location": "/schluesselworte/#werte-loschen_2",
            "text": "Den aktuellen Wert aus der Datenserie entfernen:  myDataSeries.Reset();  Einen Wert in der Vergangenheit aus der Datenserie entfernen:  myDataSeries.Reset(int barsAgo);",
            "title": "Werte l\u00f6schen"
        },
        {
            "location": "/schluesselworte/#werte-auf-gultigkeit-prufen_2",
            "text": "myDataSeries.ContainsValue(int barsAgo);",
            "title": "Werte auf G\u00fcltigkeit pr\u00fcfen"
        },
        {
            "location": "/schluesselworte/#wert-auslesen_2",
            "text": "Print (\"F\u00fcr den Bar von\" + Time[0] + \" ist der Wert der Datenserie: \" + myDataSeries[0]);",
            "title": "Wert auslesen"
        },
        {
            "location": "/schluesselworte/#beispiel_12",
            "text": "//Speichert einen Versatz von -6 Stunden (Eastern Time, New York) f\u00fcr eine Zeitzonenumrechnung\nmyDataSeries.Set(Time[0].AddHours(-6));",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#floatseries",
            "text": "",
            "title": "FloatSeries"
        },
        {
            "location": "/schluesselworte/#beschreibung_19",
            "text": "FloatSeries ist eine Datenserie, die f\u00fcr jeden Bar einen Float-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#neue-datenserie-anlegen_2",
            "text": "Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen:  //Variablendeklaration\nprivate FloatSeries myDataSeries;  In der Methode OnInit() dieser Variable eine neue Instanz von StringSeries zuweisen:  protected override void OnInit()\n{\nmyDatatSeries = new FloatSeries(this);\nCalculateOnClosedBar = true;\n}",
            "title": "Neue DatenSerie anlegen"
        },
        {
            "location": "/schluesselworte/#werte-zuweisen_3",
            "text": "Der Datenserie an aktueller Position einen Wert zuweisen:  myDataSeries.Set(float Value);  Einen Wert in der Vergangenheit in die Datenserie schreiben:  myDataSeries.Set(int barsAgo, float Value);",
            "title": "Werte zuweisen"
        },
        {
            "location": "/schluesselworte/#werte-loschen_3",
            "text": "Den aktuellen Wert aus der Datenserie entfernen:  myDataSeries.Reset();  Einen Wert in der Vergangenheit aus der Datenserie entfernen:  myDataSeries.Reset(int barsAgo);",
            "title": "Werte l\u00f6schen"
        },
        {
            "location": "/schluesselworte/#werte-auf-gultigkeit-prufen_3",
            "text": "myDataSeries.ContainsValue(int barsAgo);",
            "title": "Werte auf G\u00fcltigkeit pr\u00fcfen"
        },
        {
            "location": "/schluesselworte/#wert-auslesen_3",
            "text": "Print (\"F\u00fcr den Bar von\" + Time[0] + \" ist der Wert der Datenserie: \" + myDataSeries[0]);",
            "title": "Wert auslesen"
        },
        {
            "location": "/schluesselworte/#beispiel_13",
            "text": "//Speichert die Spanne zwischen dem Hoch und dem Tief eines Bars\nmyDataSeries.Set(Math.Abs((float) High[0] - (float) Low[0]));",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#intseries",
            "text": "",
            "title": "IntSeries"
        },
        {
            "location": "/schluesselworte/#beschreibung_20",
            "text": "IntSeries ist eine Datenserie, die f\u00fcr jeden Bar einen Integer-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#neue-datenserie-anlegen_3",
            "text": "Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen:  //Variablendeklaration\nprivate IntSeries myDataSeries;  In der Methode OnInit() dieser Variable eine neue Instanz von StringSeries zuweisen:  protected override void OnInit()\n{\nmyDataSeries = new IntSeries(this);\nCalculateOnClosedBar = true;\n}",
            "title": "Neue DatenSerie anlegen"
        },
        {
            "location": "/schluesselworte/#werte-zuweisen_4",
            "text": "Der Datenserie an aktueller Position einen Wert zuweisen:  myDataSeries.Set(int Value);  Einen Wert in der Vergangenheit in die Datenserie schreiben:  myDataSeries.Set(int barsAgo, int Value);",
            "title": "Werte zuweisen"
        },
        {
            "location": "/schluesselworte/#werte-loschen_4",
            "text": "Den aktuellen Wert aus der Datenserie entfernen:  myDataSeries.Reset();  Einen Wert in der Vergangenheit aus der Datenserie entfernen:  myDataSeries.Reset(int barsAgo);",
            "title": "Werte l\u00f6schen"
        },
        {
            "location": "/schluesselworte/#werte-auf-gultigkeit-prufen_4",
            "text": "myDataSeries.ContainsValue(int barsAgo);",
            "title": "Werte auf G\u00fcltigkeit pr\u00fcfen"
        },
        {
            "location": "/schluesselworte/#wert-auslesen_4",
            "text": "Print (\"F\u00fcr den Bar von \" + Time[0] + \"ist der Wert der Datenserie\"+ myDataSeries[0]);",
            "title": "Wert auslesen"
        },
        {
            "location": "/schluesselworte/#beispiel_14",
            "text": "//Speichert f\u00fcr jeden Bar die Spanne in Ticks zwischen dem Hoch und dem Tief\nmyDataSeries.Set((int) ((High[0] - Low[0]) / TickSize));",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#longseries",
            "text": "",
            "title": "LongSeries"
        },
        {
            "location": "/schluesselworte/#beschreibung_21",
            "text": "LongSeries ist eine Datenserie, die f\u00fcr jeden Bar einen Integer-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#neue-datenserie-anlegen_4",
            "text": "Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen:  //Variablendeklaration\nprivate LongSeries myDataSeries;  In der Methode OnInit() dieser Variable eine neue Instanz von LongSeries zuweisen:  protected override void OnInit()\n{\nmyDataSeries = new LongSeries(this);\nCalculateOnClosedBar = true;\n}",
            "title": "Neue DatenSerie anlegen"
        },
        {
            "location": "/schluesselworte/#werte-zuweisen_5",
            "text": "Der Datenserie an aktueller Position einen Wert zuweisen:  myDataSeries.Set(long Value);  Einen Wert in der Vergangenheit aus der Datenserie entfernen:  myDataSeries.Set(int barsAgo, long Value);",
            "title": "Werte zuweisen"
        },
        {
            "location": "/schluesselworte/#werte-loschen_5",
            "text": "Den aktuellen Wert aus der Datenserie entfernen:  myDataSeries.Reset();  Einen Wert in der Vergangenheit aus der Datenserie entfernen:  myDataSeries.Reset(int barsAgo);",
            "title": "Werte l\u00f6schen"
        },
        {
            "location": "/schluesselworte/#werte-auf-gultigkeit-prufen_5",
            "text": "myDataSeries.ContainsValue(int barsAgo);",
            "title": "Werte auf G\u00fcltigkeit pr\u00fcfen"
        },
        {
            "location": "/schluesselworte/#wert-auslesen_5",
            "text": "Print (\"F\u00fcr den Bar von \" + Time[0] + \"ist der Wert der Datenserie: \" + myDataSeries[0]);",
            "title": "Wert auslesen"
        },
        {
            "location": "/schluesselworte/#beispiel_15",
            "text": "//Speichert f\u00fcr jeden Bar die Spanne in Ticks zwischen dem Hoch und dem Tief\nmyDataSeries.Set((long) ((High[0] - Low[0]) / TickSize));",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#stringseries",
            "text": "",
            "title": "StringSeries"
        },
        {
            "location": "/schluesselworte/#beschreibung_22",
            "text": "StringSeries ist eine Datenserie, die f\u00fcr jeden Bar einen String-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#neue-datenserie-anlegen_5",
            "text": "Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen:  //Variablendeklaration\nprivate StringSeries myDataSeries;  In der Methode OnInit() dieser Variable eine neue Instanz von StringSeries zuweisen:  protected override void OnInit()\n{\nmyDataSeries = new StringSeries(this);\nCalculateOnClosedBar = true;\n}",
            "title": "Neue DatenSerie anlegen"
        },
        {
            "location": "/schluesselworte/#werte-zuweisen_6",
            "text": "Der Datenserie an aktueller Position einen Wert zuweisen:  myDataSeries.Set(string Value);  Einen Wert in der Vergangenheit in die Datenserie schreiben:  myDataSeries.Set(int barsAgo, string Value);",
            "title": "Werte zuweisen"
        },
        {
            "location": "/schluesselworte/#werte-loschen_6",
            "text": "Den aktuellen Wert aus der Datenserie entfernen:  myDataSeries.Reset();  Einen Wert in der Vergangenheit aus der Datenserie entfernen:  myDataSeries.Reset(int barsAgo);",
            "title": "Werte l\u00f6schen"
        },
        {
            "location": "/schluesselworte/#werte-auf-gultigkeit-prufen_6",
            "text": "myDataSeries.ContainsValue(int barsAgo);",
            "title": "Werte auf G\u00fcltigkeit pr\u00fcfen"
        },
        {
            "location": "/schluesselworte/#wert-auslesen_6",
            "text": "Print (\"F\u00fcr den Bar von \" + Time[0] + \"ist der Wert der Datenserie: \" + myDataSeries[0]);",
            "title": "Wert auslesen"
        },
        {
            "location": "/schluesselworte/#beispiel_16",
            "text": "//Speichert f\u00fcr jeden Bar den Wochentag (Montag, Dienstag ...)\nmyDataSeries.Set(string.Format(\"{0:dddd}\", Time[0]));",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#dayofweek",
            "text": "",
            "title": "DayOfWeek"
        },
        {
            "location": "/schluesselworte/#beschreibung_23",
            "text": "\"DayOfWeek\" gibt den zu einem DateTime-Wert, wie z.B. dem Zeitstempel eines Bars, geh\u00f6renden Wochentag aus.  Dar\u00fcberhinaus sind nat\u00fcrlich auch alle Methoden verwendbar, die in C# f\u00fcr DateTime-Objekte definiert sind, z.B. Day, Month, Year, Hour, Minute, Second, DayOfWeek usw.  Siehe  http://msdn.microsoft.com/de-de/library/03ybds8y.aspx",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#definition_1",
            "text": "Eigenschaft DayOfWeek  public enum DayOfWeek\n-   DayOfWeek.Monday\n-   DayOfWeek.Tuesday\n-   DayOfWeek.Wednesday\n-   DayOfWeek.Thursday\n-   DayOfWeek.Friday\n-   DayOfWeek.Saturday\n-   DayOfWeek.Sunday",
            "title": "Definition"
        },
        {
            "location": "/schluesselworte/#beispiele_4",
            "text": "//Ausgabe des Wochentages f\u00fcr jeden Bar\nPrint(Time[0].DayOfWeek);\n//An einem Freitag keine Trades ausf\u00fchren\nif (Time[0].DayOfWeek == DayOfWeek.Friday)\nreturn;",
            "title": "Beispiele"
        },
        {
            "location": "/schluesselworte/#displacement",
            "text": "",
            "title": "Displacement"
        },
        {
            "location": "/schluesselworte/#beschreibung_24",
            "text": "Mit der Angabe Displacement kann eine gezeichnete Indikatorlinie auf der Zeitachse (x-Achse) nach links bzw. rechts verschoben werden.\nDie Eigenschaft kann im Script abgefragt werden und liefert einen int-Wert.  Blue line: Displacement = 0 (Original)\nRed line: Displacement = -5\nGreen line: Displacement = +5",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_14",
            "text": "Displacement",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#parameter_12",
            "text": "int Offfset Anzahl Bars, um die der Indikator verschoben werden soll.",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#beispiel_17",
            "text": "protected override void OnInit()\n{\nAdd(new OnPaint(Color.Red, \"MyPlot1\"));\n//Displacement of the plot by one bar to the right\nDisplacement = 1;\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#email-function",
            "text": "",
            "title": "Email function"
        },
        {
            "location": "/schluesselworte/#beschreibung_25",
            "text": "Override-Methode zum Senden von E-Mails.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#parameter_13",
            "text": "keine",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_3",
            "text": "string",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#verwendung_15",
            "text": "Verwendet f\u00fcr komplizierte Berechnung auf einem letzten Bar",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel_18",
            "text": "protected override void OnOrderExecution(IExecution execution)\n{\nif (execution.Order != null && execution.Order.OrderState == OrderState.Filled)\n{\nif (oEnter != null && execution.Name == oEnter.Name)\n{\n// Enter-Order gef\u00fcllt\nif (_sendMail) this.SendEmail(Core.AccountManager.Core.Settings.MailDefaultFromAddress, Core.PreferenceManager.DefaultEmailAddress,\nexecution.Instrument.Symbol + \" order \" + execution.Name + \" executed.\", \"The order for \" + execution.Instrument.Name + \" was executed. Invest: \" + (Trade.Quantity * Trade.AvgPrice).ToString(\"F2\"));\n}\nelse if (oTStop != null && execution.Name == oTStop.Name)\n{\nOrderStatus = 0; // Trend-Stopp-Order gef\u00fcllt\nif (_sendMail) this.SendEmail(Core.AccountManager.Core.Settings.MailDefaultFromAddress, Core.PreferenceManager.DefaultEmailAddress,\nexecution.Instrument.Symbol +\" order \" + execution.Name + \" executed.\",\nexecution.Instrument.Symbol +\" order \" + execution.Name + \" executed. Profit:\" + Trade.ClosedProfitLoss.ToString(\"F2\"));\n}\n}\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#firsttickofbar",
            "text": "",
            "title": "FirstTickOfBar"
        },
        {
            "location": "/schluesselworte/#beschreibung_26",
            "text": "FirstTickOfBar ist eine Eigenschaft, vom Type bool, die immer dann \"true\" ergibt, wenn der aktuell hereinkommende Tick einem neuen Bar zugeordnet wird, dieser Tick also der erste Tick eines neuen Bars ist.\nDie Eigenschaft kann nur sinnvoll eingesetzt werden, wenn der Indikator bzw. die Startegie im Tick-by-Tick-Modus l\u00e4uft, d.h. wenn CalculateOnClosedBar = false gesetzt ist und der verwendete Datenfeed Realtime-Kurse liefert.\nBei Verwendung von EoD-Daten in einem Tageschart ist FirstTickOfBar f\u00fcr den letzten Bar immer true.\nFirstTickOfBar sollte nicht au\u00dferhalb der OnCalculate() Methode verwendet werden..  siehe auch  Bars.TicksCountForLastBar .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_16",
            "text": "FirstTickOfBar",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel_19",
            "text": "// Innerhalb einer Tick-By-Tick-Strategie einen Teil nur Bar-by-Bar ausf\u00fchren\nif (FirstTickOfBar)\n{\nif (CCI(20)[1] < -250)\nOpenLong();\nreturn;\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#firsttickofbarmtf",
            "text": "",
            "title": "FirstTickOfBarMtf"
        },
        {
            "location": "/schluesselworte/#beschreibung_27",
            "text": "FirstTickOfBarMtf ist die   multi-time frame  Variante von  FirstTickOfBar .  Die Einstellung von CalculateOnClosedBar wirkt sich nur auf die prim\u00e4re Zeiteinheit (Chart-Zeiteinheit) aus. Wenn jedoch mit multi-bars gearbeitet wird, werden die Ticks der sekund\u00e4ren Zeiteinheit(en) unabh\u00e4ngig von der Einstellung von CalculateOnClosedBar  immer Tick-by-Tick bereitgestellt.\nMit Hilfe von FirstTickOfBarMtf, ist es m\u00f6glich, festzustellen, wann in einer sekund\u00e4ren Zeiteinheit ein neuer Bar beginnt.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_17",
            "text": "FirstTickOfBarMtf(ProcessingBarSeriesIndex)",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#parameter_14",
            "text": "FirstTickOfBarMtf(ProcessingBarSeriesIndex).  siehe  ProcessingBarSeriesIndex .",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#beispiel_20",
            "text": "if (FirstTickOfBarMtf(ProcessingBarSeriesIndex))\nPrint(\"A new bar has begun.\");",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#getcurrentask",
            "text": "",
            "title": "GetCurrentAsk()"
        },
        {
            "location": "/schluesselworte/#beschreibung_28",
            "text": "Die Methode GetCurrentAsk() liefert den aktuellen Kurs auf der Ask-Seite des Orderbuchs. Wenn AgenaTrader keine Level1-Daten zur Verf\u00fcgung stehen, liefert die Funktion den Kurs des letzten Umsatzes.  siehe auch   GetCurrentBid()  und  OnLevel1() .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_18",
            "text": "GetCurrentAsk()",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_4",
            "text": "double value",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#parameter_15",
            "text": "keiner",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#beispiel_21",
            "text": "Wenn eine Einstiegsbedingung erf\u00fcllt ist, soll 1 Kontrakt zum aktuellen Ask-Kurs verkauft werden.  private IOrder entryOrder = null;\nprotected override void OnCalculate()\n{\n// Einstiegsbedingung\nif (Close[0] < SMA(20)[0] && entryOrder == null)\n// Verkauf 1 Kontrakt zum aktuellen AskKurs\nentryOrder = SubmitOrder(0, OrderAction.SellShort, OrderType.Limit, 1, GetCurrentAsk(), 0, \"\", \"Enter short\");\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#getcurrentaskvolume",
            "text": "",
            "title": "GetCurrentAskVolume()"
        },
        {
            "location": "/schluesselworte/#beschreibung_29",
            "text": "Die Methode GetCurrentAskVolume() liefert das aktuelle Volumen auf der Ask-Seite des Orderbuchs. Diese Funktion ist nur lauff\u00e4hig, wenn der Datenanbieter Level2-Daten liefert.  siehe auch  GetCurrentBidVolume() ,  GetCurrentBid()  und  OnLevel1() .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_19",
            "text": "GetCurrentAskVolume()",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_5",
            "text": "Long  value",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#parameter_16",
            "text": "keiner",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#beispiel_22",
            "text": "protected override void OnCalculate()\n{\n   if (GetCurrentAskVolume() < GetCurrentBidVolume())\n       Print(\"AskVolume {0} < BidVolume {1}\", GetCurrentAskVolume(), GetCurrentBidVolume());\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#getcurrentbid",
            "text": "",
            "title": "GetCurrentBid()"
        },
        {
            "location": "/schluesselworte/#beschreibung_30",
            "text": "Die Methode GetCurrentBid() liefert den aktuellen Kurs auf der Bid-Seite des Orderbuchs. Wenn AgenaTrader keine Level1-Daten zur Verf\u00fcgung stehen, liefert die Funktion den Kurs des letzten Umsatzes.  siehe auch  GetCurrentAsk()  und  OnLevel1() .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_20",
            "text": "GetCurrentBid()",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_6",
            "text": "double value",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#parameter_17",
            "text": "keiner",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#beispiel_23",
            "text": "Wenn eine Einstiegsbedingung erf\u00fcllt ist, soll 1 Kontrakt zum aktuellen Bid-Kurs gekauft werden.  private IOrder entryOrder = null;\nprotected override void OnCalculate()\n{\n// Einstiegsbedingung\nif (Close[0] > SMA(20)[0] && entryOrder == null)\n// Kauf 1 Kontrakt zum aktuellen BidKurs\nentryOrder = SubmitOrder(0, OrderAction.Buy, OrderType.Limit, 1, GetCurrentBid(), 0, \"\", \"Enter long\");\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#getcurrentbidvolume",
            "text": "",
            "title": "GetCurrentBidVolume()"
        },
        {
            "location": "/schluesselworte/#beschreibung_31",
            "text": "Die Methode GetCurrentBidVolume() liefert das aktuelle Volumen auf der Bid-Seite des Orderbuchs. Diese Funktion ist nur lauff\u00e4hig, wenn der Datenanbieter Level2-Daten liefert.  siehe auch  GetCurrentAskVolume ,  GetCurrentBid()  und  OnLevel1() .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_21",
            "text": "GetCurrentBidVolume()",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_7",
            "text": "Long value",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#parameter_18",
            "text": "keiner",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#beispiel_24",
            "text": "protected override void OnCalculate()\n{\n   if (GetCurrentAskVolume() < GetCurrentBidVolume())\n       Print(\"AskVolume {0} < BidVolume {1}\", GetCurrentAskVolume(), GetCurrentBidVolume());\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#getcurrentprice",
            "text": "",
            "title": "GetCurrentPrice()"
        },
        {
            "location": "/schluesselworte/#beschreibung_32",
            "text": "Die Methode GetCurrentPrice() liefert den aktuellen Kurs (Latest). Wenn AgenaTrader keine Level1-Daten zur Verf\u00fcgung stehen, liefert die Funktion den Kurs des letzten Umsatzes.  siehe auch  GetCurrentAsk ,  GetCurrentBid()  und  OnLevel1() .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_22",
            "text": "GetCurrentPrice()",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_8",
            "text": "keiner",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#parameter_19",
            "text": "double value",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#beispiel_25",
            "text": "Wenn eine Einstiegsbedingung erf\u00fcllt ist, soll 1 Kontrakt zum aktuellen Kurs gekauft werden.  private IOrder entryOrder = null;\n\nprotected override void OnCalculate()\n{\n   // Einstiegsbedingung\n   if (Close[0] > SMA(20)[0] && entryOrder == null)\n       // Kauf 1 Kontrakt zum aktuellen BidKurs\n       entryOrder = SubmitOrder(0, OrderAction.Buy, OrderType.Limit, 1, GetCurrentPrice(), 0,\"\", \"Enter Long\");\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#getcurrentspread",
            "text": "",
            "title": "GetCurrentSpread()"
        },
        {
            "location": "/schluesselworte/#beschreibung_33",
            "text": "Die Methode GetCurrentSpread() liefert den aktuellen Spread.  siehe auch  GetCurrentAsk ,  GetCurrentBid()  and  OnLevel1() .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_23",
            "text": "GetCurrentSpread()",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_9",
            "text": "keiner",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#parameter_20",
            "text": "double",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#beispiel_26",
            "text": "Wenn eine Anfangsbedingung erf\u00fcllt ist, sollte ein Vertrag zum aktuellen Wechselkurs gekauft werden.  protected override void OnCalculate()\n{\n       Print(\"Der aktuelle Spread ist {0}\", GetCurrentSpread());\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#getdayasint",
            "text": "",
            "title": "GetDayAsInt()"
        },
        {
            "location": "/schluesselworte/#beschreibung_34",
            "text": "GetDayAsIntist eine Methode, die sich speziell an unerfahrene Programmierer richtet, die mit der durchaus komplizierten .Net-DateTime-Struktur aus C# Schwierigkeiten haben.\nErfahrene Programmierer k\u00f6nnen die DateTime-Funktionen auch direkt verwenden.  GetDayAsInt liefert eine int-Repr\u00e4sentation im Format yyyyMMdd.\n(yyyy = Jahr,  MM = Monat, dd = Tag)  Die Zahl f\u00fcr den 13.08.2012 lautet damit 20120813.  Siehe auch  GetTimeAsInt .  Hilfe zu DateTime:  http://msdn.microsoft.com/de-de/library/system.datetime.aspx",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_24",
            "text": "GetDayAsInt(DateTime time)",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiele_5",
            "text": "// Am 11. September besser keine Trades eingehen\nif (GetDayAsInt(Time[0]) = 20130911)\nreturn;",
            "title": "Beispiele"
        },
        {
            "location": "/schluesselworte/#getserieshighestvalue",
            "text": "",
            "title": "GetSeriesHighestValue"
        },
        {
            "location": "/schluesselworte/#beschreibung_35",
            "text": "Die Methode GetSeriesHighestValue() sucht in einer vorgegebenen Anzahl von Perioden nach dem h\u00f6chsten Bar und gibt an, vor wievielen Bars dieser h\u00f6chste Bar zu finden ist  Siehe auch  GetSeriesLowestValue() .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#parameter_21",
            "text": "period Anzahl von Bars, innerhalb derer gesucht werden soll  series Jede Datenserie, wie Close, High, Low usw.",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_10",
            "text": "int barsAgo Vor wievielen Bars trat das Hoch auf",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#verwendung_25",
            "text": "GetSeriesHighestValue(IDataSeries series, int period)",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiele_6",
            "text": "// Vor wievielen Bars lag das h\u00f6chste Hoch der aktuellen Session?\nPrint(GetSeriesHighestValue(High, Bars.BarsCountForSession - 1));\n// Welchen Kurs hatte das bisher h\u00f6chste Open der aktuellen Session?\nPrint(\"The highest price for the session was: \" + Open[GetSeriesHighestValue(High, Bars.BarsCountForSession - 1)]);",
            "title": "Beispiele"
        },
        {
            "location": "/schluesselworte/#getserieslowestvalue",
            "text": "",
            "title": "GetSeriesLowestValue"
        },
        {
            "location": "/schluesselworte/#beschreibung_36",
            "text": "Die Methode  GetSeriesLowestValue() sucht in einer vorgegebenen Anzahl von Perioden nach dem tiefsten Bar und gibt an, vor wievielen Bars dieser tiefste Bar zu finden ist.  Siehe auch  GetSeriesHighestValue() .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#parameter_22",
            "text": "period Anzahl von Bars, innerhalb derer gesucht werden soll  series Jede Datenserie, wie Close, High, Low usw.",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_11",
            "text": "int  barsAgo Vor wievielen Bars trat das Tief auf",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#verwendung_26",
            "text": "GetSerieLowestValue(IDataSeries series, int period)",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiele_7",
            "text": "// Vor wievielen Bars lag das tiefste Tief der aktuellen Session?\nPrint(GetSeriesLowestValue(Low, Bars.BarsCountForSession - 1));\n// Welchen Kurs hatte das bisher tiefste Open der aktuellen Session?\nPrint(\"The lowest open price of the current session was: \" + Open[GetSeriesLowestValue(Low, Bars.BarsCountForSession - 1)]);",
            "title": "Beispiele"
        },
        {
            "location": "/schluesselworte/#gettimeasint",
            "text": "",
            "title": "GetTimeAsInt()"
        },
        {
            "location": "/schluesselworte/#beschreibung_37",
            "text": "GetTimeAsInt ist eine Methode, die sich speziell an unerfahrene Programmierer richtet, die mit der durchaus komplizierten .Net-DateTime-Struktur aus C# Schwierigkeiten haben.\nErfahrene Programmierer k\u00f6nnen die DateTime-Funktionen auch direkt verwenden..  GetTimeAsInt liefert eine int-Repr\u00e4sentation im Format HHmmss.\n(HH = Stunde,  mm = Minute, ss = Sekunde)  Die Uhrzeit 07:30 Uhr wird dargestellt als 73000 und 14:15:12 wird zu 141512.  Siehe auch  GetDayAsInt .  Hilfe zu DateTime:  http://msdn.microsoft.com/de-de/library/system.datetime.aspx",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_27",
            "text": "GetTimeAsInt(DateTime time)",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiele_8",
            "text": "// Nur zwischen 08:15 Uhr und 16:35 Uhr Trades eingehen\nif (GetTimeAsInt(Time[0]) >= 81500 && GetTimeAsInt(Time[0]) <= 163500)\n{\n// irgendeine Handelslogic\n}",
            "title": "Beispiele"
        },
        {
            "location": "/schluesselworte/#historical",
            "text": "",
            "title": "Historical"
        },
        {
            "location": "/schluesselworte/#beschreibung_38",
            "text": "Mit Historical l\u00e4\u00dft sich \u00fcberpr\u00fcfen, ob AgenaScript mit historen Daten oder mit Real-Time-Daten arbeitet.\nSolange OnCalculate() f\u00fcr historische Daten aufgerufen wird, ist Historical = true, in dem Moment, in dem die Verarbeitung von Live-Daten beginnt, wird Historical = false.\nW\u00e4hrend ein Backtest ausgef\u00fchrt wird, ist Historical immer true.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_28",
            "text": "Historical",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_12",
            "text": "true  bei Verarbeitung von historischen Daten false  bei Verarbeitung von Real-Time-Daten",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#beispiele_9",
            "text": "protected override void OnCalculate()\n{\n// Nur f\u00fcr realtime-Daten ausf\u00fchren\nif (IsHistoricalMode) return;\n// irgendeine Handelslogik\n}",
            "title": "Beispiele"
        },
        {
            "location": "/schluesselworte/#inputpricetype",
            "text": "",
            "title": "InputPriceType"
        },
        {
            "location": "/schluesselworte/#beschreibung_39",
            "text": "Die Eigenschaft InputPriceType legt fest, welche Kursreihe bei der Berechnung in Indikatoren als Standard verwendet werden soll, wenn keine Datenreihe explizit angegeben ist.\nInputPriceType kann in der OnInit()-Methode stehen. Die Angabe hat dann f\u00fcr alle weiteren Berechnungen im Indikator G\u00fcltigkeit.\nSteht InputPriceType in OnCalculate(), gilt die \u00c4nderung der Eingangsdatenreihe ab der n\u00e4chsten Anweisung.\nJedes weitere Auftreten von InputPriceType wird ignoriert!  Siehe auch   PriceType",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_29",
            "text": "InputPriceType",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel1",
            "text": "protected override void OnInit()\n{\nClearTraceWindow();\nInputPriceType = PriceType.Low;\n}\nprotected override void OnCalculate()\n{\n// Die Eingangsdatenreihe f\u00fcr den Indikator (Input) ist Low\nPrint(Low[0] + \" \" + InSeries[0] + \" \" + InputPriceType);\n}",
            "title": "Beispiel1"
        },
        {
            "location": "/schluesselworte/#beispiel2",
            "text": "protected override void OnCalculate()\n{\n// Diese Werte sind identisch,\n     // da standardm\u00e4\u00dfig Close als Inputdatenreihe verwendet wird\nPrint(SMA(20)[0] + \" \" + SMA(Close, 20)[0]);\nInputPriceType = PriceType.Low;\n// ab hier wird Low anstatt Close als Standard verwendet\n// Die beiden Werte sind identisch\nPrint(SMA(20)[0] + \" \" + SMA(Low, 20)[0]);\nInputPriceType = PriceType.High;\n// Diese Anweisung wird ignoriert.\n     // Es gilt weiterhin Input = Low !!!\n}",
            "title": "Beispiel2"
        },
        {
            "location": "/schluesselworte/#instrument",
            "text": "",
            "title": "Instrument"
        },
        {
            "location": "/schluesselworte/#beschreibung_40",
            "text": "Mit Instrument werden Informationen zum Handelsinstrument (Aktie, Future etc.) bereitgestellt, f\u00fcr welches ein Indikator, eine Strategie usw. gerade l\u00e4uft.  Ausf\u00fchrliche Details finden sich unter  Instruments .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#isadddrawingstopricepanel",
            "text": "",
            "title": "IsAddDrawingsToPricePanel"
        },
        {
            "location": "/schluesselworte/#beschreibung_41",
            "text": "Die Eigenschaft  \"IsAddDrawingsToPricePanel\" legt fest, in welchem Panel Zeichenobjekte gezeichnet werden.  IsAddDrawingsToPricePanel = true (default)  Zeichenobjekte werden im Preischart gezeichnet  IsAddDrawingsToPricePanel = false  Zeichenobjekte werden in dem Panel (Subchart) gezeichnet, das dem Indikator zugeordnet ist.  Ist der Indikator bereits dem Preischart zugeordnet (Overlay = true) ist diese Eigenschaft wirkungslos, d.h. es wird in diesem Fall kein neuer Subchart ge\u00f6ffnet.  Die Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false)",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_30",
            "text": "IsAddDrawingsToPricePanel",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel_27",
            "text": "protected override void OnInit()\n{\n// Indikator in einem neuen Subchart zeichnen\nIsOverlay = false;\nAdd(new OnPaint(Color.Red, \"MyPlot1\"));\n// Zeichenobjekte im Preischart zeichnen\nIsAddDrawingsToPricePanel = true;\n}\nprotected override void OnCalculate()\n{\n// zeichnet im Preischart eine vertikale Linie am Bar von vor 5 Perioden\nAddChartVerticalLine(\"MyVerticalLine\", 5, Color.Black);\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#isautoadjustablescale",
            "text": "",
            "title": "IsAutoAdjustableScale"
        },
        {
            "location": "/schluesselworte/#beschreibung_42",
            "text": "Auto scale is a property of indicators that can be set within the OnInit() method.  IsAutoAdjustableScale = true (default)  Die Preisachse (y-Achse) des Charts wird so eingestellt, dass alle Plots und Lines eines Indikators bzw. einer Strategie im Chart sichtbar sind.  IsAutoAdjustableScale = false  Plots und Lines eines Indikators bzw. einer Strategie werden nicht in die Skalierung der Preisachse (y-Achse) eines Charts mit einbezogen. Sie k\u00f6nnen auch ausserhalb des sichtbaren Chartbereichs liegen.  Die Eigenschaft kann abgefragt werden, und liefert \"true\" bzw. \"false\".",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_31",
            "text": "IsAutoAdjustableScale",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel_28",
            "text": "protected override void OnInit()\n{\n//Chart so skalieren, dass alle Zeichenobjekte sichtbar sind\nIsAutoAdjustableScale = true;\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#isoverlay",
            "text": "",
            "title": "IsOverlay"
        },
        {
            "location": "/schluesselworte/#beschreibung_43",
            "text": "Die Eigenschaft Overlay legt fest, ob die Indikatorausgaben, wie Plots und Linien, im Preischart \u00fcber die Kursbars gezeichnet werden oder ob ein neues separates Chartfenster unterhalb des Preischarts ge\u00f6ffnet wird.  IsOverlay = true  Es wird \u00fcber den Kurs gezeichnet (wie z.B. ein  SMA )  IsOverlay = false (default)  Es wird ein separates Chartfenster ge\u00f6ffnet (wie z.B. ein  RSI )  Die Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false).",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_32",
            "text": "IsOverlay",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel_29",
            "text": "protected override void OnInit()\n{\nAdd(new OnPaint(Color.Red, \"MyPlot1\"));\n//Der Indikator soll in einem separaten Fenster dargestellt werden\nIsOverlay = false;\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#isprocessingbarindexlast",
            "text": "",
            "title": "IsProcessingBarIndexLast"
        },
        {
            "location": "/schluesselworte/#description_1",
            "text": "Indicates if current bar is last in calculation.",
            "title": "Description"
        },
        {
            "location": "/schluesselworte/#parameter_23",
            "text": "None",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#return-value",
            "text": "Type bool",
            "title": "Return value"
        },
        {
            "location": "/schluesselworte/#usage",
            "text": "used for complicated calculation on a last bar",
            "title": "Usage"
        },
        {
            "location": "/schluesselworte/#example",
            "text": "protected override void OnCalculate()\n{\n            base.OnCalculate();\n            if (!IsProcessingBarIndexLast)\n                return;\n            bool isUpdated;\n}",
            "title": "Example"
        },
        {
            "location": "/schluesselworte/#isserierising",
            "text": "",
            "title": "IsSerieRising()"
        },
        {
            "location": "/schluesselworte/#beschreibung_44",
            "text": "Mit der Methode IsSerieRising() kann gepr\u00fcft werden, ob eine \"ist steigend\"-Bedingung vorliegt, d.h. ob der aktuelle Wert gr\u00f6\u00dfer ist als der Wert des vorhergehenden Bars.  Siehe auch  CrossAbove() ,  CrossBelow() ,  IsSerieRising() ,  IsSerieFalling() .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_33",
            "text": "IsSerieRising(IDataSeries series)",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_13",
            "text": "true  wenn die Datenreihe steigt false  wenn die Datenreihe nicht steigt",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#parameter_24",
            "text": "series eine Datenserie, wie z.B. ein Indikator, Close, High o.\u00e4",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#beispiele_10",
            "text": "// Pr\u00fcfen, ob der SMA(20) steigt\nif (IsSerieRising(SMA(20)))\nPrint(\"The SMA(20) is currently rising.\");",
            "title": "Beispiele"
        },
        {
            "location": "/schluesselworte/#isseriesfalling",
            "text": "",
            "title": "IsSeriesFalling()"
        },
        {
            "location": "/schluesselworte/#beschreibung_45",
            "text": "Mit der Methode  IsSeriesFalling() kann gepr\u00fcft werden, ob eine \"ist fallend\"-Bedingung vorliegt, d.h. ob der aktuelle Wert kleiner ist als der Wert des vorhergehenden Bars.  Siehe auch   CrossAbove() ,  CrossBelow() ,  IsSerieRising() ,  IsSerieFalling() .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_34",
            "text": "IsSerieFalling(IDataSeries series)",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_14",
            "text": "true  wenn die Datenreihe f\u00e4llt false  wenn die Datenreihe nicht f\u00e4llt",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#parameter_25",
            "text": "series eine Datenserie, wie z.B. ein Indikator, Close, High o.\u00e4",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#beispiele_11",
            "text": "// Pr\u00fcfen, ob der SMA(20) f\u00e4llt\nif (IsSerieFalling(SMA(20)))\nPrint(\"The SMA(20) is currently falling.\");",
            "title": "Beispiele"
        },
        {
            "location": "/schluesselworte/#isshowchartverticalgrid",
            "text": "",
            "title": "IsShowChartVerticalGrid"
        },
        {
            "location": "/schluesselworte/#beschreibung_46",
            "text": "Die Eigenschaft IsShowChartVerticalGrid legt fest, ob in regelm\u00e4\u00dfigen Abst\u00e4nden vertikale Linien im Chart (das sog. vertikale Grid) angezeigt werden sollen.  IsShowChartVerticalGrid = true (default)  Vertikale Gitternetzlinien werden im Chart angezeigt.  IsShowChartVerticalGrid = false  Vertikale Gitternetzlinien werden nicht im Chart angezeigt.  Die Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false).",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_35",
            "text": "IsShowChartVerticalGrid",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel_30",
            "text": "protected override void OnInit()\n{\nAdd(new OnPaint(Color.Red, \"MyPlot1\"));\n// Vertikale Gitternetzlinien sollen nicht im Chart angezeigt werden\nIsShowChartVerticalGrid = false;\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#isshowindatabox",
            "text": "",
            "title": "IsShowInDataBox"
        },
        {
            "location": "/schluesselworte/#beschreibung_47",
            "text": "Die Eigenschaft  \"IsShowInDataBox\" gibt an, ob die Werte des Indikators (Datenserien) in der DataBox des Charts enthalten sein sollen oder nicht.  Die Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false)  IsShowInDataBox = true (default)  Die Indikatorwerte werden in der DataBox angezeigt.  IsShowInDataBox = false  Die Indikatorwerte werden nicht in der DataBox angezeigt.  Im Bild werden die Werte von 3 gleitenden Durchschnitten in der DataBox angezeigt.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_36",
            "text": "IsShowInDataBox",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel_31",
            "text": "protected override void OnInit()\n{\nAdd(new OnPaint(Color.Red, \"MyPlot1\"));\n//Werte sollen nicht in der DataBox angezeigt werden\nIsShowInDataBox = false;\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#isshowpricemarkers",
            "text": "",
            "title": "IsShowPriceMarkers"
        },
        {
            "location": "/schluesselworte/#beschreibung_48",
            "text": "Die Eigenschaft PaintPriceMarkers legt fest, ob f\u00fcr die Indikatorausgaben, am rechten Chartrand (in der Preisachse) die sog. PriceMarkers angezeigt werden sollen oder nicht. In manchen F\u00e4llen ist es sinnvoll, dies f\u00fcr eine bessere \u00dcbersicht im Chart auszuschalten. IsShowPriceMarkers = true (default)  PriceMarkers werden in der Preisachse angezeigt.  IsShowPriceMarkers = false  PriceMarkers werden nicht in der Preisachse angezeigt.  Die Eigenschaft kann imScript abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false).",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_37",
            "text": "IsShowPriceMarkers",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel_32",
            "text": "protected override void OnInit()\n{\nAdd(new OnPaint(Color.Red, \"MyPlot1\"));\n//IsShowPriceMarkers sollen nicht angezeigt werden\nIsShowPriceMarkers = false;\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#level1args",
            "text": "",
            "title": "Level1Args"
        },
        {
            "location": "/schluesselworte/#beschreibung_49",
            "text": "Der Datentyp MarketDataEventArgs repr\u00e4sentiert eine \u00c4nderung in den Level-I-Daten und wird als Parameter in der Funktion OnLevel1() verwendet.           AskSize  Das aktuelle Ordervolumen auf der Ask-Seite.    AskPrice  Der aktuelle Ask-Kurs    BidSize  Das aktuelle Ordervolumen auf der Bid-Seite    BidPrice  Der aktuelle Bid-Kurs.    Instrument  Ein Objekt des Types IInstrument, das das Handelsinstrument beinhaltet, f\u00fcr welches die Level-I-Daten geliefert werden. Siehe  Instruments    LastPrice  Der letzte durch einen Umsatz entstandene Kurs    MarketDataType  M\u00f6gliche Werte sind: MarketDataType.Ask, MarketDataType.AskSize, MarketDataType.Bid, MarketDataType.BidSize, MarketDataType.Last, MarketDataType.Volume    Price  Tenth\u00e4lt den gleichen Wert wie LastPrice. Das Feld ist nur aus Kompatibilit\u00e4tsgr\u00fcnden vorhanden.    Time  Ein DateTime-Wert, der den Zeitstempel der \u00c4nderung beinhaltet.    Volume  Ein long-Wert, der das Volumen, d.h. den letzten realen Umsatz angiebt.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#beispiel_33",
            "text": "siehe Beispiel unter  OnLevel1() .",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#level2args",
            "text": "",
            "title": "Level2Args"
        },
        {
            "location": "/schluesselworte/#beschreibung_50",
            "text": "Der Datentyp  Level2Args repr\u00e4sentiert eine \u00c4nderung in den Level-II-Daten (Markttiefe) und wird als Parameter in der Funktion OnLevel2() verwendet.           MarketDataType  M\u00f6gliche Werte sind: MarketDataType.Ask, MarketDataType.Bid    MarketMaker  Ein string-Wert, der die Market Maker ID enth\u00e4llt    Position  Ein int-Wert, der die Position innerhalb der Markttiefe angiebt    Operation  Steht f\u00fcr die Aktion, die durch die \u00c4nderung in einem Orderbuch ausgel\u00f6st wird.  M\u00f6gliche Werte sind: Operation.Insert, Operation.Remove, Operation.Update    Price  Eine double-Wert, der den jeweiligen Bid/Ask-Kurs    Time  Ein DateTime-Wert, der den Zeitstempel der \u00c4nderung beinhaltet    Volume  Ein long-Wert, der das Volumen angiebt",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#beispiel_34",
            "text": "siehe Beispiel unter  OnLevel2() .",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#levelline",
            "text": "",
            "title": "LevelLine()"
        },
        {
            "location": "/schluesselworte/#beschreibung_51",
            "text": "EinA LevelLine object wird genutzt, um eine horizontale Linie in einen Chart zu zeichnen. \u00dcblicherweise sind dies obere und untere Triggerlinien wie z.B. beim RSI-Indikator die 70 und die 30 Linie.\nDiese hier beschriebenen Linien sind nicht zu verwechseln mit der Linie aus den Zeichenobjekten  (siehe \"AddChartHorizontalLine\").\nLevelLine objectwerden einem Indikator mit Hilfe der Add()-Methode hinzugef\u00fcgt und damit in die Lines-Collection aufgenommen.  Siehe auch  OnPaint .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#parameter_26",
            "text": "Color  Linienfarbe    Name  Bezeichnung    Pen  ein Pen-Objekt    Value  Gibt an, bei welchem Wert auf der y-Achse (Preisachse) die Linie gezeichnet werden soll",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#verwendung_38",
            "text": "LevelLine(Color color, double value, string name)\nLevelLine(Pen pen, double value, string name)",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#weitere-informationen_1",
            "text": "Informationen zur Klasse Pen:  http://msdn.microsoft.com/de-de/library/system.drawing.pen.aspx",
            "title": "Weitere Informationen"
        },
        {
            "location": "/schluesselworte/#beispiele_12",
            "text": "// Beispiel 1\n// Eine Linie mit Standardwerten bei 70 in den Chart zeichnen\nAdd(new LevelLine(Color.Black, 70, \"Upper\"));\n// Beispiel 2\n// Eine Linie mit selbstdefinierten Werten in den Chart zeichnen\nprivate LevelLine line;\nprivate Pen pen;\nprotected override void OnInit()\n{\n// einen roten Stift mit der Linienst\u00e4rke 1 definieren\npen = new Pen(Color.Red, 1);\n// eine horizontale Linie bei 10 definieren\nline = new LevelLine(pen, 10, \"MyLine\");\n// die oben def. Linie dem Indikator hinzuf\u00fcgen\nAdd(line);\n}\n// Beispiel 3\n// Kurzform f\u00fcr die Linie aus Bespiel 2\nAdd(new LevelLine(new Pen(Color.Red, 1), 10, \"MyLine\"));",
            "title": "Beispiele"
        },
        {
            "location": "/schluesselworte/#log",
            "text": "",
            "title": "Log()"
        },
        {
            "location": "/schluesselworte/#beschreibung_52",
            "text": "Mit Log() ist es m\u00f6glich, Ausgaben in das LogFile (Log Tab) von AgenaTrader zu schreiben. Es werden 5 verschiedene LogLevel unterst\u00fctzt.  Hinweis: Ist der Log-Tab nicht sichtbar, kann er mit Tools-Log angezeigt werden.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_39",
            "text": "**Log**(string message, LogLevel logLevel)",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#parameter_27",
            "text": "message  Text (message)    logLevel  M\u00f6gliche Werte sind: InfoLogLevel.Info, InfoLogLevel.Message, InfoLogLevel.Warning, InfoLogLevel.ShowAlert, InfoLogLevel.Error",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#beispiel_35",
            "text": "//Tab protocol\nLog(\"Das ist eine Information.\", InfoLogLevel.Info); //white\nLog(\"Das ist eine Nachricht.\", InfoLogLevel.Message); // white\nLog(\"Das ist eine Warnung.\", InfoLogLevel.Warning); // blue\nLog(\"Das ist ein Alarm.\", InfoLogLevel.ShowAlert); //green\nLog(\"Das ist ein Fehler.\", InfoLogLevel.Error); // red\n//Tab messages\nLog(\"This is a message (messages).\", InfoLogLevel.Message); //white\n//PopUp & protocoll\nLog(\"This is an alert popup window.\", InfoLogLevel.ShowAlert); //green\n\n//Output-Tab:\n//InfoLogLevel.Message = send to Tab \"Messages\" not \"Log\"\n\n//Action:\n/*\nInfoLogLevel.Error: also the AT-Status-Line is red and flashes\nInfoLogLevel.ShowAlert: opens also a modeless messagebox\n*/\n\n/*\nSummary: * - InfoLogLevel.ShowAlert Color: green Tab: Log Action: modeless Messagebox * - InfoLogLevel.Warning Color: blue Tab: Log * - InfoLogLevel.Info Color: white Tab: Log * - InfoLogLevel.Error Color: red Tab: Log Action: AT-Status-Line: red + flashing (Error) * - InfoLogLevel.Message Color: white Tab: Messages\n*/  Crossreference:\na crossreference to Print() and ShowAlert()",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#occurred",
            "text": "",
            "title": "Occurred"
        },
        {
            "location": "/schluesselworte/#beschreibung_53",
            "text": "Diese DataSeries werden unter Bedingungen verwendet und geben an, ob ein Signal aufgetreten ist(1-long, -1 short, 0- kein signal )",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#parameter_28",
            "text": "keiner",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_15",
            "text": "Int",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#verwendung_40",
            "text": "Im Skriptzustand f\u00fcr short, long, kein Signal",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel_36",
            "text": "protected override void OnCalculate()\n{\nif ( ProcessingBarIndex %2 == 0 )\nOccurred.Set(1); // Long\nelse if ( ProcessingBarIndex %3 == 0 )\nOccurred.Set(-1); // Short\nelse\nOccurred.Set(0);\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#onbarsrequirements",
            "text": "",
            "title": "OnBarsRequirements()"
        },
        {
            "location": "/schluesselworte/#beschreibung_54",
            "text": "Die OnBarsRequirements() Methode wird einmal zu Beginn einer Indikator- bzw. Strategieberechnung aufgerufen. Die Methode ist nur bei Verwendung von MultiBars notwendig.\nInnerhalb von InitRequirements werden keine weiteren Programmierbefehle ausgef\u00fchrt.\nF\u00fcr eigene Initialisierungen sind die MethodenOnInit() bzw. OnStart() zu verwenden.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#parameter_29",
            "text": "keiner",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_16",
            "text": "keiner",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#beispiel_37",
            "text": "protected override void OnBarsRequirements()\n{\nAdd(DatafeedHistoryPeriodicity.Day, 1);\nAdd(DatafeedHistoryPeriodicity.Week, 1);\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#oninit",
            "text": "",
            "title": "OnInit()"
        },
        {
            "location": "/schluesselworte/#beschreibung_55",
            "text": "Die OnInit()-Methode wird einmal zu Beginn einer Indikator- bzw. Strategieberechnung aufgerufen. Die Methode kann verwendet werden um Indikatoreigenschaften zu setzen, eigene Variablen zu initialisieren oder Plots hinzuzuf\u00fcgen.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#parameter_30",
            "text": "keiner",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_17",
            "text": "keiner",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#verwendung_41",
            "text": "protected override void OnInit()",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#wichtige-schlusselworte",
            "text": "Add()  AllowRemovalOfChartDrawings  IsAutoScale  RequiredBarsCount  CalculateOnClosedBar  ClearTraceWindow  Displacement  IsShowInDataBox  IsAddDrawingsToPricePanel  InputPriceType  IsOverlay  IsShowPriceMarkers  IsShowChartVerticalGrid   zus\u00e4tzlich f\u00fcr Strategien   DefaultOrderQuantity  EntriesPerDirection  SetUpStopLoss()  SetUpProfitTarget()  SetUpTrailStop()  TimeInForce  TraceOrders",
            "title": "wichtige Schl\u00fcsselworte"
        },
        {
            "location": "/schluesselworte/#weitere-informationen_2",
            "text": "Achtung: \nDie OnInit()-Methode wird nicht nur am Beginn einer Indikator- bzw. Strategieberechnung aufgerufen, sondern auch unerwartet z.B. wenn ein Chart neu geladen wird oder der Eigenschaftsdialog von Indikatoren ge\u00f6ffnet wird usw.\nEntwickler von eigenen AgenaScripts sollten diese Methode NICHT verwenden, um eigene Routinen laufen zu lassen, Forms zu \u00f6ffnen, Lizenzchecks auszuf\u00fchren u. dgl. mehr. Hierzu ist die Methode  OnStart() zu verwenden.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/schluesselworte/#beispiel_38",
            "text": "protected override void OnInit()\n{\nAdd(new OnPaint(Color.Blue, \"myPlot\"));\nClearTraceWindow();\nIsAutoScale = false;\nIsOverlay = true;\nIsShowPriceMarkers = false;\nIsShowInDataBox = false;\nCalculateOnClosedBar = true;\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#onpaint",
            "text": "",
            "title": "OnPaint()"
        },
        {
            "location": "/schluesselworte/#beschreibung_56",
            "text": "EinOnPaint (drawing)wird genutzt, um einen Indikator in einem Chart graphisch darzustellen. Plot-Objekte werden einem Indikator mit Hilfe der Add()-Methode hinzugef\u00fcgt und damit in die Plots-Collection aufgenommen.\nSiehe auch   LevelLine .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#parameter_31",
            "text": "Color  Zeichenfarbe    Pen  ein Pen-Objekt    PlotStyle  Linienart: PlotStyle.Bar, PlotStyle.Block, PlotStyle.Cross, PlotStyle.Dot, PlotStyle.Hash, PlotStyle.LevelLine, PlotStyle.Square, PlotStyle.TriangleDown, PlotStyle.TriangleUp    Name  Bezeichnung",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#verwendung_42",
            "text": "OnPaint(Color color, string name)\nOnPaint(Pen pen, string name)\nOnPaint(Color color, PlotStyle plotStyle, string name)\nOnPaint(Pen pen, PlotStyle plotStyle, string name)",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#weitere-informationen_3",
            "text": "Informationen zur Klasse Pen:  http://msdn.microsoft.com/de-de/library/system.drawing.pen.aspx",
            "title": "Weitere Informationen"
        },
        {
            "location": "/schluesselworte/#beispiele_13",
            "text": "// Beispiel 1\n// Plot mit Standardwerten (Linie mit Linienst\u00e4rke 1)\nAdd(new OnPaint(Color.Green, \"MyPlot\"));\n// Beispiel 2\n// benutzerdefinierte Werte f\u00fcr Pen und PlotStyle\nprivate OnPaint plot;\nprivate Pen pen;\nprotected override void OnInit()\n{\n// einen roten Stift mit der Linienst\u00e4rke 6 definieren\npen = new Pen(Color.Blue, 6);\n// eine Punkt-Linie mit dem dicken roten Stift von oben definieren\nplot = new OnPaint(pen, PlotStyle.Dot, \"MyPlot\");\n// den oben def. Plot als Darstellung f\u00fcr den Indikator verwenden\nAdd(plot);\n}\n// Beispiel 3\n// Kurzform von Beispiel 2\nprotected override void OnInit()\n{\nAdd(new OnPaint(new Pen(Color.Blue, 6), PlotStyle.Dot, \"MyPlot\"));\n}",
            "title": "Beispiele"
        },
        {
            "location": "/schluesselworte/#inputparameter",
            "text": "",
            "title": "InputParameter()"
        },
        {
            "location": "/schluesselworte/#beschreibung_57",
            "text": "Attribut, das f\u00fcr die Anpassung der Indikatoren verwendet wird",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_18",
            "text": "keiner",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#parameter_32",
            "text": "keiner",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#beispiele_14",
            "text": "[Description(\"Period for the medium mean average\")]\n[InputParameter]\n[DisplayName(\"MA Medium\")]\npublic int MA_Medium\n{\n    get \n    { \n        return _ma_medium; \n    }\n    set\n    {\n        _ma_medium = value;\n    }\n}",
            "title": "Beispiele"
        },
        {
            "location": "/schluesselworte/#playsound",
            "text": "",
            "title": "PlaySound()"
        },
        {
            "location": "/schluesselworte/#beschreibung_58",
            "text": "Die Methode PlaySound() dient dazu, ein Wav-File abzuspielen.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_43",
            "text": "PlaySound (wavFile)",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_19",
            "text": "keiner",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#parameter_33",
            "text": "wavFile Dateiname der Wav-Datei zum Abspielen",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#beispiel_39",
            "text": "using System.IO;\nstring path = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);\nstring file = \"\\\\\\\\AgenaTrader\\\\\\\\Sounds\\\\\\\\Alert1.wav\";\nPlaySound(path + file);",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#plotmethod",
            "text": "",
            "title": "PlotMethod"
        },
        {
            "location": "/schluesselworte/#beschreibung_59",
            "text": "In jedem Indikator kann die Plot-Methode \u00fcberschrieben werden um mit Mittlen der Graphics-Klasse (System.Drawing) dem Preis-Chart  eigene Grafiken hinzuzuf\u00fcgen (GDI+).  Siehe  http://msdn.microsoft.com/de-de/library/system.drawing.graphics.aspx .  Das Objekt   Chart  bietet einige n\u00fctzliche Parameter.  Weitere Beispiele:  Bar Numbering ,  PlotSample ,  Chart Background Image .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#parameter_34",
            "text": "graphics Das graphics-Objekt des Preischarts (der sog. context)  rectangle Die Gr\u00f6\u00dfe der Zeichenfl\u00e4che (Type public struct rectangle)  double min Der kleinste Kurs in der y-Achse  double max Der gr\u00f6\u00dfte Kurs in der y-Achse",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_20",
            "text": "keiner",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#verwendung_44",
            "text": "public override void OnPaint(Graphics graphics, Rectangle r, double min, double max)",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel_40",
            "text": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing AgenaTrader.API;\nusing AgenaTrader.Custom;\nusing AgenaTrader.Plugins;\nnamespace AgenaTrader.UserCode\n{\n[Description(\"Example for the usage of the plot method.\")]\npublic class PlotSample : UserIndicator\n{\nprivate StringFormat stringFormat = new StringFormat();\nprivate SolidBrush brush = new SolidBrush(Color.Black);\nprivate Font font = new Font(\"Arial\", 10);\nprotected override void OnInit()\n{\nIsChartOnlyIndicator = true;\nIsOverlay = true;\n}\nprotected override void OnCalculate()\n{}\nprotected override void OnDispose()\n{\nbrush.Dispose();\nstringFormat.Dispose();\n}\npublic override void OnPaint(Graphics graphics, Rectangle r, double min, double max)\n{\n// Ausfuellen eines Rechtecks\nSolidBrush tmpBrush = new SolidBrush(Color.LightGray);\ngraphics.FillRectangle(tmpBrush, new Rectangle (0, 0, 300, 300));\ntmpBrush.Dispose();\n// Zeichnen einer roten Linie von oben links nach unten recht\nPen pen = new Pen(Color.Red);\ngraphics.AddChartLine(pen, r.X, r.Y, r.X + r.Width, r.Y + r.Height);\n// Zeichnen einer roten Linie von unten links nach oben rechts\n// Verwenden von AnitAlias (Die Linie erscheint glatter)\n// Die aktuellen Einstellungen fuer die Glaettung werden gesichert\n // und nach dem Zeichnen wiederhergestellt\nSmoothingMode oldSmoothingMode = graphics.SmoothingMode; //Einstellung sichern\ngraphics.SmoothingMode = SmoothingMode.AntiAlias; // hohe Glaettung verwenden\ngraphics.AddChartLine(pen, r.X, r.Y + r.Height, r.X + r.Width, r.Y);\ngraphics.SmoothingMode = oldSmoothingMode; // Einstellungen wiederherstellen\npen.Dispose();\n// Text in die obere linke Ecke (Position 10,35) schreiben\nstringFormat.Alignment = StringAlignment.Near; // Text links ausrichten\nbrush.Color = Color.Blue;\ngraphics.DrawString(\"Hello world!\", font, brush, r.X + 10, r.Y + 35, stringFormat);\n// Text in die linke untere Ecke schreiben und eine Linie darum herumzeichnen\nbrush.Color = Color.Aquamarine;\ngraphics.FillRectangle(brush, r.X + 10, r.Y + r.Height - 20, 140, 19);\n// Aeussere Linie zeichnen\npen = new Pen(Color.Black);\ngraphics.AddChartRectangle(pen, r.X + 10, r.Y + r.Height - 20, 140, 19);\npen.Dispose();\n// Text schreiben\nbrush.Color = Color.Red;\ngraphics.DrawString(\"Here is bottom left!\", font, brush, r.X + 10, r.Y + r.Height - 20, stringFormat);\n}\n}\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#pricetype",
            "text": "",
            "title": "PriceType"
        },
        {
            "location": "/schluesselworte/#beschreibung_60",
            "text": "PriceType beschreibt die Art von Kursdaten.  Siehe auch  InputPriceType  Folgende Werte stehen zur Verf\u00fcgung:\n-   PriceType.Close\n-   PriceType.High\n-   PriceType.Low\n-   PriceType.Median\n-   PriceType.Open\n-   PriceType.Typical\n-   PriceType.Volume\n-   PriceType.Weighted",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_45",
            "text": "PriceType",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel_41",
            "text": "Siehe Beispiel unter  InputPriceType",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#print",
            "text": "",
            "title": "Print()"
        },
        {
            "location": "/schluesselworte/#beschreibung_61",
            "text": "Die Methode Print() schreibt Ausgaben in das AgenaTrader Output-Window.\nSiehe auch  ClearTraceWindow .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_46",
            "text": "Print(string message)\nPrint(bool value)\nPrint(double value)\nPrint(int value)\nPrint(DateTime value)\nPrint(string format, string message)",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#parameter_35",
            "text": "string Text ein individueller Meldungstext",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_21",
            "text": "keiner",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#weitere-informationen_4",
            "text": "Hinweise zum Formatieren von Ausgaben finden Sie unter  Formatting numbers .  Hinweise zur String.Format()-Methode:   http://msdn.microsoft.com/de-de/library/fht0f5be%28v=vs.80%29.aspx",
            "title": "Weitere Informationen"
        },
        {
            "location": "/schluesselworte/#beispiel_42",
            "text": "// \"Quick&Dirty\"-Formatierung einer Zahl mit 2 Nachkommastellen\nPrint(Close[0].ToString(\"0.00\"));\n// Wochentag aus dem Zeitstempel des Bars ausgeben\nPrint(string.Format(\"{0:dddd}\", Time[0]));\n// Ein zus\u00e4tzlicher Zeilenvorschub mit ESC-Sequenz\nPrint(\"One empty row afterwards \\\\n\");",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#processingbarindex",
            "text": "",
            "title": "ProcessingBarIndex"
        },
        {
            "location": "/schluesselworte/#beschreibung_62",
            "text": "ProcessingBarIndex  ist eine Nummerierung von Bars, die in der Methode OnCalculate()  verwendet wird. Wenn in einem Chart z.B. 500 Bars dargestellt werden und auf diese ein Indikator berechnet werden soll, so beginnt AgenaTrader mit der Berechnung (also dem Aufruf von OnCalculate() bei dem \u00e4ltesten Bar. Dieser bekommt die Nummer 0. Ist die Berechnung f\u00fcr diesen Bar abgeschlossen, wird OnCalculate() f\u00fcr den n\u00e4chsten Bar aufgerufen. Dieser bekommt dann die Nummer 1 usw. bis zum letzten Bar, der die Nummer 499 bekommt.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#parameter_36",
            "text": "keiner",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_22",
            "text": "ProcessingBarIndex ist eine Variable vom Typ int, die immer die Nummer des sich gerade in Bearbeitung befindenden Bars enth\u00e4lt.",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#verwendung_47",
            "text": "ProcessingBarIndex",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#weitere-informationen_5",
            "text": "Die in der Methode  OnCalculate() verwendete Nummerierung mit ProcessingBarIndex unterscheidet sich vom  Barindex  und  Bars . Das Verst\u00e4ndnis dieses Unterschiedes ist sehr wichtig! Bitte das folgende genau lesen!  ProcessingBarIndex nummeriert fortlaufend vom \u00e4ltesten zum j\u00fcngsten Bar beginnend bei 0. Der Barindex ist f\u00fcr den j\u00fcngsten Bar immer 0. Im Beispiel unten steht Time[0] f\u00fcr den Zeitstempel des aktuellen Bars. Der Index des \u00e4ltesten Bars wird mit jedem neu hinzukommenden Damit wird eine logische Z\u00e4hlung f\u00fcr barsAgo m\u00f6glich. Der Zeitstempel f\u00fcr den Bar von vor 5 Perioden ist damit Time[5].\nBei Verwendung mehrerer Zeiteinheiten (multi-bars)in einem Indikator siehe ProcessingBarIndexes.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/schluesselworte/#beispiel_43",
            "text": "protected override void OnCalculate()\n{\nPrint(\"Call of OnCalculate for bar nr. \" + ProcessingBarIndex + \" of \" + Time[0]);\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#removechartdrawing",
            "text": "",
            "title": "RemoveChartDrawing()"
        },
        {
            "location": "/schluesselworte/#beschreibung_63",
            "text": "Die Methode RemoveChartDrawing() entfernt ein bestimmtes Zeichenobjekt vom Chart anhand einer eindeutigen Kennzeichnung (tag).\nSiehe auch  RemoveChartDrawings() .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_48",
            "text": "RemoveChartDrawings(string tag)",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_23",
            "text": "keiner",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#parameter_37",
            "text": "string tag Der Name eines Zeichenobjekts zur eindeutigen Identifizierung",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#beispiel_44",
            "text": "RemoveChartDrawings(\"Meine Linie\");",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#removechartdrawings",
            "text": "",
            "title": "RemoveChartDrawings()"
        },
        {
            "location": "/schluesselworte/#beschreibung_64",
            "text": "Die Methode RemoveDrawObjects() entfernt alle Zeichenobjekte vom Chart.\nSiehe auch  RemoveChartDrawings() .",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_49",
            "text": "RemoveChartDrawings()",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_24",
            "text": "keiner",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#beispiel_45",
            "text": "//Alle Zeicheobjekte vom Chart l\u00f6schen\nRemoveChartDrawings();",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#requiredbarscount",
            "text": "",
            "title": "RequiredBarsCount"
        },
        {
            "location": "/schluesselworte/#beschreibung_65",
            "text": "Die Eigenschaft BarsRequired gibt an, wieviele historische Bars mindestens ben\u00f6tigt werden, damit ein Indikator bzw. eine Strategie erstmal die Methode OnCalculate() aufrufen und mit den Berechnungen beginnen kann. BarsRequired sollte in der OnInit() Methode angegeben werden.\nDie Einstellung sollte sorgf\u00e4ltig gew\u00e4hlt werden. Z.B. braucht man zur Berechnung eines gleitenden Durchschnittes \u00fcber 100 Tage auch mindestens 100 Tage historische Daten, damit das Ergebnis korrekt ist.  Die Eigenschaft kann im Script abgefragt werden und liefert einen int-Wert.  Wenn OnBarUpdate erstmals aufgerufen wird, ist  ProcessingBarIndex property = 0, unabh\u00e4ngig vom Wert von RequiredBarsCount.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_50",
            "text": "RequiredBarsCount",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#beispiel_46",
            "text": "protected override void OnInit()\n{\n//Der Indikator ben\u00f6tigt mindestens 50 Bars Historie\nRequiredBarsCount = 50;\n}",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#showalert",
            "text": "",
            "title": "ShowAlert()"
        },
        {
            "location": "/schluesselworte/#beschreibung_66",
            "text": "Mit der Methode  ShowAlert wird ein akustischer und/oder visueller Alarm erzeugt.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_51",
            "text": "ShowAlert(string message, bool showMessageBox, string soundLocation);\n//Aus Kompatibilit\u00e4tsgr\u00fcnden ist noch eine veraltete Signatur enthalten. Bei Nutzung dieses Aufrufvariante werden die Farbangaben und \"rearmSeconds\" ignoriert.\nShowAlert(string id, AlertPriority priority, string message, string soundLocation, int rearmSeconds, Color backColor, Color forColor);",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_25",
            "text": "keiner",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#parameter_38",
            "text": "message  Nachrichtentext, der im Messages-Tab angezeigt wird.    soundLocation  Name eines Sound-Files im *.wav Format. Ist kein Pfad angegeben, wird \"Eigene Dokumente\\AgenaTrader\\Sounds\" verwendet.    showMessageBox  wenn true, wird zus\u00e4tzlich zum Sound eine Messagebox auf dem Bildschim angezeigt.",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#beispiel_47",
            "text": "// Hinweis ausgeben, wenn der SMA(20) unter SMA(50) kreuzt\nif (CrossBelow(SMA(20), SMA(50), 1))\nAlert(\"Check short signal!\", true, \"Alert4.wav\");  Um Musikdateien in anderen Verzeichnissen wiederzugeben, muss der vollst\u00e4ndige Pfad angegeben werden, z.B.:  string pathOfSoundfile = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments)+@\"\\\\MyAlertSounds\\\\\";\nstring nameOfSoundFile = \"MyAlertSoundFile.wav\";\nAlert(\"Message text\", true, pathOfSoundfile + nameOfSoundFile);",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#ticksize",
            "text": "Ein Tick ist die kleinst m\u00f6gliche Kurs\u00e4nderung eines Finanzinstruments an einer B\u00f6rse. Wenn die Handelspreise z.B. mit zwei Stellen nach dem Komma angegeben werden, betr\u00e4gt ein Tick 0,01. Im Forexhandel (W\u00e4hrungshandel) wird mit 4 bzw. 5 Stellen nach dem Komma gearbeitet. Ein Tick - der im Forexhandel als Pip bezeichnet wird - betr\u00e4gt dementsprechend 0,0001 bzw. 0,00001.\nDer Tickwert wird durch die B\u00f6rse fest vorgegeben und \u00e4ndert sich (in der Regel) nicht.\nSiehe auch  Instrument.TickSize .  \u00dcblicherweise wird heute ein Tick als Dezimalzahl angegeben. Historisch wurden besonders im amerikanischen Raum Aktien jedoch mit einer Tickgr\u00f6\u00dfe von 1/16 von einem Dollar notiert.  Bei Rohstoffen ist diese Notierung noch weit verbreitet. Der Corn-Future (ZC - Mais) wird genau wie Wheat (ZW - Weizen) in \u00bc US-Cent/bushel (entspricht 12,50 US-$ je Kontrakt) notiert.  US-Statsanleihen (T-Bonds) werden mit Tickgr\u00f6\u00dfen von 1/32 Punkten gehandelt, was 31,25 US-Dollar entspricht.  Die Notierung erfolgt mit Hochkomma:\n149'00 entspricht genau 149,\n149'01 entspricht 149 1/32 (also 149,03125),\n149'31 enspricht 149 31/32 (149,96875),\ndanach folgt dann 150'00.  In sog. T-Bond-Intermonth Spreads werden die Notierungen in Vierteln von 1/32 angegeben, was dann einem Punktwert von $7.8125 per Kontrakt entspricht.  Die Notierungen erfolgt mit Bindestrich:  17-24 entspricht 17 24/32 Punkten,\n17-242 entspricht 17 24,25/32 Punkten,\n17-245 entspricht 17 24,5/32 Punkten und\n17-247 entspricht 17 24,75/32 Punkten.\nDie n\u00e4chste Notierung nach 17-247 ist 17-25, dann wieder 17-252, 17-255 usw.\nNach 17-317 folgt 18.  Die Kontraktspezifikationen sind auf den Internetseiten der jeweiligen B\u00f6rsen ver\u00f6ffentlicht.  CME:  http://www.cmegroup.com  under Products & Trading\nEurex (FDAX):  http://www.eurexchange.com/exchange-en/products/idx/dax/17206/  siehe auch   Instrument.TickSize .",
            "title": "TickSize"
        },
        {
            "location": "/schluesselworte/#timeframe",
            "text": "siehe  Bars.TimeFrame .  Bei Verwendung mehrerer Zeiteinheiten ( Multibars ) in einem Indikator siehe  TimeFrames .",
            "title": "TimeFrame"
        },
        {
            "location": "/schluesselworte/#update",
            "text": "",
            "title": "Update()"
        },
        {
            "location": "/schluesselworte/#beschreibung_67",
            "text": "Die Methode Update() ruft die OnCalculateMethode einmal auf, um Indikatorwerte neu zu berechnen.  Update() ist mit Vorsicht und nur von erfahrenen Programmierern zu verwenden.",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_52",
            "text": "Update()",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#ruckgabewert_26",
            "text": "keiner",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/schluesselworte/#parameter_39",
            "text": "keiner",
            "title": "Parameter"
        },
        {
            "location": "/schluesselworte/#beispiel_48",
            "text": "Die Wirkung von Update l\u00e4\u00dft sich mit Hilfe von 2 Indikatoren veranschaulichen.\nDer erste Indikator \"Ind1\" nutzt eine public Variable aus Indikator \"Ind2\".  Code von Ind1:  public class Ind1 : UserIndicator\n{\nprotected override void OnCalculate()\n{\nPrint( Ind2().MyPublicVariable );\n}\n}  Code von Ind2:  private double myPublicVariable = 0;\nprotected override void OnCalculate()\n{\nmyPublicVariable = 1;\n}\npublic double MyPublicVariable\n{\nget\n{\nUpdate();\nreturn myPublicVariable;\n}\n}  Ohne Update() - Falsch \nWenn Ind2 von Ind1 aufgerufen wird, wird die get-Methode von MyPublicVariable in Ind2 aufgerufen. Ohne Update() w\u00fcrde der Wert von myPublicVariable zur\u00fcckgegeben werden. In diesem Falle eine 0.  Mit Update() - Richtig \nDurch den Aufruf von Update() wird zun\u00e4chst OnBarUpdate() von Ind2 ausgef\u00fchrt. Damit wird myPublicVariable auf 1 gesetzt. Anschlie\u00dfend wird der Wert 1 an den aufrufenden Indikator Ind1 \u00fcbergeben.",
            "title": "Beispiel"
        },
        {
            "location": "/schluesselworte/#value",
            "text": "",
            "title": "Value"
        },
        {
            "location": "/schluesselworte/#beschreibung_68",
            "text": "Value ist ein DataSeries-Objekt, welches die erste Datenserie eines Indikators enth\u00e4lt.  Beim Aufruf der Add()-Methode wird automatisch ein Value-Objekt erzeugt und der Collection Values hinzugef\u00fcgt.  Value ist identisch mit  Values[0].",
            "title": "Beschreibung"
        },
        {
            "location": "/schluesselworte/#verwendung_53",
            "text": "Value  Value[ int  barsAgo]",
            "title": "Verwendung"
        },
        {
            "location": "/schluesselworte/#weitere-informationen_6",
            "text": "Die f\u00fcr eine Collection bekannten Methoden Set(), Reset() und Count() sind auf Value anwendbar.",
            "title": "Weitere Informationen"
        },
        {
            "location": "/schluesselworte/#beispiel_49",
            "text": "Siehe  Values .",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/",
            "text": "Zeichenobjekte\n\n\nAddChartAndrewsPitchfork()\n\n\nBeschreibung\n\n\nAddChartAndrewsPitchfork() zeichnet ein Andrew's Pitchfork.\n\n\nInformationen zur Verwendung:\n-   \nvtad.de\n\n-   \nhvolumen-analyse.de\n\n-   \nGodmode-Trader.de\n\n\nVerwendung\n\n\nAddChartAndrewsPitchfork(string name, bool autoScale, int start1BarsBack, double start1Y, int start2BarsBack, double start2Y, int start3BarsBack, double start3Y, Color color, DashStyle dashStyle, int width)\nAddChartAndrewsPitchfork(string name, bool autoScale, DateTime start1Time, double start1Y, DateTime start2Time, double start2Y, DateTime start3Time, double start3Y, Color color, DashStyle dashStyle, int width)\n\n\n\n\nR\u00fcckgabewert\n\n\nA drawing object of the type IAndrewsPitchfork (interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist.\n\n\n\n\n\n\nstart1BarsBack\n\n\nAnzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt1 (x-Achse)\n\n\n\n\n\n\nstart1Time\n\n\nDatum/Zeit f\u00fcr Ankerpunkt1 (x-Achse)\n\n\n\n\n\n\nstart1Y\n\n\ny-Wert f\u00fcr Ankerpunkt1\n\n\n\n\n\n\nstart2BarsBack\n\n\nAnzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt2 (x-Achse)\n\n\n\n\n\n\nstart2Time\n\n\nDatum/Zeit f\u00fcr Ankerpunkt2(x-Achse)\n\n\n\n\n\n\nstart2Y\n\n\ny-Wert f\u00fcr Ankerpunkt2\n\n\n\n\n\n\nstart3BarsBack\n\n\nAnzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt3 (x-Achse)\n\n\n\n\n\n\nstart3Time\n\n\nDatum/Zeit f\u00fcr Ankerpunk3 (x-Achse)\n\n\n\n\n\n\nstart3Y\n\n\n-Wert f\u00fcr Ankerpunkt3\n\n\n\n\n\n\ncolor\n\n\nFarbe des Zeichenobjekts\n\n\n\n\n\n\ndashStyle\n\n\nLinienart\n\n\n\n\n\n\n\n\nDashStyle.Dash\n\n\n\n\n\n\n\n\nDashStyle.DashDot\n\n\n\n\n\n\n\n\nDashStyle.DashDotDot\n\n\n\n\n\n\n\n\nDashStyle.Dot\n\n\n\n\n\n\n\n\nDashStyle.Solid\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggf. mu\u00df\n\n\n\n\n\n\n\n\nusing System.Drawing.Drawing2D; mit eingebunden werden.\n\n\n\n\n\n\nwidth\n\n\nLinienst\u00e4rke in Punkten\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet ein Andrew's Pitchfork (\"Mistgabel\")\nAddChartAndrewsPitchfork(\"MyAPF\", true, 4, Low[4], 3, High[3], 1, Low[1], Color.Black, DashStyle.Solid, 2);\n\n\n\n\nAddChartArc()\n\n\nBeschreibung\n\n\nAddChartArc() zeichnet einen Kreisbogen.\n\n\nVerwendung\n\n\nAddChartArc(string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color)\nAddChartArc(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, DashStyle dashStyle, int width)\nAddChartArc(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, DashStyle dashStyle, int width)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ IArc (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu\n\n\n\n\n\n\nbarsBackStart\n\n\nAnzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den Startpunkt\n\n\n\n\n\n\nstartTime\n\n\nDatum/Uhrzeit f\u00fcr den Startpunkt\n\n\n\n\n\n\nstartY\n\n\ny-Wert f\u00fcr den Startpunkt\n\n\n\n\n\n\nbarsBackEnd\n\n\nAnzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den Endpunkt\n\n\n\n\n\n\nendTime\n\n\nDatum/Uhrzeit f\u00fcr den Endpunkt\n\n\n\n\n\n\nendY\n\n\ny-Wert f\u00fcr den Endpunkt\n\n\n\n\n\n\ncolor\n\n\nFarbe des Zeichenobjekts\n\n\n\n\n\n\ndashStyle\n\n\nLinienart\n\n\n\n\n\n\n\n\nDashStyle.Dash\n\n\n\n\n\n\n\n\nDashStyle.DashDot\n\n\n\n\n\n\n\n\nDashStyle.DashDotDot\n\n\n\n\n\n\n\n\nDashStyle.Dot\n\n\n\n\n\n\n\n\nDashStyle.Solid\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggf. mu\u00df\n\n\n\n\n\n\n\n\nusing System.Drawing.Drawing2D; mit eingebunden werden.\n\n\n\n\n\n\nwidth\n\n\nLinienst\u00e4rke in Punkten\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet einen blauen Kreisbogen\nAddChartArc(\"MyArc-\" + ProcessingBarIndex, true, 10, 10, 0, 20, Color.Blue, DashStyle.Solid, 3);\n\n\n\n\nAddChartArrowDown()\n\n\nBeschreibung\n\n\nAddChartArrowDown()  zeichnet einen nach unten gerichteten Pfeil:\n\n\n\n\nDrawArrowUp(), DrawDiamond(), DrawDot(), DrawSquare(), DrawTriangleUp(),  \nAddChartArrowUp()\n, \nAddChartArrowDown()\n, \nAddChartDiamond()\n, \nAddChartDot()\n, \nAddChartSquare()\n, \nAddChartTriangleUp()\n, \nAddChartTriangleDown()\n.\n\n\nVerwendung\n\n\nAddChartArrowDown(string name, bool autoScale, int barsAgo, double y, Color color)\nAddChartArrowDown(string name, bool autoScale, DateTime time, double y, Color color)\n\n\n\n\nR\u00fcckgabewert\n\n\nA drawing object of the type IArrowDown (interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen\n\n\n\n\n\n\nbarsAgo\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar der Pfeil gezeichnet werden soll\n\n\n\n\n\n\n(0=aktueller Bar)\n\n\n\n\n\n\n\n\ntime\n\n\nDatum/Uhrzeit des Bars, an dem der Pfeil gezeichnet werden soll\n\n\n\n\n\n\ny\n\n\ny-Wert f\u00fcr den Pfeil\n\n\n\n\n\n\ncolor\n\n\nFarbe des Zeichenobjekts\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet am akt. Bar einen roten Pfeil 3 Ticks \u00fcber dem Hoch\nAddChartArrowDown(\"MyArrow-\" + ProcessingBarIndex, true, 0, High[0] + 3*TickSize, Color.Red);\n// Zeichnet einen roten Pfeil auf einem Dreistufen-Umkehrmuster\nif(High[2] > High[3] && High[1] > High[2] && Close[0] < Open[0])\nAddChartArrowDown(ProcessingBarIndex.ToString(), true, 0, High[0] + 3*TickSize, Color.Red);\n\n\n\n\nAddChartArrowLine()\n\n\nBeschreibung\n\n\nAddChartArrowLine() zeichnet einen Pfeil.\n\n\n\n\nVerwendung\n\n\n AddChartArrowLine (string name,  int  barsBackStart,  double  startY,  int  barsBackEnd,  double  endY, Color color)\n AddChartArrowLine (string name,  bool  autoScale,  int  barsBackStart,  double  startY,  int  barsBackEnd,  double  endY, Color color, DashStyle dashStyle,  int  width)\n AddChartArrowLine (string name,  bool  autoScale, DateTime startTime,  double  startY, DateTime endTime,  double  endY, Color color, DashStyle dashStyle,  int  width)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ IArrowLine (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist\n\n\n\n\n\n\nbarsBackStart\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar der Pfeil beginnen soll (0=aktueller Bar)\n\n\n\n\n\n\nstartTime\n\n\nDatum/Uhrzeit des Bars, an dem der Pfeil beginnen soll\n\n\n\n\n\n\nstartY\n\n\ny-Wert, an dem der Pfeil beginnen soll\n\n\n\n\n\n\nbarsBackEnd\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar der Pfeil enden soll (0=aktueller Bar)\n\n\n\n\n\n\nendTime\n\n\nDatum/Uhrzeit des Bars, an dem der Pfeil enden\n\n\n\n\n\n\nendY\n\n\ny-Wert, an dem der Pfeil enden soll\n\n\n\n\n\n\ncolor\n\n\nFarbe des Zeichenobjekts\n\n\n\n\n\n\ndashStyle\n\n\nLinienart\n\n\n\n\n\n\n\n\nDashStyle.Dash\n\n\n\n\n\n\n\n\nDashStyle.DashDot\n\n\n\n\n\n\n\n\nDashStyle.DashDotDot\n\n\n\n\n\n\n\n\nDashStyle.Dot\n\n\n\n\n\n\n\n\nDashStyle.Solid\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggf. mu\u00df\n\n\n\n\n\n\n\n\nusing System.Drawing.Drawing2D; mit eingebunden werden.\n\n\n\n\n\n\nwidth\n\n\nLinienst\u00e4rke in Punkten\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet einen schwarzen Pfeil\nAddChartArrowLine(\"MyArrow-\" + ProcessingBarIndex, false, 10, 10, 0, 5, Color.Black, DashStyle.Solid, 4);\n\n\n\n\nAddChartArrowUp()\n\n\nBeschreibung\n\n\nAddChartArowUp() zeichnet einen nach oben gerichteten Pfeil:\n\n\n\n\nSiehe auch \nAddChartArrowUp()\n, \nAddChartArrowDown()\n, \nAddChartDiamond()\n, \nAddChartDot()\n, \nAddChartSquare()\n, \nAddChartTriangleUp()\n, \nAddChartTriangleDown()\n.\n\n\nVerwendung\n\n\nAddChartArrowUp(string name, bool autoScale, int barsAgo, double y, Color color)\nAddChartArrowUp(string name, bool autoScale, DateTime time, double y, Color color)\n\n\n\n\nR\u00fcckgabewert\n\n\nA drawing object of the type IArrowUp (interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen\n\n\n\n\n\n\nbarsAgo\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar der Pfeil gezeichnet werden soll\n\n\n\n\n\n\n(0=aktueller Bar)\n\n\n\n\n\n\n\n\ntime\n\n\nDatum/Uhrzeit des Bars, an dem der Pfeil gezeichnet werden soll\n\n\n\n\n\n\ny\n\n\ny-Wert f\u00fcr den Pfeil\n\n\n\n\n\n\ncolor\n\n\nFarbe des Zeichenobjekts\n\n\n\n\n\n\n\n\nExample\n\n\n// zeichnet einen gr\u00fcnen Pfeil am akt. Bar 3 Ticks unter dem Tief\nAddChartArrowUp(\"MyArrow-\"  + ProcessingBarIndex, true, 0, Low[0] - 3*TickSize, Color.Green);\n\n\n\n\nAddChartDiamond()\n\n\nBeschreibung\n\n\nAddChartDiamond() zeichnet einen Diamanten:\n\n\n\n\nSiehe auch \nAddChartArrowUp()\n, \nAddChartArrowDown()\n, \nAddChartDiamond()\n, \nAddChartDot()\n, \nAddChartSquare()\n, \nAddChartTriangleUp()\n, \nAddChartTriangleDown()\n.\n\n\nVerwendung\n\n\nAddChartDiamond(string name, bool autoScale, int barsAgo, double y, Color color)\nAddChartDiamond(string name, bool autoScale, DateTime time, double y, Color color)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ IDiamond (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen\n\n\n\n\n\n\nbarsAgo\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar der Pfeil gezeichnet werden soll\n\n\n\n\n\n\n(0=aktueller Bar)\n\n\n\n\n\n\n\n\ntime\n\n\nDatum/Uhrzeit des Bars, an dem der Pfeil gezeichnet werden soll\n\n\n\n\n\n\ny\n\n\ny-Wert f\u00fcr den Pfeil\n\n\n\n\n\n\ncolor\n\n\nFarbe des Zeichenobjekts\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet einen hellblauen Diamanten am akt. Bar 5 Ticks unter dem Tief\nAddChartDiamond(\"MyDiamond-\" + ProcessingBarIndex, true, 0, Low[0] - 5*TickSize, Color.SteelBlue);\n\n\n\n\nAddChartDot()\n\n\nBeschreibung\n\n\nAddChartDot() zeichnet einen Punkt:\n\n\n\n\nSiehe auch \nAddChartArrowUp()\n, \nAddChartArrowDown()\n, \nAddChartDiamond()\n, \nAddChartDot()\n, \nAddChartSquare()\n, \nAddChartTriangleUp()\n, \nAddChartTriangleDown()\n.\n\n\nVerwendung\n\n\nAddChartDot(string name, bool autoScale, int barsAgo, double y, Color color)\nAddChartDot(string name, bool autoScale, DateTime time, double y, Color color)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ IDot (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen\n\n\n\n\n\n\nbarsAgo\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar der Pfeil gezeichnet werden soll\n\n\n\n\n\n\n(0=aktueller Bar)\n\n\n\n\n\n\n\n\ntime\n\n\nDatum/Uhrzeit des Bars, an dem der Pfeil gezeichnet werden soll\n\n\n\n\n\n\ny\n\n\ny-Wert f\u00fcr den Pfeil\n\n\n\n\n\n\ncolor\n\n\nFarbe des Zeichenobjekts\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet einen orangen Punkt am akt. Bar 5 Ticks \u00fcber dem Hoch\nAddChartDot(\"MyDot-\" + ProcessingBarIndex, true, 0, High[0] + 5*TickSize, Color.Orange);\n\n\n\n\nAddChartEllipse()\n\n\nBeschreibung\n\n\nAddChartEllipse() zeichnet eine Ellipse.\n\n\nVerwendung\n\n\nAddChartEllipse(string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color)\nAddChartEllipse(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, Color areaColor, int areaOpacity)\nAddChartEllipse(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, Color areaColor, int areaOpacity)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ IEllipse (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist\n\n\n\n\n\n\nbarsBackStart\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar die Ellipse beginnen soll (0=aktueller Bar)\n\n\n\n\n\n\nstartTime\n\n\nDatum/Uhrzeit des Bars, an dem die Ellipse beginnen soll\n\n\n\n\n\n\nstartY\n\n\nWert, an dem die Ellipse beginnen soll\n\n\n\n\n\n\nbarsBackEnd\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar die Ellipse enden soll (0=aktueller Bar)\n\n\n\n\n\n\nendTime\n\n\nDatum/Uhrzeit des Bars, an dem die Ellipse enden soll\n\n\n\n\n\n\nendY\n\n\ny-Wert, an dem die Ellipse enden soll\n\n\n\n\n\n\ncolor\n\n\nRandfarbe des Zeichenobjekts\n\n\n\n\n\n\nareaColor\n\n\nF\u00fcllfarbe des Zeichenobjekts\n\n\n\n\n\n\nareaOpacity\n\n\nTransparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 = komplett transparent; 255 = keine Transparenz)\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet eine gelbe Ellipse vom akt. Bar bis 5 Bars zur\u00fcck\nAddChartEllipse(\"MyEllipse-\" + ProcessingBarIndex, true, 5, High[5], 0, Close[0], Color.Yellow, Color.Yellow, 1);\n\n\n\n\nAddChartExtendedLine()\n\n\nBeschreibung\n\n\nAddChartExtendedLine() zeichnet eine Linie mit unendlichem Endpunkt.\n\n\nSiehe auch \nAddChartLine()\n, \nAddChartHorizontalLine()\n, \nAddChartVerticalLine()\n, \nAddChartRay()\n.\n\n\nVerwendung\n\n\nAddChartExtendedLine(string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color)\nAddChartExtendedLine(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, DashStyle dashStyle, int width)\nAddChartExtendedLine(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, DashStyle dashStyle, int width)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ IExtendedLine (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist\n\n\n\n\n\n\nbarsBackStart\n\n\nAnzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den Startpunkt\n\n\n\n\n\n\nstartTime\n\n\nDatum/Uhrzeit f\u00fcr den Startpunkt\n\n\n\n\n\n\nstartY\n\n\ny-Wert f\u00fcr den Startpunkt\n\n\n\n\n\n\nbarsBackEnd\n\n\nAnzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den zweiten Punkt (Einen Endpunkt gibt es bei diesem Zeichenobjekt nicht\n\n\n\n\n\n\nendTime\n\n\nDatum/Uhrzeit f\u00fcr den Endpunkt\n\n\n\n\n\n\nendY\n\n\ny-Wert f\u00fcr den Endpunkt\n\n\n\n\n\n\ncolor\n\n\nFarbe des Zeichenobjekts\n\n\n\n\n\n\ndashStyle\n\n\nLinienart\n\n\n\n\n\n\n\n\nDashStyle.Dash\n\n\n\n\n\n\n\n\nDashStyle.DashDot\n\n\n\n\n\n\n\n\nDashStyle.DashDotDot\n\n\n\n\n\n\n\n\nDashStyle.Dot\n\n\n\n\n\n\n\n\nDashStyle.Solid\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggf. mu\u00df\n\n\n\n\n\n\n\n\nusing System.Drawing.Drawing2D;  mit eingebunden werden.\n\n\n\n\n\n\nwidth\n\n\nLinienst\u00e4rke in Punkten\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet eine Linie ohne Endpunkt\nAddChartExtendedLine(\"MyExt.LevelLine-\" + ProcessingBarIndex, false, 10, Close[10], 0, Close[0], Color.Black, DashStyle.Solid, 1);\n\n\n\n\nAddChartFibonacciCircle()\n\n\nBeschreibung\n\n\nAddChartFibonacciCircle() zeichnet Fibonacci-Kreise.\n\n\nVerwendung\n\n\nAddChartFibonacciCircle(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY)\nAddChartFibonacciCircle(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ IFibonacciCircle (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist\n\n\n\n\n\n\nbarsBackStart\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci-Kreise beginnen sollen.\n\n\n\n\n\n\nstartTime\n\n\nDatum/Uhrzeit des Bars, an dem die Fibonacci-Kreise beginnen sollen\n\n\n\n\n\n\nstartY\n\n\ny-Wert, an dem die Fibonacci-Kreise beginnen sollen\n\n\n\n\n\n\nbarsBackEnd\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci-Kreise enden sollen (0=aktueller Bar)\n\n\n\n\n\n\nendTime\n\n\nDatum/Uhrzeit des Bars, an dem die Fibonacci-Kreise enden sollen\n\n\n\n\n\n\nendY\n\n\ny-Wert, an dem die Fibonacci-Kreise enden sollen\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet Fibonacci-Kreise\nAddChartFibonacciCircle(\"MyFibCircle-\"  + ProcessingBarIndex, true, 5, Low[5], 0, High[0]);\n\n\n\n\nAddChartFibonacciExtensions()\n\n\nBeschreibung\n\n\nAddChartFibonacciExtensions() zeichnet Fibonacci Extensions\n\n\nVerwendung\n\n\nAddChartFibonacciExtensions(string name, bool autoScale, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, int start3BarsAgo, double start3Y)\nAddChartFibonacciExtensions(string name, bool autoScale, DateTime start1Time, double start1Y, DateTime start2Time, double start2Y, DateTime start3Time, double start3Y)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ IFibonacciExtensions (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist.\n\n\n\n\n\n\nstart1BarsAgo\n\n\nAnzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt1 (x-Achse)\n\n\n\n\n\n\nstart1Time\n\n\nDatum/Zeit f\u00fcr Ankerpunkt1 (x-Achse)\n\n\n\n\n\n\nstart1Y\n\n\ny-Wert f\u00fcr Ankerpunkt1\n\n\n\n\n\n\nstart2BarsAgo\n\n\nAnzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt2 (x-Achse)\n\n\n\n\n\n\nstart2Time\n\n\nDatum/Zeit f\u00fcr Ankerpunkt2(x-Achse)\n\n\n\n\n\n\nstart2Y\n\n\ny-Wert f\u00fcr Ankerpunkt2\n\n\n\n\n\n\nstart3BarsAgo\n\n\nAnzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt3 (x-Achse)\n\n\n\n\n\n\nstart3Time\n\n\nDatum/Zeit f\u00fcr Ankerpunk3 (x-Achse)\n\n\n\n\n\n\nstart3Y\n\n\ny-Wert f\u00fcr Ankerpunkt3\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet FibonacciExtensions\nAddChartFibonacciExtensions(\"MyFibExt-\"  + ProcessingBarIndex, true, 4, Low[4], 3, High[3], 1, Low[1]);\n\n\n\n\nAddChartFibonacciProjections()\n\n\nBeschreibung\n\n\nDraw Fibonacci Projections () zeichnet Fibonacci Projections.\n\n\nVerwendung\n\n\nAddChartFibonacciProjections(string name, bool autoScale, DateTime start1Time, double start1Y,DateTime start2Time, double start2Y, DateTime start3Time, double start3Y)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ IFibonacciProjections (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist.\n\n\n\n\n\n\nstart1Time\n\n\nDatum/Zeit f\u00fcr Ankerpunkt1 (x-Achse)\n\n\n\n\n\n\nstart1Y\n\n\ny-Wert f\u00fcr Ankerpunkt1\n\n\n\n\n\n\nstart2Time\n\n\nDatum/Zeit f\u00fcr Ankerpunkt2(x-Achse)\n\n\n\n\n\n\nstart2Y\n\n\ny-Wert f\u00fcr Ankerpunkt2\n\n\n\n\n\n\nstart3Time\n\n\nDatum/Zeit f\u00fcr Ankerpunk3 (x-Achse)\n\n\n\n\n\n\nstart3Y\n\n\ny-Wert f\u00fcr Ankerpunkt3\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet FibonacciProjections\nAddChartFibonacciProjections(\"MyFibPro-\"  + ProcessingBarIndex, true, Low[4], 3, High[3], 1, Low[1], 2);\n\n\n\n\n\nAddChartFibonacciRetracements()\n\n\nBeschreibung\n\n\nAddChartFibonacciRetracements() dzeichnet Fibonacci Retracements.\n\n\nVerwendung\n\n\nAddChartFibonacciRetracements(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY)\nAddChartFibonacciRetracements(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY)\n\n\n\n\nR\u00fcckgabewert\n\n\nA drawing object of the type IFibonacciRetracements (interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist\n\n\n\n\n\n\nbarsBackStart\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci Retracements beginnen sollen.\n\n\n\n\n\n\nstartTime\n\n\nDatum/Uhrzeit des Bars, an dem die Fibonacci Retracements beginnen sollen\n\n\n\n\n\n\nstartY\n\n\ny-Wert, an dem die Fibonacci Retracements beginnen sollen\n\n\n\n\n\n\nbarsBackEnd\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci Retracements enden sollen (0=aktueller Bar)\n\n\n\n\n\n\nendTime\n\n\nDatum/Uhrzeit des Bars, an dem die Fibonacci Retracements enden sollen\n\n\n\n\n\n\nendY\n\n\ny-Wert, an dem die Fibonacci Retracements enden sollen\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet Fibonnaci Retracements\nAddChartFibonacciRetracements(\"MyFibRet-\"  + ProcessingBarIndex, true, 10, Low[10], 0, High[0]);\n\n\n\n\nAddChartFibonacciTimeExtensions()\n\n\nBeschreibung\n\n\nAddChartFibonacciTimeExtensions() zeichnet Fibonacci Retracements.\n\n\nVerwendung\n\n\nAddChartFibonacciTimeExtensions(string name, int barsBackStart, double startY, int barsBackEnd, double endY)\nAddChartFibonacciTimeExtensions(string name, DateTime startTime, double startY, DateTime endTime, double endY)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ IFibonacciTimeExtensions (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nbarsBackStart\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci TimeExtensions beginnen sollen.\n\n\n\n\n\n\nstartTime\n\n\nDatum/Uhrzeit des Bars, an dem die Fibonacci TimeExtensions beginnen sollen\n\n\n\n\n\n\nstartY\n\n\ny-Wert, an dem die Fibonacci-Kreise beginnen sollen\n\n\n\n\n\n\nbarsBackEnd\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci TimeExtensions enden sollen (0=aktueller Bar)\n\n\n\n\n\n\nendTime\n\n\nDatum/Uhrzeit des Bars, an dem die Fibonacci TimeExtensions enden sollen\n\n\n\n\n\n\nendY\n\n\ny-Wert, an dem die Fibonacci TimeExtensions enden sollen\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet Fibonacci TimeExtensions\nAddChartFibonacciTimeExtensions(\"MyFibTimeExt-\" + ProcessingBarIndex, 10, Low[10], 0, High[0]);\n\n\n\n\nAddChartGannFan()\n\n\nBeschreibung\n\n\nAddChartGannFan() zeichnet Fibonacci Retracements.\n\n\nVerwendung\n\n\nAddChartGannFan(string name, bool autoScale, int barsAgo, double y)\nAddChartGannFan(string name, bool autoScale, DateTime time, double y)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ IGannFan (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist\n\n\n\n\n\n\nbarsAgo\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar der GannFan gezeichnet werden soll\n\n\n\n\n\n\ntime\n\n\nDatum/Uhrzeit des Bars, an dem der GannFan gezeichnet werden soll\n\n\n\n\n\n\ny\n\n\ny-Wert, an dem der GannFan gezeichnet werden soll\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet einen Gann Fan am Tief des Bars von vor 10 Perioden\nAddChartGannFan(\"MyGannFan-\" + ProcessingBarIndex, true, 10, Low[10]);\n\n\n\n\nAddChartHorizontalLine()\n\n\nBeschreibung\n\n\nAddChartHorizontalLine() zeichnet eine horizontale Linie in den Chart.\n\n\nSiehe auch \nAddChartLine()\n, \nAddChartVerticalLine()\n, \nAddChartExtendedLine()\n, \nAddChartRay()\n.\n\n\nVerwendung\n\n\nAddChartHorizontalLine(string name, double y, Color color)\nAddChartHorizontalLine(string name, bool autoScale, double y, Color color, DashStyle dashStyle, int width)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ IHorizontalLine (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist\n\n\n\n\n\n\ny\n\n\nein beliebiger double-Wert\n\n\n\n\n\n\ncolor\n\n\nLinienfarbe\n\n\n\n\n\n\ndashStyle\n\n\nLinienart\n\n\n\n\n\n\n\n\nDashStyle.Dash\n\n\n\n\n\n\n\n\nDashStyle.DashDot\n\n\n\n\n\n\n\n\nDashStyle.DashDotDot\n\n\n\n\n\n\n\n\nDashStyle.Dot\n\n\n\n\n\n\n\n\nDashStyle.Solid\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggf. mu\u00df\n\n\n\n\n\n\n\n\nusing System.Drawing.Drawing2D; mit eingebunden werden.\n\n\n\n\n\n\nwidth\n\n\nLinienst\u00e4rke\n\n\n\n\n\n\n\n\nBeispiele\n\n\n// zeichnet eine horizontale Linie bei y=10\nAddChartHorizontalLine(\"MyHorizontalLine-\" + ProcessingBarIndex, 10, Color.Black);\n\n\n\n\nAddChartLine()\n\n\nBeschreibung\n\n\nAddChartLine()  zeichnet eine (Trend-) Linie.\n\n\nSiehe auch  \nAddChartHorizontalLine()\n, \nAddChartVerticalLine()\n, \nAddChartExtendedLine()\n, \nAddChartRay()\n.\n\n\nVerwendung\n\n\nAddChartLine(string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color)\nAddChartLine(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, DashStyle dashStyle, int width)\nAddChartLine(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, DashStyle dashStyle, int width)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ ITrendLine (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist\n\n\n\n\n\n\nbarsBackStart\n\n\nAnzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den Startpunkt\n\n\n\n\n\n\nstartTime\n\n\nDatum/Uhrzeit f\u00fcr den Startpunkt\n\n\n\n\n\n\nstartY\n\n\ny-Wert f\u00fcr den Startpunkt\n\n\n\n\n\n\nbarsBackEnd\n\n\nAnzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den zweiten Punkt (Einen Endpunkt gibt es bei diesem Zeichenobjekt nicht)\n\n\n\n\n\n\nendTime\n\n\nDatum/Uhrzeit f\u00fcr den Endpunkt\n\n\n\n\n\n\nendY\n\n\ny-Wert f\u00fcr den Endpunkt\n\n\n\n\n\n\ncolor\n\n\nFarbe des Zeichenobjekts\n\n\n\n\n\n\ndashStyle\n\n\nLinienart\n\n\n\n\n\n\n\n\nDashStyle.Dash\n\n\n\n\n\n\n\n\nDashStyle.DashDot\n\n\n\n\n\n\n\n\nDashStyle.DashDotDot\n\n\n\n\n\n\n\n\nDashStyle.Dot\n\n\n\n\n\n\n\n\nDashStyle.Solid\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggf. mu\u00df\n\n\n\n\n\n\n\n\nusing System.Drawing.Drawing2D; mit eingebunden werden.\n\n\n\n\n\n\nwidth\n\n\nLinienst\u00e4rke in Punkten\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet eine Linie\nAddChartLine(\"MyLine-\" + ProcessingBarIndex, false, 10, Close[10], 0, Close[0], Color.Black, DashStyle.Solid, 1);\n\n\n\n\nAddChartRay()\n\n\nBeschreibung\n\n\nAddChartRay() zeichnet eine (Trend-) Linie, die zu einer Seite ins Unendliche verl\u00e4ngert wird.\n\n\nSiehe auch \nAddChartLine()\n, \nAddChartHorizontalLine()\n, \nAddChartVerticalLine()\n, \nAddChartExtendedLine()\n.\n\n\nVerwendung\n\n\nAddChartRay(string name, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, Color color)\nAddChartRay(string name, bool autoScale, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, Color color, DashStyle dashStyle, int width)\nAddChartRay(string name, bool autoScale, DateTime start1Time, double start1Y, DateTime start2Time, double start2Y, Color color, DashStyle dashStyle, int width)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ IRay (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist.\n\n\n\n\n\n\nstart1BarsAgo\n\n\nAnzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt1 (x-Achse)\n\n\n\n\n\n\nstart1Time\n\n\nDatum/Zeit f\u00fcr Ankerpunkt1 (x-Achse)\n\n\n\n\n\n\nstart1Y\n\n\ny-Wert f\u00fcr Ankerpunkt1\n\n\n\n\n\n\nstart2BarsAgo\n\n\nAnzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt2 (x-Achse)\n\n\n\n\n\n\nstart2Time\n\n\nDatum/Zeit f\u00fcr Ankerpunkt2(x-Achse)\n\n\n\n\n\n\nstart2Y\n\n\ny-Wert f\u00fcr Ankerpunkt2\n\n\n\n\n\n\ncolor\n\n\nFarbe des Zeichenobjekts\n\n\n\n\n\n\ndashStyle\n\n\nLinienart\n\n\n\n\n\n\n\n\nDashStyle.Dash\n\n\n\n\n\n\n\n\nDashStyle.DashDot\n\n\n\n\n\n\n\n\nDashStyle.DashDotDot\n\n\n\n\n\n\n\n\nDashStyle.Dot\n\n\n\n\n\n\n\n\nDashStyle.Solid\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggf. mu\u00df\n\n\n\n\n\n\n\n\nusing System.Drawing.Drawing2D; mit eingebunden werden.\n\n\n\n\n\n\nwidth\n\n\nLinienst\u00e4rke\n\n\n\n\n\n\n\n\nBeispiele\n\n\n// zeichnet eine Linie vom Bar von vor 10 Perioden \u00fcber den aktuellen Bar (x-Achse)\n// --> Linie wird nach rechts verl\u00e4ngert\n// von y=3 \u00fcber y=7\nAddChartRay(\"MyRay-\" + ProcessingBarIndex, 10, 3, 0, 7, Color.Green);\n// zeichnet eine Linie vom akt. Bar \u00fcber den Bar von vor 10 Perioden\n// --> Linie wird nach links verl\u00e4ngert\n// von y=3 \u00fcber y=7\nAddChartRay(\"MyRay-\" + ProcessingBarIndex, 0, 3, 10, 7, Color.Green);\n\n\n\n\nAddChartRectangle()\n\n\nBeschreibung\n\n\nAddChartRectangle() zeichnet ein Rechteck.\n\n\nVerwendung\n\n\nAddChartRectangle(string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color)\nAddChartRectangle(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, Color areaColor, int areaOpacity)\nAddChartRectangle(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, Color areaColor, int areaOpacity)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ IRectangle (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist.\n\n\n\n\n\n\nbarsBackStart\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar sich die eine Ecke des Rechtecks befinden soll (0=aktueller Bar)\n\n\n\n\n\n\nstartTime\n\n\nDatum/Uhrzeit des Bars, an dem sich die eine Ecke des Rechtecks befinden soll\n\n\n\n\n\n\nstartY\n\n\ny-Wert, an dem die sich die eine Ecke des Rechtecks befinden soll\n\n\n\n\n\n\nbarsBackEnd\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar sich die zweite Ecke des Rechtecks befinden soll (0=aktueller Bar)\n\n\n\n\n\n\nendTime\n\n\nDatum/Uhrzeit des Bars, an dem sich die zweite Ecke des Rechtecks befinden soll\n\n\n\n\n\n\nendY\n\n\ny-Wert, an dem die sich die zweite Ecke des Rechtecks befinden soll\n\n\n\n\n\n\ncolor\n\n\nFarbe des Zeichenobjekts\n\n\n\n\n\n\nareaColor\n\n\nF\u00fcllfarbe des Zeichenobjekts\n\n\n\n\n\n\nareaOpacity\n\n\nTransparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 =  komplett transparent, 255 = keine Transparenz)\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet ein gr\u00fcnes Rechteck vom Tief von vor 10 Perioden zum Hoch von vor 5 Perioden\n// mit der F\u00fcllfarbe PaleGreen und einer Transparenz von 2\nAddChartRectangle(\"MyRect-\" + ProcessingBarIndex, true, 10, Low[10], 5, High[5], Color.PaleGreen, Color.PaleGreen, 2);\n\n\n\n\nAddChartRegion()\n\n\nBeschreibung\n\n\nAddChartRegion() DrawRegion() f\u00fcllt einen bestimmten Bereich auf einem Chart aus.\n\n\nVerwendung\n\n\nAddChartRegion(string name, int barsBackStart, int barsBackEnd, IDataSeries series, double y, Color outlineColor, Color areaColor, int areaOpacity)\nAddChartRegion(string name, int barsBackStart, int barsBackEnd, IDataSeries series1, IDataSeries series2, Color outlineColor, Color areaColor, int areaOpacity)\nAddChartRegion(string name, DateTime startTime, DateTime endTime, IDataSeries series, double y, Color outlineColor, Color areaColor, int areaOpacity)\nAddChartRegion(string name, DateTime startTime, DateTime endTime, IDataSeries series1, IDataSeries series2, Color outlineColor, Color areaColor, int areaOpacity)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ IRegion (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nbarsBackStart\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar sich die eine Ecke des Rechtecks befinden soll (0=aktueller Bar)\n\n\n\n\n\n\nstartTime\n\n\nDatum/Uhrzeit des Bars, an dem sich die eine Ecke des Rechtecks befinden soll\n\n\n\n\n\n\nbarsBackEnd\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar sich die zweite Ecke des Rechtecks befinden soll (0=aktueller Bar)\n\n\n\n\n\n\nendTime\n\n\nDatum/Uhrzeit des Bars, an dem sich die zweite Ecke des Rechtecks befinden soll\n\n\n\n\n\n\nseries1, series2\n\n\njedes Datenserie, wie z.B. ein Indikator, Close, High, Low usw.  Der jeweilige Wert der Datenserie f\u00fcr den aktuellen Bar wird als y-Wert herangezogen\n\n\n\n\n\n\ny\n\n\nein beliebiger double-Wert\n\n\n\n\n\n\noutlineColor\n\n\nFarbe f\u00fcr die Umrandung des Bereichs\n\n\n\n\n\n\nareaColor\n\n\nF\u00fcllfarbe des Zeichenobjekts\n\n\n\n\n\n\nareaOpacity\n\n\nTransparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 =  komplett transparent, 255 = keine Transparenz)\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// f\u00fcllt den Bereich zwischen dem oberen und dem unteren Bollinger Band\nAddChartRegion(\"MyRegion\", ProcessingBarIndex, 0, Bollinger(2, 14).Upper, Bollinger(2, 14).Lower, Color.Empty, Color.Lime, 100);\n\n\n\n\nAddChartRegressionChannel()\n\n\nBeschreibung\n\n\nAddChartRegressionChannel()zeichnet einen Regressionskanal.\n\n\nVerwendung\n\n\nAddChartRegressionChannel(string name, int barsBackStart, int barsBackEnd, Color color)\nAddChartRegressionChannel(string name, bool autoScale, int barsBackStart, int barsBackEnd, Color upperColor, DashStyle upperDashStyle, int upperWidth, Color middleColor, DashStyle middleDashStyle, int middleWidth, Color lowerColor, DashStyle lowerDashStyle, int lowerWidth)\nAddChartRegressionChannel(string name, bool autoScale, DateTime startTime, DateTime endTime, Color upperColor, DashStyle upperDashStyle, int upperWidth, Color middleColor, DashStyle middleDashStyle, int middleWidth, Color lowerColor, DashStyle lowerDashStyle, int lowerWidth)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ IRegressionChannel (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist.\n\n\n\n\n\n\nbarsBackStart\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar der Regressionskanal beginnen soll (0=aktueller Bar)\n\n\n\n\n\n\nstartTime\n\n\nDatum/Uhrzeit des Bars, an dem der Regressionskanal beginnen soll\n\n\n\n\n\n\nbarsBackEnd\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar der Regressionskanal enden soll (0=aktueller Bar)\n\n\n\n\n\n\nendTime\n\n\nDatum/Uhrzeit des Bars, an dem der Regressionskanal enden soll\n\n\n\n\n\n\ncolor\n\n\nFarbe des Zeichenobjekts\n\n\n\n\n\n\nupperDashStyle, middleDashStyle, lowerDashStyle\n\n\nLinienart\n\n\n\n\n\n\n\n\nDashStyle.Dash\n\n\n\n\n\n\n\n\nDashStyle.DashDot\n\n\n\n\n\n\n\n\nDashStyle.DashDotDot\n\n\n\n\n\n\n\n\nDashStyle.Dot\n\n\n\n\n\n\n\n\nDashStyle.Solid\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggf. mu\u00df:\n\n\n\n\n\n\n\n\nusing System.Drawing.Drawing2D; mit eingebunden werden.\n\n\n\n\n\n\nupperColor,  middleColor,    lowerColor\n\n\njeweilige Linienfarbe\n\n\n\n\n\n\nupperWidth,   middleWidth,  lowerWidth\n\n\njeweilige Linienst\u00e4rke\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet einen Regressionskanal vom Tief des Bars von vor 10 Tagen\n// zum Hoch des Bars von vor 5 Tagen\nAddChartRegressionChannel(\"MyRegChannel-\" + ProcessingBarIndex, 10, 0, Color.Black);\n\n\n\n\nAddChartSquare()\n\n\nBeschreibung\n\n\nAddChartSquare()  zeichnet ein Quadrat:\n\n\n\n\nSiehe auch \nAddChartArrowUp()\n, \nAddChartArrowDown()\n, \nAddChartDiamond()\n, \nAddChartDot()\n, \nAddChartTriangleUp()\n, \nAddChartTriangleDown()\n.\n\n\nVerwendung\n\n\nDrawSqare(string name, bool autoScale, int barsAgo, double y, Color color)\nDrawSqare(string name, bool autoScale, DateTime time, double y, Color color)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ ISquare (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen\n\n\n\n\n\n\nbarsAgo\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar das Quadrat gezeichnet werden soll (0=aktueller Bar)\n\n\n\n\n\n\nTime\n\n\nDatum/Uhrzeit des Bars, an dem das Quadrat gezeichnet werden soll\n\n\n\n\n\n\nY\n\n\ny-Wert, an dem das Quadrat gezeichnet werden soll\n\n\n\n\n\n\ncolor\n\n\nFarbe des Zeichenobjekts\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet ein durnkelrotes Quadrat am akt. Bar 10 Ticks \u00fcber dem Hoch\nAddChartSquare(\"MySquare\", true, 0, High[0] + 10*TickSize, Color.DarkRed);\n\n\n\n\nAddChartText()\n\n\nBeschreibung\n\n\nAddChartText() schreibt einen beliebigen Text auf den Chart.\n\n\nSiehe auch \nAddChartTextFixed()\n.\n\n\nVerwendung\n\n\nAddChartText(string tag, string text, int barsAgo, double y, Color color);\nAddChartText(string tag, string text, TextPosition textPosition, Color textColor, Font font, Color outlineColor, Color areaColor, int areaOpacity);\nAddChartText(string tag, string text, int barsAgo, double y, Color textColor, Font font, StringAlignment alignment, Color outlineColor, Color areaColor, int areaOpacity);\nAddChartText(string tag, bool autoScale, string text, int barsAgo, double y, int yPixelOffset, Color textColor, Font font, StringAlignment alignment, Color outlineColor, Color areaColor, int areaOpacity);\nAddChartText(string tag, bool autoScale, string text, DateTime x, double y, int yPixelOffset, Color textColor, Font font, StringAlignment alignment, Color outlineColor, Color areaColor, int areaOpacity);\nAddChartText(string tag, bool autoScale, string text, DateTime x, double y, int pixelOffset, Color textColor, Font font, StringAlignment alignment, HorizontalAlignment hAlign, VerticalAlignment vAlign, Color outlineColor, Color areaColor);\nAddChartText(string tag, bool autoScale, string text, int barsAgo, double y, int yPixelOffset, Color textColor, Font font, StringAlignment alignment, HorizontalAlignment hAlign, VerticalAlignment vAlign, Color outlineColor, Color areaColor, int areaOpacity);\nAddChartText(string tag, bool autoScale, string text, DateTime x, double y, int pixelOffset, Color textColor, Font font, StringAlignment alignment, HorizontalAlignment hAlign, VerticalAlignment vAlign, Color outlineColor, Color areaColor);   \n\n\n\n\nwichtiger Hinweis:\n\nBei Verwendung der Signaturen, die HorizontalAlignment und VerticalAlignment enthalten, sind die folgenden beiden Zeilen dem Programmcode hinzuzuf\u00fcgen:\n\n\nusing System.Windows.Forms;\nusing System.Windows.Forms.VisualStyles;\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ IText (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist\n\n\n\n\n\n\nText\n\n\nDer auszugebende Text (Der Text darf auch den Zeilenumbruch \"\\n\" enthalten.)\n\n\n\n\n\n\nbarsAgo\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar der Text ausgegeben werden soll (0=aktueller Bar)\n\n\n\n\n\n\n(Welcher Bar den Index 0 hat, ist abh\u00e4ngig von CalculateOnBarClose.)\n\n\n\n\n\n\n\n\nTime\n\n\nDatum/Uhrzeit des Bars, an dem der Text beginnen soll\n\n\n\n\n\n\nY\n\n\ny-Wert, an dem der Text geschrieben werden soll\n\n\n\n\n\n\nyPixelOffset\n\n\nvertikale Verschiebung des Textes. Positive Werte verschieben den Text nach oben, negative Werte nach unten.\n\n\n\n\n\n\ntextColor\n\n\nTextfarbe\n\n\n\n\n\n\nFont\n\n\nSchriftart f\u00fcr den Text\n\n\n\n\n\n\nAlignment\n\n\nm\u00f6gliche Werte sind: StringAlignment.Center, StringAlignment.Far, StringAlignment.Near\n\n\n\n\n\n\nHAlign\n\n\nm\u00f6gliche Werte sind: HorizontalAlign.Left, HorizontalAlign.Center, HorizontalAlign.Right\n\n\n\n\n\n\nVAlign\n\n\nm\u00f6gliche Werte sind: VerticalAlign.Top, VerticalAlign.Center, VerticalAlign.Bottom\n\n\n\n\n\n\noutlineColor\n\n\nFarbe des Rahmens um den Text (F\u00fcr keinen Rahmen Color.Empty verwenden)\n\n\n\n\n\n\nareaColor\n\n\nF\u00fcllfarbe der Textbox (F\u00fcr keine F\u00fcllung Color.Empty verwenden)\n\n\n\n\n\n\nareaOpacity\n\n\nTransparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 =  komplett transparent, 255 = keine Transparenz)\n\n\n\n\n\n\n\n\nBeispiele\n\n\n// schreibt einen Text bei y=3.0 \nAddChartText(\"MyText-\" + ProcessingBarIndex, \"This is sample text.\", 10, 3, Color.Black);\n// schreibt einen roten Text in Schriftgr\u00f6\u00dfe Arial 7\nAddChartText(\"MyText-\" + ProcessingBarIndex, false, \"This is sample text.\", Time[0], Close[0]+50*TickSize, 0,\nColor.Red, new Font(\"Arial\",7), StringAlignment.Center, Color.Blue, Color.DarkOliveGreen, 10);\n\n\n\n\nNachstehende Anweisung f\u00fchrt zu diesem Ergebnis:\n\n\n\n\nAddChartText(\"MyTag\",true,\"Text\",1, // barsAgo\nHigh[1], // y\n10, // yPixelOffset\nColor.Blue, // Text color\nnew Font(\"Arial\", 10, FontStyle.Bold),\nStringAlignment.Center,\nHorizontalAlignment.Center,\nVerticalAlignment.Bottom,\nColor.Red, // Outline color\nColor.Yellow, // Fill color\n100); // Opacity\n\n\n\n\nAddChartTextFixed()\n\n\nBeschreibung\n\n\nAddChartTextFixed() schreibt Text an eine von 5 m\u00f6glichen festen Stellen im Chart.\n\n\nSiehe auch \nAddChartText()\n.\n\n\nVerwendung\n\n\nAddChartTextFixed(string tag, string text, TextPosition textPosition);\nAddChartTextFixed(string tag, string text, TextPosition textPosition, Color textColor, Font font, Color outlineColor, Color areaColor);\nAddChartTextFixed(string tag, string text, TextPosition textPosition, Color textColor, Font font, Color outlineColor, Color areaColor, int areaOpacity);\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ ITextFixed (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\ntext\n\n\nThe text to be displayed\n\n\n\n\n\n\nTextPosition\n\n\nTextPosition.BottomLeft, TextPosition.BottomRight, TextPosition.Center, TextPosition.TopLeft, TextPosition.TopRight\n\n\n\n\n\n\ntextColor\n\n\nTextfarbe\n\n\n\n\n\n\nfont\n\n\nSchriftart f\u00fcr den Text\n\n\n\n\n\n\noutlineColor\n\n\nFarbe des Rahmens um den Text (F\u00fcr keinen Rahmen Color.Empty verwenden)\n\n\n\n\n\n\nareaColor\n\n\nF\u00fcllfarbe der Textbox (F\u00fcr keine F\u00fcllung Color.Empty verwenden)\n\n\n\n\n\n\nareaOpacity\n\n\nTransparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 =  komplett transparent, 255 = keine Transparenz)\n\n\n\n\n\n\n\n\nBeispiele\n\n\n// schreibt einen Text in die Mitte des Charts\nAddChartTextFixed(\"MyText-\" + ProcessingBarIndex, \"\"Das ist ein Beispieltext.\", TextPosition.Center);\n// schreibt einen roten Text mit einem blauen Rand in die Mitte des Charts\nAddChartTextFixed(\"MyText-\" + ProcessingBarIndex, \"Das ist ein Beispieltext.\", TextPosition.Center, Color.Red, new Font(\"Arial\",35), Color.Blue, Color.Empty, 10);\n\n\n\n\nAddChartTrendChannel()\n\n\nBeschreibung\n\n\nAddChartTrendChannel() zeichnet einen Trendkanal.\n\n\nVerwendung\n\n\nAddChartTrendChannel(string name, bool autoScale, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, int start3BarsAgo, double start3Y)\nAddChartTrendChannel(string name, bool autoScale, DateTime start1Time, double start1Y, DateTime start2Time, double start2Y, DateTime start3Time, double start3Y)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ ITrendChannel (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nA clearly identifiable name for the drawing object\n\n\n\n\n\n\nautoScale\n\n\nAdjusts the scale of the y-axis so that drawing objects can be viewed in their entirety\n\n\n\n\n\n\nstart1BarsAgo\n\n\nNumber of bars ago for start point 1 (x-axis)\n\n\n\n\n\n\nstart1Time\n\n\nDate/time for start point 1 (x-axis)\n\n\n\n\n\n\nstart1Y\n\n\ny-value for start point 1\n\n\n\n\n\n\nstart2BarsAgo\n\n\nNumber of bars ago for start point 2 (x-axis)\n\n\n\n\n\n\nstart2Time\n\n\nDate/time for start point 2 (x-axis)\n\n\n\n\n\n\nstart2Y\n\n\ny-value for start point 2\n\n\n\n\n\n\nstart3BarsAgo\n\n\nNumber of bars ago for start point 3 (x-axis)\n\n\n\n\n\n\nstart3Time\n\n\nDate/time for start point 3 (x-axis)\n\n\n\n\n\n\nstart3Y\n\n\ny-value for start point 3\n\n\n\n\n\n\n\n\nBeispiele\n\n\n// zeichnet einen Trendkanal\nAddChartTrendChannel(\"MyTrendChannel-\" + ProcessingBarIndex, true, 10, Low[10], 0, High[0], 10, High[10] + 5 * TickSize);\n\n\n\n\nAddChartTriangle()\n\n\nBeschreibung\n\n\nAddChartTriangle() zeichnet ein Dreieck.\n\n\nVerwendung\n\n\nAddChartTriangle(string name, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, int start3BarsAgo, double start3Y, Color color)\nAddChartTriangle(string name, bool autoScale, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, int start3BarsAgo, double start3Y, Color color, Color areaColor, int areaOpacity)\nAddChartTriangle(string name, bool autoScale, DateTime start1Time, double start1Y, DateTime start2Time, double start2Y, DateTime start3Time, double start3Y, Color color, Color areaColor, int areaOpacity)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ ITriangle (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist\n\n\n\n\n\n\nstart1BarsAgo\n\n\nAnzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt1 (x-Achse)\n\n\n\n\n\n\nstart1Time\n\n\nDatum/Zeit f\u00fcr Ankerpunkt1 (x-Achse)\n\n\n\n\n\n\nstart1Y\n\n\ny-Wert f\u00fcr Ankerpunkt1\n\n\n\n\n\n\nstart2BarsAgo\n\n\nAnzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt2 (x-Achse)\n\n\n\n\n\n\nstart2Time\n\n\nDatum/Zeit f\u00fcr Ankerpunkt2 (x-Achse)\n\n\n\n\n\n\nstart2Y\n\n\ny-Wert f\u00fcr Ankerpunkt2\n\n\n\n\n\n\nstart3BarsAgo\n\n\nAnzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt3 (x-Achse)\n\n\n\n\n\n\nstart3Time\n\n\nDatum/Zeit f\u00fcr Ankerpunkt3 (x-Achse)\n\n\n\n\n\n\nstart3Y\n\n\ny-Wert f\u00fcr Ankerpunkt3\n\n\n\n\n\n\ncolor\n\n\nFarbe des Zeichenobjekts\n\n\n\n\n\n\nareaColor\n\n\nF\u00fcllen Sie Farbe des Zeichnungsobjekt\n\n\n\n\n\n\nareaOpacity\n\n\nTransparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 =  komplett transparent, 255 = keine Transparenz)\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet ein gr\u00fcnes Dreieck\nAddChartTriangle(\"tag1\", 4, Low[4], 3, High[3], 1, Low[1], Color.Green);\n\n\n\n\nAddChartTriangleDown()\n\n\nBeschreibung\n\n\nAddChartTriangleDown() zeichnet ein kleines abw\u00e4rtsgerichtetes Dreieck.\n\n\n\n\nSiehe auch \nAddChartArrowUp()\n, \nAddChartArrowDown()\n, \nAddChartDiamond()\n, \nAddChartDot()\n, \nAddChartSquare()\n, \nAddChartTriangleUp()\n.\n\n\nVerwendung\n\n\nAddChartTriangleDown(string name, bool autoScale, int barsAgo, double y, Color color)\nAddChartTriangleDown(string name, bool autoScale, DateTime time, double y, Color color)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ ITriangleDown (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist\n\n\n\n\n\n\nbarsAgo\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar das Dreieck gezeichnet werden soll\n\n\n\n\n\n\ntime\n\n\nDatum/Uhrzeit des Bars, an dem das Dreieck gezeichnet werden soll\n\n\n\n\n\n\ny\n\n\ny-Wert, an dem das Dreieck gezeichnet werden\n\n\n\n\n\n\ncolor\n\n\nFarbe des Zeichenobjekts\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet ein kleines rotes Dreieck am akt. Bar 10 Ticks \u00fcber dem Hoch\nAddChartTriangleDown(\"MyTriangleDown-\" + ProcessingBarIndex, true, 0, High[0] + 10*TickSize, Color.Red);\n\n\n\n\nAddChartTriangleUp()\n\n\nBeschreibung\n\n\nAddChartTriangleUp() zeichnet ein kleines aufw\u00e4rtsgerichtetes Dreieck.\n\n\n\n\nSiehe auch \nAddChartArrowUp()\n, \nAddChartArrowDown()\n, \nAddChartDiamond()\n, \nAddChartDot()\n, \nAddChartSquare()\n, \nAddChartTriangleDown()\n.\n\n\nVerwendung\n\n\nAddChartTriangleUp(string name, bool autoScale, int barsAgo, double y, Color color)\nAddChartTriangleUp(string name, bool autoScale, DateTime time, double y, Color color)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ ITriangleUp (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nautoScale\n\n\nSkalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist\n\n\n\n\n\n\nbarsAgo\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar das Dreieck gezeichnet werden soll\n\n\n\n\n\n\ntime\n\n\nDatum/Uhrzeit des Bars, an dem das Dreieck gezeichnet werden soll\n\n\n\n\n\n\ny\n\n\ny-Wert, an dem das Dreieck gezeichnet werden\n\n\n\n\n\n\ncolor\n\n\nFarbe des Zeichenobjekts\n\n\n\n\n\n\n\n\nBeispiel\n\n\n// zeichnet ein kleines hellgr\u00fcnes Dreieck am akt. Bar 10 Ticks unter dem Tief\nAddChartTriangleUp(\"MyTriangleUp-\" + ProcessingBarIndex, true, 0, Low[0] - 10*TickSize, Color.LightGreen);\n\n\n\n\nAddChartVerticalLine()\n\n\nBeschreibung\n\n\nAddChartVerticalLine() zeichnet eine vertikale Linie in den Chart.\n\n\nSiehe auch \nAddChartLine()\n, \nAddChartHorizontalLine()\n, \nAddChartExtendedLine()\n, \nAddChartRay()\n.\n\n\nVerwendung\n\n\nAddChartVerticalLine(string name, int barsAgo, Color color)\nAddChartVerticalLine(string name, int barsAgo, Color color, DashStyle dashStyle, int width)\nAddChartVerticalLine(string name, DateTime time, Color color, DashStyle dashStyle, int width)\n\n\n\n\nR\u00fcckgabewert\n\n\nEin Zeichenobjekt vom Typ IVerticalLine (Interface)\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\n\n\nDer Name eines Zeichenobjekts zur eindeutigen Identifizierung\n\n\n\n\n\n\nbarsAgo\n\n\nGibt an, an welchem zur\u00fcckliegenden Bar die vertikale Linie gezeichnet werden soll (0=aktueller Bar)\n\n\n\n\n\n\ntime\n\n\nDatum/Uhrzeit des Bars, an dem die vertikale Linie gezeichnet werden soll\n\n\n\n\n\n\ncolor\n\n\nLinienfarbe\n\n\n\n\n\n\ndashStyle\n\n\nLinienart\n\n\n\n\n\n\n\n\nDashStyle.Dash\n\n\n\n\n\n\n\n\nDashStyle.DashDot\n\n\n\n\n\n\n\n\nDashStyle.DashDotDot\n\n\n\n\n\n\n\n\nDashStyle.Dot\n\n\n\n\n\n\n\n\nDashStyle.Solid\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggf. mu\u00df\n\n\n\n\n\n\n\n\nusing System.Drawing.Drawing2D; mit eingebunden werden.\n\n\n\n\n\n\nwidth\n\n\nLinienst\u00e4rke\n\n\n\n\n\n\n\n\nBeispiele\n\n\n// zeichnet eine vertikale Linie am Bar von vor 10 Perioden\nAddChartVerticalLine(\"MyVerticalLine-\" + ProcessingBarIndex, 10, Color.Black);",
            "title": "Zeichenobjekte"
        },
        {
            "location": "/zeichenobjekte/#zeichenobjekte",
            "text": "",
            "title": "Zeichenobjekte"
        },
        {
            "location": "/zeichenobjekte/#addchartandrewspitchfork",
            "text": "",
            "title": "AddChartAndrewsPitchfork()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung",
            "text": "AddChartAndrewsPitchfork() zeichnet ein Andrew's Pitchfork.  Informationen zur Verwendung:\n-    vtad.de \n-    hvolumen-analyse.de \n-    Godmode-Trader.de",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung",
            "text": "AddChartAndrewsPitchfork(string name, bool autoScale, int start1BarsBack, double start1Y, int start2BarsBack, double start2Y, int start3BarsBack, double start3Y, Color color, DashStyle dashStyle, int width)\nAddChartAndrewsPitchfork(string name, bool autoScale, DateTime start1Time, double start1Y, DateTime start2Time, double start2Y, DateTime start3Time, double start3Y, Color color, DashStyle dashStyle, int width)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert",
            "text": "A drawing object of the type IAndrewsPitchfork (interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist.    start1BarsBack  Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt1 (x-Achse)    start1Time  Datum/Zeit f\u00fcr Ankerpunkt1 (x-Achse)    start1Y  y-Wert f\u00fcr Ankerpunkt1    start2BarsBack  Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt2 (x-Achse)    start2Time  Datum/Zeit f\u00fcr Ankerpunkt2(x-Achse)    start2Y  y-Wert f\u00fcr Ankerpunkt2    start3BarsBack  Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt3 (x-Achse)    start3Time  Datum/Zeit f\u00fcr Ankerpunk3 (x-Achse)    start3Y  -Wert f\u00fcr Ankerpunkt3    color  Farbe des Zeichenobjekts    dashStyle  Linienart     DashStyle.Dash     DashStyle.DashDot     DashStyle.DashDotDot     DashStyle.Dot     DashStyle.Solid         ggf. mu\u00df     using System.Drawing.Drawing2D; mit eingebunden werden.    width  Linienst\u00e4rke in Punkten",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel",
            "text": "// zeichnet ein Andrew's Pitchfork (\"Mistgabel\")\nAddChartAndrewsPitchfork(\"MyAPF\", true, 4, Low[4], 3, High[3], 1, Low[1], Color.Black, DashStyle.Solid, 2);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addchartarc",
            "text": "",
            "title": "AddChartArc()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_1",
            "text": "AddChartArc() zeichnet einen Kreisbogen.",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_1",
            "text": "AddChartArc(string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color)\nAddChartArc(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, DashStyle dashStyle, int width)\nAddChartArc(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, DashStyle dashStyle, int width)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_1",
            "text": "Ein Zeichenobjekt vom Typ IArc (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_1",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu    barsBackStart  Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den Startpunkt    startTime  Datum/Uhrzeit f\u00fcr den Startpunkt    startY  y-Wert f\u00fcr den Startpunkt    barsBackEnd  Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den Endpunkt    endTime  Datum/Uhrzeit f\u00fcr den Endpunkt    endY  y-Wert f\u00fcr den Endpunkt    color  Farbe des Zeichenobjekts    dashStyle  Linienart     DashStyle.Dash     DashStyle.DashDot     DashStyle.DashDotDot     DashStyle.Dot     DashStyle.Solid         ggf. mu\u00df     using System.Drawing.Drawing2D; mit eingebunden werden.    width  Linienst\u00e4rke in Punkten",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_1",
            "text": "// zeichnet einen blauen Kreisbogen\nAddChartArc(\"MyArc-\" + ProcessingBarIndex, true, 10, 10, 0, 20, Color.Blue, DashStyle.Solid, 3);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addchartarrowdown",
            "text": "",
            "title": "AddChartArrowDown()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_2",
            "text": "AddChartArrowDown()  zeichnet einen nach unten gerichteten Pfeil:   DrawArrowUp(), DrawDiamond(), DrawDot(), DrawSquare(), DrawTriangleUp(),   AddChartArrowUp() ,  AddChartArrowDown() ,  AddChartDiamond() ,  AddChartDot() ,  AddChartSquare() ,  AddChartTriangleUp() ,  AddChartTriangleDown() .",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_2",
            "text": "AddChartArrowDown(string name, bool autoScale, int barsAgo, double y, Color color)\nAddChartArrowDown(string name, bool autoScale, DateTime time, double y, Color color)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_2",
            "text": "A drawing object of the type IArrowDown (interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_2",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen    barsAgo  Gibt an, an welchem zur\u00fcckliegenden Bar der Pfeil gezeichnet werden soll    (0=aktueller Bar)     time  Datum/Uhrzeit des Bars, an dem der Pfeil gezeichnet werden soll    y  y-Wert f\u00fcr den Pfeil    color  Farbe des Zeichenobjekts",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_2",
            "text": "// zeichnet am akt. Bar einen roten Pfeil 3 Ticks \u00fcber dem Hoch\nAddChartArrowDown(\"MyArrow-\" + ProcessingBarIndex, true, 0, High[0] + 3*TickSize, Color.Red);\n// Zeichnet einen roten Pfeil auf einem Dreistufen-Umkehrmuster\nif(High[2] > High[3] && High[1] > High[2] && Close[0] < Open[0])\nAddChartArrowDown(ProcessingBarIndex.ToString(), true, 0, High[0] + 3*TickSize, Color.Red);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addchartarrowline",
            "text": "",
            "title": "AddChartArrowLine()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_3",
            "text": "AddChartArrowLine() zeichnet einen Pfeil.",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_3",
            "text": "AddChartArrowLine (string name,  int  barsBackStart,  double  startY,  int  barsBackEnd,  double  endY, Color color)\n AddChartArrowLine (string name,  bool  autoScale,  int  barsBackStart,  double  startY,  int  barsBackEnd,  double  endY, Color color, DashStyle dashStyle,  int  width)\n AddChartArrowLine (string name,  bool  autoScale, DateTime startTime,  double  startY, DateTime endTime,  double  endY, Color color, DashStyle dashStyle,  int  width)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_3",
            "text": "Ein Zeichenobjekt vom Typ IArrowLine (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_3",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist    barsBackStart  Gibt an, an welchem zur\u00fcckliegenden Bar der Pfeil beginnen soll (0=aktueller Bar)    startTime  Datum/Uhrzeit des Bars, an dem der Pfeil beginnen soll    startY  y-Wert, an dem der Pfeil beginnen soll    barsBackEnd  Gibt an, an welchem zur\u00fcckliegenden Bar der Pfeil enden soll (0=aktueller Bar)    endTime  Datum/Uhrzeit des Bars, an dem der Pfeil enden    endY  y-Wert, an dem der Pfeil enden soll    color  Farbe des Zeichenobjekts    dashStyle  Linienart     DashStyle.Dash     DashStyle.DashDot     DashStyle.DashDotDot     DashStyle.Dot     DashStyle.Solid         ggf. mu\u00df     using System.Drawing.Drawing2D; mit eingebunden werden.    width  Linienst\u00e4rke in Punkten",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_3",
            "text": "// zeichnet einen schwarzen Pfeil\nAddChartArrowLine(\"MyArrow-\" + ProcessingBarIndex, false, 10, 10, 0, 5, Color.Black, DashStyle.Solid, 4);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addchartarrowup",
            "text": "",
            "title": "AddChartArrowUp()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_4",
            "text": "AddChartArowUp() zeichnet einen nach oben gerichteten Pfeil:   Siehe auch  AddChartArrowUp() ,  AddChartArrowDown() ,  AddChartDiamond() ,  AddChartDot() ,  AddChartSquare() ,  AddChartTriangleUp() ,  AddChartTriangleDown() .",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_4",
            "text": "AddChartArrowUp(string name, bool autoScale, int barsAgo, double y, Color color)\nAddChartArrowUp(string name, bool autoScale, DateTime time, double y, Color color)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_4",
            "text": "A drawing object of the type IArrowUp (interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_4",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen    barsAgo  Gibt an, an welchem zur\u00fcckliegenden Bar der Pfeil gezeichnet werden soll    (0=aktueller Bar)     time  Datum/Uhrzeit des Bars, an dem der Pfeil gezeichnet werden soll    y  y-Wert f\u00fcr den Pfeil    color  Farbe des Zeichenobjekts",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#example",
            "text": "// zeichnet einen gr\u00fcnen Pfeil am akt. Bar 3 Ticks unter dem Tief\nAddChartArrowUp(\"MyArrow-\"  + ProcessingBarIndex, true, 0, Low[0] - 3*TickSize, Color.Green);",
            "title": "Example"
        },
        {
            "location": "/zeichenobjekte/#addchartdiamond",
            "text": "",
            "title": "AddChartDiamond()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_5",
            "text": "AddChartDiamond() zeichnet einen Diamanten:   Siehe auch  AddChartArrowUp() ,  AddChartArrowDown() ,  AddChartDiamond() ,  AddChartDot() ,  AddChartSquare() ,  AddChartTriangleUp() ,  AddChartTriangleDown() .",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_5",
            "text": "AddChartDiamond(string name, bool autoScale, int barsAgo, double y, Color color)\nAddChartDiamond(string name, bool autoScale, DateTime time, double y, Color color)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_5",
            "text": "Ein Zeichenobjekt vom Typ IDiamond (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_5",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen    barsAgo  Gibt an, an welchem zur\u00fcckliegenden Bar der Pfeil gezeichnet werden soll    (0=aktueller Bar)     time  Datum/Uhrzeit des Bars, an dem der Pfeil gezeichnet werden soll    y  y-Wert f\u00fcr den Pfeil    color  Farbe des Zeichenobjekts",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_4",
            "text": "// zeichnet einen hellblauen Diamanten am akt. Bar 5 Ticks unter dem Tief\nAddChartDiamond(\"MyDiamond-\" + ProcessingBarIndex, true, 0, Low[0] - 5*TickSize, Color.SteelBlue);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addchartdot",
            "text": "",
            "title": "AddChartDot()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_6",
            "text": "AddChartDot() zeichnet einen Punkt:   Siehe auch  AddChartArrowUp() ,  AddChartArrowDown() ,  AddChartDiamond() ,  AddChartDot() ,  AddChartSquare() ,  AddChartTriangleUp() ,  AddChartTriangleDown() .",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_6",
            "text": "AddChartDot(string name, bool autoScale, int barsAgo, double y, Color color)\nAddChartDot(string name, bool autoScale, DateTime time, double y, Color color)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_6",
            "text": "Ein Zeichenobjekt vom Typ IDot (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_6",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen    barsAgo  Gibt an, an welchem zur\u00fcckliegenden Bar der Pfeil gezeichnet werden soll    (0=aktueller Bar)     time  Datum/Uhrzeit des Bars, an dem der Pfeil gezeichnet werden soll    y  y-Wert f\u00fcr den Pfeil    color  Farbe des Zeichenobjekts",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_5",
            "text": "// zeichnet einen orangen Punkt am akt. Bar 5 Ticks \u00fcber dem Hoch\nAddChartDot(\"MyDot-\" + ProcessingBarIndex, true, 0, High[0] + 5*TickSize, Color.Orange);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addchartellipse",
            "text": "",
            "title": "AddChartEllipse()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_7",
            "text": "AddChartEllipse() zeichnet eine Ellipse.",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_7",
            "text": "AddChartEllipse(string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color)\nAddChartEllipse(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, Color areaColor, int areaOpacity)\nAddChartEllipse(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, Color areaColor, int areaOpacity)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_7",
            "text": "Ein Zeichenobjekt vom Typ IEllipse (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_7",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist    barsBackStart  Gibt an, an welchem zur\u00fcckliegenden Bar die Ellipse beginnen soll (0=aktueller Bar)    startTime  Datum/Uhrzeit des Bars, an dem die Ellipse beginnen soll    startY  Wert, an dem die Ellipse beginnen soll    barsBackEnd  Gibt an, an welchem zur\u00fcckliegenden Bar die Ellipse enden soll (0=aktueller Bar)    endTime  Datum/Uhrzeit des Bars, an dem die Ellipse enden soll    endY  y-Wert, an dem die Ellipse enden soll    color  Randfarbe des Zeichenobjekts    areaColor  F\u00fcllfarbe des Zeichenobjekts    areaOpacity  Transparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 = komplett transparent; 255 = keine Transparenz)",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_6",
            "text": "// zeichnet eine gelbe Ellipse vom akt. Bar bis 5 Bars zur\u00fcck\nAddChartEllipse(\"MyEllipse-\" + ProcessingBarIndex, true, 5, High[5], 0, Close[0], Color.Yellow, Color.Yellow, 1);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addchartextendedline",
            "text": "",
            "title": "AddChartExtendedLine()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_8",
            "text": "AddChartExtendedLine() zeichnet eine Linie mit unendlichem Endpunkt.  Siehe auch  AddChartLine() ,  AddChartHorizontalLine() ,  AddChartVerticalLine() ,  AddChartRay() .",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_8",
            "text": "AddChartExtendedLine(string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color)\nAddChartExtendedLine(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, DashStyle dashStyle, int width)\nAddChartExtendedLine(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, DashStyle dashStyle, int width)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_8",
            "text": "Ein Zeichenobjekt vom Typ IExtendedLine (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_8",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist    barsBackStart  Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den Startpunkt    startTime  Datum/Uhrzeit f\u00fcr den Startpunkt    startY  y-Wert f\u00fcr den Startpunkt    barsBackEnd  Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den zweiten Punkt (Einen Endpunkt gibt es bei diesem Zeichenobjekt nicht    endTime  Datum/Uhrzeit f\u00fcr den Endpunkt    endY  y-Wert f\u00fcr den Endpunkt    color  Farbe des Zeichenobjekts    dashStyle  Linienart     DashStyle.Dash     DashStyle.DashDot     DashStyle.DashDotDot     DashStyle.Dot     DashStyle.Solid         ggf. mu\u00df     using System.Drawing.Drawing2D;  mit eingebunden werden.    width  Linienst\u00e4rke in Punkten",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_7",
            "text": "// zeichnet eine Linie ohne Endpunkt\nAddChartExtendedLine(\"MyExt.LevelLine-\" + ProcessingBarIndex, false, 10, Close[10], 0, Close[0], Color.Black, DashStyle.Solid, 1);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addchartfibonaccicircle",
            "text": "",
            "title": "AddChartFibonacciCircle()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_9",
            "text": "AddChartFibonacciCircle() zeichnet Fibonacci-Kreise.",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_9",
            "text": "AddChartFibonacciCircle(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY)\nAddChartFibonacciCircle(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_9",
            "text": "Ein Zeichenobjekt vom Typ IFibonacciCircle (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_9",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist    barsBackStart  Gibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci-Kreise beginnen sollen.    startTime  Datum/Uhrzeit des Bars, an dem die Fibonacci-Kreise beginnen sollen    startY  y-Wert, an dem die Fibonacci-Kreise beginnen sollen    barsBackEnd  Gibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci-Kreise enden sollen (0=aktueller Bar)    endTime  Datum/Uhrzeit des Bars, an dem die Fibonacci-Kreise enden sollen    endY  y-Wert, an dem die Fibonacci-Kreise enden sollen",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_8",
            "text": "// zeichnet Fibonacci-Kreise\nAddChartFibonacciCircle(\"MyFibCircle-\"  + ProcessingBarIndex, true, 5, Low[5], 0, High[0]);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addchartfibonacciextensions",
            "text": "",
            "title": "AddChartFibonacciExtensions()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_10",
            "text": "AddChartFibonacciExtensions() zeichnet Fibonacci Extensions",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_10",
            "text": "AddChartFibonacciExtensions(string name, bool autoScale, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, int start3BarsAgo, double start3Y)\nAddChartFibonacciExtensions(string name, bool autoScale, DateTime start1Time, double start1Y, DateTime start2Time, double start2Y, DateTime start3Time, double start3Y)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_10",
            "text": "Ein Zeichenobjekt vom Typ IFibonacciExtensions (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_10",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist.    start1BarsAgo  Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt1 (x-Achse)    start1Time  Datum/Zeit f\u00fcr Ankerpunkt1 (x-Achse)    start1Y  y-Wert f\u00fcr Ankerpunkt1    start2BarsAgo  Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt2 (x-Achse)    start2Time  Datum/Zeit f\u00fcr Ankerpunkt2(x-Achse)    start2Y  y-Wert f\u00fcr Ankerpunkt2    start3BarsAgo  Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt3 (x-Achse)    start3Time  Datum/Zeit f\u00fcr Ankerpunk3 (x-Achse)    start3Y  y-Wert f\u00fcr Ankerpunkt3",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_9",
            "text": "// zeichnet FibonacciExtensions\nAddChartFibonacciExtensions(\"MyFibExt-\"  + ProcessingBarIndex, true, 4, Low[4], 3, High[3], 1, Low[1]);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addchartfibonacciprojections",
            "text": "",
            "title": "AddChartFibonacciProjections()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_11",
            "text": "Draw Fibonacci Projections () zeichnet Fibonacci Projections.",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_11",
            "text": "AddChartFibonacciProjections(string name, bool autoScale, DateTime start1Time, double start1Y,DateTime start2Time, double start2Y, DateTime start3Time, double start3Y)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_11",
            "text": "Ein Zeichenobjekt vom Typ IFibonacciProjections (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_11",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist.    start1Time  Datum/Zeit f\u00fcr Ankerpunkt1 (x-Achse)    start1Y  y-Wert f\u00fcr Ankerpunkt1    start2Time  Datum/Zeit f\u00fcr Ankerpunkt2(x-Achse)    start2Y  y-Wert f\u00fcr Ankerpunkt2    start3Time  Datum/Zeit f\u00fcr Ankerpunk3 (x-Achse)    start3Y  y-Wert f\u00fcr Ankerpunkt3",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_10",
            "text": "// zeichnet FibonacciProjections\nAddChartFibonacciProjections(\"MyFibPro-\"  + ProcessingBarIndex, true, Low[4], 3, High[3], 1, Low[1], 2);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addchartfibonacciretracements",
            "text": "",
            "title": "AddChartFibonacciRetracements()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_12",
            "text": "AddChartFibonacciRetracements() dzeichnet Fibonacci Retracements.",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_12",
            "text": "AddChartFibonacciRetracements(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY)\nAddChartFibonacciRetracements(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_12",
            "text": "A drawing object of the type IFibonacciRetracements (interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_12",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist    barsBackStart  Gibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci Retracements beginnen sollen.    startTime  Datum/Uhrzeit des Bars, an dem die Fibonacci Retracements beginnen sollen    startY  y-Wert, an dem die Fibonacci Retracements beginnen sollen    barsBackEnd  Gibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci Retracements enden sollen (0=aktueller Bar)    endTime  Datum/Uhrzeit des Bars, an dem die Fibonacci Retracements enden sollen    endY  y-Wert, an dem die Fibonacci Retracements enden sollen",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_11",
            "text": "// zeichnet Fibonnaci Retracements\nAddChartFibonacciRetracements(\"MyFibRet-\"  + ProcessingBarIndex, true, 10, Low[10], 0, High[0]);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addchartfibonaccitimeextensions",
            "text": "",
            "title": "AddChartFibonacciTimeExtensions()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_13",
            "text": "AddChartFibonacciTimeExtensions() zeichnet Fibonacci Retracements.",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_13",
            "text": "AddChartFibonacciTimeExtensions(string name, int barsBackStart, double startY, int barsBackEnd, double endY)\nAddChartFibonacciTimeExtensions(string name, DateTime startTime, double startY, DateTime endTime, double endY)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_13",
            "text": "Ein Zeichenobjekt vom Typ IFibonacciTimeExtensions (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_13",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    barsBackStart  Gibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci TimeExtensions beginnen sollen.    startTime  Datum/Uhrzeit des Bars, an dem die Fibonacci TimeExtensions beginnen sollen    startY  y-Wert, an dem die Fibonacci-Kreise beginnen sollen    barsBackEnd  Gibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci TimeExtensions enden sollen (0=aktueller Bar)    endTime  Datum/Uhrzeit des Bars, an dem die Fibonacci TimeExtensions enden sollen    endY  y-Wert, an dem die Fibonacci TimeExtensions enden sollen",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_12",
            "text": "// zeichnet Fibonacci TimeExtensions\nAddChartFibonacciTimeExtensions(\"MyFibTimeExt-\" + ProcessingBarIndex, 10, Low[10], 0, High[0]);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addchartgannfan",
            "text": "",
            "title": "AddChartGannFan()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_14",
            "text": "AddChartGannFan() zeichnet Fibonacci Retracements.",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_14",
            "text": "AddChartGannFan(string name, bool autoScale, int barsAgo, double y)\nAddChartGannFan(string name, bool autoScale, DateTime time, double y)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_14",
            "text": "Ein Zeichenobjekt vom Typ IGannFan (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_14",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist    barsAgo  Gibt an, an welchem zur\u00fcckliegenden Bar der GannFan gezeichnet werden soll    time  Datum/Uhrzeit des Bars, an dem der GannFan gezeichnet werden soll    y  y-Wert, an dem der GannFan gezeichnet werden soll",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_13",
            "text": "// zeichnet einen Gann Fan am Tief des Bars von vor 10 Perioden\nAddChartGannFan(\"MyGannFan-\" + ProcessingBarIndex, true, 10, Low[10]);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addcharthorizontalline",
            "text": "",
            "title": "AddChartHorizontalLine()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_15",
            "text": "AddChartHorizontalLine() zeichnet eine horizontale Linie in den Chart.  Siehe auch  AddChartLine() ,  AddChartVerticalLine() ,  AddChartExtendedLine() ,  AddChartRay() .",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_15",
            "text": "AddChartHorizontalLine(string name, double y, Color color)\nAddChartHorizontalLine(string name, bool autoScale, double y, Color color, DashStyle dashStyle, int width)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_15",
            "text": "Ein Zeichenobjekt vom Typ IHorizontalLine (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_15",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist    y  ein beliebiger double-Wert    color  Linienfarbe    dashStyle  Linienart     DashStyle.Dash     DashStyle.DashDot     DashStyle.DashDotDot     DashStyle.Dot     DashStyle.Solid         ggf. mu\u00df     using System.Drawing.Drawing2D; mit eingebunden werden.    width  Linienst\u00e4rke",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiele",
            "text": "// zeichnet eine horizontale Linie bei y=10\nAddChartHorizontalLine(\"MyHorizontalLine-\" + ProcessingBarIndex, 10, Color.Black);",
            "title": "Beispiele"
        },
        {
            "location": "/zeichenobjekte/#addchartline",
            "text": "",
            "title": "AddChartLine()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_16",
            "text": "AddChartLine()  zeichnet eine (Trend-) Linie.  Siehe auch   AddChartHorizontalLine() ,  AddChartVerticalLine() ,  AddChartExtendedLine() ,  AddChartRay() .",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_16",
            "text": "AddChartLine(string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color)\nAddChartLine(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, DashStyle dashStyle, int width)\nAddChartLine(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, DashStyle dashStyle, int width)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_16",
            "text": "Ein Zeichenobjekt vom Typ ITrendLine (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_16",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist    barsBackStart  Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den Startpunkt    startTime  Datum/Uhrzeit f\u00fcr den Startpunkt    startY  y-Wert f\u00fcr den Startpunkt    barsBackEnd  Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den zweiten Punkt (Einen Endpunkt gibt es bei diesem Zeichenobjekt nicht)    endTime  Datum/Uhrzeit f\u00fcr den Endpunkt    endY  y-Wert f\u00fcr den Endpunkt    color  Farbe des Zeichenobjekts    dashStyle  Linienart     DashStyle.Dash     DashStyle.DashDot     DashStyle.DashDotDot     DashStyle.Dot     DashStyle.Solid         ggf. mu\u00df     using System.Drawing.Drawing2D; mit eingebunden werden.    width  Linienst\u00e4rke in Punkten",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_14",
            "text": "// zeichnet eine Linie\nAddChartLine(\"MyLine-\" + ProcessingBarIndex, false, 10, Close[10], 0, Close[0], Color.Black, DashStyle.Solid, 1);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addchartray",
            "text": "",
            "title": "AddChartRay()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_17",
            "text": "AddChartRay() zeichnet eine (Trend-) Linie, die zu einer Seite ins Unendliche verl\u00e4ngert wird.  Siehe auch  AddChartLine() ,  AddChartHorizontalLine() ,  AddChartVerticalLine() ,  AddChartExtendedLine() .",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_17",
            "text": "AddChartRay(string name, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, Color color)\nAddChartRay(string name, bool autoScale, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, Color color, DashStyle dashStyle, int width)\nAddChartRay(string name, bool autoScale, DateTime start1Time, double start1Y, DateTime start2Time, double start2Y, Color color, DashStyle dashStyle, int width)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_17",
            "text": "Ein Zeichenobjekt vom Typ IRay (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_17",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist.    start1BarsAgo  Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt1 (x-Achse)    start1Time  Datum/Zeit f\u00fcr Ankerpunkt1 (x-Achse)    start1Y  y-Wert f\u00fcr Ankerpunkt1    start2BarsAgo  Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt2 (x-Achse)    start2Time  Datum/Zeit f\u00fcr Ankerpunkt2(x-Achse)    start2Y  y-Wert f\u00fcr Ankerpunkt2    color  Farbe des Zeichenobjekts    dashStyle  Linienart     DashStyle.Dash     DashStyle.DashDot     DashStyle.DashDotDot     DashStyle.Dot     DashStyle.Solid         ggf. mu\u00df     using System.Drawing.Drawing2D; mit eingebunden werden.    width  Linienst\u00e4rke",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiele_1",
            "text": "// zeichnet eine Linie vom Bar von vor 10 Perioden \u00fcber den aktuellen Bar (x-Achse)\n// --> Linie wird nach rechts verl\u00e4ngert\n// von y=3 \u00fcber y=7\nAddChartRay(\"MyRay-\" + ProcessingBarIndex, 10, 3, 0, 7, Color.Green);\n// zeichnet eine Linie vom akt. Bar \u00fcber den Bar von vor 10 Perioden\n// --> Linie wird nach links verl\u00e4ngert\n// von y=3 \u00fcber y=7\nAddChartRay(\"MyRay-\" + ProcessingBarIndex, 0, 3, 10, 7, Color.Green);",
            "title": "Beispiele"
        },
        {
            "location": "/zeichenobjekte/#addchartrectangle",
            "text": "",
            "title": "AddChartRectangle()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_18",
            "text": "AddChartRectangle() zeichnet ein Rechteck.",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_18",
            "text": "AddChartRectangle(string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color)\nAddChartRectangle(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, Color areaColor, int areaOpacity)\nAddChartRectangle(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, Color areaColor, int areaOpacity)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_18",
            "text": "Ein Zeichenobjekt vom Typ IRectangle (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_18",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist.    barsBackStart  Gibt an, an welchem zur\u00fcckliegenden Bar sich die eine Ecke des Rechtecks befinden soll (0=aktueller Bar)    startTime  Datum/Uhrzeit des Bars, an dem sich die eine Ecke des Rechtecks befinden soll    startY  y-Wert, an dem die sich die eine Ecke des Rechtecks befinden soll    barsBackEnd  Gibt an, an welchem zur\u00fcckliegenden Bar sich die zweite Ecke des Rechtecks befinden soll (0=aktueller Bar)    endTime  Datum/Uhrzeit des Bars, an dem sich die zweite Ecke des Rechtecks befinden soll    endY  y-Wert, an dem die sich die zweite Ecke des Rechtecks befinden soll    color  Farbe des Zeichenobjekts    areaColor  F\u00fcllfarbe des Zeichenobjekts    areaOpacity  Transparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 =  komplett transparent, 255 = keine Transparenz)",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_15",
            "text": "// zeichnet ein gr\u00fcnes Rechteck vom Tief von vor 10 Perioden zum Hoch von vor 5 Perioden\n// mit der F\u00fcllfarbe PaleGreen und einer Transparenz von 2\nAddChartRectangle(\"MyRect-\" + ProcessingBarIndex, true, 10, Low[10], 5, High[5], Color.PaleGreen, Color.PaleGreen, 2);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addchartregion",
            "text": "",
            "title": "AddChartRegion()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_19",
            "text": "AddChartRegion() DrawRegion() f\u00fcllt einen bestimmten Bereich auf einem Chart aus.",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_19",
            "text": "AddChartRegion(string name, int barsBackStart, int barsBackEnd, IDataSeries series, double y, Color outlineColor, Color areaColor, int areaOpacity)\nAddChartRegion(string name, int barsBackStart, int barsBackEnd, IDataSeries series1, IDataSeries series2, Color outlineColor, Color areaColor, int areaOpacity)\nAddChartRegion(string name, DateTime startTime, DateTime endTime, IDataSeries series, double y, Color outlineColor, Color areaColor, int areaOpacity)\nAddChartRegion(string name, DateTime startTime, DateTime endTime, IDataSeries series1, IDataSeries series2, Color outlineColor, Color areaColor, int areaOpacity)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_19",
            "text": "Ein Zeichenobjekt vom Typ IRegion (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_19",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    barsBackStart  Gibt an, an welchem zur\u00fcckliegenden Bar sich die eine Ecke des Rechtecks befinden soll (0=aktueller Bar)    startTime  Datum/Uhrzeit des Bars, an dem sich die eine Ecke des Rechtecks befinden soll    barsBackEnd  Gibt an, an welchem zur\u00fcckliegenden Bar sich die zweite Ecke des Rechtecks befinden soll (0=aktueller Bar)    endTime  Datum/Uhrzeit des Bars, an dem sich die zweite Ecke des Rechtecks befinden soll    series1, series2  jedes Datenserie, wie z.B. ein Indikator, Close, High, Low usw.  Der jeweilige Wert der Datenserie f\u00fcr den aktuellen Bar wird als y-Wert herangezogen    y  ein beliebiger double-Wert    outlineColor  Farbe f\u00fcr die Umrandung des Bereichs    areaColor  F\u00fcllfarbe des Zeichenobjekts    areaOpacity  Transparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 =  komplett transparent, 255 = keine Transparenz)",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_16",
            "text": "// f\u00fcllt den Bereich zwischen dem oberen und dem unteren Bollinger Band\nAddChartRegion(\"MyRegion\", ProcessingBarIndex, 0, Bollinger(2, 14).Upper, Bollinger(2, 14).Lower, Color.Empty, Color.Lime, 100);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addchartregressionchannel",
            "text": "",
            "title": "AddChartRegressionChannel()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_20",
            "text": "AddChartRegressionChannel()zeichnet einen Regressionskanal.",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_20",
            "text": "AddChartRegressionChannel(string name, int barsBackStart, int barsBackEnd, Color color)\nAddChartRegressionChannel(string name, bool autoScale, int barsBackStart, int barsBackEnd, Color upperColor, DashStyle upperDashStyle, int upperWidth, Color middleColor, DashStyle middleDashStyle, int middleWidth, Color lowerColor, DashStyle lowerDashStyle, int lowerWidth)\nAddChartRegressionChannel(string name, bool autoScale, DateTime startTime, DateTime endTime, Color upperColor, DashStyle upperDashStyle, int upperWidth, Color middleColor, DashStyle middleDashStyle, int middleWidth, Color lowerColor, DashStyle lowerDashStyle, int lowerWidth)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_20",
            "text": "Ein Zeichenobjekt vom Typ IRegressionChannel (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_20",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist.    barsBackStart  Gibt an, an welchem zur\u00fcckliegenden Bar der Regressionskanal beginnen soll (0=aktueller Bar)    startTime  Datum/Uhrzeit des Bars, an dem der Regressionskanal beginnen soll    barsBackEnd  Gibt an, an welchem zur\u00fcckliegenden Bar der Regressionskanal enden soll (0=aktueller Bar)    endTime  Datum/Uhrzeit des Bars, an dem der Regressionskanal enden soll    color  Farbe des Zeichenobjekts    upperDashStyle, middleDashStyle, lowerDashStyle  Linienart     DashStyle.Dash     DashStyle.DashDot     DashStyle.DashDotDot     DashStyle.Dot     DashStyle.Solid         ggf. mu\u00df:     using System.Drawing.Drawing2D; mit eingebunden werden.    upperColor,  middleColor,    lowerColor  jeweilige Linienfarbe    upperWidth,   middleWidth,  lowerWidth  jeweilige Linienst\u00e4rke",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_17",
            "text": "// zeichnet einen Regressionskanal vom Tief des Bars von vor 10 Tagen\n// zum Hoch des Bars von vor 5 Tagen\nAddChartRegressionChannel(\"MyRegChannel-\" + ProcessingBarIndex, 10, 0, Color.Black);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addchartsquare",
            "text": "",
            "title": "AddChartSquare()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_21",
            "text": "AddChartSquare()  zeichnet ein Quadrat:   Siehe auch  AddChartArrowUp() ,  AddChartArrowDown() ,  AddChartDiamond() ,  AddChartDot() ,  AddChartTriangleUp() ,  AddChartTriangleDown() .",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_21",
            "text": "DrawSqare(string name, bool autoScale, int barsAgo, double y, Color color)\nDrawSqare(string name, bool autoScale, DateTime time, double y, Color color)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_21",
            "text": "Ein Zeichenobjekt vom Typ ISquare (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_21",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen    barsAgo  Gibt an, an welchem zur\u00fcckliegenden Bar das Quadrat gezeichnet werden soll (0=aktueller Bar)    Time  Datum/Uhrzeit des Bars, an dem das Quadrat gezeichnet werden soll    Y  y-Wert, an dem das Quadrat gezeichnet werden soll    color  Farbe des Zeichenobjekts",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_18",
            "text": "// zeichnet ein durnkelrotes Quadrat am akt. Bar 10 Ticks \u00fcber dem Hoch\nAddChartSquare(\"MySquare\", true, 0, High[0] + 10*TickSize, Color.DarkRed);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addcharttext",
            "text": "",
            "title": "AddChartText()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_22",
            "text": "AddChartText() schreibt einen beliebigen Text auf den Chart.  Siehe auch  AddChartTextFixed() .",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_22",
            "text": "AddChartText(string tag, string text, int barsAgo, double y, Color color);\nAddChartText(string tag, string text, TextPosition textPosition, Color textColor, Font font, Color outlineColor, Color areaColor, int areaOpacity);\nAddChartText(string tag, string text, int barsAgo, double y, Color textColor, Font font, StringAlignment alignment, Color outlineColor, Color areaColor, int areaOpacity);\nAddChartText(string tag, bool autoScale, string text, int barsAgo, double y, int yPixelOffset, Color textColor, Font font, StringAlignment alignment, Color outlineColor, Color areaColor, int areaOpacity);\nAddChartText(string tag, bool autoScale, string text, DateTime x, double y, int yPixelOffset, Color textColor, Font font, StringAlignment alignment, Color outlineColor, Color areaColor, int areaOpacity);\nAddChartText(string tag, bool autoScale, string text, DateTime x, double y, int pixelOffset, Color textColor, Font font, StringAlignment alignment, HorizontalAlignment hAlign, VerticalAlignment vAlign, Color outlineColor, Color areaColor);\nAddChartText(string tag, bool autoScale, string text, int barsAgo, double y, int yPixelOffset, Color textColor, Font font, StringAlignment alignment, HorizontalAlignment hAlign, VerticalAlignment vAlign, Color outlineColor, Color areaColor, int areaOpacity);\nAddChartText(string tag, bool autoScale, string text, DateTime x, double y, int pixelOffset, Color textColor, Font font, StringAlignment alignment, HorizontalAlignment hAlign, VerticalAlignment vAlign, Color outlineColor, Color areaColor);     wichtiger Hinweis: \nBei Verwendung der Signaturen, die HorizontalAlignment und VerticalAlignment enthalten, sind die folgenden beiden Zeilen dem Programmcode hinzuzuf\u00fcgen:  using System.Windows.Forms;\nusing System.Windows.Forms.VisualStyles;",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_22",
            "text": "Ein Zeichenobjekt vom Typ IText (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_22",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist    Text  Der auszugebende Text (Der Text darf auch den Zeilenumbruch \"\\n\" enthalten.)    barsAgo  Gibt an, an welchem zur\u00fcckliegenden Bar der Text ausgegeben werden soll (0=aktueller Bar)    (Welcher Bar den Index 0 hat, ist abh\u00e4ngig von CalculateOnBarClose.)     Time  Datum/Uhrzeit des Bars, an dem der Text beginnen soll    Y  y-Wert, an dem der Text geschrieben werden soll    yPixelOffset  vertikale Verschiebung des Textes. Positive Werte verschieben den Text nach oben, negative Werte nach unten.    textColor  Textfarbe    Font  Schriftart f\u00fcr den Text    Alignment  m\u00f6gliche Werte sind: StringAlignment.Center, StringAlignment.Far, StringAlignment.Near    HAlign  m\u00f6gliche Werte sind: HorizontalAlign.Left, HorizontalAlign.Center, HorizontalAlign.Right    VAlign  m\u00f6gliche Werte sind: VerticalAlign.Top, VerticalAlign.Center, VerticalAlign.Bottom    outlineColor  Farbe des Rahmens um den Text (F\u00fcr keinen Rahmen Color.Empty verwenden)    areaColor  F\u00fcllfarbe der Textbox (F\u00fcr keine F\u00fcllung Color.Empty verwenden)    areaOpacity  Transparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 =  komplett transparent, 255 = keine Transparenz)",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiele_2",
            "text": "// schreibt einen Text bei y=3.0 \nAddChartText(\"MyText-\" + ProcessingBarIndex, \"This is sample text.\", 10, 3, Color.Black);\n// schreibt einen roten Text in Schriftgr\u00f6\u00dfe Arial 7\nAddChartText(\"MyText-\" + ProcessingBarIndex, false, \"This is sample text.\", Time[0], Close[0]+50*TickSize, 0,\nColor.Red, new Font(\"Arial\",7), StringAlignment.Center, Color.Blue, Color.DarkOliveGreen, 10);  Nachstehende Anweisung f\u00fchrt zu diesem Ergebnis:   AddChartText(\"MyTag\",true,\"Text\",1, // barsAgo\nHigh[1], // y\n10, // yPixelOffset\nColor.Blue, // Text color\nnew Font(\"Arial\", 10, FontStyle.Bold),\nStringAlignment.Center,\nHorizontalAlignment.Center,\nVerticalAlignment.Bottom,\nColor.Red, // Outline color\nColor.Yellow, // Fill color\n100); // Opacity",
            "title": "Beispiele"
        },
        {
            "location": "/zeichenobjekte/#addcharttextfixed",
            "text": "",
            "title": "AddChartTextFixed()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_23",
            "text": "AddChartTextFixed() schreibt Text an eine von 5 m\u00f6glichen festen Stellen im Chart.  Siehe auch  AddChartText() .",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_23",
            "text": "AddChartTextFixed(string tag, string text, TextPosition textPosition);\nAddChartTextFixed(string tag, string text, TextPosition textPosition, Color textColor, Font font, Color outlineColor, Color areaColor);\nAddChartTextFixed(string tag, string text, TextPosition textPosition, Color textColor, Font font, Color outlineColor, Color areaColor, int areaOpacity);",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_23",
            "text": "Ein Zeichenobjekt vom Typ ITextFixed (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_23",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    text  The text to be displayed    TextPosition  TextPosition.BottomLeft, TextPosition.BottomRight, TextPosition.Center, TextPosition.TopLeft, TextPosition.TopRight    textColor  Textfarbe    font  Schriftart f\u00fcr den Text    outlineColor  Farbe des Rahmens um den Text (F\u00fcr keinen Rahmen Color.Empty verwenden)    areaColor  F\u00fcllfarbe der Textbox (F\u00fcr keine F\u00fcllung Color.Empty verwenden)    areaOpacity  Transparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 =  komplett transparent, 255 = keine Transparenz)",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiele_3",
            "text": "// schreibt einen Text in die Mitte des Charts\nAddChartTextFixed(\"MyText-\" + ProcessingBarIndex, \"\"Das ist ein Beispieltext.\", TextPosition.Center);\n// schreibt einen roten Text mit einem blauen Rand in die Mitte des Charts\nAddChartTextFixed(\"MyText-\" + ProcessingBarIndex, \"Das ist ein Beispieltext.\", TextPosition.Center, Color.Red, new Font(\"Arial\",35), Color.Blue, Color.Empty, 10);",
            "title": "Beispiele"
        },
        {
            "location": "/zeichenobjekte/#addcharttrendchannel",
            "text": "",
            "title": "AddChartTrendChannel()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_24",
            "text": "AddChartTrendChannel() zeichnet einen Trendkanal.",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_24",
            "text": "AddChartTrendChannel(string name, bool autoScale, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, int start3BarsAgo, double start3Y)\nAddChartTrendChannel(string name, bool autoScale, DateTime start1Time, double start1Y, DateTime start2Time, double start2Y, DateTime start3Time, double start3Y)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_24",
            "text": "Ein Zeichenobjekt vom Typ ITrendChannel (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_24",
            "text": "name  A clearly identifiable name for the drawing object    autoScale  Adjusts the scale of the y-axis so that drawing objects can be viewed in their entirety    start1BarsAgo  Number of bars ago for start point 1 (x-axis)    start1Time  Date/time for start point 1 (x-axis)    start1Y  y-value for start point 1    start2BarsAgo  Number of bars ago for start point 2 (x-axis)    start2Time  Date/time for start point 2 (x-axis)    start2Y  y-value for start point 2    start3BarsAgo  Number of bars ago for start point 3 (x-axis)    start3Time  Date/time for start point 3 (x-axis)    start3Y  y-value for start point 3",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiele_4",
            "text": "// zeichnet einen Trendkanal\nAddChartTrendChannel(\"MyTrendChannel-\" + ProcessingBarIndex, true, 10, Low[10], 0, High[0], 10, High[10] + 5 * TickSize);",
            "title": "Beispiele"
        },
        {
            "location": "/zeichenobjekte/#addcharttriangle",
            "text": "",
            "title": "AddChartTriangle()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_25",
            "text": "AddChartTriangle() zeichnet ein Dreieck.",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_25",
            "text": "AddChartTriangle(string name, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, int start3BarsAgo, double start3Y, Color color)\nAddChartTriangle(string name, bool autoScale, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, int start3BarsAgo, double start3Y, Color color, Color areaColor, int areaOpacity)\nAddChartTriangle(string name, bool autoScale, DateTime start1Time, double start1Y, DateTime start2Time, double start2Y, DateTime start3Time, double start3Y, Color color, Color areaColor, int areaOpacity)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_25",
            "text": "Ein Zeichenobjekt vom Typ ITriangle (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_25",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist    start1BarsAgo  Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt1 (x-Achse)    start1Time  Datum/Zeit f\u00fcr Ankerpunkt1 (x-Achse)    start1Y  y-Wert f\u00fcr Ankerpunkt1    start2BarsAgo  Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt2 (x-Achse)    start2Time  Datum/Zeit f\u00fcr Ankerpunkt2 (x-Achse)    start2Y  y-Wert f\u00fcr Ankerpunkt2    start3BarsAgo  Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt3 (x-Achse)    start3Time  Datum/Zeit f\u00fcr Ankerpunkt3 (x-Achse)    start3Y  y-Wert f\u00fcr Ankerpunkt3    color  Farbe des Zeichenobjekts    areaColor  F\u00fcllen Sie Farbe des Zeichnungsobjekt    areaOpacity  Transparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 =  komplett transparent, 255 = keine Transparenz)",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_19",
            "text": "// zeichnet ein gr\u00fcnes Dreieck\nAddChartTriangle(\"tag1\", 4, Low[4], 3, High[3], 1, Low[1], Color.Green);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addcharttriangledown",
            "text": "",
            "title": "AddChartTriangleDown()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_26",
            "text": "AddChartTriangleDown() zeichnet ein kleines abw\u00e4rtsgerichtetes Dreieck.   Siehe auch  AddChartArrowUp() ,  AddChartArrowDown() ,  AddChartDiamond() ,  AddChartDot() ,  AddChartSquare() ,  AddChartTriangleUp() .",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_26",
            "text": "AddChartTriangleDown(string name, bool autoScale, int barsAgo, double y, Color color)\nAddChartTriangleDown(string name, bool autoScale, DateTime time, double y, Color color)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_26",
            "text": "Ein Zeichenobjekt vom Typ ITriangleDown (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_26",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist    barsAgo  Gibt an, an welchem zur\u00fcckliegenden Bar das Dreieck gezeichnet werden soll    time  Datum/Uhrzeit des Bars, an dem das Dreieck gezeichnet werden soll    y  y-Wert, an dem das Dreieck gezeichnet werden    color  Farbe des Zeichenobjekts",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_20",
            "text": "// zeichnet ein kleines rotes Dreieck am akt. Bar 10 Ticks \u00fcber dem Hoch\nAddChartTriangleDown(\"MyTriangleDown-\" + ProcessingBarIndex, true, 0, High[0] + 10*TickSize, Color.Red);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addcharttriangleup",
            "text": "",
            "title": "AddChartTriangleUp()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_27",
            "text": "AddChartTriangleUp() zeichnet ein kleines aufw\u00e4rtsgerichtetes Dreieck.   Siehe auch  AddChartArrowUp() ,  AddChartArrowDown() ,  AddChartDiamond() ,  AddChartDot() ,  AddChartSquare() ,  AddChartTriangleDown() .",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_27",
            "text": "AddChartTriangleUp(string name, bool autoScale, int barsAgo, double y, Color color)\nAddChartTriangleUp(string name, bool autoScale, DateTime time, double y, Color color)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_27",
            "text": "Ein Zeichenobjekt vom Typ ITriangleUp (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_27",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    autoScale  Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist    barsAgo  Gibt an, an welchem zur\u00fcckliegenden Bar das Dreieck gezeichnet werden soll    time  Datum/Uhrzeit des Bars, an dem das Dreieck gezeichnet werden soll    y  y-Wert, an dem das Dreieck gezeichnet werden    color  Farbe des Zeichenobjekts",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiel_21",
            "text": "// zeichnet ein kleines hellgr\u00fcnes Dreieck am akt. Bar 10 Ticks unter dem Tief\nAddChartTriangleUp(\"MyTriangleUp-\" + ProcessingBarIndex, true, 0, Low[0] - 10*TickSize, Color.LightGreen);",
            "title": "Beispiel"
        },
        {
            "location": "/zeichenobjekte/#addchartverticalline",
            "text": "",
            "title": "AddChartVerticalLine()"
        },
        {
            "location": "/zeichenobjekte/#beschreibung_28",
            "text": "AddChartVerticalLine() zeichnet eine vertikale Linie in den Chart.  Siehe auch  AddChartLine() ,  AddChartHorizontalLine() ,  AddChartExtendedLine() ,  AddChartRay() .",
            "title": "Beschreibung"
        },
        {
            "location": "/zeichenobjekte/#verwendung_28",
            "text": "AddChartVerticalLine(string name, int barsAgo, Color color)\nAddChartVerticalLine(string name, int barsAgo, Color color, DashStyle dashStyle, int width)\nAddChartVerticalLine(string name, DateTime time, Color color, DashStyle dashStyle, int width)",
            "title": "Verwendung"
        },
        {
            "location": "/zeichenobjekte/#ruckgabewert_28",
            "text": "Ein Zeichenobjekt vom Typ IVerticalLine (Interface)",
            "title": "R\u00fcckgabewert"
        },
        {
            "location": "/zeichenobjekte/#parameter_28",
            "text": "name  Der Name eines Zeichenobjekts zur eindeutigen Identifizierung    barsAgo  Gibt an, an welchem zur\u00fcckliegenden Bar die vertikale Linie gezeichnet werden soll (0=aktueller Bar)    time  Datum/Uhrzeit des Bars, an dem die vertikale Linie gezeichnet werden soll    color  Linienfarbe    dashStyle  Linienart     DashStyle.Dash     DashStyle.DashDot     DashStyle.DashDotDot     DashStyle.Dot     DashStyle.Solid         ggf. mu\u00df     using System.Drawing.Drawing2D; mit eingebunden werden.    width  Linienst\u00e4rke",
            "title": "Parameter"
        },
        {
            "location": "/zeichenobjekte/#beispiele_5",
            "text": "// zeichnet eine vertikale Linie am Bar von vor 10 Perioden\nAddChartVerticalLine(\"MyVerticalLine-\" + ProcessingBarIndex, 10, Color.Black);",
            "title": "Beispiele"
        },
        {
            "location": "/tipps_und_tricks/",
            "text": "Tipps und Tricks\n\n\nHinweis:\n\nCode \u00c4nderungen in selbst-erstellten Indikatoren werden automatisch auf Conditions angewandt, welche den Indikator verwenden sofern diese im \"body\" von z.B. \"OnCalculate/OnBarUpdate\" durchgef\u00fchrt wurden. \u00c4nderungen von Parametern, Output Serien, etc. ben\u00f6tigen eine manuelle \u00c4nderung der Conditions.\n\n\nBar Nummerierung im Chart\n\n\nDas Beispiel zeigt die Verwendung der Plot-Methode und der Eigenschaften des \nChart\n Objekts.\n\n\n\n\nHinweis:\n\nHinweis:\nZu Demonstrationszwecken wird innerhalb des Teils \"Bar-Nummerierung\" f\u00fcr jeden Aufruf von Paint jeweils einige male new und Dispose aufgerufen.\nAus Performance-Sicht ist die L\u00f6sung im Teil \"Eigenschaften von ChartControl\" mit einer festen Variablendeklaration und den Aufrufen von Dispose in OnTermination wesentlich besser.\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Linq;\nusing System.Xml;\nusing System.Xml.Serialization;\nusing AgenaTrader.API;\nusing AgenaTrader.Custom;\nusing AgenaTrader.Plugins;\nusing AgenaTrader.Helper;\nnamespace AgenaTrader.UserCode\n{\n[Description(\"PlotSample\")]\npublic class PlotSample : UserIndicator\n{\nPen pen = new Pen(Color.Blue);\nStringFormat sf = new StringFormat();\nSolidBrush brush = new SolidBrush(Color.Black);\nFont font = new Font(\"Arial\", 10, FontStyle.Bold);\nprotected override void OnInit()\n{\nIsOverlay = true;\n}\nprotected override void OnDispose()\n{\nif (pen!=null) pen.Dispose();\nif (sf!=null) sf.Dispose();\nif (brush!=null) brush.Dispose();\nif (font!=null) font.Dispose();\n}\nprotected override void OnCalculate()\n{}\npublic override void OnPaint(Graphics g, Rectangle r, double min, double max)\n{\nif (Bars == null || Chart == null) return;\n// Eigenschaften von Chart\nstring s;\ns = \"bounds: \"+r.X.ToString()+\" \"+r.Y.ToString()+\" \"+r.Height.ToString()+\" \"+r.Width.ToString();\ng.DrawString(s, font, brush, 10, 50, sf);\ns = \"min: \"+Instrument.Round2TickSize(min).ToString()+\" max: \"+Instrument.Round2TickSize(max).ToString();\ng.DrawString(s, font, brush, 10, 70, sf);\ns = \"BarSpace: \"+Chart.BarSpace.ToString()+\" BarWidth: \"+Chart.BarWidth.ToString();\ng.DrawString(s, font, brush, 10, 90, sf);\ns = \"Bars.Count: \"+Bars.Count.ToString();\ng.DrawString(s, font, brush, 10, 110, sf);\ns = \"BarsPainted: \"+Chart.BarsPainted.ToString() + \" FirstBarPainted: \"+Chart.FirstBarPainted.ToString() + \" LastBarPainted: \"+Chart.LastBarPainted.ToString();\ng.DrawString(s, font, brush, 10, 130, sf);\ns = \"BarsVisible: \"+Chart.BarsVisible.ToString() + \" FirstBarVisible: \"+Chart.FirstBarVisible.ToString() + \" LastBarVisible: \"+Chart.LastBarVisible.ToString();\ng.DrawString(s, font, brush, 10, 150, sf);\n// Bar Nummerierung\nStringFormat _sf = new StringFormat();\nSolidBrush _brush = new SolidBrush(Color.Blue);\nFont _font = new Font(\"Arial\", 8);\nSizeF _stringSize = new SizeF();\n_sf.Alignment = StringAlignment.Center;\nfor (int i=Chart.FirstBarVisible; i<=Chart.LastBarVisible; i++)\n{\nstring text = i.ToString();\n_stringSize = g.MeasureString(text, _font);\nint x = Chart.GetXByBarIdx(Bars, i);\nint y = Chart.GetYByValue(this, High[Abs2Ago(i)] + 3*TickSize) - (int) _stringSize.Height;\ng.DrawString(text, _font, _brush, x, y, _sf);\n}\n_sf.Dispose();\n_brush.Dispose();\n_font.Dispose();\n}\nprivate int Abs2Ago(int idx)\n{\nreturn Math.Max(0,Bars.Count-idx-1-(CalculateOnClosedBar?1:0));\n}\n}\n}\n\n\n\n\nEigenes Chart-Hintergrundbild\n\n\nDurch die Plot-Methode ist es sehr leicht m\u00f6glich, dem Chart ein eigenes Hintergrundbild hinzuzuf\u00fcgen.\n\n\nDas folgende Beispiel verwendet ein Bild im JPG-Format im Hauptverzeichnis auf der Festplatte (C:).\n\n\nusing System;\nusing System.Drawing;\nusing AgenaTrader.Custom;\nusing AgenaTrader.Plugins;\nnamespace AgenaTrader.UserCode\n{\npublic class BackgroundPicture : UserIndicator\n{\nImage img;\nprotected override void OnStart()\n{\ntry { img = Image.FromFile(\"C:\\\\\\\\MyCar.jpg\"); } catch {}\n}\npublic override void OnPaint(Graphics g, Rectangle r, double min, double max)\n{\nif (Chart == null || img == null) return;\ng.DrawImage(img,r);\n}\n}\n}\n\n\n\n\n\n\nFile-Auswahl in den Properties\n\n\nUm in den Properties (Eigenschaften) eines Indikators eine File-Auswahl zu erm\u00f6glichen, ben\u00f6tigt man einen Typ-Converter.\n\n\nDas folgende Beispiel zeigt, wie eine Auswahl von WAV-Dateien f\u00fcr einen Alarm programmiert werden kann:\n\n\nusing System;\nusing System.IO;\nusing System.Collections;\nusing System.ComponentModel;\nusing AgenaTrader.Custom;\nusing AgenaTrader.Plugins;\nnamespace AgenaTrader.UserCode\n{\n[Description(\"File Picker Example.\")]\npublic class FilePicker : UserIndicator\n{\nprivate string _soundFile = \"Alert4.wav\";\nprivate static string _dir = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments) + @\"\\\\AgenaTrader\\\\Sounds\\\\\";\ninternal class MyConverter : TypeConverter\n{\npublic override bool GetStandardValuesSupported(ITypeDescriptorContext context)\n{\nreturn true;\n}\npublic override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)\n{\nif (context == null) return null;\nArrayList list = new ArrayList();\nDirectoryInfo dir = new DirectoryInfo(_dir);\nFileInfo[] files = dir.GetFiles(\"*.wav\");\nforeach (FileInfo file in files) list.Add(file.Name);\nreturn new TypeConverter.StandardValuesCollection(list);\n}\n}\nprotected override void OnStart()\n{\nPlaySound(_soundFile);\n}\n[Description(\"Choose file to play.\")]\n[Category (\"Sound\")]\n[TypeConverter(typeof(MyConverter))]\npublic string SoundFile\n{\nget { return _soundFile; }\nset { _soundFile = value; }\n}\n}\n}\n\n\n\n\nFormatieren von Zahlen\n\n\nFormatieren von Zahlen\n\n\nGenerelles zur Formatierung in C#\n\n\ndouble d = 123.4567890;\nPrint(\"Ohne Formatierung : \" + d.ToString()); // 123.456789\nPrint(\"als W\u00e4hrung : \" + d.ToString(\"C\")); // 123.46 \u20ac\nPrint(\"Exponential : \" + d.ToString(\"E\")); // 1.234568E+002\nPrint(\"als Festkommazahl : \" + d.ToString(\"F2\")); // 123.46\nPrint(\"Generell : \" + d.ToString(\"G\")); // 123.456789\nPrint(\"als Prozentzahl : \" + d.ToString(\"P0\")); // 12.346%\nPrint(\"Tmit 2 Nachkommastellen : \" + d.ToString(\"N2\")); // 123.45\nPrint(\"mit 3 Nachkommastellen : \" + d.ToString(\"N3\")); // 123.457\nPrint(\"mit 4 Nachkommastellen : \" + d.ToString(\"N4\")); // 123.4568\n\n\n\n\nN\u00fctzliche Funktionen\n\n\nLiefert das W\u00e4hrungssymbol des aktuellen Instruments:\n\n\npublic string getWaehrungssymbol() {\nstring s = \"\";\nswitch (Instrument.Currency) {\ncase Currencies.USD : s = \"$\"; break;\ncase Currencies.EUR : s = \"\u20ac\"; break;\ncase Currencies.CHF : s = \"CHF\"; break;\ncase Currencies.GBP : s = ((char)163).ToString(); break;\ncase Currencies.JPY : s = ((char)165).ToString(); break;\n}\nreturn s;\n}\n\n\n\n\nWandelt eine Zahl in eine W\u00e4hrung mit Tausendertrennung und 2 Nachkommastellen um\nDas Tausendertrennzeichen ist abh\u00e4ngig von eingestellter \"Culture\".\n\n\npublic string getWaehrungOhneSymbol(double d) {\n// Tausender Trennzeichen (abh. von eingestellter Culture) und 2 Nachkommastellen\nreturn d.ToString(\"\\#,\\#\\#0.00\");\n}\n\n\n\n\nWandelt eine Zahl in eine W\u00e4hrung mit Tausendertrennung, 2 Nachkommastellen und einem W\u00e4hrungssymbol um.\n\n\npublic string getWaehrungMitSymbol(double d) {\n// Dollar wird vorangestellt. Alles andere kommt hintendran\nstring s=getWaehrungOhneSymbol(d);\nstring w=getWaehrungssymbol();\nif (w==\"$\") s=w+\" \"+s; else s+=\" \"+w;\nreturn s;\n}\n\n\n\n\nWandelt eine Zahl in eine W\u00e4hrung mit Tausendertrennung, 2 Nachkommastellen und einem W\u00e4hrungssymbol um und f\u00fcllt bis zu einer festen L\u00e4nge mit f\u00fchrenden Leerzeichen auf.\nDiese Funktion ist sehr gut f\u00fcr eine tabellarische Ausgabe geeignet.\n\n\npublic string getWaehrungMitSymbol(double d, int Laenge) {\n// fuehrende Leerzeichen bis feste Laenge erreicht ist\nstring s=getWaehrungMitSymbol(d);\nfor (int i=s.Length; i<Laenge; i++) s=\" \"+s;\nreturn s;\n}\n\n\n\n\nWandelt eine Zahl in eine Prozentangabe um. Es wird nicht gerechnet, nur formatiert.\nF\u00fchrendes Pluszeichen, eine Nachkommastelle und Prozentzeichen\n\n\npublic string getPercent(double d) {\nd=Math.Round(d, 1);\nstring s=(d>0)?\"+\":\"\"; // Leading plus sign\nreturn s+d.ToString(\"0.0\")+\"%\";\n}\n\n\n\n\nFormatiert einen Kurswert in Abh\u00e4ngigkeit von der Anzahl der Nachkommastellen, in der der Wert notiert wird.\nMit Tausendertrennzeichen und fester L\u00e4nge, d.h. es wird auch rechts ggf. mit Nullen aufgef\u00fcllt.\nWegen der Verwendung von CultureInfo mu\u00df der NameSpace  \nSystem.Globalization\n  eingebunden sein.\n\n\npublic string format(double d)\n{\nint tickLength = 0;\n// ticksize.ToString() ist z.B. bei 6J = \"1E-06\" und Length ist dann 5\n// und nicht richtigerweise 8 wie bei \"0,000001\")\nif (TickSize < 1) tickLength = TickSize.ToString(\"0.\\#\\#\\#\\#\\#\\#\\#\\#\\#\\#\\#\").Length - 2;\nstring f = \"{0:n\"+tickLength.ToString()+\"}\";\nreturn string.Format(CultureInfo.CurrentCulture, f, d);\n}\n\n\n\n\nBeispiele\n\n\ndouble profit = 1234.567890;\nPrint(\"getCurrencyWithoutSymbol \": + getWaehrungOhneSymbol(Gewinn)); // 1234.57\nPrint(\"getCurrencyWithSymbol :\" + getWaehrungMitSymbol(Gewinn)); // $ 1,234.57\nPrint(\"getCurrencyWithSymbol :\" + getWaehrungMitSymbol(Gewinn)); // $ 1,234.57\ndouble percentage profit = 12.3456789;\nPrint(\"getPercent :\" + getPercent(ProzGewinn)); // +12.3%\ndouble price = 123.4567;\nPrint(\"getPrice :\" + getKurs(Kurs)); // 123.46\n\n\n\n\nIndex-Convertierung\n\n\nEs gibt 2 Arten der Indizierung in AgenaTrader.\n\n\n\n\n\n\nDie Bars werden vom j\u00fcngsten zum \u00e4ltesten Bar nummeriert.\nDiese Art wird in der OnBarUpdate()-Methode verwenden.\nDer jeweils letzte Bar bekommt den Index 0, der \u00e4lteste hat den Index Bars.Count-1.\n\n\n\n\n\n\nDie Bars werden vom \u00e4ltesten zum j\u00fcngsten Bar nummeriert.\nDiese Art wird h\u00e4ufig in der OnPaint()-Methode in for-Schleifen verwendet.\nDer \u00e4lteste Bar bekommt den Index 0, der j\u00fcngste Bar hat den Index Bars.Count-1.\n\n\n\n\n\n\nDie folgende Funktion kann zur Umrechnung der Index-Arten verwendet werden:\n\n\nprivate int Convert(int idx)\n{\nreturn Math.Max(0,Bars.Count-idx-1-(CalculateOnClosedBar?1:0));\n}\n\n\n\n\nIndikatornamen \u00fcberschreiben\n\n\nDer Namen des Indikators (bzw. einer Strategie), der im Eigenschaftendialog und am oberen Rand des Charts angezeigt wird. Verwenden Sie die ToString() Methode und die Eigenschaft DisplayName, um sie zu \u00fcberschreiben.\n\n\npublic override string ToString()\n{\nreturn \"My Name\";\n}\n\n\n\n\npublic override string DisplayName\n     {\n         get\n         {\n            return \"My Name\";\n         }\n     }\n\n\n\n\nHinweis:\n\nVerwenden Sie immer beide Methoden in Ihren Skripts, um sicherzustellen, dass Ihr spezieller Name auf allen AgenaTrader-Formularen verwendet wird.\n\n\nRechteck mit abgerundeten Ecken\n\n\nDurch die Verwendung der Graphics Methoden k\u00f6nnen sehr interessante Formen in einen Chart gezeichnet werden.\nEin Beispiel hierf\u00fcr ist die Klasse RoundedRectangle, die Rechtecke mit abgerundeten Ecken zeichnet.\nDas Ergebnis sieht sehr viel \"moderner\" aus, als ein klassisches Rectangle.\n\n\n\n\nExample Code:\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Linq;\nusing System.Xml;\nusing System.Xml.Serialization;\nusing System.Drawing.Drawing2D;\nusing AgenaTrader.API;\nusing AgenaTrader.Custom;\nusing AgenaTrader.Plugins;\nnamespace AgenaTrader.UserCode\n{\n[Description(\"Demo of RoundedRectangles\")]\npublic class DemoRoundedRectangle : UserIndicator\n{\nprotected override void OnInit()\n{\nIsOverlay = true;\n}\nprotected override void OnCalculate() {}\npublic override void OnPaint(Graphics g, Rectangle r, double min, double max)\n{\nGraphicsPath path;\n// zeichnet ein Rechteck mit abgerundeten Ecken\npath = RoundedRectangle.Create(30, 50, 100, 100,8);\ng.DrawPath(Pens.Black, path);\n// zeichnet ein ausgef\u00fclltes Rechteck mit Radius 20\n // abgerundet sind nur die linke obere und rechte untere Ecke\npath = RoundedRectangle.Create(160, 50, 100, 100, 20,\nRoundedRectangle.RectangleCorners.TopLeft|RoundedRectangle.RectangleCorners.BottomRight);\ng.FillPath(Brushes.Orange, path);\n}\n}\npublic abstract class RoundedRectangle\n{\npublic enum RectangleCorners\n{\nNone = 0, TopLeft = 1, TopRight = 2, BottomLeft = 4, BottomRight = 8,\nAll = TopLeft | TopRight | BottomLeft | BottomRight\n}\npublic static GraphicsPath Create(int x, int y, int width, int height, int radius, RectangleCorners corners)\n{\nRectangle r = new Rectangle(x,y,width, height);\nRectangle tlc = new Rectangle(r.Left, r.Top,Math.Min(2 * radius, r.Width),Math.Min(2 * radius, r.Height));\nRectangle trc = tlc;\ntrc.X = r.Right - 2 * radius;\nRectangle blc = tlc;\nblc.Y = r.Bottom - 2 * radius;\nRectangle brc = blc;\nbrc.X = r.Right - 2 * radius;\nPoint[] n = new Point[]\n{\nnew Point(tlc.Left, tlc.Bottom), tlc.Location,\nnew Point(tlc.Right, tlc.Top), trc.Location,\nnew Point(trc.Right, trc.Top),\nnew Point(trc.Right, trc.Bottom),\nnew Point(brc.Right, brc.Top),\nnew Point(brc.Right, brc.Bottom),\nnew Point(brc.Left, brc.Bottom),\nnew Point(blc.Right, blc.Bottom),\nnew Point(blc.Left, blc.Bottom), blc.Location\n};\nGraphicsPath p = new GraphicsPath();\np.StartFigure();\n//Top left corner\nif ((RectangleCorners.TopLeft & corners) == RectangleCorners.TopLeft)\np.AddArc(tlc, 180, 90);\nelse\np.AddLines(new Point[] { n[0], n[1], n[2] });\n//Top edge\np.AddLine(n[2], n[3]);\n//Top right corner\nif ((RectangleCorners.TopRight & corners) == RectangleCorners.TopRight)\np.AddArc(trc, 270, 90);\nelse\np.AddLines(new Point[] { n[3], n[4], n[5] });\n//Right edge\np.AddLine(n[5], n[6]);\n//Bottom right corner\nif ((RectangleCorners.BottomRight & corners) == RectangleCorners.BottomRight)\np.AddArc(brc, 0, 90);\nelse\np.AddLines(new Point[] { n[6], n[7], n[8] });\n//Bottom edge\np.AddLine(n[8], n[9]);\n//Bottom left corner\nif ((RectangleCorners.BottomLeft & corners) == RectangleCorners.BottomLeft)\np.AddArc(blc, 90, 90);\nelse\np.AddLines(new Point[] { n[9], n[10], n[11] });\n//Left edge\np.AddLine(n[11], n[0]);\np.CloseFigure();\nreturn p;\n}\npublic static GraphicsPath Create(Rectangle rect, int radius, RectangleCorners c)\n{ return Create(rect.X, rect.Y, rect.Width, rect.Height, Math.Max(1,radius), c); }\npublic static GraphicsPath Create(int x, int y, int width, int height, int radius)\n{ return Create(x, y, width, height, Math.Max(1,radius), RectangleCorners.All); }\npublic static GraphicsPath Create(Rectangle rect, int radius)\n{ return Create(rect.X, rect.Y, rect.Width, rect.Height, Math.Max(1,radius)); }\npublic static GraphicsPath Create(int x, int y, int width, int height)\n{ return Create(x, y, width, height, 8); }\npublic static GraphicsPath Create(Rectangle rect)\n{ return Create(rect.X, rect.Y, rect.Width, rect.Height); }\n}\n}",
            "title": "Tipps und Tricks"
        },
        {
            "location": "/tipps_und_tricks/#tipps-und-tricks",
            "text": "Hinweis: \nCode \u00c4nderungen in selbst-erstellten Indikatoren werden automatisch auf Conditions angewandt, welche den Indikator verwenden sofern diese im \"body\" von z.B. \"OnCalculate/OnBarUpdate\" durchgef\u00fchrt wurden. \u00c4nderungen von Parametern, Output Serien, etc. ben\u00f6tigen eine manuelle \u00c4nderung der Conditions.",
            "title": "Tipps und Tricks"
        },
        {
            "location": "/tipps_und_tricks/#bar-nummerierung-im-chart",
            "text": "Das Beispiel zeigt die Verwendung der Plot-Methode und der Eigenschaften des  Chart  Objekts.   Hinweis: \nHinweis:\nZu Demonstrationszwecken wird innerhalb des Teils \"Bar-Nummerierung\" f\u00fcr jeden Aufruf von Paint jeweils einige male new und Dispose aufgerufen.\nAus Performance-Sicht ist die L\u00f6sung im Teil \"Eigenschaften von ChartControl\" mit einer festen Variablendeklaration und den Aufrufen von Dispose in OnTermination wesentlich besser.  using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Linq;\nusing System.Xml;\nusing System.Xml.Serialization;\nusing AgenaTrader.API;\nusing AgenaTrader.Custom;\nusing AgenaTrader.Plugins;\nusing AgenaTrader.Helper;\nnamespace AgenaTrader.UserCode\n{\n[Description(\"PlotSample\")]\npublic class PlotSample : UserIndicator\n{\nPen pen = new Pen(Color.Blue);\nStringFormat sf = new StringFormat();\nSolidBrush brush = new SolidBrush(Color.Black);\nFont font = new Font(\"Arial\", 10, FontStyle.Bold);\nprotected override void OnInit()\n{\nIsOverlay = true;\n}\nprotected override void OnDispose()\n{\nif (pen!=null) pen.Dispose();\nif (sf!=null) sf.Dispose();\nif (brush!=null) brush.Dispose();\nif (font!=null) font.Dispose();\n}\nprotected override void OnCalculate()\n{}\npublic override void OnPaint(Graphics g, Rectangle r, double min, double max)\n{\nif (Bars == null || Chart == null) return;\n// Eigenschaften von Chart\nstring s;\ns = \"bounds: \"+r.X.ToString()+\" \"+r.Y.ToString()+\" \"+r.Height.ToString()+\" \"+r.Width.ToString();\ng.DrawString(s, font, brush, 10, 50, sf);\ns = \"min: \"+Instrument.Round2TickSize(min).ToString()+\" max: \"+Instrument.Round2TickSize(max).ToString();\ng.DrawString(s, font, brush, 10, 70, sf);\ns = \"BarSpace: \"+Chart.BarSpace.ToString()+\" BarWidth: \"+Chart.BarWidth.ToString();\ng.DrawString(s, font, brush, 10, 90, sf);\ns = \"Bars.Count: \"+Bars.Count.ToString();\ng.DrawString(s, font, brush, 10, 110, sf);\ns = \"BarsPainted: \"+Chart.BarsPainted.ToString() + \" FirstBarPainted: \"+Chart.FirstBarPainted.ToString() + \" LastBarPainted: \"+Chart.LastBarPainted.ToString();\ng.DrawString(s, font, brush, 10, 130, sf);\ns = \"BarsVisible: \"+Chart.BarsVisible.ToString() + \" FirstBarVisible: \"+Chart.FirstBarVisible.ToString() + \" LastBarVisible: \"+Chart.LastBarVisible.ToString();\ng.DrawString(s, font, brush, 10, 150, sf);\n// Bar Nummerierung\nStringFormat _sf = new StringFormat();\nSolidBrush _brush = new SolidBrush(Color.Blue);\nFont _font = new Font(\"Arial\", 8);\nSizeF _stringSize = new SizeF();\n_sf.Alignment = StringAlignment.Center;\nfor (int i=Chart.FirstBarVisible; i<=Chart.LastBarVisible; i++)\n{\nstring text = i.ToString();\n_stringSize = g.MeasureString(text, _font);\nint x = Chart.GetXByBarIdx(Bars, i);\nint y = Chart.GetYByValue(this, High[Abs2Ago(i)] + 3*TickSize) - (int) _stringSize.Height;\ng.DrawString(text, _font, _brush, x, y, _sf);\n}\n_sf.Dispose();\n_brush.Dispose();\n_font.Dispose();\n}\nprivate int Abs2Ago(int idx)\n{\nreturn Math.Max(0,Bars.Count-idx-1-(CalculateOnClosedBar?1:0));\n}\n}\n}",
            "title": "Bar Nummerierung im Chart"
        },
        {
            "location": "/tipps_und_tricks/#eigenes-chart-hintergrundbild",
            "text": "Durch die Plot-Methode ist es sehr leicht m\u00f6glich, dem Chart ein eigenes Hintergrundbild hinzuzuf\u00fcgen.  Das folgende Beispiel verwendet ein Bild im JPG-Format im Hauptverzeichnis auf der Festplatte (C:).  using System;\nusing System.Drawing;\nusing AgenaTrader.Custom;\nusing AgenaTrader.Plugins;\nnamespace AgenaTrader.UserCode\n{\npublic class BackgroundPicture : UserIndicator\n{\nImage img;\nprotected override void OnStart()\n{\ntry { img = Image.FromFile(\"C:\\\\\\\\MyCar.jpg\"); } catch {}\n}\npublic override void OnPaint(Graphics g, Rectangle r, double min, double max)\n{\nif (Chart == null || img == null) return;\ng.DrawImage(img,r);\n}\n}\n}",
            "title": "Eigenes Chart-Hintergrundbild"
        },
        {
            "location": "/tipps_und_tricks/#file-auswahl-in-den-properties",
            "text": "Um in den Properties (Eigenschaften) eines Indikators eine File-Auswahl zu erm\u00f6glichen, ben\u00f6tigt man einen Typ-Converter.  Das folgende Beispiel zeigt, wie eine Auswahl von WAV-Dateien f\u00fcr einen Alarm programmiert werden kann:  using System;\nusing System.IO;\nusing System.Collections;\nusing System.ComponentModel;\nusing AgenaTrader.Custom;\nusing AgenaTrader.Plugins;\nnamespace AgenaTrader.UserCode\n{\n[Description(\"File Picker Example.\")]\npublic class FilePicker : UserIndicator\n{\nprivate string _soundFile = \"Alert4.wav\";\nprivate static string _dir = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments) + @\"\\\\AgenaTrader\\\\Sounds\\\\\";\ninternal class MyConverter : TypeConverter\n{\npublic override bool GetStandardValuesSupported(ITypeDescriptorContext context)\n{\nreturn true;\n}\npublic override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)\n{\nif (context == null) return null;\nArrayList list = new ArrayList();\nDirectoryInfo dir = new DirectoryInfo(_dir);\nFileInfo[] files = dir.GetFiles(\"*.wav\");\nforeach (FileInfo file in files) list.Add(file.Name);\nreturn new TypeConverter.StandardValuesCollection(list);\n}\n}\nprotected override void OnStart()\n{\nPlaySound(_soundFile);\n}\n[Description(\"Choose file to play.\")]\n[Category (\"Sound\")]\n[TypeConverter(typeof(MyConverter))]\npublic string SoundFile\n{\nget { return _soundFile; }\nset { _soundFile = value; }\n}\n}\n}",
            "title": "File-Auswahl in den Properties"
        },
        {
            "location": "/tipps_und_tricks/#formatieren-von-zahlen",
            "text": "",
            "title": "Formatieren von Zahlen"
        },
        {
            "location": "/tipps_und_tricks/#formatieren-von-zahlen_1",
            "text": "Generelles zur Formatierung in C#  double d = 123.4567890;\nPrint(\"Ohne Formatierung : \" + d.ToString()); // 123.456789\nPrint(\"als W\u00e4hrung : \" + d.ToString(\"C\")); // 123.46 \u20ac\nPrint(\"Exponential : \" + d.ToString(\"E\")); // 1.234568E+002\nPrint(\"als Festkommazahl : \" + d.ToString(\"F2\")); // 123.46\nPrint(\"Generell : \" + d.ToString(\"G\")); // 123.456789\nPrint(\"als Prozentzahl : \" + d.ToString(\"P0\")); // 12.346%\nPrint(\"Tmit 2 Nachkommastellen : \" + d.ToString(\"N2\")); // 123.45\nPrint(\"mit 3 Nachkommastellen : \" + d.ToString(\"N3\")); // 123.457\nPrint(\"mit 4 Nachkommastellen : \" + d.ToString(\"N4\")); // 123.4568",
            "title": "Formatieren von Zahlen"
        },
        {
            "location": "/tipps_und_tricks/#nutzliche-funktionen",
            "text": "Liefert das W\u00e4hrungssymbol des aktuellen Instruments:  public string getWaehrungssymbol() {\nstring s = \"\";\nswitch (Instrument.Currency) {\ncase Currencies.USD : s = \"$\"; break;\ncase Currencies.EUR : s = \"\u20ac\"; break;\ncase Currencies.CHF : s = \"CHF\"; break;\ncase Currencies.GBP : s = ((char)163).ToString(); break;\ncase Currencies.JPY : s = ((char)165).ToString(); break;\n}\nreturn s;\n}  Wandelt eine Zahl in eine W\u00e4hrung mit Tausendertrennung und 2 Nachkommastellen um\nDas Tausendertrennzeichen ist abh\u00e4ngig von eingestellter \"Culture\".  public string getWaehrungOhneSymbol(double d) {\n// Tausender Trennzeichen (abh. von eingestellter Culture) und 2 Nachkommastellen\nreturn d.ToString(\"\\#,\\#\\#0.00\");\n}  Wandelt eine Zahl in eine W\u00e4hrung mit Tausendertrennung, 2 Nachkommastellen und einem W\u00e4hrungssymbol um.  public string getWaehrungMitSymbol(double d) {\n// Dollar wird vorangestellt. Alles andere kommt hintendran\nstring s=getWaehrungOhneSymbol(d);\nstring w=getWaehrungssymbol();\nif (w==\"$\") s=w+\" \"+s; else s+=\" \"+w;\nreturn s;\n}  Wandelt eine Zahl in eine W\u00e4hrung mit Tausendertrennung, 2 Nachkommastellen und einem W\u00e4hrungssymbol um und f\u00fcllt bis zu einer festen L\u00e4nge mit f\u00fchrenden Leerzeichen auf.\nDiese Funktion ist sehr gut f\u00fcr eine tabellarische Ausgabe geeignet.  public string getWaehrungMitSymbol(double d, int Laenge) {\n// fuehrende Leerzeichen bis feste Laenge erreicht ist\nstring s=getWaehrungMitSymbol(d);\nfor (int i=s.Length; i<Laenge; i++) s=\" \"+s;\nreturn s;\n}  Wandelt eine Zahl in eine Prozentangabe um. Es wird nicht gerechnet, nur formatiert.\nF\u00fchrendes Pluszeichen, eine Nachkommastelle und Prozentzeichen  public string getPercent(double d) {\nd=Math.Round(d, 1);\nstring s=(d>0)?\"+\":\"\"; // Leading plus sign\nreturn s+d.ToString(\"0.0\")+\"%\";\n}  Formatiert einen Kurswert in Abh\u00e4ngigkeit von der Anzahl der Nachkommastellen, in der der Wert notiert wird.\nMit Tausendertrennzeichen und fester L\u00e4nge, d.h. es wird auch rechts ggf. mit Nullen aufgef\u00fcllt.\nWegen der Verwendung von CultureInfo mu\u00df der NameSpace   System.Globalization   eingebunden sein.  public string format(double d)\n{\nint tickLength = 0;\n// ticksize.ToString() ist z.B. bei 6J = \"1E-06\" und Length ist dann 5\n// und nicht richtigerweise 8 wie bei \"0,000001\")\nif (TickSize < 1) tickLength = TickSize.ToString(\"0.\\#\\#\\#\\#\\#\\#\\#\\#\\#\\#\\#\").Length - 2;\nstring f = \"{0:n\"+tickLength.ToString()+\"}\";\nreturn string.Format(CultureInfo.CurrentCulture, f, d);\n}",
            "title": "N\u00fctzliche Funktionen"
        },
        {
            "location": "/tipps_und_tricks/#beispiele",
            "text": "double profit = 1234.567890;\nPrint(\"getCurrencyWithoutSymbol \": + getWaehrungOhneSymbol(Gewinn)); // 1234.57\nPrint(\"getCurrencyWithSymbol :\" + getWaehrungMitSymbol(Gewinn)); // $ 1,234.57\nPrint(\"getCurrencyWithSymbol :\" + getWaehrungMitSymbol(Gewinn)); // $ 1,234.57\ndouble percentage profit = 12.3456789;\nPrint(\"getPercent :\" + getPercent(ProzGewinn)); // +12.3%\ndouble price = 123.4567;\nPrint(\"getPrice :\" + getKurs(Kurs)); // 123.46",
            "title": "Beispiele"
        },
        {
            "location": "/tipps_und_tricks/#index-convertierung",
            "text": "Es gibt 2 Arten der Indizierung in AgenaTrader.    Die Bars werden vom j\u00fcngsten zum \u00e4ltesten Bar nummeriert.\nDiese Art wird in der OnBarUpdate()-Methode verwenden.\nDer jeweils letzte Bar bekommt den Index 0, der \u00e4lteste hat den Index Bars.Count-1.    Die Bars werden vom \u00e4ltesten zum j\u00fcngsten Bar nummeriert.\nDiese Art wird h\u00e4ufig in der OnPaint()-Methode in for-Schleifen verwendet.\nDer \u00e4lteste Bar bekommt den Index 0, der j\u00fcngste Bar hat den Index Bars.Count-1.    Die folgende Funktion kann zur Umrechnung der Index-Arten verwendet werden:  private int Convert(int idx)\n{\nreturn Math.Max(0,Bars.Count-idx-1-(CalculateOnClosedBar?1:0));\n}",
            "title": "Index-Convertierung"
        },
        {
            "location": "/tipps_und_tricks/#indikatornamen-uberschreiben",
            "text": "Der Namen des Indikators (bzw. einer Strategie), der im Eigenschaftendialog und am oberen Rand des Charts angezeigt wird. Verwenden Sie die ToString() Methode und die Eigenschaft DisplayName, um sie zu \u00fcberschreiben.  public override string ToString()\n{\nreturn \"My Name\";\n}  public override string DisplayName\n     {\n         get\n         {\n            return \"My Name\";\n         }\n     }  Hinweis: \nVerwenden Sie immer beide Methoden in Ihren Skripts, um sicherzustellen, dass Ihr spezieller Name auf allen AgenaTrader-Formularen verwendet wird.",
            "title": "Indikatornamen \u00fcberschreiben"
        },
        {
            "location": "/tipps_und_tricks/#rechteck-mit-abgerundeten-ecken",
            "text": "Durch die Verwendung der Graphics Methoden k\u00f6nnen sehr interessante Formen in einen Chart gezeichnet werden.\nEin Beispiel hierf\u00fcr ist die Klasse RoundedRectangle, die Rechtecke mit abgerundeten Ecken zeichnet.\nDas Ergebnis sieht sehr viel \"moderner\" aus, als ein klassisches Rectangle.   Example Code:\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Linq;\nusing System.Xml;\nusing System.Xml.Serialization;\nusing System.Drawing.Drawing2D;\nusing AgenaTrader.API;\nusing AgenaTrader.Custom;\nusing AgenaTrader.Plugins;\nnamespace AgenaTrader.UserCode\n{\n[Description(\"Demo of RoundedRectangles\")]\npublic class DemoRoundedRectangle : UserIndicator\n{\nprotected override void OnInit()\n{\nIsOverlay = true;\n}\nprotected override void OnCalculate() {}\npublic override void OnPaint(Graphics g, Rectangle r, double min, double max)\n{\nGraphicsPath path;\n// zeichnet ein Rechteck mit abgerundeten Ecken\npath = RoundedRectangle.Create(30, 50, 100, 100,8);\ng.DrawPath(Pens.Black, path);\n// zeichnet ein ausgef\u00fclltes Rechteck mit Radius 20\n // abgerundet sind nur die linke obere und rechte untere Ecke\npath = RoundedRectangle.Create(160, 50, 100, 100, 20,\nRoundedRectangle.RectangleCorners.TopLeft|RoundedRectangle.RectangleCorners.BottomRight);\ng.FillPath(Brushes.Orange, path);\n}\n}\npublic abstract class RoundedRectangle\n{\npublic enum RectangleCorners\n{\nNone = 0, TopLeft = 1, TopRight = 2, BottomLeft = 4, BottomRight = 8,\nAll = TopLeft | TopRight | BottomLeft | BottomRight\n}\npublic static GraphicsPath Create(int x, int y, int width, int height, int radius, RectangleCorners corners)\n{\nRectangle r = new Rectangle(x,y,width, height);\nRectangle tlc = new Rectangle(r.Left, r.Top,Math.Min(2 * radius, r.Width),Math.Min(2 * radius, r.Height));\nRectangle trc = tlc;\ntrc.X = r.Right - 2 * radius;\nRectangle blc = tlc;\nblc.Y = r.Bottom - 2 * radius;\nRectangle brc = blc;\nbrc.X = r.Right - 2 * radius;\nPoint[] n = new Point[]\n{\nnew Point(tlc.Left, tlc.Bottom), tlc.Location,\nnew Point(tlc.Right, tlc.Top), trc.Location,\nnew Point(trc.Right, trc.Top),\nnew Point(trc.Right, trc.Bottom),\nnew Point(brc.Right, brc.Top),\nnew Point(brc.Right, brc.Bottom),\nnew Point(brc.Left, brc.Bottom),\nnew Point(blc.Right, blc.Bottom),\nnew Point(blc.Left, blc.Bottom), blc.Location\n};\nGraphicsPath p = new GraphicsPath();\np.StartFigure();\n//Top left corner\nif ((RectangleCorners.TopLeft & corners) == RectangleCorners.TopLeft)\np.AddArc(tlc, 180, 90);\nelse\np.AddLines(new Point[] { n[0], n[1], n[2] });\n//Top edge\np.AddLine(n[2], n[3]);\n//Top right corner\nif ((RectangleCorners.TopRight & corners) == RectangleCorners.TopRight)\np.AddArc(trc, 270, 90);\nelse\np.AddLines(new Point[] { n[3], n[4], n[5] });\n//Right edge\np.AddLine(n[5], n[6]);\n//Bottom right corner\nif ((RectangleCorners.BottomRight & corners) == RectangleCorners.BottomRight)\np.AddArc(brc, 0, 90);\nelse\np.AddLines(new Point[] { n[6], n[7], n[8] });\n//Bottom edge\np.AddLine(n[8], n[9]);\n//Bottom left corner\nif ((RectangleCorners.BottomLeft & corners) == RectangleCorners.BottomLeft)\np.AddArc(blc, 90, 90);\nelse\np.AddLines(new Point[] { n[9], n[10], n[11] });\n//Left edge\np.AddLine(n[11], n[0]);\np.CloseFigure();\nreturn p;\n}\npublic static GraphicsPath Create(Rectangle rect, int radius, RectangleCorners c)\n{ return Create(rect.X, rect.Y, rect.Width, rect.Height, Math.Max(1,radius), c); }\npublic static GraphicsPath Create(int x, int y, int width, int height, int radius)\n{ return Create(x, y, width, height, Math.Max(1,radius), RectangleCorners.All); }\npublic static GraphicsPath Create(Rectangle rect, int radius)\n{ return Create(rect.X, rect.Y, rect.Width, rect.Height, Math.Max(1,radius)); }\npublic static GraphicsPath Create(int x, int y, int width, int height)\n{ return Create(x, y, width, height, 8); }\npublic static GraphicsPath Create(Rectangle rect)\n{ return Create(rect.X, rect.Y, rect.Width, rect.Height); }\n}\n}",
            "title": "Rechteck mit abgerundeten Ecken"
        }
    ]
}