{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Die folgende API-Dokumentation ben\u00f6tigt AgenaTrader in der Version 2.0.1.x AgenaScript ist eine in die Handelsplattform AgenaTrader integrierte Programmiersprache. Die Syntax von AgenaScript ist von der Programmiersprache C# abgeleitet. Mit AgenaScript k\u00f6nnen alle Anliegen umgesetzt werden, die z.B. f\u00fcr den Condition Escort zu komplex sind. Das Spektrum reicht von der Programmierung eines einfachen Indikators bis hin zu eigenen Applikationen, bei denen AgenaTrader sozusagen nur noch im Hintergrund ben\u00f6tigt wird. Generell sind alle Dinge umsetzbar, die auch in DotNet realisierbar sind: Indikatoren fast beliebiger Komplexit\u00e4t, Signalanzeige, Excel-Export, Auswertungen, Chartanzeigen, Sound, Farben uvm. Information contained in this help document: Ereignisse AgenaScript arbeitet ereignisorientiert. Wenn z.B. eine Kerze in einer Zeiteinheit abgeschlossen ist und eine neue Kerze beginnt, ist dies ein Ereignis. Wenn neue Kurse vom Datenanbieter geliefert werden oder eine Order vom Broker ausgef\u00fchrt wird, immer handelt es sich um Ereignisse. Mit AgenaScript k\u00f6nnen Sie auf alle diese Ereignisse reagieren. Wie dies genau funktioniert und welche Ereignisse es gibt, ist Gegenstand dieses Abschnitts. Schl\u00fcsselworte Wie jede Programmiersprache besitzt auch AgenaTrader einen Satz von Befehlen, die Sie in eigenen Scripts verwenden k\u00f6nnen. Mit diesen sog. Schl\u00fcsselworten sollten Sie gut vertraut sein, wenn Sie Ihre eignenen Indikatoren bzw. Handelssysteme erstellen m\u00f6chten. Strategieprogrammierung Mit AgenaScript ist es m\u00f6glich, eigene Handelsstrategien zu erstellen um diese live im Markt handeln zu lassen. Welche Voraussetzungen dazu notwendig sind und wie Orders an den Broker \u00fcbergeben und intern verwaltet werden, erfahren Sie hier. Tipps und Tricks In diesem Bereich werden L\u00f6sungen f\u00fcr nicht ganz allt\u00e4gliche Probleme gezeigt. Um diese Beispiele nachvollziehen zu k\u00f6nnen, ist allerdings einiges an Erfahrung in der Programmierung Voraussetzung. Der fortgeschrittene Anwender wird hier einige Dinge finden, die er in seine eigenen Programmierungen \u00fcbernehmen kann. Umgang mit Bars und Instrumenten Hier wird im Detail gezeigt, wie mit AgenaScript auf die einzelnen Bars bzw. Kerzen und auf verschiedene Handelsinstrumente zugegriffen werden kann. Zeichenobjekte Alle Zeichenobjekte, die Sie im Chart verwenden k\u00f6nnen, sind auh \u00fcber AgenaScript erreichbar. So k\u00f6nnen Sie z.B. Linien, Pfeile, Rechtecke, Kreise usw. an bestimmten Stellen im Chart automatisch anzeigen und wieder entfernen lassen. Die M\u00f6glichkeiten sind nahezu un\u00fcberschaubar.","title":"Los gehts"},{"location":"ereignisse/","text":"Ereignisse AgenaTrader ist nach der Definition der Softwaretechnik eine ereignisorientierte Applikation. Die Programmierung in AgenaTrader mit Methoden des Application Programming Interface ( API ) beruht initial auf dem \u00dcberschreiben von vordefinierten Routinen zur Ereignisbehandlung. Folgende Methoden k\u00f6nnen verwendet, d.h. \u00fcberschrieben werden: OnBrokerConnect() OnBrokerDisconnect() OnCalculate() OnChartPanelMouseDown() OnChartPanelMouseMove() OnDispose() OnLevel1() OnLevel2() OnOrderChanged() OnOrderExecution() OnStart() OnStop() OnBrokerConnect() Beschreibung Die Methode OnBrokerConnect() wird jedesmal dann aufgerufen, wenn die Verbindung zum Broker hergestellt wurde. Mit Hilfe von OnBrokerConnect() besteht die M\u00f6glichkeit, bei einem Verbindungsabbruch mit dem Broker, die bestehenden bzw. noch offenen Orders wieder der Strategie zuzuordnen und somit von dieser wieder verwalten zu lassen Siehe auch weitere Methoden zur Ereignisbehandlung unter Ereignisse . Parameter keine Verwendung protected override void OnBrokerConnect() Beispiel private IOrder _takeProfit = null; private IOrder _trailingStop = null; protected override void OnBrokerConnect() { if (Trade != null && Trade.PositionType != PositionType.Flat) { _takeProfit = Orders.FirstOrDefault(o => o.Name == this.GetType().Name && o.OrderType ==OrderType.Limit); _trailingStop = Orders.FirstOrDefault(o => o.Name == this.GetType().Name && o.OrderType ==OrderType.Stop); } } OnBrokerDisconnect() Beschreibung Die Methode OnBrokerDisconnect() wird jedesmal dann aufgerufen, wenn die Verbindung zum Broker unterbrochen wurde. Siehe auch weitere Methoden zur Ereignisbehandlung unter Ereignisse . Parameter Ein Objekt vom Typ TradingDatafeedChangedEventArgs Verwendung protected override void OnBrokerDisconnect(TradingDatafeedChangedEventArgs e) Beispiel protected override void OnBrokerDisconnect(TradingDatafeedChangedEventArgs e) { if (e.Connected) Print(\"Die Verbindung zum Broker wird getrennt.\"); else Print(\"Die Verbindung zum Broker wurde getrennt.\"); } OnCalculate() Beschreibung Die Methode OnCalculate() wird immer dann aufgerufen, wenn sich ein Bar \u00e4ndert. Abh\u00e4ngig von der Variablen CalculateOnClosedBar ,wird sie entweder bei jedem hereinkommenden Tick oder erst nach Fertigstellung eines Bars aufgerufen. OnCalculate ist die wichtigste Methode, die im Normalfall auch den gr\u00f6\u00dften Teil des Codes selbsterstellter Indikatoren bzw. Strategien enth\u00e4lt. Die Bearbeitung beginnt mit dem \u00e4ltesten Bar und l\u00e4uft bis zum j\u00fcngsten Bar im Chart. Der \u00e4lteste Bar erh\u00e4lt dabei die Nummer 0. Es wird fortlaufend weiter nummeriert. Auf diese Nummerierung kann \u00fcber die Variable ProcessingBarIndex zugegriffen werden, siehe Beispiel unten. Achtung: Diese Nummerierung unterscheidet sich vom BarIndex, siehe Bars . More information can be found here: Ereignisse . Parameter keiner Verwendung protected override void OnCalculate() Beispiel protected override void OnCalculate() { Print(\"Aufruf von OnBarUpdate f\u00fcr Bar Nr. \" + ProcessingBarIndex + \" von \" +Time[0]); } OnChartPanelMouseDown() Beschreibung In einem Indikator, oder einer Strategie, kann die aktuelle Position der Maus ausgewertet und verarbeitet werden. Daf\u00fcr ist es notwendig, dass man einen EventHandler als Methode programmiert und diese Methode anschlie\u00dfend dem Event ChartControl.ChartPanelMouseDown hinzuf\u00fcgt. Achtung! Es ist wichtig, den EventHandler innerhalb der OnDispose() Methode wieder aus dem Event zu entfernen, da sonst der EventHandler selbst dann noch ausgef\u00fchrt wird, wenn der Indikator aus dem Chart entfernt wurde! Beispiel using System; using System.Collections.Generic; using System.ComponentModel; using System.Drawing; using System.Drawing.Drawing2D; using System.Linq; using System.Xml; using System.Xml.Serialization; using AgenaTrader.API; using AgenaTrader.Custom; using AgenaTrader.Plugins; using AgenaTrader.Helper; namespace AgenaTrader.UserCode { public class ChartPanelMouseDown : UserIndicator { protected override void OnInit() { IsOverlay = true; } protected override void OnStart() { // Add event listener if (Chart != null) Chart.ChartPanelMouseDown += OnChartPanelMouseDown; } protected override void OnDispose() { // Remove event listener if (Chart != null) Chart.ChartPanelMouseDown -= OnChartPanelMouseDown; } private void OnChartPanelMouseDown(object sender,System.Windows.Forms.MouseEventArgs e) { Print(\"X = {0}, Y = {1}\", Chart.GetDateTimeByX(e.X),Chart.GetPriceByY(e.Y)); } } } OnChartPanelMouseMove() Beschreibung In einem Indikator, oder einer Strategie, kann die aktuelle Position der Maus ausgewertet und verarbeitet werden. Daf\u00fcr ist es notwendig, dass man einen EventHandler als Methode programmiert und diese Methode anschlie\u00dfend dem Event Chart.ChartPanelMouseMove hinzuf\u00fcgt. Achtung! Es ist wichtig, den EventHandler innerhalb der OnDispose() Methode wieder aus dem Event zu entfernen, da sonst der EventHandler selbst dann noch ausgef\u00fchrt wird, wenn der Indikator aus dem Chart entfernt wurde! Beispiel using System; using System.Collections.Generic; using System.ComponentModel; using System.Drawing; using System.Drawing.Drawing2D; using System.Linq; using System.Xml; using System.Xml.Serialization; using AgenaTrader.API; using AgenaTrader.Custom; using AgenaTrader.Plugins; using AgenaTrader.Helper; namespace AgenaTrader.UserCode { public class ChartPanelMouseMove : UserIndicator { protected override void OnInit() { IsOverlay = true; } protected override void OnStart() { // Add event listener if (Chart != null) Chart.ChartPanelMouseMove += OnChartPanelMouseMove; } protected override void OnDispose() { // Remove event listener if (Chart != null) Chart.ChartPanelMouseMove -= OnChartPanelMouseMove; } private void OnChartPanelMouseMove(object sender, System.Windows.Forms.MouseEventArgs e) { Print(\"X = {0}, Y = {1}\", Chart.GetDateTimeByX(e.X), Chart.GetPriceByY(e.Y)); } } } OnDispose() Beschreibung Die Methode OnDispose() kann \u00fcberschrieben werden, um alle im Script verwendeten Ressourcen wieder freizugeben. Siehe auch OnInit() und OnStart() . Siehe auch weitere Methoden zur Ereignisbehandlung unter Ereignisse . Parameter keiner Verwendung protected override void OnDispose() Weitere Informationen Achtung: Bitte \u00fcberschreiben Sie nicht die Dispose() Methode, da diese erst sehr viel sp\u00e4ter aufgerufen werden kann. Ressourcen bleiben zu lange erhalten und k\u00f6nnen zu unerwartetem und unvorhersehbarem Verhalten der gesamten Anwendung f\u00fchren. Beispiel protected override void OnDispose() { if (Window != null) { Window.Dispose(); Window = null; } } OnLevel1() Beschreibung Die Methode OnLevel1() wird bei jeder \u00c4nderung in den Level-I-Daten aufgerufen, d.h. bei einer \u00c4nderung des Bid-Preises, Ask-Preises, des Bid-Volumens, des Ask-Volumens und nat\u00fcrlich des Last-Preises nachdem ein realer Umsatz stattfand. In a multibar indicator, the ProcessingBarSeriesIndex die jeweilige Datenreihe ermittelt werden, f\u00fcr die OnLevel1() aufgerufen wurde. OnLevel1() wird nicht f\u00fcr historische Daten aufgerufen Siehe auch weitere Methoden zur Ereignisbehandlung unter Ereignisse . Hinweis zu Daten von Yahoo (YFeed) Das Feld \"LastPrice\" entspricht - wie gewohnt - je nach letztem Handelsumsatz entweder dem \"BidPrice\" oder dem \"AskPrice\". Das Feld \"MarketDataType\" ist immer \"Last\". Die Felder \"Volumen\", \"BidSize\" und \"AskSize\" sind immer 0. Verwendung protected override void OnLevel1(Level1Args e) Parameter [*Level1Args*] e Beispiel protected override void OnLevel1(Level1Args e) { Print(\"AskPrice \"+e.AskPrice); Print(\"AskSize \"+e.AskSize); Print(\"BidPrice \"+e.BidPrice); Print(\"BidSize \"+e.BidSize); Print(\"Instrument \"+e.Instrument); Print(\"LastPrice \"+e.LastPrice); Print(\"MarketDataType \"+e.MarketDataType); Print(\"Price \"+e.Price); Print(\"Time \"+e.Time); Print(\"Volume \"+e.Volume); } OnLevel2() Beschreibung Die Methode OnLevel2() wird bei jeder \u00c4nderung in den Level-II-Daten (Markttiefe) aufgerufen. In einem Multibar-Indikator kann mit ProcessingBarSeriesIndex die jeweilige Datenreihe ermittelt werden, f\u00fcr die OnMarketDepth() aufgerufen wurde. OnLevel2 wird nicht f\u00fcr historische Daten aufgerufen. Siehe auch weitere Methoden zur Ereignisbehandlung unter Ereignisse . Verwendung protected override void OnLevel2(Level2Args e) Parameter Ein Objekt von Level2Args Beispiel protected override void OnLevel2(Level2Args e) { // Ausgabe des jeweils aktuellen Ask-Kurses if (e.MarketDataType == MarketDataType.Bit) Print(\"The current bit is \" + e.Price ); } OnOrderChanged() Beschreibung Die Methode OnOrderChanged() wird jedesmal dann aufgerufen, wenn sich der Status einer durch eine Strategie verwaltete Order \u00e4ndert. Ene Status\u00e4nderung kann dabei durch die \u00c4nderung des Volumens, des Preises oder des Status an der B\u00f6rse (von working zu filled) ausgel\u00f6st werden. Es ist sichergestellt, dass diese Methode f\u00fcr alle Ereignisse in der korrekten Reihenfolge aufgerufen wird. Wichtiger Hinweis: Wenn eine Strategie durch Orderausf\u00fchrungen gesteuert werden soll, ist es ratsamer, OnOrderExecution() anstelle von OnOrderChanged() zu verwenden. Es kann sonst zu Problemen bei Teilausf\u00fchrungen kommen.. Siehe auch weitere Methoden zur Ereignisbehandlung unter Ereignisse . Parameter Ein Order-Objekt vom Type IOrder Verwendung protected override void OnOrderChanged(IOrder order) Beispiel private IOrder entry = null; protected override void OnCalculate() { if (CrossAbove(EMA(14), SMA(50), 1) && IsSerieRising(ADX(20))) entry = OpenLong(\"EMACrossesSMA\"); if (entry != null && entry == order) { if (order.OrderState == OrderState.Filled) { PlaySound(\"OrderFilled.wav\"); entryOrder = null; } } } protected override void OnOrderChanged(IOrder order) { } OnOrderExecution() Beschreibung Die Methode OnOrderExecution() wird jedesmal dann aufgerufen, wenn eine Order ausgef\u00fchrt (filled) wurde oder sich der Status einer durch eine Strategie verwaltete Order \u00e4ndert. Ene Status\u00e4nderung kann dabei durch die \u00c4nderung des Volumens, des Preises oder des Status an der B\u00f6rse (von working zu filled) ausgel\u00f6st werden. Es ist sichergestellt, dass diese Methode f\u00fcr alle Ereignisse in der korrekten Reihenfolge aufgerufen wird. OnOrderExecution() wird immer nach OnOrderChanged() aufgerufen. Siehe auch weitere Methoden zur Ereignisbehandlung unter Ereignisse . Parameter Ein execution-Objekt vom Type IExecution Verwendung protected override void OnOrderExecution(IExecution execution) Beispiel private IOrder entry = null; protected override void OnCalculate() { if (CrossAbove(EMA(14), SMA(50), 1) && IsSerieRising(ADX(20))) entry = OpenLong(\"EMACrossesSMA\"); } protected override void OnOrderExecution(IExecution execution) { // Beispiel if (entry != null && execution.Order == entry) { Print(execution.Price.ToString()); Print(execution.Order.OrderState.ToString()); } } OnStart() Beschreibung Die Methode OnStart() kann \u00fcberschrieben werden, um eigene Variablen zu initialisieren, Lizenzchecks auszuf\u00fchren, UserForms aufzurufen usw. OnStart() wird nur einmal am Beginn des Scrips nach OnInit() und vor OnCalculate() aufgerufen. Siehe auch OnDispose() . Siehe auch weitere Methoden zur Ereignisbehandlung unter Ereignisse . Parameter keiner Verwendung protected override void OnStart() Beispiel private myForm Window; protected override void OnStart() { if (Chart != null) { Window = new myForm(); Window.Show(); } } OnStop() Beschreibung Die OnStop()-Methode wird aufgerufen, sobald ein Script beendet wird. Dies kann z.B. vorkommen, wenn ein Indikator vom Chart entfernt wurde oder eine Spalte mit einem Indikator / einer gescripteten Condition vom Scanner entfernt wurde. Siehe auch OnDispose() . Siehe auch weitere Methoden zur Ereignisbehandlung unter Ereignisse . Parameter keiner Verwendung protected override void OnStop() Beispiel protected override void OnStop() { Log(\"Stop: \" + this.ToString() + \" | \" + Instrument.Symbol, InfoLogLevel.Info); }","title":"Ereignisse"},{"location":"ereignisse/#ereignisse","text":"AgenaTrader ist nach der Definition der Softwaretechnik eine ereignisorientierte Applikation. Die Programmierung in AgenaTrader mit Methoden des Application Programming Interface ( API ) beruht initial auf dem \u00dcberschreiben von vordefinierten Routinen zur Ereignisbehandlung. Folgende Methoden k\u00f6nnen verwendet, d.h. \u00fcberschrieben werden: OnBrokerConnect() OnBrokerDisconnect() OnCalculate() OnChartPanelMouseDown() OnChartPanelMouseMove() OnDispose() OnLevel1() OnLevel2() OnOrderChanged() OnOrderExecution() OnStart() OnStop()","title":"Ereignisse"},{"location":"ereignisse/#onbrokerconnect","text":"","title":"OnBrokerConnect()"},{"location":"ereignisse/#beschreibung","text":"Die Methode OnBrokerConnect() wird jedesmal dann aufgerufen, wenn die Verbindung zum Broker hergestellt wurde. Mit Hilfe von OnBrokerConnect() besteht die M\u00f6glichkeit, bei einem Verbindungsabbruch mit dem Broker, die bestehenden bzw. noch offenen Orders wieder der Strategie zuzuordnen und somit von dieser wieder verwalten zu lassen Siehe auch weitere Methoden zur Ereignisbehandlung unter Ereignisse .","title":"Beschreibung"},{"location":"ereignisse/#parameter","text":"keine","title":"Parameter"},{"location":"ereignisse/#verwendung","text":"protected override void OnBrokerConnect()","title":"Verwendung"},{"location":"ereignisse/#beispiel","text":"private IOrder _takeProfit = null; private IOrder _trailingStop = null; protected override void OnBrokerConnect() { if (Trade != null && Trade.PositionType != PositionType.Flat) { _takeProfit = Orders.FirstOrDefault(o => o.Name == this.GetType().Name && o.OrderType ==OrderType.Limit); _trailingStop = Orders.FirstOrDefault(o => o.Name == this.GetType().Name && o.OrderType ==OrderType.Stop); } }","title":"Beispiel"},{"location":"ereignisse/#onbrokerdisconnect","text":"","title":"OnBrokerDisconnect()"},{"location":"ereignisse/#beschreibung_1","text":"Die Methode OnBrokerDisconnect() wird jedesmal dann aufgerufen, wenn die Verbindung zum Broker unterbrochen wurde. Siehe auch weitere Methoden zur Ereignisbehandlung unter Ereignisse .","title":"Beschreibung"},{"location":"ereignisse/#parameter_1","text":"Ein Objekt vom Typ TradingDatafeedChangedEventArgs","title":"Parameter"},{"location":"ereignisse/#verwendung_1","text":"protected override void OnBrokerDisconnect(TradingDatafeedChangedEventArgs e)","title":"Verwendung"},{"location":"ereignisse/#beispiel_1","text":"protected override void OnBrokerDisconnect(TradingDatafeedChangedEventArgs e) { if (e.Connected) Print(\"Die Verbindung zum Broker wird getrennt.\"); else Print(\"Die Verbindung zum Broker wurde getrennt.\"); }","title":"Beispiel"},{"location":"ereignisse/#oncalculate","text":"","title":"OnCalculate()"},{"location":"ereignisse/#beschreibung_2","text":"Die Methode OnCalculate() wird immer dann aufgerufen, wenn sich ein Bar \u00e4ndert. Abh\u00e4ngig von der Variablen CalculateOnClosedBar ,wird sie entweder bei jedem hereinkommenden Tick oder erst nach Fertigstellung eines Bars aufgerufen. OnCalculate ist die wichtigste Methode, die im Normalfall auch den gr\u00f6\u00dften Teil des Codes selbsterstellter Indikatoren bzw. Strategien enth\u00e4lt. Die Bearbeitung beginnt mit dem \u00e4ltesten Bar und l\u00e4uft bis zum j\u00fcngsten Bar im Chart. Der \u00e4lteste Bar erh\u00e4lt dabei die Nummer 0. Es wird fortlaufend weiter nummeriert. Auf diese Nummerierung kann \u00fcber die Variable ProcessingBarIndex zugegriffen werden, siehe Beispiel unten. Achtung: Diese Nummerierung unterscheidet sich vom BarIndex, siehe Bars . More information can be found here: Ereignisse .","title":"Beschreibung"},{"location":"ereignisse/#parameter_2","text":"keiner","title":"Parameter"},{"location":"ereignisse/#verwendung_2","text":"protected override void OnCalculate()","title":"Verwendung"},{"location":"ereignisse/#beispiel_2","text":"protected override void OnCalculate() { Print(\"Aufruf von OnBarUpdate f\u00fcr Bar Nr. \" + ProcessingBarIndex + \" von \" +Time[0]); }","title":"Beispiel"},{"location":"ereignisse/#onchartpanelmousedown","text":"","title":"OnChartPanelMouseDown()"},{"location":"ereignisse/#beschreibung_3","text":"In einem Indikator, oder einer Strategie, kann die aktuelle Position der Maus ausgewertet und verarbeitet werden. Daf\u00fcr ist es notwendig, dass man einen EventHandler als Methode programmiert und diese Methode anschlie\u00dfend dem Event ChartControl.ChartPanelMouseDown hinzuf\u00fcgt.","title":"Beschreibung"},{"location":"ereignisse/#achtung","text":"Es ist wichtig, den EventHandler innerhalb der OnDispose() Methode wieder aus dem Event zu entfernen, da sonst der EventHandler selbst dann noch ausgef\u00fchrt wird, wenn der Indikator aus dem Chart entfernt wurde!","title":"Achtung!"},{"location":"ereignisse/#beispiel_3","text":"using System; using System.Collections.Generic; using System.ComponentModel; using System.Drawing; using System.Drawing.Drawing2D; using System.Linq; using System.Xml; using System.Xml.Serialization; using AgenaTrader.API; using AgenaTrader.Custom; using AgenaTrader.Plugins; using AgenaTrader.Helper; namespace AgenaTrader.UserCode { public class ChartPanelMouseDown : UserIndicator { protected override void OnInit() { IsOverlay = true; } protected override void OnStart() { // Add event listener if (Chart != null) Chart.ChartPanelMouseDown += OnChartPanelMouseDown; } protected override void OnDispose() { // Remove event listener if (Chart != null) Chart.ChartPanelMouseDown -= OnChartPanelMouseDown; } private void OnChartPanelMouseDown(object sender,System.Windows.Forms.MouseEventArgs e) { Print(\"X = {0}, Y = {1}\", Chart.GetDateTimeByX(e.X),Chart.GetPriceByY(e.Y)); } } }","title":"Beispiel"},{"location":"ereignisse/#onchartpanelmousemove","text":"","title":"OnChartPanelMouseMove()"},{"location":"ereignisse/#beschreibung_4","text":"In einem Indikator, oder einer Strategie, kann die aktuelle Position der Maus ausgewertet und verarbeitet werden. Daf\u00fcr ist es notwendig, dass man einen EventHandler als Methode programmiert und diese Methode anschlie\u00dfend dem Event Chart.ChartPanelMouseMove hinzuf\u00fcgt.","title":"Beschreibung"},{"location":"ereignisse/#achtung_1","text":"Es ist wichtig, den EventHandler innerhalb der OnDispose() Methode wieder aus dem Event zu entfernen, da sonst der EventHandler selbst dann noch ausgef\u00fchrt wird, wenn der Indikator aus dem Chart entfernt wurde!","title":"Achtung!"},{"location":"ereignisse/#beispiel_4","text":"using System; using System.Collections.Generic; using System.ComponentModel; using System.Drawing; using System.Drawing.Drawing2D; using System.Linq; using System.Xml; using System.Xml.Serialization; using AgenaTrader.API; using AgenaTrader.Custom; using AgenaTrader.Plugins; using AgenaTrader.Helper; namespace AgenaTrader.UserCode { public class ChartPanelMouseMove : UserIndicator { protected override void OnInit() { IsOverlay = true; } protected override void OnStart() { // Add event listener if (Chart != null) Chart.ChartPanelMouseMove += OnChartPanelMouseMove; } protected override void OnDispose() { // Remove event listener if (Chart != null) Chart.ChartPanelMouseMove -= OnChartPanelMouseMove; } private void OnChartPanelMouseMove(object sender, System.Windows.Forms.MouseEventArgs e) { Print(\"X = {0}, Y = {1}\", Chart.GetDateTimeByX(e.X), Chart.GetPriceByY(e.Y)); } } }","title":"Beispiel"},{"location":"ereignisse/#ondispose","text":"","title":"OnDispose()"},{"location":"ereignisse/#beschreibung_5","text":"Die Methode OnDispose() kann \u00fcberschrieben werden, um alle im Script verwendeten Ressourcen wieder freizugeben. Siehe auch OnInit() und OnStart() . Siehe auch weitere Methoden zur Ereignisbehandlung unter Ereignisse .","title":"Beschreibung"},{"location":"ereignisse/#parameter_3","text":"keiner","title":"Parameter"},{"location":"ereignisse/#verwendung_3","text":"protected override void OnDispose()","title":"Verwendung"},{"location":"ereignisse/#weitere-informationen","text":"Achtung: Bitte \u00fcberschreiben Sie nicht die Dispose() Methode, da diese erst sehr viel sp\u00e4ter aufgerufen werden kann. Ressourcen bleiben zu lange erhalten und k\u00f6nnen zu unerwartetem und unvorhersehbarem Verhalten der gesamten Anwendung f\u00fchren.","title":"Weitere Informationen"},{"location":"ereignisse/#beispiel_5","text":"protected override void OnDispose() { if (Window != null) { Window.Dispose(); Window = null; } }","title":"Beispiel"},{"location":"ereignisse/#onlevel1","text":"","title":"OnLevel1()"},{"location":"ereignisse/#beschreibung_6","text":"Die Methode OnLevel1() wird bei jeder \u00c4nderung in den Level-I-Daten aufgerufen, d.h. bei einer \u00c4nderung des Bid-Preises, Ask-Preises, des Bid-Volumens, des Ask-Volumens und nat\u00fcrlich des Last-Preises nachdem ein realer Umsatz stattfand. In a multibar indicator, the ProcessingBarSeriesIndex die jeweilige Datenreihe ermittelt werden, f\u00fcr die OnLevel1() aufgerufen wurde. OnLevel1() wird nicht f\u00fcr historische Daten aufgerufen Siehe auch weitere Methoden zur Ereignisbehandlung unter Ereignisse . Hinweis zu Daten von Yahoo (YFeed) Das Feld \"LastPrice\" entspricht - wie gewohnt - je nach letztem Handelsumsatz entweder dem \"BidPrice\" oder dem \"AskPrice\". Das Feld \"MarketDataType\" ist immer \"Last\". Die Felder \"Volumen\", \"BidSize\" und \"AskSize\" sind immer 0.","title":"Beschreibung"},{"location":"ereignisse/#verwendung_4","text":"protected override void OnLevel1(Level1Args e)","title":"Verwendung"},{"location":"ereignisse/#parameter_4","text":"[*Level1Args*] e","title":"Parameter"},{"location":"ereignisse/#beispiel_6","text":"protected override void OnLevel1(Level1Args e) { Print(\"AskPrice \"+e.AskPrice); Print(\"AskSize \"+e.AskSize); Print(\"BidPrice \"+e.BidPrice); Print(\"BidSize \"+e.BidSize); Print(\"Instrument \"+e.Instrument); Print(\"LastPrice \"+e.LastPrice); Print(\"MarketDataType \"+e.MarketDataType); Print(\"Price \"+e.Price); Print(\"Time \"+e.Time); Print(\"Volume \"+e.Volume); }","title":"Beispiel"},{"location":"ereignisse/#onlevel2","text":"","title":"OnLevel2()"},{"location":"ereignisse/#beschreibung_7","text":"Die Methode OnLevel2() wird bei jeder \u00c4nderung in den Level-II-Daten (Markttiefe) aufgerufen. In einem Multibar-Indikator kann mit ProcessingBarSeriesIndex die jeweilige Datenreihe ermittelt werden, f\u00fcr die OnMarketDepth() aufgerufen wurde. OnLevel2 wird nicht f\u00fcr historische Daten aufgerufen. Siehe auch weitere Methoden zur Ereignisbehandlung unter Ereignisse .","title":"Beschreibung"},{"location":"ereignisse/#verwendung_5","text":"protected override void OnLevel2(Level2Args e)","title":"Verwendung"},{"location":"ereignisse/#parameter_5","text":"Ein Objekt von Level2Args","title":"Parameter"},{"location":"ereignisse/#beispiel_7","text":"protected override void OnLevel2(Level2Args e) { // Ausgabe des jeweils aktuellen Ask-Kurses if (e.MarketDataType == MarketDataType.Bit) Print(\"The current bit is \" + e.Price ); }","title":"Beispiel"},{"location":"ereignisse/#onorderchanged","text":"","title":"OnOrderChanged()"},{"location":"ereignisse/#beschreibung_8","text":"Die Methode OnOrderChanged() wird jedesmal dann aufgerufen, wenn sich der Status einer durch eine Strategie verwaltete Order \u00e4ndert. Ene Status\u00e4nderung kann dabei durch die \u00c4nderung des Volumens, des Preises oder des Status an der B\u00f6rse (von working zu filled) ausgel\u00f6st werden. Es ist sichergestellt, dass diese Methode f\u00fcr alle Ereignisse in der korrekten Reihenfolge aufgerufen wird. Wichtiger Hinweis: Wenn eine Strategie durch Orderausf\u00fchrungen gesteuert werden soll, ist es ratsamer, OnOrderExecution() anstelle von OnOrderChanged() zu verwenden. Es kann sonst zu Problemen bei Teilausf\u00fchrungen kommen.. Siehe auch weitere Methoden zur Ereignisbehandlung unter Ereignisse .","title":"Beschreibung"},{"location":"ereignisse/#parameter_6","text":"Ein Order-Objekt vom Type IOrder","title":"Parameter"},{"location":"ereignisse/#verwendung_6","text":"protected override void OnOrderChanged(IOrder order)","title":"Verwendung"},{"location":"ereignisse/#beispiel_8","text":"private IOrder entry = null; protected override void OnCalculate() { if (CrossAbove(EMA(14), SMA(50), 1) && IsSerieRising(ADX(20))) entry = OpenLong(\"EMACrossesSMA\"); if (entry != null && entry == order) { if (order.OrderState == OrderState.Filled) { PlaySound(\"OrderFilled.wav\"); entryOrder = null; } } } protected override void OnOrderChanged(IOrder order) { }","title":"Beispiel"},{"location":"ereignisse/#onorderexecution","text":"","title":"OnOrderExecution()"},{"location":"ereignisse/#beschreibung_9","text":"Die Methode OnOrderExecution() wird jedesmal dann aufgerufen, wenn eine Order ausgef\u00fchrt (filled) wurde oder sich der Status einer durch eine Strategie verwaltete Order \u00e4ndert. Ene Status\u00e4nderung kann dabei durch die \u00c4nderung des Volumens, des Preises oder des Status an der B\u00f6rse (von working zu filled) ausgel\u00f6st werden. Es ist sichergestellt, dass diese Methode f\u00fcr alle Ereignisse in der korrekten Reihenfolge aufgerufen wird. OnOrderExecution() wird immer nach OnOrderChanged() aufgerufen. Siehe auch weitere Methoden zur Ereignisbehandlung unter Ereignisse .","title":"Beschreibung"},{"location":"ereignisse/#parameter_7","text":"Ein execution-Objekt vom Type IExecution","title":"Parameter"},{"location":"ereignisse/#verwendung_7","text":"protected override void OnOrderExecution(IExecution execution)","title":"Verwendung"},{"location":"ereignisse/#beispiel_9","text":"private IOrder entry = null; protected override void OnCalculate() { if (CrossAbove(EMA(14), SMA(50), 1) && IsSerieRising(ADX(20))) entry = OpenLong(\"EMACrossesSMA\"); } protected override void OnOrderExecution(IExecution execution) { // Beispiel if (entry != null && execution.Order == entry) { Print(execution.Price.ToString()); Print(execution.Order.OrderState.ToString()); } }","title":"Beispiel"},{"location":"ereignisse/#onstart","text":"","title":"OnStart()"},{"location":"ereignisse/#beschreibung_10","text":"Die Methode OnStart() kann \u00fcberschrieben werden, um eigene Variablen zu initialisieren, Lizenzchecks auszuf\u00fchren, UserForms aufzurufen usw. OnStart() wird nur einmal am Beginn des Scrips nach OnInit() und vor OnCalculate() aufgerufen. Siehe auch OnDispose() . Siehe auch weitere Methoden zur Ereignisbehandlung unter Ereignisse .","title":"Beschreibung"},{"location":"ereignisse/#parameter_8","text":"keiner","title":"Parameter"},{"location":"ereignisse/#verwendung_8","text":"protected override void OnStart()","title":"Verwendung"},{"location":"ereignisse/#beispiel_10","text":"private myForm Window; protected override void OnStart() { if (Chart != null) { Window = new myForm(); Window.Show(); } }","title":"Beispiel"},{"location":"ereignisse/#onstop","text":"","title":"OnStop()"},{"location":"ereignisse/#beschreibung_11","text":"Die OnStop()-Methode wird aufgerufen, sobald ein Script beendet wird. Dies kann z.B. vorkommen, wenn ein Indikator vom Chart entfernt wurde oder eine Spalte mit einem Indikator / einer gescripteten Condition vom Scanner entfernt wurde. Siehe auch OnDispose() . Siehe auch weitere Methoden zur Ereignisbehandlung unter Ereignisse .","title":"Beschreibung"},{"location":"ereignisse/#parameter_9","text":"keiner","title":"Parameter"},{"location":"ereignisse/#verwendung_9","text":"protected override void OnStop()","title":"Verwendung"},{"location":"ereignisse/#beispiel_11","text":"protected override void OnStop() { Log(\"Stop: \" + this.ToString() + \" | \" + Instrument.Symbol, InfoLogLevel.Info); }","title":"Beispiel"},{"location":"schluesselworte/","text":"Schl\u00fcsselworte AddOutput() AddLine() Beschreibung Mit der Methode Add() werden dem Chart Plot - bzw. Line-Objekte hinzugef\u00fcgt. Wenn mit Add() ein neues Plot-Objekt hinzugef\u00fcgt wird, wird automatisch auch eine Datenserie vom Typ DataSeries erzeugt, die diesem Plot zugeordnet ist. Auf diese Datenserie kann \u00fcber die Value-Collection zugegriffen werden. Add() kann in der OnInit() Methode und in der OnCalculate() Methode verwendet werden.. Parameter plot \u2013 ein OutputDescriptor Objekt line \u2013 ein LevelLine Objekt Verwendung AddOutput(new OutputDescriptor(Color.FromKnownColor(KnownColor.Black), \"MyPlot1\")); Add(LevelLine line) Beispiel #region Usings using System; using System.Collections.Generic; using System.ComponentModel; using System.Drawing; using System.Linq; using System.Xml; using System.Xml.Serialization; using AgenaTrader.API; using AgenaTrader.Custom; using AgenaTrader.Plugins; using AgenaTrader.Helper; #endregion namespace AgenaTrader.UserCode { [Description(\"Enter the description for the new custom indicator here\")] public class MyIndicator : UserIndicator { protected override void OnInit() { // 2 blaue Linien in den Chart legen, eine bei 70 und eine bei 30 Add(new LevelLine(Color.Blue, 70, \"UpperLine\")); Add(new LevelLine(Color.Blue, 30, \"LowerLine\")); // 2 Plots hinzuf\u00fcgen Add(new OutputDescriptor(Color.Red, \"myFastSMA\")); Add(new OutputDescriptor(Color.Blue, \"mySlowSMA\")); } protected override void OnCalculate() { //Mit der Set-Methode wird der Wert f\u00fcr den aktuellen Bar zugewiesen. FastSMA.Set( SMA(8)[0] ); // ist identisch mit Values[0].Set( SMA(8)[0] ); SlowSMA.Set( SMA(50)[0] );// ist identisch mit Values[1].Set( SMA(50)[0] ); } / Hier werden 2 Datenserien zur Verf\u00fcgung gestellt. // Zur Darstellung des Indikators auf dem Chart sind diese nicht notwendig. // Mit Hilfe dieser Datenserien kann von anderen Indikatoren aus auf diesen Indikator // zugegriffen werden. // Z.B. mit double d = MeinIndikator.FastSMA[0] - MeinIndikator.SlowSMA[0]; [Browsable(false)] [XmlIgnore()] public DataSeries FastSMA { get { return Outputs[0]; } } [Browsable(false)] [XmlIgnore()] public DataSeries SlowSMA { get { return Outputs[1]; } } } } AllowRemovalOfChartDrawings Beschreibung AllowRemovalOfDrawObjects ist eine Eigenschaft von Indikatoren, die in der Methode OnInit() gesetzt werden kann.. AllowRemovalOfChartDrawings = true Zeichenobjekte (DrawObjects), die von einem Indikator bzw. einer Strategie in einen Chart gezeichnet wurden, k\u00f6nnen manuell aus dem Chart entfernt werden. AllowRemovalOfChartDrawings = false (default) Zeichenobjekte (DrawObjects), die von einem Indikator bzw. einer Strategie in einen Chart gezeichnet wurden, k\u00f6nnen nicht manuell aus dem Chart entfernt werden. Sie werden erst dann vom Chart entfernt, wenn auch der Indikator bzw. die Strategie entfernt wird. Die Eigenschaft kann abgefragt werden, und liefert \"true\" bzw. \"false\". Verwendung AllowRemovalOfChartDrawings Beispiel protected override void OnInit() { Add(new OutputDescriptor(Color.FromKnownColor(KnownColor.Red), \"MyPlot1\")); //DrawObjects k\u00f6nnen aus dem Chart manuell entfernt werden AllowRemovalOfChartDrawings = true; } Attribute Attribute sind Bestandteil der Programmiersprache C#. In eigenen AgenaScript-Indikatoren bzw. Strategien k\u00f6nnen Attribute genauso verwendet werden, wie es auch in C# selbst m\u00f6glich ist. Informationen \u00fcber Die Verwendung von Attributen finden Sie u.a. hier: http://msdn.microsoft.com/de-de/library/z0w1kczw%28v=vs.80%29.aspx Die in AgenaScript am h\u00e4ufigsten verwendeten Attribute sind: Browsable Category ConditionalValue Description DisplayName TimeFrameRequirements XmlIgnore Browsable Browsable ist ein Attribute in AgenaScript. In AgenaScript werden \u00f6ffentliche Variablen (public variables) zum einen f\u00fcr die Eingabe von Parametern f\u00fcr Indikatoren genutzt (z.B. die Periode f\u00fcr einen SMA) und zum anderen f\u00fcr die Ausgabe von Ergebnissen einer Berechnung innerhalb eines Indikators (z.B. Datenserien). Variablen, die der Eingabe von Parametern dienen, m\u00fcssen im Eigenschaften-Dialog angezeigt werden. Datenserien hingegen nicht. Eine public Variable, die mit dem Attribut Browsable=false gekennzeichnet wurde, wird nicht im Eigenschaftendialog von AgenaTrader angezeigt. Standardm\u00e4\u00dfig wird Browsable = true angenommen. Daher kann bei einer Variable, die einen Eingabeparameter beinhaltet, das Attribut Browsable auch weggelassen weren. Beispiel f\u00fcr einen Parameter: Der Parameter soll im Eigenschaftsfenster angezeigt und abgefragt werden. Daher ist \"Browsable = true\" zu setzen oder das Attribut kann entfallen. [Description(\"Numbers of bars used for calculations\")] [Category(\"InputParameter\")] public int Period { get { return period; } set { period = Math.Max(1, value); } } Beispiel f\u00fcr eine Datenserie: [Browsable(false)] [DisplayName(\"Lower band\")] [XmlIgnore] public DataSeries Lower { get { return Outputs[0]; } } Category Category ist ein Attribute in AgenaScript. Das Attribut Category gibt f\u00fcr einen Parameter an, unter welcher Kategorie im Eigenschaften-Dialog der Parameter erscheint. Wenn das Attribut fehlt, wird standardm\u00e4\u00dfig die Kategorie \"InputParameter\" angenommen. Das folgende Beispiel erzeugt im Eigenschaften-Dialog die neue Kategorie \"My InputParameter\". [Category(\"My InputParameter\")] [DisplayName(\"Period number\")] public double _period { get { return _period; } set { _period = value; } } Category ist ein Attribute in AgenaScript. Das Attribut Category gibt f\u00fcr einen Parameter an, unter welcher Kategorie im Eigenschaften-Dialog der Parameter erscheint. Wenn das Attribut fehlt, wird standardm\u00e4\u00dfig die Kategorie \"InputParameter\" angenommen. Das folgende Beispiel erzeugt im Eigenschaften-Dialog die neue Kategorie \"My InputParameter\". namespace AgenaTrader.UserCode { [Description(\"Description what this indicator doing.\")] [Category(\"My Package\")] public class MyHolyGrail_Indicator : UserIndicator { /* your code here */ } } ConditionalValue ConditionalValue ist ein Attribute in AgenaScript. Normalerweise werden im ConditionEscort f\u00fcr Vergleiche die von Indikatoren bereitgestellten Datenserien (DataSeries) benutzt. Beispielsweise wird gepr\u00fcft, ob ein gleitender Durchschnitt \u00fcber oder unter einem bestimmten Kurswert liegt. Ein Indikator kann aber auch Werte als Ergebnis haben, die keine Datenserien sind, also z.B. Werte vom Typ int, double, char, boolean, string usw. Um diese Werte im Scanner oder im Condition-Escort nutzen zu k\u00f6nnen, m\u00fcssen sie mit dem Attribut \"ConditionalValue\" gekennzeichnet sein. [Browsable(false)] [XmlIgnore] [ConditionalValue] public int PublicVariable { get { Update(); return _internVariable; } } Description Description ist ein Attribute in AgenaScript. Das Attribute Description wird In AgenaScript f\u00fcr die Klasse und f\u00fcr public-Variablen verwendet. Als Attribut der Klasse ist der Text eine Beschreibung der Funktion des gesamten Indikators (bzw. der Strategie usw.) [Description(\"Displays the tick count of a bar.\")] public class TickCounter : UserIndicator { As an attribute of a public variable, the text is a description of the function of the parameter. [Description(\"Number of standard deviations\")] [DisplayName(\"# of std. dev.\")] public double NumStdDev { get { return numStdDev; } set { numStdDev = Math.Max(0, value); } } } Die Beschreibungen werden jeweils im Eigenschaften-Dialog angezeigt. DisplayName DisplayName ist ein Attribute in AgenaScript. Das Attribute DisplayName legt den Text fest, der im Eigenschaften-Dialog f\u00fcr den Parameter verwendet werden soll. Wird dieses Attribut nicht angegeben, wird der Name der public Variable verwendet. [Description(\"Number of standard deviations\")] [DisplayName(\"# of std. dev.\")] public double NumStdDev { get { return numStdDev; } set { numStdDev = Math.Max(0, value); } } TimeFrameRequirements TimeFrameRequirements ist ein Attribute in AgenaScript. Sollen in einem AgenaScript Daten verschiedener Zeiteinheiten verwendet werden, ist der Klasse das Attribut \"TimeFrameRequirements\" voranzustellen. Es k\u00f6nnen hier auch mehrere Zeiteinheiten angegeben werden: [TimeFrameRequirements(\"1 day\")] [TimeFrameRequirements(\"15 minutes\", \"1 day\", \"1 week\")] Es werden immer so viele Daten der anderen Zeiteinheit(en) bereitgestellt, wie auch Kerzen im Chart geladen sind. Sind in einem 5 Minuten-Chart beispielsweise 500 Kerzen geladen, werden auch 500 Kerzen einer anderen Zeiteinheit geladen. Im Beispiel oben also 500 Tageskerzen bzw. im 2. Beispiel 500 15-Minuen-Kerzen, 500 Tageskerzen und 500 Wochenkerzen. Die Datenmengen k\u00f6nnen schnell sehr gro\u00df werden. Das Attribut ist daher mit Umsicht zu verwenden. siehe auch MultiBars . Wichtig: Wenn in einer Klasse ein anderer Indikator verwendet wird, der seinerseits eine (oder mehrere) sekund\u00e4re Zeiteinheit(en) erfordert, mu\u00df f\u00fcr die aufrufende Klasse ebenfalls das Attribut \"TimeFrameRequirements\" angegeben werden. Ein Beispiel hierzu siehe unter GetDayBar . XMLIgnore XML ignore st ein Attribute in AgenaScript. AgenaTrader speichert in einem Template u.a. auch alle Parameter-Einstellungen eines Indikators. Die Template-Files liegen im XML-Format vor. Um zu verhindern, dass ein Parameter als Teil eines Templates gespeichert wird, kann das Attribut \"XmlIgnore\" angegeben werden. Um Parameter in einem XML-File speichern zu k\u00f6nnen, m\u00fcssen die Werte zuvor serialisiert werden. In den meisten F\u00e4llen, d.h. f\u00fcr alle g\u00e4ngigen Variablentypen geschieht dies durch AgenaTrader automatisch. Selbst definierte Datentypen k\u00f6nnen jedoch nicht automatisch serialisiert werden. Der Programmierer mu\u00df selbst f\u00fcr die korrekte Serialisierung sorgen. Im Beispiel werden Farbe und Schriftart als Parameter eines Indikators verwendet. In AgenaTrader existieren f\u00fcr die Serialisierung von Farb- und Schriftart-Informationen 2 Methoden (TextColorSerialize und TextFontSerialize), die die Serialisierung \u00fcbernehmen. Die beiden Parameter \"TextColor\" und \"TextFont\" sind daher mit dem Attribute \"XmlIgnore\" zu kennzeichnen. private Color _textColor = Color.Blue; private Font _textFont = new Font(\"Arial\", 12, FontStyle.Bold); [XmlIgnore] [Description(\"Textcolor\")] public Color TextColor { get { return _textColor; } set { _textColor = value; } } [Browsable(false)] public string TextColorSerialize { get { return SerializableColor.ToString(_textColor); } set { _textColor = SerializableColor.FromString(value); } } [XmlIgnore()] [Description(\"TextFont\")] public Font TextFont { get { return _textFont; } set { _textFont = value; } } [Browsable(false)] public string TextFontSerialize { get { return SerializableFont.ToString(_textFont); } set { _textFont = SerializableFont.FromString(value); } } CalculateOnClosedBar Beschreibung Die Eigenschaft \"CalculateOnClosedBar\" legt fest, f\u00fcr welche Ereignisse AgenaTrader die Methode OnCalculate() aufrufen soll. CalculateOnClosedBar = true OnCalculate() wird aufgerufen, wenn ein Bar beendet ist, und der n\u00e4chste hereinkommende Tick einen neuen Bar entstehen l\u00e4\u00dft. CalculateOnClosedBar = false OnCalculate() wird f\u00fcr jeden neu hereinkommenden Tick aufgerufen. Achtung bei \u00e4lterer Hardware: dies f\u00fchrt bei sehr liquiden Werten zu einer erh\u00f6hten Rechnerbelastung. Die Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false). CalculateOnClosedBar kann sowohl in OnInit() als auch in OnCalculate() eingesetzt werden.. OnCalculate wird f\u00fcr historische Daten immer nur f\u00fcr den Schlusskurs eines jeden Bars aufgerufen, auch wenn CalculateOnClosedBar=false gesetzt ist. Wird ein Indikator von einem anderen Indikator aufgerufen, so wird die Eigenschaft CalculateOnClosedBar des aufgerufenen Indikators vom aufrufenden Indikator \u00fcberschrieben. Verwendung CalculateOnClosedBar Weitere Informationen Siehe auch die Beschreibung zu Bars . Beispiel protected override void OnInit() { //Indikatorberechnung nur, wenn ein Bar fertig ausgepr\u00e4gt ist CalculateOnClosedBar = true; } Chart Chart ist ein Objekt, \u00fcber welches der lesende Zugriff auf verschiedene Eigenschaften des Charts m\u00f6glich ist. Die wichtigsten Eigenschaften sind: ChartFontColor, BackColor UpColor, DownColor Font BarMarginLeft, BarMarginRight BarSpace, BarWidth BarsPainted FirstBarPainted, LastBarPainted BarsVisible FirstBarVisible, LastBarVisible GetXByBarIdx, GetYByValue Zur Verwendung der wichtigsten Eigenschaften von Chart siehe Beispiel PlotSample . BarsPainted und BarsVisible: BarsPainted enth\u00e4lt die Anzahl der Bars, die ein Chart von seinem linken Rand zu seinem rechten Rand mit der momentanen Breite der Kerzen und dem Abstand der Kerzen zueinander anzeigen k\u00f6nnte . BarsVisible enth\u00e4lt die Anzahl der Bars, die tats\u00e4chlich zu sehen sind. FirstBarPainted und FirstBarVisible: FirstBarPainted enth\u00e4lt die Nummer des Bars, der am linken Rand des Charts angezeigt werden w\u00fcrde . FirstBarVisible enth\u00e4lt die Nummer des Bars, der tats\u00e4chlich als erster Bar links im Chart angezeigt wird. Beispiel: der Chart ist so verschoben, dass der erste Bar des Charts erst in der Mitte des Charts angezeigt wird. FirstBarPainted w\u00e4re in diesem Fall negativ. FirstBarVisible w\u00e4re 0. LastBarPainted und LastBarVisible: LastBarPainted enth\u00e4lt die Nummer des Bars, der am rechten Rand des Charts angezeigt werden w\u00fcrde . LastBarVisible enth\u00e4lt die Nummer des Bars, der tats\u00e4chlich als letzter Bar rechts im Chart angezeigt wird. Beispiel: der Chart ist so verschoben, dass der letzte Bar des Charts bereits in der Mitte des Charts angezeigt wird. LastBarPainted w\u00e4re in diesem Fall gr\u00f6\u00dfer als Bars.Count. LastBarVisible w\u00e4re in Bars.Count -1. ClearTraceWindow() Beschreibung Die Methode ClearTraceWindow() leert das Output-Fenster. Die Methode kann sowohl in OnInit() als auch in OnCalculate() eingesetzt werden. Das OutputWindow beinhaltet alle Ausgaben, die mit dem Print() -Befehl erstellt wurden. Der Einsatz des OutputWindows ist eine sehr gute M\u00f6glichkeit f\u00fcr Code-Debugging. Verwendung ClearTraceWindow() Parameter keiner R\u00fcckgabewert keiner Beispiel protected override void OnInit() { //Inhalt des OutputWindow l\u00f6schen ClearTraceWindow(); } Colors In AgenaSript stehen die folgenden Befehle f\u00fcr Farbfestlegungen bzw. -\u00e4nderungen im Chart zur Verf\u00fcgung: BackColor Hintergrundfarbe des Kurs-Charts BackColorAll Hintergrundfarbe des Kurs-Charts und aller Indikator-Panels BackColorAllSeries BackColorSeries Chart.UpColor Farbe f\u00fcr Up Ticks (Up Bars) Chart.DownColor Farbe f\u00fcr Down Ticks (Down Bars) F\u00fcr jeden Bar werden seine Farben in folgenden Dataserien gespeichert. Wird in diese Datenserien geschrieben, \u00e4ndern sich die Farben des referenzierten Bars. BarColor Farbe eines Bars BarColorSeries CandleOutlineColor CandleOutlineColorSeries BackColor Beschreibung BackColor \u00e4ndert die Hintergrundfarbe eines Bars bzw. gibt die aktuelle Hintergrundfarbe eines Bars zur\u00fcck. Siehe auch Colors , BarColor , BackColor , BackColorAll , BarColorSeries , BackColorAll , CandleOutlineColor . Parameter ein Color-Objekt vom Typ public struct Color Verwendung BackColor Beispiele // immer montags Bar-Hintergrundfarbe auf Blau \u00e4ndern if (Time[0].DayOfWeek == DayOfWeek.Monday) BackColor = Color.Blue; // \u00c4ndern der Bar-Hintergrundfarbe in Abh\u00e4ngigkeit von einem gl. Durchschnitt // Kurs \u00fcber SMA(14) --> Gr\u00fcn // Kurs unter SMA(14) --> Maroon BackColor = SMA(14)[0] >= Close[0] ? Color.Maroon : Color.LimeGreen; BackColorAll Beschreibung BackColorAll \u00e4ndert die Hintergrundfarbe eines Bars im Chartfenster und in allen Subcharts bzw. gibt die aktuelle Hintergrundfarbe eines Bars zur\u00fcck. Siehe auch Colors , BarColor , BackColor , BackColorAll , BarColorSeries , BackColorAll , CandleOutlineColor . Parameter ein Color-Objekt vom Typ public struct Color Verwendung BackColorAll Beispiel // immer montags Bar-Hintergrundfarbe auf Blau \u00e4ndern if (Time[0].DayOfWeek == DayOfWeek.Monday) BackColorAll = Color.Blue; BackColorAllSeries Beschreibung BackColorAllSeries ist eine Datenserie, die f\u00fcr jeden Bar die Hintergrundfarbe speichert. Im Unterschied zu BackColorSeries wird die Hinterrundfarbe der Subcharts mit ber\u00fccksichtigt. Siehe auch Colors , BarColor , BackColor , BackColorAll , BarColorSeries , BackColorAll , CandleOutlineColor . Parameter ein Color-Objekt vom Typ public struct Color int barsAgo Verwendung BackColorAllSeries BackColorAllSeries[int barsAgo] Bei Verwendung der Methode mit einem Index [int barsAgo] wird die Hintergrundfarbe f\u00fcr den referenzierten Bar ge\u00e4ndert bzw. ausgegeben. Beispiel siehe BackColorSeries . BackColorSeries Beschreibung BackColorSeries ist eine Datenserie, die f\u00fcr jeden Bar die Hintergrundfarbe speichert. Soll die Hintergrundfarbe von Subcharts mit ber\u00fccksichtigt werden, ist \"BackColorAllSeries\" zu verwenden. Siehe auch Colors , BarColor , BackColor , BackColorAll , BarColorSeries , BackColorAll , CandleOutlineColor . Parameter ein Color-Objekt vom Typ public struct Color int barsAgo Verwendung BackColorSeries BackColorSeries[int barsAgo] ei Verwendung der Methode mit einem Index [ int barsAgo] wird die Hintergrundfarbe f\u00fcr den referenzierten Bar ge\u00e4ndert bzw. ausgegeben. Beispiele // Welche Hintergrundfarbe hat der aktuelle Bar? (im ARGB-Format) Print (BackColorSeries[0]); // Hintergrundfarbe des aktuellen Bars auf Blau setzen // Dies ist identisch mit BackColor = Color.Blue BackColorSeries[3] = Color.Blue; // Hintergrundfarbe des vorhergehenden Bars auf Gr\u00fcn setzen BackColorSeries[1] = Color.Green; BarColor Beschreibung BarColor \u00e4ndert die Farbe eines Bars Siehe auch Colors , BarColor , BackColor , BackColorAll , BarColorSeries , BackColorAll , CandleOutlineColor . Parameter ein Color-Objekt vom Typ public struct Color Verwendung BarColor Beispiel // Wenn der Schlusskurs \u00fcber dem SMA(14) liegt, den Bar orange einf\u00e4rben if (Close[0] > SMA(14)[0]) BarColor = Color.Orange; BarColorSeries Beschreibung BarColorSeries ist eine Datenserie, die f\u00fcr jeden Bar die Farbe speichert. Siehe auch Colors , BarColor , BackColor , BackColorAll , BarColorSeries , BackColorAll , CandleOutlineColor . Parameter ein Color-Objekt vom Typ public struct Color int barsAgo Verwendung BarColorSeries BarColorSeries[ int barsAgo] Bei Verwendung der Methode mit einem Index [int barsAgo] wird die Farbe f\u00fcr den referenzierten Bar ge\u00e4ndert bzw. ausgegeben. Achtung: Es wird nur die Farbe eines Bars zur\u00fcckgegeben, dessen Farbe vorher explizit ver\u00e4ndert wurde. In allen anderen F\u00e4llen wird Color.Empty zur\u00fcckgegeben. Beispiel protected override void OnCalculate() { if (ProcessingBarIndex == Bars.Count-1-(CalculateOnClosedBar?1:0)) { // Farbe des aktuellen Bars auf Blau setzen // Dies ist identisch mit BarColor = Color.Blue BarColorSeries[0] = Color.Blue; // Farbe des vorhergehenden Bars auf Gr\u00fcn setzen BarColorSeries[1] = Color.Orange; // Farbe des 3. Bars auf Gelb setzen BarColorSeries[2] = Color.Yellow; } } CandleOutlineColor Beschreibung CandleOutlineColor \u00e4ndert die Randfarbe (incl. \"Dochte\" und \"Lunte\") eines Bars. Wenn die Farbe eines Bars mit BarColor ge\u00e4ndert wird, und die Umrandung des Bars wurde nicht mit CandleOutlineColor ver\u00e4ndert, wird die Randfarbe auf die Farbe des Bars angepasst. Siehe auch Colors , BarColor , BackColor , BackColorAll , BarColorSeries , BackColorAll , CandleOutlineColor . Parameter ein Color-Objekt vom Typ public struct Color Verwendung CandleOutlineColor Beispiel if (SMA(14)[0] > SMA(200)[0]) CandleOutlineColor = Color.LimeGreen; else CandleOutlineColor = Color.Red; CandleOutlineColorSeries Beschreibung CandleOutlineColorSeries ist eine Datenserie, die f\u00fcr jeden Bar die Randfarbe speichert. Siehe auch Colors , BarColor , BackColor , BackColorAll , BarColorSeries , BackColorAll , CandleOutlineColor . Parameter ein Color-Objekt vom Typ public struct Color int barsAgo Verwendung CandleOutlineColorSeries CandleOutlineColorSeries[int barsAgo] Bei Verwendung der Methode mit einem Index [ int barsAgo] wird die Randfarbe f\u00fcr den referenzierten Bar ausgegeben. Achtung: Es wird nur die RandFarbe eines Bars zur\u00fcckgegeben, dessen Randfarbe vorher explizit ver\u00e4ndert wurde. In allen anderen F\u00e4llen wird Color.Empty zur\u00fcckgegeben. Beispiel // Randfarbe des aktuellen Bars auf Blau setzen CandleOutlineColorSeries[0] = Color.Blue; // Randfarbe auf Chart-default zur\u00fccksetzen CandleOutlineColorSeries[0] = Color.Empty; CrossAbove() Beschreibung Mit der Methode CrossAbove() kann gepr\u00fcft werden, ob es innerhalb einer festgelegten Anzahl von Perioden eine \u00dcberkreuzung zweier Werte von unten nach oben gab. Die Werte k\u00f6nnen dabei der Kurs, ein Indikator, jede beliebige Datenserie oder ein fester Wert sein. Siehe auch CrossAbove() , CrossBelow() , IsSerieRising() , IsSerieFalling() . Verwendung CrossAbove(IDataSeries series1, double value, int lookBackPeriod) CrossAbove(IDataSeries series1, IDataSeries series2, int lookBackPeriod) R\u00fcckgabewert true eine \u00dcberkreuzung hat stattgefunden false eine \u00dcberkreuzung hat nicht stattgefunden Parameter lookBackPeriod Anzahl der Bars innerhalb derer nach dem Aufterten einer \u00dcberkreuzung gesucht wird series1 und series2 eine Datenserie, wie z.B. ein Indikator, Close, High o.\u00e4 value ein fester Wert vom Typ double Beispiele // Hinweis ausgeben, wenn der SMA(20) \u00fcber SMA(50) kreuzt if (CrossAbove(SMA(20), SMA(50), 1)) Print(\"SMA(20) has risen above SMA(50)!\"); // Hinweis ausgeben, wenn der SMA(20) \u00fcber den Wert 40 steigt if (CrossAbove(SMA(20), 40, 1)) Print(\"SMA(20) has risen above 40!\"); // Hinweis auf Long-Einstieg ausgeben, wenn innerhalb der letzten 5 Bars // der SMA(20) \u00fcber SMA(50) kreuzt und der Kurs innerhalb des letzten Bars gestiegen ist if (CrossAbove(SMA(20), SMA(50), 1) && Close[0] > Close[1]) Print(\"Long entry !!!\"); CrossBelow() Beschreibung Mit der Methode CrossBelow() kann gepr\u00fcft werden, ob es innerhalb einer festgelegten Anzahl von Perioden eine \u00dcberkreuzung zweier Werte von oben nach unten gab. Die Werte k\u00f6nnen dabei der Kurs, ein Indikator, jede beliebige Datenserie oder ein fester Wert sein. Siehe auch CrossAbove() , CrossBelow() , IsSerieRising() , IsSerieFalling() . Verwendung CrossBelow(IDataSeries series1, double value, int lookBackPeriod) CrossBelow(IDataSeries series1, IDataSeries series2, int lookBackPeriod) R\u00fcckgabewert true eine \u00dcberkreuzung hat stattgefunden false eine \u00dcberkreuzung hat nicht stattgefunden Parameter lookBackPeriod Anzahl der Bars innerhalb derer nach dem Aufterten einer \u00dcberkreuzung gesucht wird series1 und series2 eine Datenserie, wie z.B. ein Indikator, Close, High o value ein fester Wert vom Typ double Beispiele // Hinweis ausgeben, wenn der SMA(20) unter SMA(50) kreuzt if (CrossBelow(SMA(20), SMA(50), 1)) Print(\"SMA(20) has fallen below SMA(50)!\"); // Hinweis ausgeben, wenn der SMA(20) unter den Wert 40 f\u00e4llt if (CrossBelow(SMA(20), 40, 1)) Print(\"SMA(20) has fallen below 40!\"); // Hinweis auf Short-Einstieg ausgeben, wenn innerhalb der letzten 5 Bars // der SMA(20) unter SMA(50) kreuzt und der Kurs innerhalb des letzten Bars gefallen ist. if (CrossBelow(SMA(20), SMA(50), 1) && Close[1] > Close[0]) Print(\"Short entry !!!\"); DatafeedHistoryPeriodicity Beschreibung DatafeedHistoryPeriodicity ist ein Datentyp. Definition public enum DatafeedHistoryPeriodicity - DatafeedHistoryPeriodicity.Tick - DatafeedHistoryPeriodicity.Second - DatafeedHistoryPeriodicity.Minute - DatafeedHistoryPeriodicity.Hour - DatafeedHistoryPeriodicity.Day - DatafeedHistoryPeriodicity.Week - DatafeedHistoryPeriodicity.Month - DatafeedHistoryPeriodicity.Volume - DatafeedHistoryPeriodicity.Range - DatafeedHistoryPeriodicity.Quarter - DatafeedHistoryPeriodicity.Year - DatafeedHistoryPeriodicity.HeikinAshi - DatafeedHistoryPeriodicity.Renko - DatafeedHistoryPeriodicity.LineBreak - DatafeedHistoryPeriodicity.Kagi - DatafeedHistoryPeriodicity.PointAndFigure - DatafeedHistoryPeriodicity.Custom Siehe TimeFrame , TimeFrames . DataSeries Beschreibung Datenserien (DataSeries) sind eine sehr komfortable und sehr m\u00e4chtige M\u00f6glichkeit, zus\u00e4tzliche Werte f\u00fcr jeden einzelnen Bar zu speichern. Z.B. wird bei der Berechnung eines gleitenden Durchschnitts jedem Bar der f\u00fcr diesen Bar errechnete Wert zugeordnet. Eine Datenserie ist ein Array, welches exakt so viele Elemente enth\u00e4lt, wie Bars im Chart angezeigt werden. AgenaTrader sorgt daf\u00fcr, dass die Datenserien zu jedem Zeitpunkt korrekt mit den Bars synchronisiert sind. Datenserien werden exakt so benutzt, wie z.B. die Serien Close oder Time. Sie k\u00f6nnen deshalb nat\u00fcrlich auch als Eingangsdaten (Input) f\u00fcr weitere Indikatoren verwendet werden. In der Tabelle ist zu sehen, dass 4 neue Datenserien (farbig markiert) angelegt worden sind. Jede dieser Datenserien kann genau einen Wert eines speziellen Datentyps (int, bool, string, DateTime) je Bar aufnehmen. Die Indizierung mit barsAgo ist dabei identisch mit den vom System bereitgestellten Datenserien.. In AgenaTrader verwendbare Datenserien BoolSeries DataSeries DateTimeSeries FloatSeries IntSeries LongSeries StringSeries Dar\u00fcberhinaus gibt es die Datenserie ColorSeries, die jedoch nur f\u00fcr interne Zwecke bestimmt ist und nicht direkt verwendet werden sollte. Um die Farbe von Plots zu \u00e4ndern, verwenden Sie bitte PlotColors . Set(), Reset() und ContainsValue() Jede Datenserie verf\u00fcgt \u00fcber die Methoden Set() , Reset() und ContainsValue() . Mit Set(value) bzw. Set(int barsAgo, value) werden Werte in die Datenserie an der aktuellen Position bzw. an der Position \"barsAgo\" \u00fcbernommen. Mit Reset() bzw. Reset(int barsAgo) kann an der aktuellen Position bzw. an der Position \"barsAgo\" ein Wert aus der Datenserie gel\u00f6scht werden, d.h. an dieser Position existiert kein g\u00fcltiger Wert mehr. Die Programmierung mit Hilfe der Reset-Methode kann eine ansonsten sehr komplexe Logik sp\u00fcrbar vereinfachen.Insbesondere bei Bool-Serien, die nur true oder false enthalten k\u00f6nnen, ist diese Eigenschaft extrem hilfreich. Mit ContainsValue() kann gepr\u00fcft werden, ob die Datenserie an einer bestimmten Position einen g\u00fcltigen Wert enth\u00e4lt. Informationen zu den einzelnen Datentypen http://msdn.microsoft.com/de-de/library/s1ax56ch%28v=vs.80%29.aspx BoolSeries Beschreibung BoolSeries ist eine Datenserie, die f\u00fcr jeden Bar einen boolschen Wert (true oder false) aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart. Neue BoolSeries anlegen Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen: //Variablendeklaration private BoolSeries myBoolSeries; In der Methode OnInit()dieser Variable eine neue Instanz von BoolSeries zuweisen: protected override void OnInit() { myBoolSeries = new BoolSeries(this); CalculateOnClosedBar = true; } Werte zuweisen Der Datenserie an aktueller Position einen Wert zuweisen: myBoolSeries.Set(true); Einen Wert in der Vergangenheit in die Datenserie schreiben: myBoolSeries.Set(int barsAgo, bool Value); Werte l\u00f6schen Den aktuellen Wert aus der Datenserie entfernen: myBoolSeries.Reset(); Einen Wert in der Vergangenheit aus der Datenserie entfernen: myBoolSeries.Reset(int barsAgo); Werte auf G\u00fcltigkeit pr\u00fcfen myBoolSeries.ContainsValue(int barsAgo); Wert auslesen Print (\"F\u00fcr den Bar von \" + Time[0] + \" ist der Wert der Datenserie: \" + myBoolSeries[0]); Beispiel protected override void OnCalculate() { if (Close[0] > Open[0]) myBoolSeries.Set(true); else myBoolSeries.Set(false); } DataSeries Beschreibung DataSeries ist eine DataSeries die f\u00fcr jeden Bar einen double-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart. Datenserien f\u00fcr double-Werte sind die f\u00fcr Indikatoren am h\u00e4ufigsten genutzen Datenserien. Neue DatenSerie anlegen Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen: //Variablendeklaration private DataSeries myDataSeries; In der Methode OnInit() dieser Variable eine neue Instanz von DataSeries zuweisen: protected override void OnInit() { myDataSeries = new DataSeries(this); CalculateOnClosedBar = true; } Werte zuweisen Der Datenserie an aktueller Position einen Wert zuweisen: myDataSeries.Set(Bars[0].Close); Einen Wert in der Vergangenheit in die Datenserie schreiben: myDataSeries.Set(int barsAgo, double Value); Werte l\u00f6schen Den aktuellen Wert aus der Datenserie entfernen: myDataSeries.Reset(); Einen Wert in der Vergangenheit aus der Datenserie entfernen: myDataSeries.Reset(int barsAgo); Werte auf G\u00fcltigkeit pr\u00fcfen myDataSeries.ContainsValue(int barsAgo); Wert auslesen Print (\"F\u00fcr den Bar von \" + Time[0] + \"ist der Wert der Datenserie: \" + myDataSeries[0]); Beispiel //Speichert die Spanne zwischen dem Hoch und dem Tief eines Bars myDataSeries.Set(Math.Abs(High[0]-Low[0])); DateTimeSeries Beschreibung Date time series ist eine DataSeries die f\u00fcr jeden Bar einen DateTime-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart. Neue DatenSerie anlegen Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen: //Variablendeklaration private DateTimeSeries myDataSeries; In der Methode OnInit() dieser Variable eine neue Instanz von StringSeries zuweisen: protected override void OnInit() { myDataSeries = new DateTimeSeries(this); CalculateOnClosedBar = true; } Werte zuweisen Der Datenserie an aktueller Position einen Wert zuweisen: myDataSeries.Set(DateTime Value); Einen Wert in der Vergangenheit in die Datenserie schreiben: myDataSeries.Set(int barsAgo, DateTime Value); Werte l\u00f6schen Den aktuellen Wert aus der Datenserie entfernen: myDataSeries.Reset(); Einen Wert in der Vergangenheit aus der Datenserie entfernen: myDataSeries.Reset(int barsAgo); Werte auf G\u00fcltigkeit pr\u00fcfen myDataSeries.ContainsValue(int barsAgo); Wert auslesen Print (\"F\u00fcr den Bar von\" + Time[0] + \" ist der Wert der Datenserie: \" + myDataSeries[0]); Beispiel //Speichert einen Versatz von -6 Stunden (Eastern Time, New York) f\u00fcr eine Zeitzonenumrechnung myDataSeries.Set(Time[0].AddHours(-6)); FloatSeries Beschreibung FloatSeries ist eine Datenserie, die f\u00fcr jeden Bar einen Float-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart. Neue DatenSerie anlegen Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen: //Variablendeklaration private FloatSeries myDataSeries; In der Methode OnInit() dieser Variable eine neue Instanz von StringSeries zuweisen: protected override void OnInit() { myDatatSeries = new FloatSeries(this); CalculateOnClosedBar = true; } Werte zuweisen Der Datenserie an aktueller Position einen Wert zuweisen: myDataSeries.Set(float Value); Einen Wert in der Vergangenheit in die Datenserie schreiben: myDataSeries.Set(int barsAgo, float Value); Werte l\u00f6schen Den aktuellen Wert aus der Datenserie entfernen: myDataSeries.Reset(); Einen Wert in der Vergangenheit aus der Datenserie entfernen: myDataSeries.Reset(int barsAgo); Werte auf G\u00fcltigkeit pr\u00fcfen myDataSeries.ContainsValue(int barsAgo); Wert auslesen Print (\"F\u00fcr den Bar von\" + Time[0] + \" ist der Wert der Datenserie: \" + myDataSeries[0]); Beispiel //Speichert die Spanne zwischen dem Hoch und dem Tief eines Bars myDataSeries.Set(Math.Abs((float) High[0] - (float) Low[0])); IntSeries Beschreibung IntSeries ist eine Datenserie, die f\u00fcr jeden Bar einen Integer-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart. Neue DatenSerie anlegen Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen: //Variablendeklaration private IntSeries myDataSeries; In der Methode OnInit() dieser Variable eine neue Instanz von StringSeries zuweisen: protected override void OnInit() { myDataSeries = new IntSeries(this); CalculateOnClosedBar = true; } Werte zuweisen Der Datenserie an aktueller Position einen Wert zuweisen: myDataSeries.Set(int Value); Einen Wert in der Vergangenheit in die Datenserie schreiben: myDataSeries.Set(int barsAgo, int Value); Werte l\u00f6schen Den aktuellen Wert aus der Datenserie entfernen: myDataSeries.Reset(); Einen Wert in der Vergangenheit aus der Datenserie entfernen: myDataSeries.Reset(int barsAgo); Werte auf G\u00fcltigkeit pr\u00fcfen myDataSeries.ContainsValue(int barsAgo); Wert auslesen Print (\"F\u00fcr den Bar von \" + Time[0] + \"ist der Wert der Datenserie\"+ myDataSeries[0]); Beispiel //Speichert f\u00fcr jeden Bar die Spanne in Ticks zwischen dem Hoch und dem Tief myDataSeries.Set((int) ((High[0] - Low[0]) / TickSize)); LongSeries Beschreibung LongSeries ist eine Datenserie, die f\u00fcr jeden Bar einen Integer-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart. Neue DatenSerie anlegen Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen: //Variablendeklaration private LongSeries myDataSeries; In der Methode OnInit() dieser Variable eine neue Instanz von LongSeries zuweisen: protected override void OnInit() { myDataSeries = new LongSeries(this); CalculateOnClosedBar = true; } Werte zuweisen Der Datenserie an aktueller Position einen Wert zuweisen: myDataSeries.Set(long Value); Einen Wert in der Vergangenheit aus der Datenserie entfernen: myDataSeries.Set(int barsAgo, long Value); Werte l\u00f6schen Den aktuellen Wert aus der Datenserie entfernen: myDataSeries.Reset(); Einen Wert in der Vergangenheit aus der Datenserie entfernen: myDataSeries.Reset(int barsAgo); Werte auf G\u00fcltigkeit pr\u00fcfen myDataSeries.ContainsValue(int barsAgo); Wert auslesen Print (\"F\u00fcr den Bar von \" + Time[0] + \"ist der Wert der Datenserie: \" + myDataSeries[0]); Beispiel //Speichert f\u00fcr jeden Bar die Spanne in Ticks zwischen dem Hoch und dem Tief myDataSeries.Set((long) ((High[0] - Low[0]) / TickSize)); StringSeries Beschreibung StringSeries ist eine Datenserie, die f\u00fcr jeden Bar einen String-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart. Neue DatenSerie anlegen Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen: //Variablendeklaration private StringSeries myDataSeries; In der Methode OnInit() dieser Variable eine neue Instanz von StringSeries zuweisen: protected override void OnInit() { myDataSeries = new StringSeries(this); CalculateOnClosedBar = true; } Werte zuweisen Der Datenserie an aktueller Position einen Wert zuweisen: myDataSeries.Set(string Value); Einen Wert in der Vergangenheit in die Datenserie schreiben: myDataSeries.Set(int barsAgo, string Value); Werte l\u00f6schen Den aktuellen Wert aus der Datenserie entfernen: myDataSeries.Reset(); Einen Wert in der Vergangenheit aus der Datenserie entfernen: myDataSeries.Reset(int barsAgo); Werte auf G\u00fcltigkeit pr\u00fcfen myDataSeries.ContainsValue(int barsAgo); Wert auslesen Print (\"F\u00fcr den Bar von \" + Time[0] + \"ist der Wert der Datenserie: \" + myDataSeries[0]); Beispiel //Speichert f\u00fcr jeden Bar den Wochentag (Montag, Dienstag ...) myDataSeries.Set(string.Format(\"{0:dddd}\", Time[0])); DayOfWeek Beschreibung \"DayOfWeek\" gibt den zu einem DateTime-Wert, wie z.B. dem Zeitstempel eines Bars, geh\u00f6renden Wochentag aus. Dar\u00fcberhinaus sind nat\u00fcrlich auch alle Methoden verwendbar, die in C# f\u00fcr DateTime-Objekte definiert sind, z.B. Day, Month, Year, Hour, Minute, Second, DayOfWeek usw. Siehe http://msdn.microsoft.com/de-de/library/03ybds8y.aspx Definition Eigenschaft DayOfWeek public enum DayOfWeek - DayOfWeek.Monday - DayOfWeek.Tuesday - DayOfWeek.Wednesday - DayOfWeek.Thursday - DayOfWeek.Friday - DayOfWeek.Saturday - DayOfWeek.Sunday Beispiele //Ausgabe des Wochentages f\u00fcr jeden Bar Print(Time[0].DayOfWeek); //An einem Freitag keine Trades ausf\u00fchren if (Time[0].DayOfWeek == DayOfWeek.Friday) return; Displacement Beschreibung Mit der Angabe Displacement kann eine gezeichnete Indikatorlinie auf der Zeitachse (x-Achse) nach links bzw. rechts verschoben werden. Die Eigenschaft kann im Script abgefragt werden und liefert einen int-Wert. Blue line: Displacement = 0 (Original) Red line: Displacement = -5 Green line: Displacement = +5 Verwendung Displacement Parameter int Offfset Anzahl Bars, um die der Indikator verschoben werden soll. Beispiel protected override void OnInit() { Add(new (Color.FromKnownColor(KnownColor.Red), \"MyPlot1\")); //Displacement of the plot by one bar to the right Displacement = 1; } Email function Beschreibung Override-Methode zum Senden von E-Mails. Parameter keine R\u00fcckgabewert string Verwendung Verwendet f\u00fcr komplizierte Berechnung auf einem letzten Bar Beispiel protected override void OnOrderExecution(IExecution execution) { if (execution.Order != null && execution.Order.OrderState == OrderState.Filled) { if (oEnter != null && execution.Name == oEnter.Name) { // Enter-Order gef\u00fcllt if (_sendMail) this.SendEmail(Core.AccountManager.Core.Settings.MailDefaultFromAddress, Core.PreferenceManager.DefaultEmailAddress, execution.Instrument.Symbol + \" order \" + execution.Name + \" executed.\", \"The order for \" + execution.Instrument.Name + \" was executed. Invest: \" + (Trade.Quantity * Trade.AvgPrice).ToString(\"F2\")); } else if (oTStop != null && execution.Name == oTStop.Name) { OrderStatus = 0; // Trend-Stopp-Order gef\u00fcllt if (_sendMail) this.SendEmail(Core.AccountManager.Core.Settings.MailDefaultFromAddress, Core.PreferenceManager.DefaultEmailAddress, execution.Instrument.Symbol +\" order \" + execution.Name + \" executed.\", execution.Instrument.Symbol +\" order \" + execution.Name + \" executed. Profit:\" + Trade.ClosedProfitLoss.ToString(\"F2\")); } } } FirstTickOfBar Beschreibung FirstTickOfBar ist eine Eigenschaft, vom Type bool, die immer dann \"true\" ergibt, wenn der aktuell hereinkommende Tick einem neuen Bar zugeordnet wird, dieser Tick also der erste Tick eines neuen Bars ist. Die Eigenschaft kann nur sinnvoll eingesetzt werden, wenn der Indikator bzw. die Startegie im Tick-by-Tick-Modus l\u00e4uft, d.h. wenn CalculateOnClosedBar = false gesetzt ist und der verwendete Datenfeed Realtime-Kurse liefert. Bei Verwendung von EoD-Daten in einem Tageschart ist FirstTickOfBar f\u00fcr den letzten Bar immer true. FirstTickOfBar sollte nicht au\u00dferhalb der OnCalculate() Methode verwendet werden.. siehe auch Bars.TicksCountForLastBar . Verwendung FirstTickOfBar Beispiel // Innerhalb einer Tick-By-Tick-Strategie einen Teil nur Bar-by-Bar ausf\u00fchren if (FirstTickOfBar) { if (CCI(20)[1] < -250) OpenLong(); return; } FirstTickOfBarMtf Beschreibung FirstTickOfBarMtf ist die multi-time frame Variante von FirstTickOfBar . Die Einstellung von CalculateOnClosedBar wirkt sich nur auf die prim\u00e4re Zeiteinheit (Chart-Zeiteinheit) aus. Wenn jedoch mit multi-bars gearbeitet wird, werden die Ticks der sekund\u00e4ren Zeiteinheit(en) unabh\u00e4ngig von der Einstellung von CalculateOnClosedBar immer Tick-by-Tick bereitgestellt. Mit Hilfe von FirstTickOfBarMtf, ist es m\u00f6glich, festzustellen, wann in einer sekund\u00e4ren Zeiteinheit ein neuer Bar beginnt. Verwendung FirstTickOfBarMtf(ProcessingBarSeriesIndex) Parameter FirstTickOfBarMtf(ProcessingBarSeriesIndex). siehe ProcessingBarSeriesIndex . Beispiel if (FirstTickOfBarMtf(ProcessingBarSeriesIndex)) Print(\"A new bar has begun.\"); GetCurrentAsk() Beschreibung Die Methode GetCurrentAsk() liefert den aktuellen Kurs auf der Ask-Seite des Orderbuchs. Wenn AgenaTrader keine Level1-Daten zur Verf\u00fcgung stehen, liefert die Funktion den Kurs des letzten Umsatzes. siehe auch GetCurrentBid() und OnLevel1() . Verwendung GetCurrentAsk() R\u00fcckgabewert double value Parameter keiner Beispiel Wenn eine Einstiegsbedingung erf\u00fcllt ist, soll 1 Kontrakt zum aktuellen Ask-Kurs verkauft werden. private IOrder entryOrder = null; protected override void OnCalculate() { // Einstiegsbedingung if (Close[0] < SMA(20)[0] && entryOrder == null) // Verkauf 1 Kontrakt zum aktuellen AskKurs entryOrder = SubmitOrder(0, OrderAction.SellShort, OrderType.Limit, 1, GetCurrentAsk(), 0, \"\", \"Enter short\"); } GetCurrentAskVolume() Beschreibung Die Methode GetCurrentAskVolume() liefert das aktuelle Volumen auf der Ask-Seite des Orderbuchs. Diese Funktion ist nur lauff\u00e4hig, wenn der Datenanbieter Level2-Daten liefert. siehe auch GetCurrentBidVolume() , GetCurrentBid() und OnLevel1() . Verwendung GetCurrentAskVolume() R\u00fcckgabewert Long value Parameter keiner Beispiel protected override void OnCalculate() { if (GetCurrentAskVolume() < GetCurrentBidVolume()) Print(\"AskVolume {0} < BidVolume {1}\", GetCurrentAskVolume(), GetCurrentBidVolume()); } GetCurrentBid() Beschreibung Die Methode GetCurrentBid() liefert den aktuellen Kurs auf der Bid-Seite des Orderbuchs. Wenn AgenaTrader keine Level1-Daten zur Verf\u00fcgung stehen, liefert die Funktion den Kurs des letzten Umsatzes. siehe auch GetCurrentAsk() und OnLevel1() . Verwendung GetCurrentBid() R\u00fcckgabewert double value Parameter keiner Beispiel Wenn eine Einstiegsbedingung erf\u00fcllt ist, soll 1 Kontrakt zum aktuellen Bid-Kurs gekauft werden. private IOrder entryOrder = null; protected override void OnCalculate() { // Einstiegsbedingung if (Close[0] > SMA(20)[0] && entryOrder == null) // Kauf 1 Kontrakt zum aktuellen BidKurs entryOrder = SubmitOrder(0, OrderAction.Buy, OrderType.Limit, 1, GetCurrentBid(), 0, \"\", \"Enter long\"); } GetCurrentBidVolume() Beschreibung Die Methode GetCurrentBidVolume() liefert das aktuelle Volumen auf der Bid-Seite des Orderbuchs. Diese Funktion ist nur lauff\u00e4hig, wenn der Datenanbieter Level2-Daten liefert. siehe auch GetCurrentAskVolume , GetCurrentBid() und OnLevel1() . Verwendung GetCurrentBidVolume() R\u00fcckgabewert Long value Parameter keiner Beispiel protected override void OnCalculate() { if (GetCurrentAskVolume() < GetCurrentBidVolume()) Print(\"AskVolume {0} < BidVolume {1}\", GetCurrentAskVolume(), GetCurrentBidVolume()); } GetCurrentPrice() Beschreibung Die Methode GetCurrentPrice() liefert den aktuellen Kurs (Latest). Wenn AgenaTrader keine Level1-Daten zur Verf\u00fcgung stehen, liefert die Funktion den Kurs des letzten Umsatzes. siehe auch GetCurrentAsk , GetCurrentBid() und OnLevel1() . Verwendung GetCurrentPrice() R\u00fcckgabewert keiner Parameter double value Beispiel Wenn eine Einstiegsbedingung erf\u00fcllt ist, soll 1 Kontrakt zum aktuellen Kurs gekauft werden. private IOrder entryOrder = null; protected override void OnCalculate() { // Einstiegsbedingung if (Close[0] > SMA(20)[0] && entryOrder == null) // Kauf 1 Kontrakt zum aktuellen BidKurs entryOrder = SubmitOrder(0, OrderAction.Buy, OrderType.Limit, 1, GetCurrentPrice(), 0,\"\", \"Enter Long\"); } GetCurrentSpread() Beschreibung Die Methode GetCurrentSpread() liefert den aktuellen Spread. siehe auch GetCurrentAsk , GetCurrentBid() and OnLevel1() . Verwendung GetCurrentSpread() R\u00fcckgabewert keiner Parameter double Beispiel Wenn eine Anfangsbedingung erf\u00fcllt ist, sollte ein Vertrag zum aktuellen Wechselkurs gekauft werden. protected override void OnCalculate() { Print(\"Der aktuelle Spread ist {0}\", GetCurrentSpread()); } GetDayAsInt() Beschreibung GetDayAsIntist eine Methode, die sich speziell an unerfahrene Programmierer richtet, die mit der durchaus komplizierten .Net-DateTime-Struktur aus C# Schwierigkeiten haben. Erfahrene Programmierer k\u00f6nnen die DateTime-Funktionen auch direkt verwenden. GetDayAsInt liefert eine int-Repr\u00e4sentation im Format yyyyMMdd. (yyyy = Jahr, MM = Monat, dd = Tag) Die Zahl f\u00fcr den 13.08.2012 lautet damit 20120813. Siehe auch GetTimeAsInt . Hilfe zu DateTime: http://msdn.microsoft.com/de-de/library/system.datetime.aspx Verwendung GetDayAsInt(DateTime time) Beispiele // Am 11. September besser keine Trades eingehen if (GetDayAsInt(Time[0]) = 20130911) return; GetSeriesHighestValue Beschreibung Die Methode GetSeriesHighestValue() sucht in einer vorgegebenen Anzahl von Perioden nach dem h\u00f6chsten Bar und gibt an, vor wievielen Bars dieser h\u00f6chste Bar zu finden ist Siehe auch GetSeriesLowestValue() . Parameter period Anzahl von Bars, innerhalb derer gesucht werden soll series Jede Datenserie, wie Close, High, Low usw. R\u00fcckgabewert int barsAgo Vor wievielen Bars trat das Hoch auf Verwendung GetSeriesHighestValue(IDataSeries series, int period) Beispiele // Vor wievielen Bars lag das h\u00f6chste Hoch der aktuellen Session? Print(GetSeriesHighestValue(High, Bars.BarsCountForSession - 1)); // Welchen Kurs hatte das bisher h\u00f6chste Open der aktuellen Session? Print(\"The highest price for the session was: \" + Open[GetSeriesHighestValue(High, Bars.BarsCountForSession - 1)]); GetSeriesLowestValue Beschreibung Die Methode GetSeriesLowestValue() sucht in einer vorgegebenen Anzahl von Perioden nach dem tiefsten Bar und gibt an, vor wievielen Bars dieser tiefste Bar zu finden ist. Siehe auch GetSeriesHighestValue() . Parameter period Anzahl von Bars, innerhalb derer gesucht werden soll series Jede Datenserie, wie Close, High, Low usw. R\u00fcckgabewert int barsAgo Vor wievielen Bars trat das Tief auf Verwendung GetSerieLowestValue(IDataSeries series, int period) Beispiele // Vor wievielen Bars lag das tiefste Tief der aktuellen Session? Print(GetSeriesLowestValue(Low, Bars.BarsCountForSession - 1)); // Welchen Kurs hatte das bisher tiefste Open der aktuellen Session? Print(\"The lowest open price of the current session was: \" + Open[GetSeriesLowestValue(Low, Bars.BarsCountForSession - 1)]); GetTimeAsInt() Beschreibung GetTimeAsInt ist eine Methode, die sich speziell an unerfahrene Programmierer richtet, die mit der durchaus komplizierten .Net-DateTime-Struktur aus C# Schwierigkeiten haben. Erfahrene Programmierer k\u00f6nnen die DateTime-Funktionen auch direkt verwenden.. GetTimeAsInt liefert eine int-Repr\u00e4sentation im Format HHmmss. (HH = Stunde, mm = Minute, ss = Sekunde) Die Uhrzeit 07:30 Uhr wird dargestellt als 73000 und 14:15:12 wird zu 141512. Siehe auch GetDayAsInt . Hilfe zu DateTime: http://msdn.microsoft.com/de-de/library/system.datetime.aspx Verwendung GetTimeAsInt(DateTime time) Beispiele // Nur zwischen 08:15 Uhr und 16:35 Uhr Trades eingehen if (GetTimeAsInt(Time[0]) >= 81500 && GetTimeAsInt(Time[0]) <= 163500) { // irgendeine Handelslogic } Historical Beschreibung Mit Historical l\u00e4\u00dft sich \u00fcberpr\u00fcfen, ob AgenaScript mit historen Daten oder mit Real-Time-Daten arbeitet. Solange OnCalculate() f\u00fcr historische Daten aufgerufen wird, ist Historical = true, in dem Moment, in dem die Verarbeitung von Live-Daten beginnt, wird Historical = false. W\u00e4hrend ein Backtest ausgef\u00fchrt wird, ist Historical immer true. Verwendung Historical R\u00fcckgabewert true bei Verarbeitung von historischen Daten false bei Verarbeitung von Real-Time-Daten Beispiele protected override void OnCalculate() { // Nur f\u00fcr realtime-Daten ausf\u00fchren if (IsHistoricalMode) return; // irgendeine Handelslogik } InputPriceType Beschreibung Die Eigenschaft InputPriceType legt fest, welche Kursreihe bei der Berechnung in Indikatoren als Standard verwendet werden soll, wenn keine Datenreihe explizit angegeben ist. InputPriceType kann in der OnInit()-Methode stehen. Die Angabe hat dann f\u00fcr alle weiteren Berechnungen im Indikator G\u00fcltigkeit. Steht InputPriceType in OnCalculate(), gilt die \u00c4nderung der Eingangsdatenreihe ab der n\u00e4chsten Anweisung. Jedes weitere Auftreten von InputPriceType wird ignoriert! Siehe auch PriceType Verwendung InputPriceType Beispiel1 protected override void OnInit() { ClearTraceWindow(); InputPriceType = PriceType.Low; } protected override void OnCalculate() { // Die Eingangsdatenreihe f\u00fcr den Indikator (Input) ist Low Print(Low[0] + \" \" + InSeries[0] + \" \" + InputPriceType); } Beispiel2 protected override void OnCalculate() { // Diese Werte sind identisch, // da standardm\u00e4\u00dfig Close als Inputdatenreihe verwendet wird Print(SMA(20)[0] + \" \" + SMA(Close, 20)[0]); InputPriceType = PriceType.Low; // ab hier wird Low anstatt Close als Standard verwendet // Die beiden Werte sind identisch Print(SMA(20)[0] + \" \" + SMA(Low, 20)[0]); InputPriceType = PriceType.High; // Diese Anweisung wird ignoriert. // Es gilt weiterhin Input = Low !!! } Instrument Beschreibung Mit Instrument werden Informationen zum Handelsinstrument (Aktie, Future etc.) bereitgestellt, f\u00fcr welches ein Indikator, eine Strategie usw. gerade l\u00e4uft. Ausf\u00fchrliche Details finden sich unter Instruments . IsAddDrawingsToPricePanel Beschreibung Die Eigenschaft \"IsAddDrawingsToPricePanel\" legt fest, in welchem Panel Zeichenobjekte gezeichnet werden. IsAddDrawingsToPricePanel = true (default) Zeichenobjekte werden im Preischart gezeichnet IsAddDrawingsToPricePanel = false Zeichenobjekte werden in dem Panel (Subchart) gezeichnet, das dem Indikator zugeordnet ist. Ist der Indikator bereits dem Preischart zugeordnet (Overlay = true) ist diese Eigenschaft wirkungslos, d.h. es wird in diesem Fall kein neuer Subchart ge\u00f6ffnet. Die Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false) Verwendung IsAddDrawingsToPricePanel Beispiel protected override void OnInit() { // Indikator in einem neuen Subchart zeichnen IsOverlay = false; (Color.FromKnownColor(KnownColor.Red), \"MyPlot1\")); // Zeichenobjekte im Preischart zeichnen IsAddDrawingsToPricePanel = true; } protected override void OnCalculate() { // zeichnet im Preischart eine vertikale Linie am Bar von vor 5 Perioden AddChartVerticalLine(\"MyVerticalLine\", 5, Color.Black); } IsAutoAdjustableScale Beschreibung Auto scale is a property of indicators that can be set within the OnInit() method. IsAutoAdjustableScale = true (default) Die Preisachse (y-Achse) des Charts wird so eingestellt, dass alle Plots und Lines eines Indikators bzw. einer Strategie im Chart sichtbar sind. IsAutoAdjustableScale = false Plots und Lines eines Indikators bzw. einer Strategie werden nicht in die Skalierung der Preisachse (y-Achse) eines Charts mit einbezogen. Sie k\u00f6nnen auch ausserhalb des sichtbaren Chartbereichs liegen. Die Eigenschaft kann abgefragt werden, und liefert \"true\" bzw. \"false\". Verwendung IsAutoAdjustableScale Beispiel protected override void OnInit() { //Chart so skalieren, dass alle Zeichenobjekte sichtbar sind IsAutoAdjustableScale = true; } IsOverlay Beschreibung Die Eigenschaft Overlay legt fest, ob die Indikatorausgaben, wie Plots und Linien, im Preischart \u00fcber die Kursbars gezeichnet werden oder ob ein neues separates Chartfenster unterhalb des Preischarts ge\u00f6ffnet wird. IsOverlay = true Es wird \u00fcber den Kurs gezeichnet (wie z.B. ein SMA ) IsOverlay = false (default) Es wird ein separates Chartfenster ge\u00f6ffnet (wie z.B. ein RSI ) Die Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false). Verwendung IsOverlay Beispiel protected override void OnInit() { (Color.FromKnownColor(KnownColor.Red), \"MyPlot1\")); //Der Indikator soll in einem separaten Fenster dargestellt werden IsOverlay = false; } IsProcessingBarIndexLast Description Indicates if current bar is last in calculation. Parameter None Return value Type bool Usage used for complicated calculation on a last bar Example protected override void OnCalculate() { base.OnCalculate(); if (!IsProcessingBarIndexLast) return; bool isUpdated; } IsSerieRising() Beschreibung Mit der Methode IsSerieRising() kann gepr\u00fcft werden, ob eine \"ist steigend\"-Bedingung vorliegt, d.h. ob der aktuelle Wert gr\u00f6\u00dfer ist als der Wert des vorhergehenden Bars. Siehe auch CrossAbove() , CrossBelow() , IsSerieRising() , IsSerieFalling() . Verwendung IsSerieRising(IDataSeries series) R\u00fcckgabewert true wenn die Datenreihe steigt false wenn die Datenreihe nicht steigt Parameter series eine Datenserie, wie z.B. ein Indikator, Close, High o.\u00e4 Beispiele // Pr\u00fcfen, ob der SMA(20) steigt if (IsSerieRising(SMA(20))) Print(\"The SMA(20) is currently rising.\"); IsSeriesFalling() Beschreibung Mit der Methode IsSeriesFalling() kann gepr\u00fcft werden, ob eine \"ist fallend\"-Bedingung vorliegt, d.h. ob der aktuelle Wert kleiner ist als der Wert des vorhergehenden Bars. Siehe auch CrossAbove() , CrossBelow() , IsSerieRising() , IsSerieFalling() . Verwendung IsSerieFalling(IDataSeries series) R\u00fcckgabewert true wenn die Datenreihe f\u00e4llt false wenn die Datenreihe nicht f\u00e4llt Parameter series eine Datenserie, wie z.B. ein Indikator, Close, High o.\u00e4 Beispiele // Pr\u00fcfen, ob der SMA(20) f\u00e4llt if (IsSerieFalling(SMA(20))) Print(\"The SMA(20) is currently falling.\"); IsShowChartVerticalGrid Beschreibung Die Eigenschaft IsShowChartVerticalGrid legt fest, ob in regelm\u00e4\u00dfigen Abst\u00e4nden vertikale Linien im Chart (das sog. vertikale Grid) angezeigt werden sollen. IsShowChartVerticalGrid = true (default) Vertikale Gitternetzlinien werden im Chart angezeigt. IsShowChartVerticalGrid = false Vertikale Gitternetzlinien werden nicht im Chart angezeigt. Die Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false). Verwendung IsShowChartVerticalGrid Beispiel protected override void OnInit() { (Color.FromKnownColor(KnownColor.Black), \"MyPlot1\")); // Vertikale Gitternetzlinien sollen nicht im Chart angezeigt werden IsShowChartVerticalGrid = false; } IsShowInDataBox Beschreibung Die Eigenschaft \"IsShowInDataBox\" gibt an, ob die Werte des Indikators (Datenserien) in der DataBox des Charts enthalten sein sollen oder nicht. Die Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false) IsShowInDataBox = true (default) Die Indikatorwerte werden in der DataBox angezeigt. IsShowInDataBox = false Die Indikatorwerte werden nicht in der DataBox angezeigt. Im Bild werden die Werte von 3 gleitenden Durchschnitten in der DataBox angezeigt. Verwendung IsShowInDataBox Beispiel protected override void OnInit() { (Color.FromKnownColor(KnownColor.Black), \"MyPlot1\")); //Werte sollen nicht in der DataBox angezeigt werden IsShowInDataBox = false; } IsShowPriceMarkers Beschreibung Die Eigenschaft PaintPriceMarkers legt fest, ob f\u00fcr die Indikatorausgaben, am rechten Chartrand (in der Preisachse) die sog. PriceMarkers angezeigt werden sollen oder nicht. In manchen F\u00e4llen ist es sinnvoll, dies f\u00fcr eine bessere \u00dcbersicht im Chart auszuschalten. IsShowPriceMarkers = true (default) PriceMarkers werden in der Preisachse angezeigt. IsShowPriceMarkers = false PriceMarkers werden nicht in der Preisachse angezeigt. Die Eigenschaft kann imScript abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false). Verwendung IsShowPriceMarkers Beispiel protected override void OnInit() { (Color.FromKnownColor(KnownColor.Black), \"MyPlot1\")); //IsShowPriceMarkers sollen nicht angezeigt werden IsShowPriceMarkers = false; } Level1Args Beschreibung Der Datentyp MarketDataEventArgs repr\u00e4sentiert eine \u00c4nderung in den Level-I-Daten und wird als Parameter in der Funktion OnLevel1() verwendet. AskSize Das aktuelle Ordervolumen auf der Ask-Seite. AskPrice Der aktuelle Ask-Kurs BidSize Das aktuelle Ordervolumen auf der Bid-Seite BidPrice Der aktuelle Bid-Kurs. Instrument Ein Objekt des Types IInstrument, das das Handelsinstrument beinhaltet, f\u00fcr welches die Level-I-Daten geliefert werden. Siehe Instruments LastPrice Der letzte durch einen Umsatz entstandene Kurs MarketDataType M\u00f6gliche Werte sind: MarketDataType.Ask, MarketDataType.AskSize, MarketDataType.Bid, MarketDataType.BidSize, MarketDataType.Last, MarketDataType.Volume Price Tenth\u00e4lt den gleichen Wert wie LastPrice. Das Feld ist nur aus Kompatibilit\u00e4tsgr\u00fcnden vorhanden. Time Ein DateTime-Wert, der den Zeitstempel der \u00c4nderung beinhaltet. Volume Ein long-Wert, der das Volumen, d.h. den letzten realen Umsatz angiebt. Beispiel siehe Beispiel unter OnLevel1() . Level2Args Beschreibung Der Datentyp Level2Args repr\u00e4sentiert eine \u00c4nderung in den Level-II-Daten (Markttiefe) und wird als Parameter in der Funktion OnLevel2() verwendet. MarketDataType M\u00f6gliche Werte sind: MarketDataType.Ask, MarketDataType.Bid MarketMaker Ein string-Wert, der die Market Maker ID enth\u00e4llt Position Ein int-Wert, der die Position innerhalb der Markttiefe angiebt Operation Steht f\u00fcr die Aktion, die durch die \u00c4nderung in einem Orderbuch ausgel\u00f6st wird. M\u00f6gliche Werte sind: Operation.Insert, Operation.Remove, Operation.Update Price Eine double-Wert, der den jeweiligen Bid/Ask-Kurs Time Ein DateTime-Wert, der den Zeitstempel der \u00c4nderung beinhaltet Volume Ein long-Wert, der das Volumen angiebt Beispiel siehe Beispiel unter OnLevel2() . LevelLine() Beschreibung EinA LevelLine object wird genutzt, um eine horizontale Linie in einen Chart zu zeichnen. \u00dcblicherweise sind dies obere und untere Triggerlinien wie z.B. beim RSI-Indikator die 70 und die 30 Linie. Diese hier beschriebenen Linien sind nicht zu verwechseln mit der Linie aus den Zeichenobjekten (siehe \"AddChartHorizontalLine\"). LevelLine objectwerden einem Indikator mit Hilfe der Add()-Methode hinzugef\u00fcgt und damit in die Lines-Collection aufgenommen. Siehe auch OutputDescriptor . Parameter Color Linienfarbe Name Bezeichnung Pen ein Pen-Objekt Value Gibt an, bei welchem Wert auf der y-Achse (Preisachse) die Linie gezeichnet werden soll Verwendung LevelLine(Color color, double value, string name) LevelLine(Pen pen, double value, string name) Weitere Informationen Informationen zur Klasse Pen: http://msdn.microsoft.com/de-de/library/system.drawing.pen.aspx Beispiele // Beispiel 1 // Eine Linie mit Standardwerten bei 70 in den Chart zeichnen Add(new LevelLine(Color.Black, 70, \"Upper\")); // Beispiel 2 // Eine Linie mit selbstdefinierten Werten in den Chart zeichnen private LevelLine line; private Pen pen; protected override void OnInit() { // einen roten Stift mit der Linienst\u00e4rke 1 definieren pen = new Pen(Color.Red, 1); // eine horizontale Linie bei 10 definieren line = new LevelLine(pen, 10, \"MyLine\"); // die oben def. Linie dem Indikator hinzuf\u00fcgen Add(line); } // Beispiel 3 // Kurzform f\u00fcr die Linie aus Bespiel 2 Add(new LevelLine(new Pen(Color.Red, 1), 10, \"MyLine\")); Log() Beschreibung Mit Log() ist es m\u00f6glich, Ausgaben in das LogFile (Log Tab) von AgenaTrader zu schreiben. Es werden 5 verschiedene LogLevel unterst\u00fctzt. Hinweis: Ist der Log-Tab nicht sichtbar, kann er mit Tools-Log angezeigt werden. Verwendung **Log**(string message, LogLevel logLevel) Parameter message Text (message) logLevel M\u00f6gliche Werte sind: InfoLogLevel.Info, InfoLogLevel.Message, InfoLogLevel.Warning, InfoLogLevel.ShowAlert, InfoLogLevel.Error Beispiel //Tab protocol Log(\"Das ist eine Information.\", InfoLogLevel.Info); //white Log(\"Das ist eine Nachricht.\", InfoLogLevel.Message); // white Log(\"Das ist eine Warnung.\", InfoLogLevel.Warning); // blue Log(\"Das ist ein Alarm.\", InfoLogLevel.ShowAlert); //green Log(\"Das ist ein Fehler.\", InfoLogLevel.Error); // red //Tab messages Log(\"This is a message (messages).\", InfoLogLevel.Message); //white //PopUp & protocoll Log(\"This is an alert popup window.\", InfoLogLevel.ShowAlert); //green //Output-Tab: //InfoLogLevel.Message = send to Tab \"Messages\" not \"Log\" //Action: /* InfoLogLevel.Error: also the AT-Status-Line is red and flashes InfoLogLevel.ShowAlert: opens also a modeless messagebox */ /* Summary: * - InfoLogLevel.ShowAlert Color: green Tab: Log Action: modeless Messagebox * - InfoLogLevel.Warning Color: blue Tab: Log * - InfoLogLevel.Info Color: white Tab: Log * - InfoLogLevel.Error Color: red Tab: Log Action: AT-Status-Line: red + flashing (Error) * - InfoLogLevel.Message Color: white Tab: Messages */ Crossreference: a crossreference to Print() and ShowAlert() Occurred Beschreibung Diese DataSeries werden unter Bedingungen verwendet und geben an, ob ein Signal aufgetreten ist(1-long, -1 short, 0- kein signal ) Parameter keiner R\u00fcckgabewert Int Verwendung Im Skriptzustand f\u00fcr short, long, kein Signal Beispiel protected override void OnCalculate() { if ( ProcessingBarIndex %2 == 0 ) Occurred.Set(1); // Long else if ( ProcessingBarIndex %3 == 0 ) Occurred.Set(-1); // Short else Occurred.Set(0); } OnBarsRequirements() Beschreibung Die OnBarsRequirements() Methode wird einmal zu Beginn einer Indikator- bzw. Strategieberechnung aufgerufen. Die Methode ist nur bei Verwendung von MultiBars notwendig. Innerhalb von InitRequirements werden keine weiteren Programmierbefehle ausgef\u00fchrt. F\u00fcr eigene Initialisierungen sind die MethodenOnInit() bzw. OnStart() zu verwenden. Parameter keiner R\u00fcckgabewert keiner Beispiel protected override void OnBarsRequirements() { Add(DatafeedHistoryPeriodicity.Day, 1); Add(DatafeedHistoryPeriodicity.Week, 1); } OnInit() Beschreibung Die OnInit()-Methode wird einmal zu Beginn einer Indikator- bzw. Strategieberechnung aufgerufen. Die Methode kann verwendet werden um Indikatoreigenschaften zu setzen, eigene Variablen zu initialisieren oder Plots hinzuzuf\u00fcgen. Parameter keiner R\u00fcckgabewert keiner Verwendung protected override void OnInit() wichtige Schl\u00fcsselworte Add() AllowRemovalOfChartDrawings IsAutoScale RequiredBarsCount CalculateOnClosedBar ClearTraceWindow Displacement IsShowInDataBox IsAddDrawingsToPricePanel InputPriceType IsOverlay IsShowPriceMarkers IsShowChartVerticalGrid zus\u00e4tzlich f\u00fcr Strategien DefaultOrderQuantity EntriesPerDirection SetUpStopLoss() SetUpProfitTarget() SetUpTrailStop() TimeInForce TraceOrders Weitere Informationen Achtung: Die OnInit()-Methode wird nicht nur am Beginn einer Indikator- bzw. Strategieberechnung aufgerufen, sondern auch unerwartet z.B. wenn ein Chart neu geladen wird oder der Eigenschaftsdialog von Indikatoren ge\u00f6ffnet wird usw. Entwickler von eigenen AgenaScripts sollten diese Methode NICHT verwenden, um eigene Routinen laufen zu lassen, Forms zu \u00f6ffnen, Lizenzchecks auszuf\u00fchren u. dgl. mehr. Hierzu ist die Methode OnStart() zu verwenden. Beispiel protected override void OnInit() { AddOutput(new OutputDescriptor(Color.FromKnownColor(KnownColor.Black), \"MyPlot1\")); ClearTraceWindow(); IsAutoScale = false; IsOverlay = true; IsShowPriceMarkers = false; IsShowInDataBox = false; CalculateOnClosedBar = true; } OutputDescriptor() Beschreibung Ein OutputDescriptor (drawing)wird genutzt, um einen Indikator in einem Chart graphisch darzustellen. Plot-Objekte werden einem Indikator mit Hilfe der Add()-Methode hinzugef\u00fcgt und damit in die Plots-Collection aufgenommen. Siehe auch LevelLine . Parameter Color Zeichenfarbe Pen ein Pen-Objekt PlotStyle Linienart: PlotStyle.Bar, PlotStyle.Block, PlotStyle.Cross, PlotStyle.Dot, PlotStyle.Hash, PlotStyle.LevelLine, PlotStyle.Square, PlotStyle.TriangleDown, PlotStyle.TriangleUp Name Bezeichnung Verwendung OutputDescriptor(Color color, string name) OutputDescriptorOutputDescriptorOutputDescriptor(Pen pen, string name) OutputDescriptorOutputDescriptor(Color color, PlotStyle plotStyle, string name) OutputDescriptor(Pen pen, PlotStyle plotStyle, string name) Weitere Informationen Informationen zur Klasse Pen: http://msdn.microsoft.com/de-de/library/system.drawing.pen.aspx Beispiele // Beispiel 1 // Plot mit Standardwerten (Linie mit Linienst\u00e4rke 1) Add(new OutputDescriptor(Color.Green, \"MyPlot\")); // Beispiel 2 // benutzerdefinierte Werte f\u00fcr Pen und PlotStyle private OutputDescriptor plot; private Pen pen; protected override void OnInit() { // einen roten Stift mit der Linienst\u00e4rke 6 definieren pen = new Pen(Color.Blue, 6); // eine Punkt-Linie mit dem dicken roten Stift von oben definieren plot = new OutputDescriptor(pen, PlotStyle.Dot, \"MyPlot\"); // den oben def. Plot als Darstellung f\u00fcr den Indikator verwenden Add(plot); } // Beispiel 3 // Kurzform von Beispiel 2 protected override void OnInit() { Add(new OutputDescriptor(new Pen(Color.Blue, 6), PlotStyle.Dot, \"MyPlot\")); } InputParameter() Beschreibung Attribut, das f\u00fcr die Anpassung der Indikatoren verwendet wird R\u00fcckgabewert keiner Parameter keiner Beispiele [Description(\"Period for the medium mean average\")] [InputParameter] [DisplayName(\"MA Medium\")] public int MA_Medium { get { return _ma_medium; } set { _ma_medium = value; } } PlaySound() Beschreibung Die Methode PlaySound() dient dazu, ein Wav-File abzuspielen. Verwendung PlaySound (wavFile) R\u00fcckgabewert keiner Parameter wavFile Dateiname der Wav-Datei zum Abspielen Beispiel using System.IO; string path = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments); string file = \"\\\\\\\\AgenaTrader\\\\\\\\Sounds\\\\\\\\Alert1.wav\"; PlaySound(path + file); PlotMethod Beschreibung In jedem Indikator kann die Plot-Methode \u00fcberschrieben werden um mit Mittlen der Graphics-Klasse (System.Drawing) dem Preis-Chart eigene Grafiken hinzuzuf\u00fcgen (GDI+). Siehe http://msdn.microsoft.com/de-de/library/system.drawing.graphics.aspx . Das Objekt Chart bietet einige n\u00fctzliche Parameter. Weitere Beispiele: Bar Numbering , PlotSample , Chart Background Image . Parameter graphics Das graphics-Objekt des Preischarts (der sog. context) rectangle Die Gr\u00f6\u00dfe der Zeichenfl\u00e4che (Type public struct rectangle) double min Der kleinste Kurs in der y-Achse double max Der gr\u00f6\u00dfte Kurs in der y-Achse R\u00fcckgabewert keiner Verwendung public override void OutputDescriptor(Graphics graphics, Rectangle r, double min, double max) Beispiel using System; using System.Collections.Generic; using System.ComponentModel; using System.Drawing; using System.Drawing.Drawing2D; using AgenaTrader.API; using AgenaTrader.Custom; using AgenaTrader.Plugins; namespace AgenaTrader.UserCode { [Description(\"Example for the usage of the plot method.\")] public class PlotSample : UserIndicator { private StringFormat stringFormat = new StringFormat(); private SolidBrush brush = new SolidBrush(Color.Black); private Font font = new Font(\"Arial\", 10); protected override void OnInit() { IsChartOnlyIndicator = true; IsOverlay = true; } protected override void OnCalculate() {} protected override void OnDispose() { brush.Dispose(); stringFormat.Dispose(); } public override void OutputDescriptor(Graphics graphics, Rectangle r, double min, double max) { // Ausfuellen eines Rechtecks SolidBrush tmpBrush = new SolidBrush(Color.LightGray); graphics.FillRectangle(tmpBrush, new Rectangle (0, 0, 300, 300)); tmpBrush.Dispose(); // Zeichnen einer roten Linie von oben links nach unten recht Pen pen = new Pen(Color.Red); graphics.AddChartLine(pen, r.X, r.Y, r.X + r.Width, r.Y + r.Height); // Zeichnen einer roten Linie von unten links nach oben rechts // Verwenden von AnitAlias (Die Linie erscheint glatter) // Die aktuellen Einstellungen fuer die Glaettung werden gesichert // und nach dem Zeichnen wiederhergestellt SmoothingMode oldSmoothingMode = graphics.SmoothingMode; //Einstellung sichern graphics.SmoothingMode = SmoothingMode.AntiAlias; // hohe Glaettung verwenden graphics.AddChartLine(pen, r.X, r.Y + r.Height, r.X + r.Width, r.Y); graphics.SmoothingMode = oldSmoothingMode; // Einstellungen wiederherstellen pen.Dispose(); // Text in die obere linke Ecke (Position 10,35) schreiben stringFormat.Alignment = StringAlignment.Near; // Text links ausrichten brush.Color = Color.Blue; graphics.DrawString(\"Hello world!\", font, brush, r.X + 10, r.Y + 35, stringFormat); // Text in die linke untere Ecke schreiben und eine Linie darum herumzeichnen brush.Color = Color.Aquamarine; graphics.FillRectangle(brush, r.X + 10, r.Y + r.Height - 20, 140, 19); // Aeussere Linie zeichnen pen = new Pen(Color.Black); graphics.AddChartRectangle(pen, r.X + 10, r.Y + r.Height - 20, 140, 19); pen.Dispose(); // Text schreiben brush.Color = Color.Red; graphics.DrawString(\"Here is bottom left!\", font, brush, r.X + 10, r.Y + r.Height - 20, stringFormat); } } } PriceType Beschreibung PriceType beschreibt die Art von Kursdaten. Siehe auch InputPriceType Folgende Werte stehen zur Verf\u00fcgung: - PriceType.Close - PriceType.High - PriceType.Low - PriceType.Median - PriceType.Open - PriceType.Typical - PriceType.Volume - PriceType.Weighted Verwendung PriceType Beispiel Siehe Beispiel unter InputPriceType Print() Beschreibung Die Methode Print() schreibt Ausgaben in das AgenaTrader Output-Window. Siehe auch ClearTraceWindow . Verwendung Print(string message) Print(bool value) Print(double value) Print(int value) Print(DateTime value) Print(string format, string message) Parameter string Text ein individueller Meldungstext R\u00fcckgabewert keiner Weitere Informationen Hinweise zum Formatieren von Ausgaben finden Sie unter Formatting numbers . Hinweise zur String.Format()-Methode: http://msdn.microsoft.com/de-de/library/fht0f5be%28v=vs.80%29.aspx Beispiel // \"Quick&Dirty\"-Formatierung einer Zahl mit 2 Nachkommastellen Print(Close[0].ToString(\"0.00\")); // Wochentag aus dem Zeitstempel des Bars ausgeben Print(string.Format(\"{0:dddd}\", Time[0])); // Ein zus\u00e4tzlicher Zeilenvorschub mit ESC-Sequenz Print(\"One empty row afterwards \\\\n\"); ProcessingBarIndex Beschreibung ProcessingBarIndex ist eine Nummerierung von Bars, die in der Methode OnCalculate() verwendet wird. Wenn in einem Chart z.B. 500 Bars dargestellt werden und auf diese ein Indikator berechnet werden soll, so beginnt AgenaTrader mit der Berechnung (also dem Aufruf von OnCalculate() bei dem \u00e4ltesten Bar. Dieser bekommt die Nummer 0. Ist die Berechnung f\u00fcr diesen Bar abgeschlossen, wird OnCalculate() f\u00fcr den n\u00e4chsten Bar aufgerufen. Dieser bekommt dann die Nummer 1 usw. bis zum letzten Bar, der die Nummer 499 bekommt. Parameter keiner R\u00fcckgabewert ProcessingBarIndex ist eine Variable vom Typ int, die immer die Nummer des sich gerade in Bearbeitung befindenden Bars enth\u00e4lt. Verwendung ProcessingBarIndex Weitere Informationen Die in der Methode OnCalculate() verwendete Nummerierung mit ProcessingBarIndex unterscheidet sich vom Barindex und Bars . Das Verst\u00e4ndnis dieses Unterschiedes ist sehr wichtig! Bitte das folgende genau lesen! ProcessingBarIndex nummeriert fortlaufend vom \u00e4ltesten zum j\u00fcngsten Bar beginnend bei 0. Der Barindex ist f\u00fcr den j\u00fcngsten Bar immer 0. Im Beispiel unten steht Time[0] f\u00fcr den Zeitstempel des aktuellen Bars. Der Index des \u00e4ltesten Bars wird mit jedem neu hinzukommenden Damit wird eine logische Z\u00e4hlung f\u00fcr barsAgo m\u00f6glich. Der Zeitstempel f\u00fcr den Bar von vor 5 Perioden ist damit Time[5]. Bei Verwendung mehrerer Zeiteinheiten (multi-bars)in einem Indikator siehe ProcessingBarIndexes. Beispiel protected override void OnCalculate() { Print(\"Call of OnCalculate for bar nr. \" + ProcessingBarIndex + \" of \" + Time[0]); } RemoveChartDrawing() Beschreibung Die Methode RemoveChartDrawing() entfernt ein bestimmtes Zeichenobjekt vom Chart anhand einer eindeutigen Kennzeichnung (tag). Siehe auch RemoveChartDrawings() . Verwendung RemoveChartDrawings(string tag) R\u00fcckgabewert keiner Parameter string tag Der Name eines Zeichenobjekts zur eindeutigen Identifizierung Beispiel RemoveChartDrawings(\"Meine Linie\"); RemoveChartDrawings() Beschreibung Die Methode RemoveDrawObjects() entfernt alle Zeichenobjekte vom Chart. Siehe auch RemoveChartDrawings() . Verwendung RemoveChartDrawings() R\u00fcckgabewert keiner Beispiel //Alle Zeicheobjekte vom Chart l\u00f6schen RemoveChartDrawings(); RequiredBarsCount Beschreibung Die Eigenschaft BarsRequired gibt an, wieviele historische Bars mindestens ben\u00f6tigt werden, damit ein Indikator bzw. eine Strategie erstmal die Methode OnCalculate() aufrufen und mit den Berechnungen beginnen kann. BarsRequired sollte in der OnInit() Methode angegeben werden. Die Einstellung sollte sorgf\u00e4ltig gew\u00e4hlt werden. Z.B. braucht man zur Berechnung eines gleitenden Durchschnittes \u00fcber 100 Tage auch mindestens 100 Tage historische Daten, damit das Ergebnis korrekt ist. Die Eigenschaft kann im Script abgefragt werden und liefert einen int-Wert. Wenn OnBarUpdate erstmals aufgerufen wird, ist ProcessingBarIndex property = 0, unabh\u00e4ngig vom Wert von RequiredBarsCount. Verwendung RequiredBarsCount Beispiel protected override void OnInit() { //Der Indikator ben\u00f6tigt mindestens 50 Bars Historie RequiredBarsCount = 50; } ShowAlert() Beschreibung Mit der Methode ShowAlert wird ein akustischer und/oder visueller Alarm erzeugt. Verwendung ShowAlert(string message, bool showMessageBox, string soundLocation); //Aus Kompatibilit\u00e4tsgr\u00fcnden ist noch eine veraltete Signatur enthalten. Bei Nutzung dieses Aufrufvariante werden die Farbangaben und \"rearmSeconds\" ignoriert. ShowAlert(string id, AlertPriority priority, string message, string soundLocation, int rearmSeconds, Color backColor, Color forColor); R\u00fcckgabewert keiner Parameter message Nachrichtentext, der im Messages-Tab angezeigt wird. soundLocation Name eines Sound-Files im *.wav Format. Ist kein Pfad angegeben, wird \"Eigene Dokumente\\AgenaTrader\\Sounds\" verwendet. showMessageBox wenn true, wird zus\u00e4tzlich zum Sound eine Messagebox auf dem Bildschim angezeigt. Beispiel // Hinweis ausgeben, wenn der SMA(20) unter SMA(50) kreuzt if (CrossBelow(SMA(20), SMA(50), 1)) Alert(\"Check short signal!\", true, \"Alert4.wav\"); Um Musikdateien in anderen Verzeichnissen wiederzugeben, muss der vollst\u00e4ndige Pfad angegeben werden, z.B.: string pathOfSoundfile = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments)+@\"\\\\MyAlertSounds\\\\\"; string nameOfSoundFile = \"MyAlertSoundFile.wav\"; Alert(\"Message text\", true, pathOfSoundfile + nameOfSoundFile); TickSize Ein Tick ist die kleinst m\u00f6gliche Kurs\u00e4nderung eines Finanzinstruments an einer B\u00f6rse. Wenn die Handelspreise z.B. mit zwei Stellen nach dem Komma angegeben werden, betr\u00e4gt ein Tick 0,01. Im Forexhandel (W\u00e4hrungshandel) wird mit 4 bzw. 5 Stellen nach dem Komma gearbeitet. Ein Tick - der im Forexhandel als Pip bezeichnet wird - betr\u00e4gt dementsprechend 0,0001 bzw. 0,00001. Der Tickwert wird durch die B\u00f6rse fest vorgegeben und \u00e4ndert sich (in der Regel) nicht. Siehe auch Instrument.TickSize . \u00dcblicherweise wird heute ein Tick als Dezimalzahl angegeben. Historisch wurden besonders im amerikanischen Raum Aktien jedoch mit einer Tickgr\u00f6\u00dfe von 1/16 von einem Dollar notiert. Bei Rohstoffen ist diese Notierung noch weit verbreitet. Der Corn-Future (ZC - Mais) wird genau wie Wheat (ZW - Weizen) in \u00bc US-Cent/bushel (entspricht 12,50 US-$ je Kontrakt) notiert. US-Statsanleihen (T-Bonds) werden mit Tickgr\u00f6\u00dfen von 1/32 Punkten gehandelt, was 31,25 US-Dollar entspricht. Die Notierung erfolgt mit Hochkomma: 149'00 entspricht genau 149, 149'01 entspricht 149 1/32 (also 149,03125), 149'31 enspricht 149 31/32 (149,96875), danach folgt dann 150'00. In sog. T-Bond-Intermonth Spreads werden die Notierungen in Vierteln von 1/32 angegeben, was dann einem Punktwert von $7.8125 per Kontrakt entspricht. Die Notierungen erfolgt mit Bindestrich: 17-24 entspricht 17 24/32 Punkten, 17-242 entspricht 17 24,25/32 Punkten, 17-245 entspricht 17 24,5/32 Punkten und 17-247 entspricht 17 24,75/32 Punkten. Die n\u00e4chste Notierung nach 17-247 ist 17-25, dann wieder 17-252, 17-255 usw. Nach 17-317 folgt 18. Die Kontraktspezifikationen sind auf den Internetseiten der jeweiligen B\u00f6rsen ver\u00f6ffentlicht. CME: http://www.cmegroup.com under Products & Trading Eurex (FDAX): http://www.eurexchange.com/exchange-en/products/idx/dax/17206/ siehe auch Instrument.TickSize . TimeFrame siehe Bars.TimeFrame . Bei Verwendung mehrerer Zeiteinheiten ( Multibars ) in einem Indikator siehe TimeFrames . Update() Beschreibung Die Methode Update() ruft die OnCalculateMethode einmal auf, um Indikatorwerte neu zu berechnen. Update() ist mit Vorsicht und nur von erfahrenen Programmierern zu verwenden. Verwendung Update() R\u00fcckgabewert keiner Parameter keiner Beispiel Die Wirkung von Update l\u00e4\u00dft sich mit Hilfe von 2 Indikatoren veranschaulichen. Der erste Indikator \"Ind1\" nutzt eine public Variable aus Indikator \"Ind2\". Code von Ind1: public class Ind1 : UserIndicator { protected override void OnCalculate() { Print( Ind2().MyPublicVariable ); } } Code von Ind2: private double myPublicVariable = 0; protected override void OnCalculate() { myPublicVariable = 1; } public double MyPublicVariable { get { Update(); return myPublicVariable; } } Ohne Update() - Falsch Wenn Ind2 von Ind1 aufgerufen wird, wird die get-Methode von MyPublicVariable in Ind2 aufgerufen. Ohne Update() w\u00fcrde der Wert von myPublicVariable zur\u00fcckgegeben werden. In diesem Falle eine 0. Mit Update() - Richtig Durch den Aufruf von Update() wird zun\u00e4chst OnBarUpdate() von Ind2 ausgef\u00fchrt. Damit wird myPublicVariable auf 1 gesetzt. Anschlie\u00dfend wird der Wert 1 an den aufrufenden Indikator Ind1 \u00fcbergeben. Value Beschreibung Value ist ein DataSeries-Objekt, welches die erste Datenserie eines Indikators enth\u00e4lt. Beim Aufruf der Add()-Methode wird automatisch ein Value-Objekt erzeugt und der Collection Values hinzugef\u00fcgt. Value ist identisch mit Values[0]. Verwendung Value Value[ int barsAgo] Weitere Informationen Die f\u00fcr eine Collection bekannten Methoden Set(), Reset() und Count() sind auf Value anwendbar. Beispiel Siehe Values .","title":"Schl\u00fcsselworte"},{"location":"schluesselworte/#schlusselworte","text":"","title":"Schl\u00fcsselworte"},{"location":"schluesselworte/#addoutput","text":"","title":"AddOutput()"},{"location":"schluesselworte/#addline","text":"","title":"AddLine()"},{"location":"schluesselworte/#beschreibung","text":"Mit der Methode Add() werden dem Chart Plot - bzw. Line-Objekte hinzugef\u00fcgt. Wenn mit Add() ein neues Plot-Objekt hinzugef\u00fcgt wird, wird automatisch auch eine Datenserie vom Typ DataSeries erzeugt, die diesem Plot zugeordnet ist. Auf diese Datenserie kann \u00fcber die Value-Collection zugegriffen werden. Add() kann in der OnInit() Methode und in der OnCalculate() Methode verwendet werden..","title":"Beschreibung"},{"location":"schluesselworte/#parameter","text":"plot \u2013 ein OutputDescriptor Objekt line \u2013 ein LevelLine Objekt","title":"Parameter"},{"location":"schluesselworte/#verwendung","text":"AddOutput(new OutputDescriptor(Color.FromKnownColor(KnownColor.Black), \"MyPlot1\")); Add(LevelLine line)","title":"Verwendung"},{"location":"schluesselworte/#beispiel","text":"#region Usings using System; using System.Collections.Generic; using System.ComponentModel; using System.Drawing; using System.Linq; using System.Xml; using System.Xml.Serialization; using AgenaTrader.API; using AgenaTrader.Custom; using AgenaTrader.Plugins; using AgenaTrader.Helper; #endregion namespace AgenaTrader.UserCode { [Description(\"Enter the description for the new custom indicator here\")] public class MyIndicator : UserIndicator { protected override void OnInit() { // 2 blaue Linien in den Chart legen, eine bei 70 und eine bei 30 Add(new LevelLine(Color.Blue, 70, \"UpperLine\")); Add(new LevelLine(Color.Blue, 30, \"LowerLine\")); // 2 Plots hinzuf\u00fcgen Add(new OutputDescriptor(Color.Red, \"myFastSMA\")); Add(new OutputDescriptor(Color.Blue, \"mySlowSMA\")); } protected override void OnCalculate() { //Mit der Set-Methode wird der Wert f\u00fcr den aktuellen Bar zugewiesen. FastSMA.Set( SMA(8)[0] ); // ist identisch mit Values[0].Set( SMA(8)[0] ); SlowSMA.Set( SMA(50)[0] );// ist identisch mit Values[1].Set( SMA(50)[0] ); } / Hier werden 2 Datenserien zur Verf\u00fcgung gestellt. // Zur Darstellung des Indikators auf dem Chart sind diese nicht notwendig. // Mit Hilfe dieser Datenserien kann von anderen Indikatoren aus auf diesen Indikator // zugegriffen werden. // Z.B. mit double d = MeinIndikator.FastSMA[0] - MeinIndikator.SlowSMA[0]; [Browsable(false)] [XmlIgnore()] public DataSeries FastSMA { get { return Outputs[0]; } } [Browsable(false)] [XmlIgnore()] public DataSeries SlowSMA { get { return Outputs[1]; } } } }","title":"Beispiel"},{"location":"schluesselworte/#allowremovalofchartdrawings","text":"","title":"AllowRemovalOfChartDrawings"},{"location":"schluesselworte/#beschreibung_1","text":"AllowRemovalOfDrawObjects ist eine Eigenschaft von Indikatoren, die in der Methode OnInit() gesetzt werden kann.. AllowRemovalOfChartDrawings = true Zeichenobjekte (DrawObjects), die von einem Indikator bzw. einer Strategie in einen Chart gezeichnet wurden, k\u00f6nnen manuell aus dem Chart entfernt werden. AllowRemovalOfChartDrawings = false (default) Zeichenobjekte (DrawObjects), die von einem Indikator bzw. einer Strategie in einen Chart gezeichnet wurden, k\u00f6nnen nicht manuell aus dem Chart entfernt werden. Sie werden erst dann vom Chart entfernt, wenn auch der Indikator bzw. die Strategie entfernt wird. Die Eigenschaft kann abgefragt werden, und liefert \"true\" bzw. \"false\".","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_1","text":"AllowRemovalOfChartDrawings","title":"Verwendung"},{"location":"schluesselworte/#beispiel_1","text":"protected override void OnInit() { Add(new OutputDescriptor(Color.FromKnownColor(KnownColor.Red), \"MyPlot1\")); //DrawObjects k\u00f6nnen aus dem Chart manuell entfernt werden AllowRemovalOfChartDrawings = true; }","title":"Beispiel"},{"location":"schluesselworte/#attribute","text":"Attribute sind Bestandteil der Programmiersprache C#. In eigenen AgenaScript-Indikatoren bzw. Strategien k\u00f6nnen Attribute genauso verwendet werden, wie es auch in C# selbst m\u00f6glich ist. Informationen \u00fcber Die Verwendung von Attributen finden Sie u.a. hier: http://msdn.microsoft.com/de-de/library/z0w1kczw%28v=vs.80%29.aspx Die in AgenaScript am h\u00e4ufigsten verwendeten Attribute sind: Browsable Category ConditionalValue Description DisplayName TimeFrameRequirements XmlIgnore","title":"Attribute"},{"location":"schluesselworte/#browsable","text":"Browsable ist ein Attribute in AgenaScript. In AgenaScript werden \u00f6ffentliche Variablen (public variables) zum einen f\u00fcr die Eingabe von Parametern f\u00fcr Indikatoren genutzt (z.B. die Periode f\u00fcr einen SMA) und zum anderen f\u00fcr die Ausgabe von Ergebnissen einer Berechnung innerhalb eines Indikators (z.B. Datenserien). Variablen, die der Eingabe von Parametern dienen, m\u00fcssen im Eigenschaften-Dialog angezeigt werden. Datenserien hingegen nicht. Eine public Variable, die mit dem Attribut Browsable=false gekennzeichnet wurde, wird nicht im Eigenschaftendialog von AgenaTrader angezeigt. Standardm\u00e4\u00dfig wird Browsable = true angenommen. Daher kann bei einer Variable, die einen Eingabeparameter beinhaltet, das Attribut Browsable auch weggelassen weren. Beispiel f\u00fcr einen Parameter: Der Parameter soll im Eigenschaftsfenster angezeigt und abgefragt werden. Daher ist \"Browsable = true\" zu setzen oder das Attribut kann entfallen. [Description(\"Numbers of bars used for calculations\")] [Category(\"InputParameter\")] public int Period { get { return period; } set { period = Math.Max(1, value); } } Beispiel f\u00fcr eine Datenserie: [Browsable(false)] [DisplayName(\"Lower band\")] [XmlIgnore] public DataSeries Lower { get { return Outputs[0]; } }","title":"Browsable"},{"location":"schluesselworte/#category","text":"Category ist ein Attribute in AgenaScript. Das Attribut Category gibt f\u00fcr einen Parameter an, unter welcher Kategorie im Eigenschaften-Dialog der Parameter erscheint. Wenn das Attribut fehlt, wird standardm\u00e4\u00dfig die Kategorie \"InputParameter\" angenommen. Das folgende Beispiel erzeugt im Eigenschaften-Dialog die neue Kategorie \"My InputParameter\". [Category(\"My InputParameter\")] [DisplayName(\"Period number\")] public double _period { get { return _period; } set { _period = value; } } Category ist ein Attribute in AgenaScript. Das Attribut Category gibt f\u00fcr einen Parameter an, unter welcher Kategorie im Eigenschaften-Dialog der Parameter erscheint. Wenn das Attribut fehlt, wird standardm\u00e4\u00dfig die Kategorie \"InputParameter\" angenommen. Das folgende Beispiel erzeugt im Eigenschaften-Dialog die neue Kategorie \"My InputParameter\". namespace AgenaTrader.UserCode { [Description(\"Description what this indicator doing.\")] [Category(\"My Package\")] public class MyHolyGrail_Indicator : UserIndicator { /* your code here */ } }","title":"Category"},{"location":"schluesselworte/#conditionalvalue","text":"ConditionalValue ist ein Attribute in AgenaScript. Normalerweise werden im ConditionEscort f\u00fcr Vergleiche die von Indikatoren bereitgestellten Datenserien (DataSeries) benutzt. Beispielsweise wird gepr\u00fcft, ob ein gleitender Durchschnitt \u00fcber oder unter einem bestimmten Kurswert liegt. Ein Indikator kann aber auch Werte als Ergebnis haben, die keine Datenserien sind, also z.B. Werte vom Typ int, double, char, boolean, string usw. Um diese Werte im Scanner oder im Condition-Escort nutzen zu k\u00f6nnen, m\u00fcssen sie mit dem Attribut \"ConditionalValue\" gekennzeichnet sein. [Browsable(false)] [XmlIgnore] [ConditionalValue] public int PublicVariable { get { Update(); return _internVariable; } }","title":"ConditionalValue"},{"location":"schluesselworte/#description","text":"Description ist ein Attribute in AgenaScript. Das Attribute Description wird In AgenaScript f\u00fcr die Klasse und f\u00fcr public-Variablen verwendet. Als Attribut der Klasse ist der Text eine Beschreibung der Funktion des gesamten Indikators (bzw. der Strategie usw.) [Description(\"Displays the tick count of a bar.\")] public class TickCounter : UserIndicator { As an attribute of a public variable, the text is a description of the function of the parameter. [Description(\"Number of standard deviations\")] [DisplayName(\"# of std. dev.\")] public double NumStdDev { get { return numStdDev; } set { numStdDev = Math.Max(0, value); } } } Die Beschreibungen werden jeweils im Eigenschaften-Dialog angezeigt.","title":"Description"},{"location":"schluesselworte/#displayname","text":"DisplayName ist ein Attribute in AgenaScript. Das Attribute DisplayName legt den Text fest, der im Eigenschaften-Dialog f\u00fcr den Parameter verwendet werden soll. Wird dieses Attribut nicht angegeben, wird der Name der public Variable verwendet. [Description(\"Number of standard deviations\")] [DisplayName(\"# of std. dev.\")] public double NumStdDev { get { return numStdDev; } set { numStdDev = Math.Max(0, value); } }","title":"DisplayName"},{"location":"schluesselworte/#timeframerequirements","text":"TimeFrameRequirements ist ein Attribute in AgenaScript. Sollen in einem AgenaScript Daten verschiedener Zeiteinheiten verwendet werden, ist der Klasse das Attribut \"TimeFrameRequirements\" voranzustellen. Es k\u00f6nnen hier auch mehrere Zeiteinheiten angegeben werden: [TimeFrameRequirements(\"1 day\")] [TimeFrameRequirements(\"15 minutes\", \"1 day\", \"1 week\")] Es werden immer so viele Daten der anderen Zeiteinheit(en) bereitgestellt, wie auch Kerzen im Chart geladen sind. Sind in einem 5 Minuten-Chart beispielsweise 500 Kerzen geladen, werden auch 500 Kerzen einer anderen Zeiteinheit geladen. Im Beispiel oben also 500 Tageskerzen bzw. im 2. Beispiel 500 15-Minuen-Kerzen, 500 Tageskerzen und 500 Wochenkerzen. Die Datenmengen k\u00f6nnen schnell sehr gro\u00df werden. Das Attribut ist daher mit Umsicht zu verwenden. siehe auch MultiBars . Wichtig: Wenn in einer Klasse ein anderer Indikator verwendet wird, der seinerseits eine (oder mehrere) sekund\u00e4re Zeiteinheit(en) erfordert, mu\u00df f\u00fcr die aufrufende Klasse ebenfalls das Attribut \"TimeFrameRequirements\" angegeben werden. Ein Beispiel hierzu siehe unter GetDayBar .","title":"TimeFrameRequirements"},{"location":"schluesselworte/#xmlignore","text":"XML ignore st ein Attribute in AgenaScript. AgenaTrader speichert in einem Template u.a. auch alle Parameter-Einstellungen eines Indikators. Die Template-Files liegen im XML-Format vor. Um zu verhindern, dass ein Parameter als Teil eines Templates gespeichert wird, kann das Attribut \"XmlIgnore\" angegeben werden. Um Parameter in einem XML-File speichern zu k\u00f6nnen, m\u00fcssen die Werte zuvor serialisiert werden. In den meisten F\u00e4llen, d.h. f\u00fcr alle g\u00e4ngigen Variablentypen geschieht dies durch AgenaTrader automatisch. Selbst definierte Datentypen k\u00f6nnen jedoch nicht automatisch serialisiert werden. Der Programmierer mu\u00df selbst f\u00fcr die korrekte Serialisierung sorgen. Im Beispiel werden Farbe und Schriftart als Parameter eines Indikators verwendet. In AgenaTrader existieren f\u00fcr die Serialisierung von Farb- und Schriftart-Informationen 2 Methoden (TextColorSerialize und TextFontSerialize), die die Serialisierung \u00fcbernehmen. Die beiden Parameter \"TextColor\" und \"TextFont\" sind daher mit dem Attribute \"XmlIgnore\" zu kennzeichnen. private Color _textColor = Color.Blue; private Font _textFont = new Font(\"Arial\", 12, FontStyle.Bold); [XmlIgnore] [Description(\"Textcolor\")] public Color TextColor { get { return _textColor; } set { _textColor = value; } } [Browsable(false)] public string TextColorSerialize { get { return SerializableColor.ToString(_textColor); } set { _textColor = SerializableColor.FromString(value); } } [XmlIgnore()] [Description(\"TextFont\")] public Font TextFont { get { return _textFont; } set { _textFont = value; } } [Browsable(false)] public string TextFontSerialize { get { return SerializableFont.ToString(_textFont); } set { _textFont = SerializableFont.FromString(value); } }","title":"XMLIgnore"},{"location":"schluesselworte/#calculateonclosedbar","text":"","title":"CalculateOnClosedBar"},{"location":"schluesselworte/#beschreibung_2","text":"Die Eigenschaft \"CalculateOnClosedBar\" legt fest, f\u00fcr welche Ereignisse AgenaTrader die Methode OnCalculate() aufrufen soll. CalculateOnClosedBar = true OnCalculate() wird aufgerufen, wenn ein Bar beendet ist, und der n\u00e4chste hereinkommende Tick einen neuen Bar entstehen l\u00e4\u00dft. CalculateOnClosedBar = false OnCalculate() wird f\u00fcr jeden neu hereinkommenden Tick aufgerufen. Achtung bei \u00e4lterer Hardware: dies f\u00fchrt bei sehr liquiden Werten zu einer erh\u00f6hten Rechnerbelastung. Die Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false). CalculateOnClosedBar kann sowohl in OnInit() als auch in OnCalculate() eingesetzt werden.. OnCalculate wird f\u00fcr historische Daten immer nur f\u00fcr den Schlusskurs eines jeden Bars aufgerufen, auch wenn CalculateOnClosedBar=false gesetzt ist. Wird ein Indikator von einem anderen Indikator aufgerufen, so wird die Eigenschaft CalculateOnClosedBar des aufgerufenen Indikators vom aufrufenden Indikator \u00fcberschrieben.","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_2","text":"CalculateOnClosedBar","title":"Verwendung"},{"location":"schluesselworte/#weitere-informationen","text":"Siehe auch die Beschreibung zu Bars .","title":"Weitere Informationen"},{"location":"schluesselworte/#beispiel_2","text":"protected override void OnInit() { //Indikatorberechnung nur, wenn ein Bar fertig ausgepr\u00e4gt ist CalculateOnClosedBar = true; }","title":"Beispiel"},{"location":"schluesselworte/#chart","text":"Chart ist ein Objekt, \u00fcber welches der lesende Zugriff auf verschiedene Eigenschaften des Charts m\u00f6glich ist. Die wichtigsten Eigenschaften sind: ChartFontColor, BackColor UpColor, DownColor Font BarMarginLeft, BarMarginRight BarSpace, BarWidth BarsPainted FirstBarPainted, LastBarPainted BarsVisible FirstBarVisible, LastBarVisible GetXByBarIdx, GetYByValue Zur Verwendung der wichtigsten Eigenschaften von Chart siehe Beispiel PlotSample . BarsPainted und BarsVisible: BarsPainted enth\u00e4lt die Anzahl der Bars, die ein Chart von seinem linken Rand zu seinem rechten Rand mit der momentanen Breite der Kerzen und dem Abstand der Kerzen zueinander anzeigen k\u00f6nnte . BarsVisible enth\u00e4lt die Anzahl der Bars, die tats\u00e4chlich zu sehen sind. FirstBarPainted und FirstBarVisible: FirstBarPainted enth\u00e4lt die Nummer des Bars, der am linken Rand des Charts angezeigt werden w\u00fcrde . FirstBarVisible enth\u00e4lt die Nummer des Bars, der tats\u00e4chlich als erster Bar links im Chart angezeigt wird. Beispiel: der Chart ist so verschoben, dass der erste Bar des Charts erst in der Mitte des Charts angezeigt wird. FirstBarPainted w\u00e4re in diesem Fall negativ. FirstBarVisible w\u00e4re 0. LastBarPainted und LastBarVisible: LastBarPainted enth\u00e4lt die Nummer des Bars, der am rechten Rand des Charts angezeigt werden w\u00fcrde . LastBarVisible enth\u00e4lt die Nummer des Bars, der tats\u00e4chlich als letzter Bar rechts im Chart angezeigt wird. Beispiel: der Chart ist so verschoben, dass der letzte Bar des Charts bereits in der Mitte des Charts angezeigt wird. LastBarPainted w\u00e4re in diesem Fall gr\u00f6\u00dfer als Bars.Count. LastBarVisible w\u00e4re in Bars.Count -1.","title":"Chart"},{"location":"schluesselworte/#cleartracewindow","text":"","title":"ClearTraceWindow()"},{"location":"schluesselworte/#beschreibung_3","text":"Die Methode ClearTraceWindow() leert das Output-Fenster. Die Methode kann sowohl in OnInit() als auch in OnCalculate() eingesetzt werden. Das OutputWindow beinhaltet alle Ausgaben, die mit dem Print() -Befehl erstellt wurden. Der Einsatz des OutputWindows ist eine sehr gute M\u00f6glichkeit f\u00fcr Code-Debugging.","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_3","text":"ClearTraceWindow()","title":"Verwendung"},{"location":"schluesselworte/#parameter_1","text":"keiner","title":"Parameter"},{"location":"schluesselworte/#ruckgabewert","text":"keiner","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#beispiel_3","text":"protected override void OnInit() { //Inhalt des OutputWindow l\u00f6schen ClearTraceWindow(); }","title":"Beispiel"},{"location":"schluesselworte/#colors","text":"In AgenaSript stehen die folgenden Befehle f\u00fcr Farbfestlegungen bzw. -\u00e4nderungen im Chart zur Verf\u00fcgung: BackColor Hintergrundfarbe des Kurs-Charts BackColorAll Hintergrundfarbe des Kurs-Charts und aller Indikator-Panels BackColorAllSeries BackColorSeries Chart.UpColor Farbe f\u00fcr Up Ticks (Up Bars) Chart.DownColor Farbe f\u00fcr Down Ticks (Down Bars) F\u00fcr jeden Bar werden seine Farben in folgenden Dataserien gespeichert. Wird in diese Datenserien geschrieben, \u00e4ndern sich die Farben des referenzierten Bars. BarColor Farbe eines Bars BarColorSeries CandleOutlineColor CandleOutlineColorSeries","title":"Colors"},{"location":"schluesselworte/#backcolor","text":"","title":"BackColor"},{"location":"schluesselworte/#beschreibung_4","text":"BackColor \u00e4ndert die Hintergrundfarbe eines Bars bzw. gibt die aktuelle Hintergrundfarbe eines Bars zur\u00fcck. Siehe auch Colors , BarColor , BackColor , BackColorAll , BarColorSeries , BackColorAll , CandleOutlineColor .","title":"Beschreibung"},{"location":"schluesselworte/#parameter_2","text":"ein Color-Objekt vom Typ public struct Color","title":"Parameter"},{"location":"schluesselworte/#verwendung_4","text":"BackColor","title":"Verwendung"},{"location":"schluesselworte/#beispiele","text":"// immer montags Bar-Hintergrundfarbe auf Blau \u00e4ndern if (Time[0].DayOfWeek == DayOfWeek.Monday) BackColor = Color.Blue; // \u00c4ndern der Bar-Hintergrundfarbe in Abh\u00e4ngigkeit von einem gl. Durchschnitt // Kurs \u00fcber SMA(14) --> Gr\u00fcn // Kurs unter SMA(14) --> Maroon BackColor = SMA(14)[0] >= Close[0] ? Color.Maroon : Color.LimeGreen;","title":"Beispiele"},{"location":"schluesselworte/#backcolorall","text":"","title":"BackColorAll"},{"location":"schluesselworte/#beschreibung_5","text":"BackColorAll \u00e4ndert die Hintergrundfarbe eines Bars im Chartfenster und in allen Subcharts bzw. gibt die aktuelle Hintergrundfarbe eines Bars zur\u00fcck. Siehe auch Colors , BarColor , BackColor , BackColorAll , BarColorSeries , BackColorAll , CandleOutlineColor .","title":"Beschreibung"},{"location":"schluesselworte/#parameter_3","text":"ein Color-Objekt vom Typ public struct Color","title":"Parameter"},{"location":"schluesselworte/#verwendung_5","text":"BackColorAll","title":"Verwendung"},{"location":"schluesselworte/#beispiel_4","text":"// immer montags Bar-Hintergrundfarbe auf Blau \u00e4ndern if (Time[0].DayOfWeek == DayOfWeek.Monday) BackColorAll = Color.Blue;","title":"Beispiel"},{"location":"schluesselworte/#backcolorallseries","text":"","title":"BackColorAllSeries"},{"location":"schluesselworte/#beschreibung_6","text":"BackColorAllSeries ist eine Datenserie, die f\u00fcr jeden Bar die Hintergrundfarbe speichert. Im Unterschied zu BackColorSeries wird die Hinterrundfarbe der Subcharts mit ber\u00fccksichtigt. Siehe auch Colors , BarColor , BackColor , BackColorAll , BarColorSeries , BackColorAll , CandleOutlineColor .","title":"Beschreibung"},{"location":"schluesselworte/#parameter_4","text":"ein Color-Objekt vom Typ public struct Color int barsAgo","title":"Parameter"},{"location":"schluesselworte/#verwendung_6","text":"BackColorAllSeries BackColorAllSeries[int barsAgo] Bei Verwendung der Methode mit einem Index [int barsAgo] wird die Hintergrundfarbe f\u00fcr den referenzierten Bar ge\u00e4ndert bzw. ausgegeben.","title":"Verwendung"},{"location":"schluesselworte/#beispiel_5","text":"siehe BackColorSeries .","title":"Beispiel"},{"location":"schluesselworte/#backcolorseries","text":"","title":"BackColorSeries"},{"location":"schluesselworte/#beschreibung_7","text":"BackColorSeries ist eine Datenserie, die f\u00fcr jeden Bar die Hintergrundfarbe speichert. Soll die Hintergrundfarbe von Subcharts mit ber\u00fccksichtigt werden, ist \"BackColorAllSeries\" zu verwenden. Siehe auch Colors , BarColor , BackColor , BackColorAll , BarColorSeries , BackColorAll , CandleOutlineColor .","title":"Beschreibung"},{"location":"schluesselworte/#parameter_5","text":"ein Color-Objekt vom Typ public struct Color int barsAgo","title":"Parameter"},{"location":"schluesselworte/#verwendung_7","text":"BackColorSeries BackColorSeries[int barsAgo] ei Verwendung der Methode mit einem Index [ int barsAgo] wird die Hintergrundfarbe f\u00fcr den referenzierten Bar ge\u00e4ndert bzw. ausgegeben.","title":"Verwendung"},{"location":"schluesselworte/#beispiele_1","text":"// Welche Hintergrundfarbe hat der aktuelle Bar? (im ARGB-Format) Print (BackColorSeries[0]); // Hintergrundfarbe des aktuellen Bars auf Blau setzen // Dies ist identisch mit BackColor = Color.Blue BackColorSeries[3] = Color.Blue; // Hintergrundfarbe des vorhergehenden Bars auf Gr\u00fcn setzen BackColorSeries[1] = Color.Green;","title":"Beispiele"},{"location":"schluesselworte/#barcolor","text":"","title":"BarColor"},{"location":"schluesselworte/#beschreibung_8","text":"BarColor \u00e4ndert die Farbe eines Bars Siehe auch Colors , BarColor , BackColor , BackColorAll , BarColorSeries , BackColorAll , CandleOutlineColor .","title":"Beschreibung"},{"location":"schluesselworte/#parameter_6","text":"ein Color-Objekt vom Typ public struct Color","title":"Parameter"},{"location":"schluesselworte/#verwendung_8","text":"BarColor","title":"Verwendung"},{"location":"schluesselworte/#beispiel_6","text":"// Wenn der Schlusskurs \u00fcber dem SMA(14) liegt, den Bar orange einf\u00e4rben if (Close[0] > SMA(14)[0]) BarColor = Color.Orange;","title":"Beispiel"},{"location":"schluesselworte/#barcolorseries","text":"","title":"BarColorSeries"},{"location":"schluesselworte/#beschreibung_9","text":"BarColorSeries ist eine Datenserie, die f\u00fcr jeden Bar die Farbe speichert. Siehe auch Colors , BarColor , BackColor , BackColorAll , BarColorSeries , BackColorAll , CandleOutlineColor .","title":"Beschreibung"},{"location":"schluesselworte/#parameter_7","text":"ein Color-Objekt vom Typ public struct Color int barsAgo","title":"Parameter"},{"location":"schluesselworte/#verwendung_9","text":"BarColorSeries BarColorSeries[ int barsAgo] Bei Verwendung der Methode mit einem Index [int barsAgo] wird die Farbe f\u00fcr den referenzierten Bar ge\u00e4ndert bzw. ausgegeben. Achtung: Es wird nur die Farbe eines Bars zur\u00fcckgegeben, dessen Farbe vorher explizit ver\u00e4ndert wurde. In allen anderen F\u00e4llen wird Color.Empty zur\u00fcckgegeben.","title":"Verwendung"},{"location":"schluesselworte/#beispiel_7","text":"protected override void OnCalculate() { if (ProcessingBarIndex == Bars.Count-1-(CalculateOnClosedBar?1:0)) { // Farbe des aktuellen Bars auf Blau setzen // Dies ist identisch mit BarColor = Color.Blue BarColorSeries[0] = Color.Blue; // Farbe des vorhergehenden Bars auf Gr\u00fcn setzen BarColorSeries[1] = Color.Orange; // Farbe des 3. Bars auf Gelb setzen BarColorSeries[2] = Color.Yellow; } }","title":"Beispiel"},{"location":"schluesselworte/#candleoutlinecolor","text":"","title":"CandleOutlineColor"},{"location":"schluesselworte/#beschreibung_10","text":"CandleOutlineColor \u00e4ndert die Randfarbe (incl. \"Dochte\" und \"Lunte\") eines Bars. Wenn die Farbe eines Bars mit BarColor ge\u00e4ndert wird, und die Umrandung des Bars wurde nicht mit CandleOutlineColor ver\u00e4ndert, wird die Randfarbe auf die Farbe des Bars angepasst. Siehe auch Colors , BarColor , BackColor , BackColorAll , BarColorSeries , BackColorAll , CandleOutlineColor .","title":"Beschreibung"},{"location":"schluesselworte/#parameter_8","text":"ein Color-Objekt vom Typ public struct Color","title":"Parameter"},{"location":"schluesselworte/#verwendung_10","text":"CandleOutlineColor","title":"Verwendung"},{"location":"schluesselworte/#beispiel_8","text":"if (SMA(14)[0] > SMA(200)[0]) CandleOutlineColor = Color.LimeGreen; else CandleOutlineColor = Color.Red;","title":"Beispiel"},{"location":"schluesselworte/#candleoutlinecolorseries","text":"","title":"CandleOutlineColorSeries"},{"location":"schluesselworte/#beschreibung_11","text":"CandleOutlineColorSeries ist eine Datenserie, die f\u00fcr jeden Bar die Randfarbe speichert. Siehe auch Colors , BarColor , BackColor , BackColorAll , BarColorSeries , BackColorAll , CandleOutlineColor .","title":"Beschreibung"},{"location":"schluesselworte/#parameter_9","text":"ein Color-Objekt vom Typ public struct Color int barsAgo","title":"Parameter"},{"location":"schluesselworte/#verwendung_11","text":"CandleOutlineColorSeries CandleOutlineColorSeries[int barsAgo] Bei Verwendung der Methode mit einem Index [ int barsAgo] wird die Randfarbe f\u00fcr den referenzierten Bar ausgegeben. Achtung: Es wird nur die RandFarbe eines Bars zur\u00fcckgegeben, dessen Randfarbe vorher explizit ver\u00e4ndert wurde. In allen anderen F\u00e4llen wird Color.Empty zur\u00fcckgegeben.","title":"Verwendung"},{"location":"schluesselworte/#beispiel_9","text":"// Randfarbe des aktuellen Bars auf Blau setzen CandleOutlineColorSeries[0] = Color.Blue; // Randfarbe auf Chart-default zur\u00fccksetzen CandleOutlineColorSeries[0] = Color.Empty;","title":"Beispiel"},{"location":"schluesselworte/#crossabove","text":"","title":"CrossAbove()"},{"location":"schluesselworte/#beschreibung_12","text":"Mit der Methode CrossAbove() kann gepr\u00fcft werden, ob es innerhalb einer festgelegten Anzahl von Perioden eine \u00dcberkreuzung zweier Werte von unten nach oben gab. Die Werte k\u00f6nnen dabei der Kurs, ein Indikator, jede beliebige Datenserie oder ein fester Wert sein. Siehe auch CrossAbove() , CrossBelow() , IsSerieRising() , IsSerieFalling() .","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_12","text":"CrossAbove(IDataSeries series1, double value, int lookBackPeriod) CrossAbove(IDataSeries series1, IDataSeries series2, int lookBackPeriod)","title":"Verwendung"},{"location":"schluesselworte/#ruckgabewert_1","text":"true eine \u00dcberkreuzung hat stattgefunden false eine \u00dcberkreuzung hat nicht stattgefunden","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#parameter_10","text":"lookBackPeriod Anzahl der Bars innerhalb derer nach dem Aufterten einer \u00dcberkreuzung gesucht wird series1 und series2 eine Datenserie, wie z.B. ein Indikator, Close, High o.\u00e4 value ein fester Wert vom Typ double","title":"Parameter"},{"location":"schluesselworte/#beispiele_2","text":"// Hinweis ausgeben, wenn der SMA(20) \u00fcber SMA(50) kreuzt if (CrossAbove(SMA(20), SMA(50), 1)) Print(\"SMA(20) has risen above SMA(50)!\"); // Hinweis ausgeben, wenn der SMA(20) \u00fcber den Wert 40 steigt if (CrossAbove(SMA(20), 40, 1)) Print(\"SMA(20) has risen above 40!\"); // Hinweis auf Long-Einstieg ausgeben, wenn innerhalb der letzten 5 Bars // der SMA(20) \u00fcber SMA(50) kreuzt und der Kurs innerhalb des letzten Bars gestiegen ist if (CrossAbove(SMA(20), SMA(50), 1) && Close[0] > Close[1]) Print(\"Long entry !!!\");","title":"Beispiele"},{"location":"schluesselworte/#crossbelow","text":"","title":"CrossBelow()"},{"location":"schluesselworte/#beschreibung_13","text":"Mit der Methode CrossBelow() kann gepr\u00fcft werden, ob es innerhalb einer festgelegten Anzahl von Perioden eine \u00dcberkreuzung zweier Werte von oben nach unten gab. Die Werte k\u00f6nnen dabei der Kurs, ein Indikator, jede beliebige Datenserie oder ein fester Wert sein. Siehe auch CrossAbove() , CrossBelow() , IsSerieRising() , IsSerieFalling() .","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_13","text":"CrossBelow(IDataSeries series1, double value, int lookBackPeriod) CrossBelow(IDataSeries series1, IDataSeries series2, int lookBackPeriod)","title":"Verwendung"},{"location":"schluesselworte/#ruckgabewert_2","text":"true eine \u00dcberkreuzung hat stattgefunden false eine \u00dcberkreuzung hat nicht stattgefunden","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#parameter_11","text":"lookBackPeriod Anzahl der Bars innerhalb derer nach dem Aufterten einer \u00dcberkreuzung gesucht wird series1 und series2 eine Datenserie, wie z.B. ein Indikator, Close, High o value ein fester Wert vom Typ double","title":"Parameter"},{"location":"schluesselworte/#beispiele_3","text":"// Hinweis ausgeben, wenn der SMA(20) unter SMA(50) kreuzt if (CrossBelow(SMA(20), SMA(50), 1)) Print(\"SMA(20) has fallen below SMA(50)!\"); // Hinweis ausgeben, wenn der SMA(20) unter den Wert 40 f\u00e4llt if (CrossBelow(SMA(20), 40, 1)) Print(\"SMA(20) has fallen below 40!\"); // Hinweis auf Short-Einstieg ausgeben, wenn innerhalb der letzten 5 Bars // der SMA(20) unter SMA(50) kreuzt und der Kurs innerhalb des letzten Bars gefallen ist. if (CrossBelow(SMA(20), SMA(50), 1) && Close[1] > Close[0]) Print(\"Short entry !!!\");","title":"Beispiele"},{"location":"schluesselworte/#datafeedhistoryperiodicity","text":"","title":"DatafeedHistoryPeriodicity"},{"location":"schluesselworte/#beschreibung_14","text":"DatafeedHistoryPeriodicity ist ein Datentyp.","title":"Beschreibung"},{"location":"schluesselworte/#definition","text":"public enum DatafeedHistoryPeriodicity - DatafeedHistoryPeriodicity.Tick - DatafeedHistoryPeriodicity.Second - DatafeedHistoryPeriodicity.Minute - DatafeedHistoryPeriodicity.Hour - DatafeedHistoryPeriodicity.Day - DatafeedHistoryPeriodicity.Week - DatafeedHistoryPeriodicity.Month - DatafeedHistoryPeriodicity.Volume - DatafeedHistoryPeriodicity.Range - DatafeedHistoryPeriodicity.Quarter - DatafeedHistoryPeriodicity.Year - DatafeedHistoryPeriodicity.HeikinAshi - DatafeedHistoryPeriodicity.Renko - DatafeedHistoryPeriodicity.LineBreak - DatafeedHistoryPeriodicity.Kagi - DatafeedHistoryPeriodicity.PointAndFigure - DatafeedHistoryPeriodicity.Custom Siehe TimeFrame , TimeFrames .","title":"Definition"},{"location":"schluesselworte/#dataseries","text":"","title":"DataSeries"},{"location":"schluesselworte/#beschreibung_15","text":"Datenserien (DataSeries) sind eine sehr komfortable und sehr m\u00e4chtige M\u00f6glichkeit, zus\u00e4tzliche Werte f\u00fcr jeden einzelnen Bar zu speichern. Z.B. wird bei der Berechnung eines gleitenden Durchschnitts jedem Bar der f\u00fcr diesen Bar errechnete Wert zugeordnet. Eine Datenserie ist ein Array, welches exakt so viele Elemente enth\u00e4lt, wie Bars im Chart angezeigt werden. AgenaTrader sorgt daf\u00fcr, dass die Datenserien zu jedem Zeitpunkt korrekt mit den Bars synchronisiert sind. Datenserien werden exakt so benutzt, wie z.B. die Serien Close oder Time. Sie k\u00f6nnen deshalb nat\u00fcrlich auch als Eingangsdaten (Input) f\u00fcr weitere Indikatoren verwendet werden. In der Tabelle ist zu sehen, dass 4 neue Datenserien (farbig markiert) angelegt worden sind. Jede dieser Datenserien kann genau einen Wert eines speziellen Datentyps (int, bool, string, DateTime) je Bar aufnehmen. Die Indizierung mit barsAgo ist dabei identisch mit den vom System bereitgestellten Datenserien..","title":"Beschreibung"},{"location":"schluesselworte/#in-agenatrader-verwendbare-datenserien","text":"BoolSeries DataSeries DateTimeSeries FloatSeries IntSeries LongSeries StringSeries Dar\u00fcberhinaus gibt es die Datenserie ColorSeries, die jedoch nur f\u00fcr interne Zwecke bestimmt ist und nicht direkt verwendet werden sollte. Um die Farbe von Plots zu \u00e4ndern, verwenden Sie bitte PlotColors .","title":"In AgenaTrader verwendbare Datenserien"},{"location":"schluesselworte/#set-reset-und-containsvalue","text":"Jede Datenserie verf\u00fcgt \u00fcber die Methoden Set() , Reset() und ContainsValue() . Mit Set(value) bzw. Set(int barsAgo, value) werden Werte in die Datenserie an der aktuellen Position bzw. an der Position \"barsAgo\" \u00fcbernommen. Mit Reset() bzw. Reset(int barsAgo) kann an der aktuellen Position bzw. an der Position \"barsAgo\" ein Wert aus der Datenserie gel\u00f6scht werden, d.h. an dieser Position existiert kein g\u00fcltiger Wert mehr. Die Programmierung mit Hilfe der Reset-Methode kann eine ansonsten sehr komplexe Logik sp\u00fcrbar vereinfachen.Insbesondere bei Bool-Serien, die nur true oder false enthalten k\u00f6nnen, ist diese Eigenschaft extrem hilfreich. Mit ContainsValue() kann gepr\u00fcft werden, ob die Datenserie an einer bestimmten Position einen g\u00fcltigen Wert enth\u00e4lt.","title":"Set(), Reset() und ContainsValue()"},{"location":"schluesselworte/#informationen-zu-den-einzelnen-datentypen","text":"http://msdn.microsoft.com/de-de/library/s1ax56ch%28v=vs.80%29.aspx","title":"Informationen zu den einzelnen Datentypen"},{"location":"schluesselworte/#boolseries","text":"","title":"BoolSeries"},{"location":"schluesselworte/#beschreibung_16","text":"BoolSeries ist eine Datenserie, die f\u00fcr jeden Bar einen boolschen Wert (true oder false) aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.","title":"Beschreibung"},{"location":"schluesselworte/#neue-boolseries-anlegen","text":"Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen: //Variablendeklaration private BoolSeries myBoolSeries; In der Methode OnInit()dieser Variable eine neue Instanz von BoolSeries zuweisen: protected override void OnInit() { myBoolSeries = new BoolSeries(this); CalculateOnClosedBar = true; }","title":"Neue BoolSeries anlegen"},{"location":"schluesselworte/#werte-zuweisen","text":"Der Datenserie an aktueller Position einen Wert zuweisen: myBoolSeries.Set(true); Einen Wert in der Vergangenheit in die Datenserie schreiben: myBoolSeries.Set(int barsAgo, bool Value);","title":"Werte zuweisen"},{"location":"schluesselworte/#werte-loschen","text":"Den aktuellen Wert aus der Datenserie entfernen: myBoolSeries.Reset(); Einen Wert in der Vergangenheit aus der Datenserie entfernen: myBoolSeries.Reset(int barsAgo);","title":"Werte l\u00f6schen"},{"location":"schluesselworte/#werte-auf-gultigkeit-prufen","text":"myBoolSeries.ContainsValue(int barsAgo);","title":"Werte auf G\u00fcltigkeit pr\u00fcfen"},{"location":"schluesselworte/#wert-auslesen","text":"Print (\"F\u00fcr den Bar von \" + Time[0] + \" ist der Wert der Datenserie: \" + myBoolSeries[0]);","title":"Wert auslesen"},{"location":"schluesselworte/#beispiel_10","text":"protected override void OnCalculate() { if (Close[0] > Open[0]) myBoolSeries.Set(true); else myBoolSeries.Set(false); }","title":"Beispiel"},{"location":"schluesselworte/#dataseries_1","text":"","title":"DataSeries"},{"location":"schluesselworte/#beschreibung_17","text":"DataSeries ist eine DataSeries die f\u00fcr jeden Bar einen double-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart. Datenserien f\u00fcr double-Werte sind die f\u00fcr Indikatoren am h\u00e4ufigsten genutzen Datenserien.","title":"Beschreibung"},{"location":"schluesselworte/#neue-datenserie-anlegen","text":"Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen: //Variablendeklaration private DataSeries myDataSeries; In der Methode OnInit() dieser Variable eine neue Instanz von DataSeries zuweisen: protected override void OnInit() { myDataSeries = new DataSeries(this); CalculateOnClosedBar = true; }","title":"Neue DatenSerie anlegen"},{"location":"schluesselworte/#werte-zuweisen_1","text":"Der Datenserie an aktueller Position einen Wert zuweisen: myDataSeries.Set(Bars[0].Close); Einen Wert in der Vergangenheit in die Datenserie schreiben: myDataSeries.Set(int barsAgo, double Value);","title":"Werte zuweisen"},{"location":"schluesselworte/#werte-loschen_1","text":"Den aktuellen Wert aus der Datenserie entfernen: myDataSeries.Reset(); Einen Wert in der Vergangenheit aus der Datenserie entfernen: myDataSeries.Reset(int barsAgo);","title":"Werte l\u00f6schen"},{"location":"schluesselworte/#werte-auf-gultigkeit-prufen_1","text":"myDataSeries.ContainsValue(int barsAgo);","title":"Werte auf G\u00fcltigkeit pr\u00fcfen"},{"location":"schluesselworte/#wert-auslesen_1","text":"Print (\"F\u00fcr den Bar von \" + Time[0] + \"ist der Wert der Datenserie: \" + myDataSeries[0]);","title":"Wert auslesen"},{"location":"schluesselworte/#beispiel_11","text":"//Speichert die Spanne zwischen dem Hoch und dem Tief eines Bars myDataSeries.Set(Math.Abs(High[0]-Low[0]));","title":"Beispiel"},{"location":"schluesselworte/#datetimeseries","text":"","title":"DateTimeSeries"},{"location":"schluesselworte/#beschreibung_18","text":"Date time series ist eine DataSeries die f\u00fcr jeden Bar einen DateTime-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.","title":"Beschreibung"},{"location":"schluesselworte/#neue-datenserie-anlegen_1","text":"Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen: //Variablendeklaration private DateTimeSeries myDataSeries; In der Methode OnInit() dieser Variable eine neue Instanz von StringSeries zuweisen: protected override void OnInit() { myDataSeries = new DateTimeSeries(this); CalculateOnClosedBar = true; }","title":"Neue DatenSerie anlegen"},{"location":"schluesselworte/#werte-zuweisen_2","text":"Der Datenserie an aktueller Position einen Wert zuweisen: myDataSeries.Set(DateTime Value); Einen Wert in der Vergangenheit in die Datenserie schreiben: myDataSeries.Set(int barsAgo, DateTime Value);","title":"Werte zuweisen"},{"location":"schluesselworte/#werte-loschen_2","text":"Den aktuellen Wert aus der Datenserie entfernen: myDataSeries.Reset(); Einen Wert in der Vergangenheit aus der Datenserie entfernen: myDataSeries.Reset(int barsAgo);","title":"Werte l\u00f6schen"},{"location":"schluesselworte/#werte-auf-gultigkeit-prufen_2","text":"myDataSeries.ContainsValue(int barsAgo);","title":"Werte auf G\u00fcltigkeit pr\u00fcfen"},{"location":"schluesselworte/#wert-auslesen_2","text":"Print (\"F\u00fcr den Bar von\" + Time[0] + \" ist der Wert der Datenserie: \" + myDataSeries[0]);","title":"Wert auslesen"},{"location":"schluesselworte/#beispiel_12","text":"//Speichert einen Versatz von -6 Stunden (Eastern Time, New York) f\u00fcr eine Zeitzonenumrechnung myDataSeries.Set(Time[0].AddHours(-6));","title":"Beispiel"},{"location":"schluesselworte/#floatseries","text":"","title":"FloatSeries"},{"location":"schluesselworte/#beschreibung_19","text":"FloatSeries ist eine Datenserie, die f\u00fcr jeden Bar einen Float-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.","title":"Beschreibung"},{"location":"schluesselworte/#neue-datenserie-anlegen_2","text":"Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen: //Variablendeklaration private FloatSeries myDataSeries; In der Methode OnInit() dieser Variable eine neue Instanz von StringSeries zuweisen: protected override void OnInit() { myDatatSeries = new FloatSeries(this); CalculateOnClosedBar = true; }","title":"Neue DatenSerie anlegen"},{"location":"schluesselworte/#werte-zuweisen_3","text":"Der Datenserie an aktueller Position einen Wert zuweisen: myDataSeries.Set(float Value); Einen Wert in der Vergangenheit in die Datenserie schreiben: myDataSeries.Set(int barsAgo, float Value);","title":"Werte zuweisen"},{"location":"schluesselworte/#werte-loschen_3","text":"Den aktuellen Wert aus der Datenserie entfernen: myDataSeries.Reset(); Einen Wert in der Vergangenheit aus der Datenserie entfernen: myDataSeries.Reset(int barsAgo);","title":"Werte l\u00f6schen"},{"location":"schluesselworte/#werte-auf-gultigkeit-prufen_3","text":"myDataSeries.ContainsValue(int barsAgo);","title":"Werte auf G\u00fcltigkeit pr\u00fcfen"},{"location":"schluesselworte/#wert-auslesen_3","text":"Print (\"F\u00fcr den Bar von\" + Time[0] + \" ist der Wert der Datenserie: \" + myDataSeries[0]);","title":"Wert auslesen"},{"location":"schluesselworte/#beispiel_13","text":"//Speichert die Spanne zwischen dem Hoch und dem Tief eines Bars myDataSeries.Set(Math.Abs((float) High[0] - (float) Low[0]));","title":"Beispiel"},{"location":"schluesselworte/#intseries","text":"","title":"IntSeries"},{"location":"schluesselworte/#beschreibung_20","text":"IntSeries ist eine Datenserie, die f\u00fcr jeden Bar einen Integer-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.","title":"Beschreibung"},{"location":"schluesselworte/#neue-datenserie-anlegen_3","text":"Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen: //Variablendeklaration private IntSeries myDataSeries; In der Methode OnInit() dieser Variable eine neue Instanz von StringSeries zuweisen: protected override void OnInit() { myDataSeries = new IntSeries(this); CalculateOnClosedBar = true; }","title":"Neue DatenSerie anlegen"},{"location":"schluesselworte/#werte-zuweisen_4","text":"Der Datenserie an aktueller Position einen Wert zuweisen: myDataSeries.Set(int Value); Einen Wert in der Vergangenheit in die Datenserie schreiben: myDataSeries.Set(int barsAgo, int Value);","title":"Werte zuweisen"},{"location":"schluesselworte/#werte-loschen_4","text":"Den aktuellen Wert aus der Datenserie entfernen: myDataSeries.Reset(); Einen Wert in der Vergangenheit aus der Datenserie entfernen: myDataSeries.Reset(int barsAgo);","title":"Werte l\u00f6schen"},{"location":"schluesselworte/#werte-auf-gultigkeit-prufen_4","text":"myDataSeries.ContainsValue(int barsAgo);","title":"Werte auf G\u00fcltigkeit pr\u00fcfen"},{"location":"schluesselworte/#wert-auslesen_4","text":"Print (\"F\u00fcr den Bar von \" + Time[0] + \"ist der Wert der Datenserie\"+ myDataSeries[0]);","title":"Wert auslesen"},{"location":"schluesselworte/#beispiel_14","text":"//Speichert f\u00fcr jeden Bar die Spanne in Ticks zwischen dem Hoch und dem Tief myDataSeries.Set((int) ((High[0] - Low[0]) / TickSize));","title":"Beispiel"},{"location":"schluesselworte/#longseries","text":"","title":"LongSeries"},{"location":"schluesselworte/#beschreibung_21","text":"LongSeries ist eine Datenserie, die f\u00fcr jeden Bar einen Integer-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.","title":"Beschreibung"},{"location":"schluesselworte/#neue-datenserie-anlegen_4","text":"Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen: //Variablendeklaration private LongSeries myDataSeries; In der Methode OnInit() dieser Variable eine neue Instanz von LongSeries zuweisen: protected override void OnInit() { myDataSeries = new LongSeries(this); CalculateOnClosedBar = true; }","title":"Neue DatenSerie anlegen"},{"location":"schluesselworte/#werte-zuweisen_5","text":"Der Datenserie an aktueller Position einen Wert zuweisen: myDataSeries.Set(long Value); Einen Wert in der Vergangenheit aus der Datenserie entfernen: myDataSeries.Set(int barsAgo, long Value);","title":"Werte zuweisen"},{"location":"schluesselworte/#werte-loschen_5","text":"Den aktuellen Wert aus der Datenserie entfernen: myDataSeries.Reset(); Einen Wert in der Vergangenheit aus der Datenserie entfernen: myDataSeries.Reset(int barsAgo);","title":"Werte l\u00f6schen"},{"location":"schluesselworte/#werte-auf-gultigkeit-prufen_5","text":"myDataSeries.ContainsValue(int barsAgo);","title":"Werte auf G\u00fcltigkeit pr\u00fcfen"},{"location":"schluesselworte/#wert-auslesen_5","text":"Print (\"F\u00fcr den Bar von \" + Time[0] + \"ist der Wert der Datenserie: \" + myDataSeries[0]);","title":"Wert auslesen"},{"location":"schluesselworte/#beispiel_15","text":"//Speichert f\u00fcr jeden Bar die Spanne in Ticks zwischen dem Hoch und dem Tief myDataSeries.Set((long) ((High[0] - Low[0]) / TickSize));","title":"Beispiel"},{"location":"schluesselworte/#stringseries","text":"","title":"StringSeries"},{"location":"schluesselworte/#beschreibung_22","text":"StringSeries ist eine Datenserie, die f\u00fcr jeden Bar einen String-Wert aufnehmen kann. Die Anzahl der Elemente dieser Serie entspricht genau der Anzahl der Bars im Chart.","title":"Beschreibung"},{"location":"schluesselworte/#neue-datenserie-anlegen_5","text":"Im Bereich f\u00fcr die Deklaration von Variablen eine neue Variable anlegen: //Variablendeklaration private StringSeries myDataSeries; In der Methode OnInit() dieser Variable eine neue Instanz von StringSeries zuweisen: protected override void OnInit() { myDataSeries = new StringSeries(this); CalculateOnClosedBar = true; }","title":"Neue DatenSerie anlegen"},{"location":"schluesselworte/#werte-zuweisen_6","text":"Der Datenserie an aktueller Position einen Wert zuweisen: myDataSeries.Set(string Value); Einen Wert in der Vergangenheit in die Datenserie schreiben: myDataSeries.Set(int barsAgo, string Value);","title":"Werte zuweisen"},{"location":"schluesselworte/#werte-loschen_6","text":"Den aktuellen Wert aus der Datenserie entfernen: myDataSeries.Reset(); Einen Wert in der Vergangenheit aus der Datenserie entfernen: myDataSeries.Reset(int barsAgo);","title":"Werte l\u00f6schen"},{"location":"schluesselworte/#werte-auf-gultigkeit-prufen_6","text":"myDataSeries.ContainsValue(int barsAgo);","title":"Werte auf G\u00fcltigkeit pr\u00fcfen"},{"location":"schluesselworte/#wert-auslesen_6","text":"Print (\"F\u00fcr den Bar von \" + Time[0] + \"ist der Wert der Datenserie: \" + myDataSeries[0]);","title":"Wert auslesen"},{"location":"schluesselworte/#beispiel_16","text":"//Speichert f\u00fcr jeden Bar den Wochentag (Montag, Dienstag ...) myDataSeries.Set(string.Format(\"{0:dddd}\", Time[0]));","title":"Beispiel"},{"location":"schluesselworte/#dayofweek","text":"","title":"DayOfWeek"},{"location":"schluesselworte/#beschreibung_23","text":"\"DayOfWeek\" gibt den zu einem DateTime-Wert, wie z.B. dem Zeitstempel eines Bars, geh\u00f6renden Wochentag aus. Dar\u00fcberhinaus sind nat\u00fcrlich auch alle Methoden verwendbar, die in C# f\u00fcr DateTime-Objekte definiert sind, z.B. Day, Month, Year, Hour, Minute, Second, DayOfWeek usw. Siehe http://msdn.microsoft.com/de-de/library/03ybds8y.aspx","title":"Beschreibung"},{"location":"schluesselworte/#definition_1","text":"Eigenschaft DayOfWeek public enum DayOfWeek - DayOfWeek.Monday - DayOfWeek.Tuesday - DayOfWeek.Wednesday - DayOfWeek.Thursday - DayOfWeek.Friday - DayOfWeek.Saturday - DayOfWeek.Sunday","title":"Definition"},{"location":"schluesselworte/#beispiele_4","text":"//Ausgabe des Wochentages f\u00fcr jeden Bar Print(Time[0].DayOfWeek); //An einem Freitag keine Trades ausf\u00fchren if (Time[0].DayOfWeek == DayOfWeek.Friday) return;","title":"Beispiele"},{"location":"schluesselworte/#displacement","text":"","title":"Displacement"},{"location":"schluesselworte/#beschreibung_24","text":"Mit der Angabe Displacement kann eine gezeichnete Indikatorlinie auf der Zeitachse (x-Achse) nach links bzw. rechts verschoben werden. Die Eigenschaft kann im Script abgefragt werden und liefert einen int-Wert. Blue line: Displacement = 0 (Original) Red line: Displacement = -5 Green line: Displacement = +5","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_14","text":"Displacement","title":"Verwendung"},{"location":"schluesselworte/#parameter_12","text":"int Offfset Anzahl Bars, um die der Indikator verschoben werden soll.","title":"Parameter"},{"location":"schluesselworte/#beispiel_17","text":"protected override void OnInit() { Add(new (Color.FromKnownColor(KnownColor.Red), \"MyPlot1\")); //Displacement of the plot by one bar to the right Displacement = 1; }","title":"Beispiel"},{"location":"schluesselworte/#email-function","text":"","title":"Email function"},{"location":"schluesselworte/#beschreibung_25","text":"Override-Methode zum Senden von E-Mails.","title":"Beschreibung"},{"location":"schluesselworte/#parameter_13","text":"keine","title":"Parameter"},{"location":"schluesselworte/#ruckgabewert_3","text":"string","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#verwendung_15","text":"Verwendet f\u00fcr komplizierte Berechnung auf einem letzten Bar","title":"Verwendung"},{"location":"schluesselworte/#beispiel_18","text":"protected override void OnOrderExecution(IExecution execution) { if (execution.Order != null && execution.Order.OrderState == OrderState.Filled) { if (oEnter != null && execution.Name == oEnter.Name) { // Enter-Order gef\u00fcllt if (_sendMail) this.SendEmail(Core.AccountManager.Core.Settings.MailDefaultFromAddress, Core.PreferenceManager.DefaultEmailAddress, execution.Instrument.Symbol + \" order \" + execution.Name + \" executed.\", \"The order for \" + execution.Instrument.Name + \" was executed. Invest: \" + (Trade.Quantity * Trade.AvgPrice).ToString(\"F2\")); } else if (oTStop != null && execution.Name == oTStop.Name) { OrderStatus = 0; // Trend-Stopp-Order gef\u00fcllt if (_sendMail) this.SendEmail(Core.AccountManager.Core.Settings.MailDefaultFromAddress, Core.PreferenceManager.DefaultEmailAddress, execution.Instrument.Symbol +\" order \" + execution.Name + \" executed.\", execution.Instrument.Symbol +\" order \" + execution.Name + \" executed. Profit:\" + Trade.ClosedProfitLoss.ToString(\"F2\")); } } }","title":"Beispiel"},{"location":"schluesselworte/#firsttickofbar","text":"","title":"FirstTickOfBar"},{"location":"schluesselworte/#beschreibung_26","text":"FirstTickOfBar ist eine Eigenschaft, vom Type bool, die immer dann \"true\" ergibt, wenn der aktuell hereinkommende Tick einem neuen Bar zugeordnet wird, dieser Tick also der erste Tick eines neuen Bars ist. Die Eigenschaft kann nur sinnvoll eingesetzt werden, wenn der Indikator bzw. die Startegie im Tick-by-Tick-Modus l\u00e4uft, d.h. wenn CalculateOnClosedBar = false gesetzt ist und der verwendete Datenfeed Realtime-Kurse liefert. Bei Verwendung von EoD-Daten in einem Tageschart ist FirstTickOfBar f\u00fcr den letzten Bar immer true. FirstTickOfBar sollte nicht au\u00dferhalb der OnCalculate() Methode verwendet werden.. siehe auch Bars.TicksCountForLastBar .","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_16","text":"FirstTickOfBar","title":"Verwendung"},{"location":"schluesselworte/#beispiel_19","text":"// Innerhalb einer Tick-By-Tick-Strategie einen Teil nur Bar-by-Bar ausf\u00fchren if (FirstTickOfBar) { if (CCI(20)[1] < -250) OpenLong(); return; }","title":"Beispiel"},{"location":"schluesselworte/#firsttickofbarmtf","text":"","title":"FirstTickOfBarMtf"},{"location":"schluesselworte/#beschreibung_27","text":"FirstTickOfBarMtf ist die multi-time frame Variante von FirstTickOfBar . Die Einstellung von CalculateOnClosedBar wirkt sich nur auf die prim\u00e4re Zeiteinheit (Chart-Zeiteinheit) aus. Wenn jedoch mit multi-bars gearbeitet wird, werden die Ticks der sekund\u00e4ren Zeiteinheit(en) unabh\u00e4ngig von der Einstellung von CalculateOnClosedBar immer Tick-by-Tick bereitgestellt. Mit Hilfe von FirstTickOfBarMtf, ist es m\u00f6glich, festzustellen, wann in einer sekund\u00e4ren Zeiteinheit ein neuer Bar beginnt.","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_17","text":"FirstTickOfBarMtf(ProcessingBarSeriesIndex)","title":"Verwendung"},{"location":"schluesselworte/#parameter_14","text":"FirstTickOfBarMtf(ProcessingBarSeriesIndex). siehe ProcessingBarSeriesIndex .","title":"Parameter"},{"location":"schluesselworte/#beispiel_20","text":"if (FirstTickOfBarMtf(ProcessingBarSeriesIndex)) Print(\"A new bar has begun.\");","title":"Beispiel"},{"location":"schluesselworte/#getcurrentask","text":"","title":"GetCurrentAsk()"},{"location":"schluesselworte/#beschreibung_28","text":"Die Methode GetCurrentAsk() liefert den aktuellen Kurs auf der Ask-Seite des Orderbuchs. Wenn AgenaTrader keine Level1-Daten zur Verf\u00fcgung stehen, liefert die Funktion den Kurs des letzten Umsatzes. siehe auch GetCurrentBid() und OnLevel1() .","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_18","text":"GetCurrentAsk()","title":"Verwendung"},{"location":"schluesselworte/#ruckgabewert_4","text":"double value","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#parameter_15","text":"keiner","title":"Parameter"},{"location":"schluesselworte/#beispiel_21","text":"Wenn eine Einstiegsbedingung erf\u00fcllt ist, soll 1 Kontrakt zum aktuellen Ask-Kurs verkauft werden. private IOrder entryOrder = null; protected override void OnCalculate() { // Einstiegsbedingung if (Close[0] < SMA(20)[0] && entryOrder == null) // Verkauf 1 Kontrakt zum aktuellen AskKurs entryOrder = SubmitOrder(0, OrderAction.SellShort, OrderType.Limit, 1, GetCurrentAsk(), 0, \"\", \"Enter short\"); }","title":"Beispiel"},{"location":"schluesselworte/#getcurrentaskvolume","text":"","title":"GetCurrentAskVolume()"},{"location":"schluesselworte/#beschreibung_29","text":"Die Methode GetCurrentAskVolume() liefert das aktuelle Volumen auf der Ask-Seite des Orderbuchs. Diese Funktion ist nur lauff\u00e4hig, wenn der Datenanbieter Level2-Daten liefert. siehe auch GetCurrentBidVolume() , GetCurrentBid() und OnLevel1() .","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_19","text":"GetCurrentAskVolume()","title":"Verwendung"},{"location":"schluesselworte/#ruckgabewert_5","text":"Long value","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#parameter_16","text":"keiner","title":"Parameter"},{"location":"schluesselworte/#beispiel_22","text":"protected override void OnCalculate() { if (GetCurrentAskVolume() < GetCurrentBidVolume()) Print(\"AskVolume {0} < BidVolume {1}\", GetCurrentAskVolume(), GetCurrentBidVolume()); }","title":"Beispiel"},{"location":"schluesselworte/#getcurrentbid","text":"","title":"GetCurrentBid()"},{"location":"schluesselworte/#beschreibung_30","text":"Die Methode GetCurrentBid() liefert den aktuellen Kurs auf der Bid-Seite des Orderbuchs. Wenn AgenaTrader keine Level1-Daten zur Verf\u00fcgung stehen, liefert die Funktion den Kurs des letzten Umsatzes. siehe auch GetCurrentAsk() und OnLevel1() .","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_20","text":"GetCurrentBid()","title":"Verwendung"},{"location":"schluesselworte/#ruckgabewert_6","text":"double value","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#parameter_17","text":"keiner","title":"Parameter"},{"location":"schluesselworte/#beispiel_23","text":"Wenn eine Einstiegsbedingung erf\u00fcllt ist, soll 1 Kontrakt zum aktuellen Bid-Kurs gekauft werden. private IOrder entryOrder = null; protected override void OnCalculate() { // Einstiegsbedingung if (Close[0] > SMA(20)[0] && entryOrder == null) // Kauf 1 Kontrakt zum aktuellen BidKurs entryOrder = SubmitOrder(0, OrderAction.Buy, OrderType.Limit, 1, GetCurrentBid(), 0, \"\", \"Enter long\"); }","title":"Beispiel"},{"location":"schluesselworte/#getcurrentbidvolume","text":"","title":"GetCurrentBidVolume()"},{"location":"schluesselworte/#beschreibung_31","text":"Die Methode GetCurrentBidVolume() liefert das aktuelle Volumen auf der Bid-Seite des Orderbuchs. Diese Funktion ist nur lauff\u00e4hig, wenn der Datenanbieter Level2-Daten liefert. siehe auch GetCurrentAskVolume , GetCurrentBid() und OnLevel1() .","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_21","text":"GetCurrentBidVolume()","title":"Verwendung"},{"location":"schluesselworte/#ruckgabewert_7","text":"Long value","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#parameter_18","text":"keiner","title":"Parameter"},{"location":"schluesselworte/#beispiel_24","text":"protected override void OnCalculate() { if (GetCurrentAskVolume() < GetCurrentBidVolume()) Print(\"AskVolume {0} < BidVolume {1}\", GetCurrentAskVolume(), GetCurrentBidVolume()); }","title":"Beispiel"},{"location":"schluesselworte/#getcurrentprice","text":"","title":"GetCurrentPrice()"},{"location":"schluesselworte/#beschreibung_32","text":"Die Methode GetCurrentPrice() liefert den aktuellen Kurs (Latest). Wenn AgenaTrader keine Level1-Daten zur Verf\u00fcgung stehen, liefert die Funktion den Kurs des letzten Umsatzes. siehe auch GetCurrentAsk , GetCurrentBid() und OnLevel1() .","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_22","text":"GetCurrentPrice()","title":"Verwendung"},{"location":"schluesselworte/#ruckgabewert_8","text":"keiner","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#parameter_19","text":"double value","title":"Parameter"},{"location":"schluesselworte/#beispiel_25","text":"Wenn eine Einstiegsbedingung erf\u00fcllt ist, soll 1 Kontrakt zum aktuellen Kurs gekauft werden. private IOrder entryOrder = null; protected override void OnCalculate() { // Einstiegsbedingung if (Close[0] > SMA(20)[0] && entryOrder == null) // Kauf 1 Kontrakt zum aktuellen BidKurs entryOrder = SubmitOrder(0, OrderAction.Buy, OrderType.Limit, 1, GetCurrentPrice(), 0,\"\", \"Enter Long\"); }","title":"Beispiel"},{"location":"schluesselworte/#getcurrentspread","text":"","title":"GetCurrentSpread()"},{"location":"schluesselworte/#beschreibung_33","text":"Die Methode GetCurrentSpread() liefert den aktuellen Spread. siehe auch GetCurrentAsk , GetCurrentBid() and OnLevel1() .","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_23","text":"GetCurrentSpread()","title":"Verwendung"},{"location":"schluesselworte/#ruckgabewert_9","text":"keiner","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#parameter_20","text":"double","title":"Parameter"},{"location":"schluesselworte/#beispiel_26","text":"Wenn eine Anfangsbedingung erf\u00fcllt ist, sollte ein Vertrag zum aktuellen Wechselkurs gekauft werden. protected override void OnCalculate() { Print(\"Der aktuelle Spread ist {0}\", GetCurrentSpread()); }","title":"Beispiel"},{"location":"schluesselworte/#getdayasint","text":"","title":"GetDayAsInt()"},{"location":"schluesselworte/#beschreibung_34","text":"GetDayAsIntist eine Methode, die sich speziell an unerfahrene Programmierer richtet, die mit der durchaus komplizierten .Net-DateTime-Struktur aus C# Schwierigkeiten haben. Erfahrene Programmierer k\u00f6nnen die DateTime-Funktionen auch direkt verwenden. GetDayAsInt liefert eine int-Repr\u00e4sentation im Format yyyyMMdd. (yyyy = Jahr, MM = Monat, dd = Tag) Die Zahl f\u00fcr den 13.08.2012 lautet damit 20120813. Siehe auch GetTimeAsInt . Hilfe zu DateTime: http://msdn.microsoft.com/de-de/library/system.datetime.aspx","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_24","text":"GetDayAsInt(DateTime time)","title":"Verwendung"},{"location":"schluesselworte/#beispiele_5","text":"// Am 11. September besser keine Trades eingehen if (GetDayAsInt(Time[0]) = 20130911) return;","title":"Beispiele"},{"location":"schluesselworte/#getserieshighestvalue","text":"","title":"GetSeriesHighestValue"},{"location":"schluesselworte/#beschreibung_35","text":"Die Methode GetSeriesHighestValue() sucht in einer vorgegebenen Anzahl von Perioden nach dem h\u00f6chsten Bar und gibt an, vor wievielen Bars dieser h\u00f6chste Bar zu finden ist Siehe auch GetSeriesLowestValue() .","title":"Beschreibung"},{"location":"schluesselworte/#parameter_21","text":"period Anzahl von Bars, innerhalb derer gesucht werden soll series Jede Datenserie, wie Close, High, Low usw.","title":"Parameter"},{"location":"schluesselworte/#ruckgabewert_10","text":"int barsAgo Vor wievielen Bars trat das Hoch auf","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#verwendung_25","text":"GetSeriesHighestValue(IDataSeries series, int period)","title":"Verwendung"},{"location":"schluesselworte/#beispiele_6","text":"// Vor wievielen Bars lag das h\u00f6chste Hoch der aktuellen Session? Print(GetSeriesHighestValue(High, Bars.BarsCountForSession - 1)); // Welchen Kurs hatte das bisher h\u00f6chste Open der aktuellen Session? Print(\"The highest price for the session was: \" + Open[GetSeriesHighestValue(High, Bars.BarsCountForSession - 1)]);","title":"Beispiele"},{"location":"schluesselworte/#getserieslowestvalue","text":"","title":"GetSeriesLowestValue"},{"location":"schluesselworte/#beschreibung_36","text":"Die Methode GetSeriesLowestValue() sucht in einer vorgegebenen Anzahl von Perioden nach dem tiefsten Bar und gibt an, vor wievielen Bars dieser tiefste Bar zu finden ist. Siehe auch GetSeriesHighestValue() .","title":"Beschreibung"},{"location":"schluesselworte/#parameter_22","text":"period Anzahl von Bars, innerhalb derer gesucht werden soll series Jede Datenserie, wie Close, High, Low usw.","title":"Parameter"},{"location":"schluesselworte/#ruckgabewert_11","text":"int barsAgo Vor wievielen Bars trat das Tief auf","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#verwendung_26","text":"GetSerieLowestValue(IDataSeries series, int period)","title":"Verwendung"},{"location":"schluesselworte/#beispiele_7","text":"// Vor wievielen Bars lag das tiefste Tief der aktuellen Session? Print(GetSeriesLowestValue(Low, Bars.BarsCountForSession - 1)); // Welchen Kurs hatte das bisher tiefste Open der aktuellen Session? Print(\"The lowest open price of the current session was: \" + Open[GetSeriesLowestValue(Low, Bars.BarsCountForSession - 1)]);","title":"Beispiele"},{"location":"schluesselworte/#gettimeasint","text":"","title":"GetTimeAsInt()"},{"location":"schluesselworte/#beschreibung_37","text":"GetTimeAsInt ist eine Methode, die sich speziell an unerfahrene Programmierer richtet, die mit der durchaus komplizierten .Net-DateTime-Struktur aus C# Schwierigkeiten haben. Erfahrene Programmierer k\u00f6nnen die DateTime-Funktionen auch direkt verwenden.. GetTimeAsInt liefert eine int-Repr\u00e4sentation im Format HHmmss. (HH = Stunde, mm = Minute, ss = Sekunde) Die Uhrzeit 07:30 Uhr wird dargestellt als 73000 und 14:15:12 wird zu 141512. Siehe auch GetDayAsInt . Hilfe zu DateTime: http://msdn.microsoft.com/de-de/library/system.datetime.aspx","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_27","text":"GetTimeAsInt(DateTime time)","title":"Verwendung"},{"location":"schluesselworte/#beispiele_8","text":"// Nur zwischen 08:15 Uhr und 16:35 Uhr Trades eingehen if (GetTimeAsInt(Time[0]) >= 81500 && GetTimeAsInt(Time[0]) <= 163500) { // irgendeine Handelslogic }","title":"Beispiele"},{"location":"schluesselworte/#historical","text":"","title":"Historical"},{"location":"schluesselworte/#beschreibung_38","text":"Mit Historical l\u00e4\u00dft sich \u00fcberpr\u00fcfen, ob AgenaScript mit historen Daten oder mit Real-Time-Daten arbeitet. Solange OnCalculate() f\u00fcr historische Daten aufgerufen wird, ist Historical = true, in dem Moment, in dem die Verarbeitung von Live-Daten beginnt, wird Historical = false. W\u00e4hrend ein Backtest ausgef\u00fchrt wird, ist Historical immer true.","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_28","text":"Historical","title":"Verwendung"},{"location":"schluesselworte/#ruckgabewert_12","text":"true bei Verarbeitung von historischen Daten false bei Verarbeitung von Real-Time-Daten","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#beispiele_9","text":"protected override void OnCalculate() { // Nur f\u00fcr realtime-Daten ausf\u00fchren if (IsHistoricalMode) return; // irgendeine Handelslogik }","title":"Beispiele"},{"location":"schluesselworte/#inputpricetype","text":"","title":"InputPriceType"},{"location":"schluesselworte/#beschreibung_39","text":"Die Eigenschaft InputPriceType legt fest, welche Kursreihe bei der Berechnung in Indikatoren als Standard verwendet werden soll, wenn keine Datenreihe explizit angegeben ist. InputPriceType kann in der OnInit()-Methode stehen. Die Angabe hat dann f\u00fcr alle weiteren Berechnungen im Indikator G\u00fcltigkeit. Steht InputPriceType in OnCalculate(), gilt die \u00c4nderung der Eingangsdatenreihe ab der n\u00e4chsten Anweisung. Jedes weitere Auftreten von InputPriceType wird ignoriert! Siehe auch PriceType","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_29","text":"InputPriceType","title":"Verwendung"},{"location":"schluesselworte/#beispiel1","text":"protected override void OnInit() { ClearTraceWindow(); InputPriceType = PriceType.Low; } protected override void OnCalculate() { // Die Eingangsdatenreihe f\u00fcr den Indikator (Input) ist Low Print(Low[0] + \" \" + InSeries[0] + \" \" + InputPriceType); }","title":"Beispiel1"},{"location":"schluesselworte/#beispiel2","text":"protected override void OnCalculate() { // Diese Werte sind identisch, // da standardm\u00e4\u00dfig Close als Inputdatenreihe verwendet wird Print(SMA(20)[0] + \" \" + SMA(Close, 20)[0]); InputPriceType = PriceType.Low; // ab hier wird Low anstatt Close als Standard verwendet // Die beiden Werte sind identisch Print(SMA(20)[0] + \" \" + SMA(Low, 20)[0]); InputPriceType = PriceType.High; // Diese Anweisung wird ignoriert. // Es gilt weiterhin Input = Low !!! }","title":"Beispiel2"},{"location":"schluesselworte/#instrument","text":"","title":"Instrument"},{"location":"schluesselworte/#beschreibung_40","text":"Mit Instrument werden Informationen zum Handelsinstrument (Aktie, Future etc.) bereitgestellt, f\u00fcr welches ein Indikator, eine Strategie usw. gerade l\u00e4uft. Ausf\u00fchrliche Details finden sich unter Instruments .","title":"Beschreibung"},{"location":"schluesselworte/#isadddrawingstopricepanel","text":"","title":"IsAddDrawingsToPricePanel"},{"location":"schluesselworte/#beschreibung_41","text":"Die Eigenschaft \"IsAddDrawingsToPricePanel\" legt fest, in welchem Panel Zeichenobjekte gezeichnet werden. IsAddDrawingsToPricePanel = true (default) Zeichenobjekte werden im Preischart gezeichnet IsAddDrawingsToPricePanel = false Zeichenobjekte werden in dem Panel (Subchart) gezeichnet, das dem Indikator zugeordnet ist. Ist der Indikator bereits dem Preischart zugeordnet (Overlay = true) ist diese Eigenschaft wirkungslos, d.h. es wird in diesem Fall kein neuer Subchart ge\u00f6ffnet. Die Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false)","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_30","text":"IsAddDrawingsToPricePanel","title":"Verwendung"},{"location":"schluesselworte/#beispiel_27","text":"protected override void OnInit() { // Indikator in einem neuen Subchart zeichnen IsOverlay = false; (Color.FromKnownColor(KnownColor.Red), \"MyPlot1\")); // Zeichenobjekte im Preischart zeichnen IsAddDrawingsToPricePanel = true; } protected override void OnCalculate() { // zeichnet im Preischart eine vertikale Linie am Bar von vor 5 Perioden AddChartVerticalLine(\"MyVerticalLine\", 5, Color.Black); }","title":"Beispiel"},{"location":"schluesselworte/#isautoadjustablescale","text":"","title":"IsAutoAdjustableScale"},{"location":"schluesselworte/#beschreibung_42","text":"Auto scale is a property of indicators that can be set within the OnInit() method. IsAutoAdjustableScale = true (default) Die Preisachse (y-Achse) des Charts wird so eingestellt, dass alle Plots und Lines eines Indikators bzw. einer Strategie im Chart sichtbar sind. IsAutoAdjustableScale = false Plots und Lines eines Indikators bzw. einer Strategie werden nicht in die Skalierung der Preisachse (y-Achse) eines Charts mit einbezogen. Sie k\u00f6nnen auch ausserhalb des sichtbaren Chartbereichs liegen. Die Eigenschaft kann abgefragt werden, und liefert \"true\" bzw. \"false\".","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_31","text":"IsAutoAdjustableScale","title":"Verwendung"},{"location":"schluesselworte/#beispiel_28","text":"protected override void OnInit() { //Chart so skalieren, dass alle Zeichenobjekte sichtbar sind IsAutoAdjustableScale = true; }","title":"Beispiel"},{"location":"schluesselworte/#isoverlay","text":"","title":"IsOverlay"},{"location":"schluesselworte/#beschreibung_43","text":"Die Eigenschaft Overlay legt fest, ob die Indikatorausgaben, wie Plots und Linien, im Preischart \u00fcber die Kursbars gezeichnet werden oder ob ein neues separates Chartfenster unterhalb des Preischarts ge\u00f6ffnet wird. IsOverlay = true Es wird \u00fcber den Kurs gezeichnet (wie z.B. ein SMA ) IsOverlay = false (default) Es wird ein separates Chartfenster ge\u00f6ffnet (wie z.B. ein RSI ) Die Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false).","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_32","text":"IsOverlay","title":"Verwendung"},{"location":"schluesselworte/#beispiel_29","text":"protected override void OnInit() { (Color.FromKnownColor(KnownColor.Red), \"MyPlot1\")); //Der Indikator soll in einem separaten Fenster dargestellt werden IsOverlay = false; }","title":"Beispiel"},{"location":"schluesselworte/#isprocessingbarindexlast","text":"","title":"IsProcessingBarIndexLast"},{"location":"schluesselworte/#description_1","text":"Indicates if current bar is last in calculation.","title":"Description"},{"location":"schluesselworte/#parameter_23","text":"None","title":"Parameter"},{"location":"schluesselworte/#return-value","text":"Type bool","title":"Return value"},{"location":"schluesselworte/#usage","text":"used for complicated calculation on a last bar","title":"Usage"},{"location":"schluesselworte/#example","text":"protected override void OnCalculate() { base.OnCalculate(); if (!IsProcessingBarIndexLast) return; bool isUpdated; }","title":"Example"},{"location":"schluesselworte/#isserierising","text":"","title":"IsSerieRising()"},{"location":"schluesselworte/#beschreibung_44","text":"Mit der Methode IsSerieRising() kann gepr\u00fcft werden, ob eine \"ist steigend\"-Bedingung vorliegt, d.h. ob der aktuelle Wert gr\u00f6\u00dfer ist als der Wert des vorhergehenden Bars. Siehe auch CrossAbove() , CrossBelow() , IsSerieRising() , IsSerieFalling() .","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_33","text":"IsSerieRising(IDataSeries series)","title":"Verwendung"},{"location":"schluesselworte/#ruckgabewert_13","text":"true wenn die Datenreihe steigt false wenn die Datenreihe nicht steigt","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#parameter_24","text":"series eine Datenserie, wie z.B. ein Indikator, Close, High o.\u00e4","title":"Parameter"},{"location":"schluesselworte/#beispiele_10","text":"// Pr\u00fcfen, ob der SMA(20) steigt if (IsSerieRising(SMA(20))) Print(\"The SMA(20) is currently rising.\");","title":"Beispiele"},{"location":"schluesselworte/#isseriesfalling","text":"","title":"IsSeriesFalling()"},{"location":"schluesselworte/#beschreibung_45","text":"Mit der Methode IsSeriesFalling() kann gepr\u00fcft werden, ob eine \"ist fallend\"-Bedingung vorliegt, d.h. ob der aktuelle Wert kleiner ist als der Wert des vorhergehenden Bars. Siehe auch CrossAbove() , CrossBelow() , IsSerieRising() , IsSerieFalling() .","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_34","text":"IsSerieFalling(IDataSeries series)","title":"Verwendung"},{"location":"schluesselworte/#ruckgabewert_14","text":"true wenn die Datenreihe f\u00e4llt false wenn die Datenreihe nicht f\u00e4llt","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#parameter_25","text":"series eine Datenserie, wie z.B. ein Indikator, Close, High o.\u00e4","title":"Parameter"},{"location":"schluesselworte/#beispiele_11","text":"// Pr\u00fcfen, ob der SMA(20) f\u00e4llt if (IsSerieFalling(SMA(20))) Print(\"The SMA(20) is currently falling.\");","title":"Beispiele"},{"location":"schluesselworte/#isshowchartverticalgrid","text":"","title":"IsShowChartVerticalGrid"},{"location":"schluesselworte/#beschreibung_46","text":"Die Eigenschaft IsShowChartVerticalGrid legt fest, ob in regelm\u00e4\u00dfigen Abst\u00e4nden vertikale Linien im Chart (das sog. vertikale Grid) angezeigt werden sollen. IsShowChartVerticalGrid = true (default) Vertikale Gitternetzlinien werden im Chart angezeigt. IsShowChartVerticalGrid = false Vertikale Gitternetzlinien werden nicht im Chart angezeigt. Die Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false).","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_35","text":"IsShowChartVerticalGrid","title":"Verwendung"},{"location":"schluesselworte/#beispiel_30","text":"protected override void OnInit() { (Color.FromKnownColor(KnownColor.Black), \"MyPlot1\")); // Vertikale Gitternetzlinien sollen nicht im Chart angezeigt werden IsShowChartVerticalGrid = false; }","title":"Beispiel"},{"location":"schluesselworte/#isshowindatabox","text":"","title":"IsShowInDataBox"},{"location":"schluesselworte/#beschreibung_47","text":"Die Eigenschaft \"IsShowInDataBox\" gibt an, ob die Werte des Indikators (Datenserien) in der DataBox des Charts enthalten sein sollen oder nicht. Die Eigenschaft kann im Script abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false) IsShowInDataBox = true (default) Die Indikatorwerte werden in der DataBox angezeigt. IsShowInDataBox = false Die Indikatorwerte werden nicht in der DataBox angezeigt. Im Bild werden die Werte von 3 gleitenden Durchschnitten in der DataBox angezeigt.","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_36","text":"IsShowInDataBox","title":"Verwendung"},{"location":"schluesselworte/#beispiel_31","text":"protected override void OnInit() { (Color.FromKnownColor(KnownColor.Black), \"MyPlot1\")); //Werte sollen nicht in der DataBox angezeigt werden IsShowInDataBox = false; }","title":"Beispiel"},{"location":"schluesselworte/#isshowpricemarkers","text":"","title":"IsShowPriceMarkers"},{"location":"schluesselworte/#beschreibung_48","text":"Die Eigenschaft PaintPriceMarkers legt fest, ob f\u00fcr die Indikatorausgaben, am rechten Chartrand (in der Preisachse) die sog. PriceMarkers angezeigt werden sollen oder nicht. In manchen F\u00e4llen ist es sinnvoll, dies f\u00fcr eine bessere \u00dcbersicht im Chart auszuschalten. IsShowPriceMarkers = true (default) PriceMarkers werden in der Preisachse angezeigt. IsShowPriceMarkers = false PriceMarkers werden nicht in der Preisachse angezeigt. Die Eigenschaft kann imScript abgefragt werden und liefert einen Wert vom Typ Boolean (true bzw. false).","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_37","text":"IsShowPriceMarkers","title":"Verwendung"},{"location":"schluesselworte/#beispiel_32","text":"protected override void OnInit() { (Color.FromKnownColor(KnownColor.Black), \"MyPlot1\")); //IsShowPriceMarkers sollen nicht angezeigt werden IsShowPriceMarkers = false; }","title":"Beispiel"},{"location":"schluesselworte/#level1args","text":"","title":"Level1Args"},{"location":"schluesselworte/#beschreibung_49","text":"Der Datentyp MarketDataEventArgs repr\u00e4sentiert eine \u00c4nderung in den Level-I-Daten und wird als Parameter in der Funktion OnLevel1() verwendet. AskSize Das aktuelle Ordervolumen auf der Ask-Seite. AskPrice Der aktuelle Ask-Kurs BidSize Das aktuelle Ordervolumen auf der Bid-Seite BidPrice Der aktuelle Bid-Kurs. Instrument Ein Objekt des Types IInstrument, das das Handelsinstrument beinhaltet, f\u00fcr welches die Level-I-Daten geliefert werden. Siehe Instruments LastPrice Der letzte durch einen Umsatz entstandene Kurs MarketDataType M\u00f6gliche Werte sind: MarketDataType.Ask, MarketDataType.AskSize, MarketDataType.Bid, MarketDataType.BidSize, MarketDataType.Last, MarketDataType.Volume Price Tenth\u00e4lt den gleichen Wert wie LastPrice. Das Feld ist nur aus Kompatibilit\u00e4tsgr\u00fcnden vorhanden. Time Ein DateTime-Wert, der den Zeitstempel der \u00c4nderung beinhaltet. Volume Ein long-Wert, der das Volumen, d.h. den letzten realen Umsatz angiebt.","title":"Beschreibung"},{"location":"schluesselworte/#beispiel_33","text":"siehe Beispiel unter OnLevel1() .","title":"Beispiel"},{"location":"schluesselworte/#level2args","text":"","title":"Level2Args"},{"location":"schluesselworte/#beschreibung_50","text":"Der Datentyp Level2Args repr\u00e4sentiert eine \u00c4nderung in den Level-II-Daten (Markttiefe) und wird als Parameter in der Funktion OnLevel2() verwendet. MarketDataType M\u00f6gliche Werte sind: MarketDataType.Ask, MarketDataType.Bid MarketMaker Ein string-Wert, der die Market Maker ID enth\u00e4llt Position Ein int-Wert, der die Position innerhalb der Markttiefe angiebt Operation Steht f\u00fcr die Aktion, die durch die \u00c4nderung in einem Orderbuch ausgel\u00f6st wird. M\u00f6gliche Werte sind: Operation.Insert, Operation.Remove, Operation.Update Price Eine double-Wert, der den jeweiligen Bid/Ask-Kurs Time Ein DateTime-Wert, der den Zeitstempel der \u00c4nderung beinhaltet Volume Ein long-Wert, der das Volumen angiebt","title":"Beschreibung"},{"location":"schluesselworte/#beispiel_34","text":"siehe Beispiel unter OnLevel2() .","title":"Beispiel"},{"location":"schluesselworte/#levelline","text":"","title":"LevelLine()"},{"location":"schluesselworte/#beschreibung_51","text":"EinA LevelLine object wird genutzt, um eine horizontale Linie in einen Chart zu zeichnen. \u00dcblicherweise sind dies obere und untere Triggerlinien wie z.B. beim RSI-Indikator die 70 und die 30 Linie. Diese hier beschriebenen Linien sind nicht zu verwechseln mit der Linie aus den Zeichenobjekten (siehe \"AddChartHorizontalLine\"). LevelLine objectwerden einem Indikator mit Hilfe der Add()-Methode hinzugef\u00fcgt und damit in die Lines-Collection aufgenommen. Siehe auch OutputDescriptor .","title":"Beschreibung"},{"location":"schluesselworte/#parameter_26","text":"Color Linienfarbe Name Bezeichnung Pen ein Pen-Objekt Value Gibt an, bei welchem Wert auf der y-Achse (Preisachse) die Linie gezeichnet werden soll","title":"Parameter"},{"location":"schluesselworte/#verwendung_38","text":"LevelLine(Color color, double value, string name) LevelLine(Pen pen, double value, string name)","title":"Verwendung"},{"location":"schluesselworte/#weitere-informationen_1","text":"Informationen zur Klasse Pen: http://msdn.microsoft.com/de-de/library/system.drawing.pen.aspx","title":"Weitere Informationen"},{"location":"schluesselworte/#beispiele_12","text":"// Beispiel 1 // Eine Linie mit Standardwerten bei 70 in den Chart zeichnen Add(new LevelLine(Color.Black, 70, \"Upper\")); // Beispiel 2 // Eine Linie mit selbstdefinierten Werten in den Chart zeichnen private LevelLine line; private Pen pen; protected override void OnInit() { // einen roten Stift mit der Linienst\u00e4rke 1 definieren pen = new Pen(Color.Red, 1); // eine horizontale Linie bei 10 definieren line = new LevelLine(pen, 10, \"MyLine\"); // die oben def. Linie dem Indikator hinzuf\u00fcgen Add(line); } // Beispiel 3 // Kurzform f\u00fcr die Linie aus Bespiel 2 Add(new LevelLine(new Pen(Color.Red, 1), 10, \"MyLine\"));","title":"Beispiele"},{"location":"schluesselworte/#log","text":"","title":"Log()"},{"location":"schluesselworte/#beschreibung_52","text":"Mit Log() ist es m\u00f6glich, Ausgaben in das LogFile (Log Tab) von AgenaTrader zu schreiben. Es werden 5 verschiedene LogLevel unterst\u00fctzt. Hinweis: Ist der Log-Tab nicht sichtbar, kann er mit Tools-Log angezeigt werden.","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_39","text":"**Log**(string message, LogLevel logLevel)","title":"Verwendung"},{"location":"schluesselworte/#parameter_27","text":"message Text (message) logLevel M\u00f6gliche Werte sind: InfoLogLevel.Info, InfoLogLevel.Message, InfoLogLevel.Warning, InfoLogLevel.ShowAlert, InfoLogLevel.Error","title":"Parameter"},{"location":"schluesselworte/#beispiel_35","text":"//Tab protocol Log(\"Das ist eine Information.\", InfoLogLevel.Info); //white Log(\"Das ist eine Nachricht.\", InfoLogLevel.Message); // white Log(\"Das ist eine Warnung.\", InfoLogLevel.Warning); // blue Log(\"Das ist ein Alarm.\", InfoLogLevel.ShowAlert); //green Log(\"Das ist ein Fehler.\", InfoLogLevel.Error); // red //Tab messages Log(\"This is a message (messages).\", InfoLogLevel.Message); //white //PopUp & protocoll Log(\"This is an alert popup window.\", InfoLogLevel.ShowAlert); //green //Output-Tab: //InfoLogLevel.Message = send to Tab \"Messages\" not \"Log\" //Action: /* InfoLogLevel.Error: also the AT-Status-Line is red and flashes InfoLogLevel.ShowAlert: opens also a modeless messagebox */ /* Summary: * - InfoLogLevel.ShowAlert Color: green Tab: Log Action: modeless Messagebox * - InfoLogLevel.Warning Color: blue Tab: Log * - InfoLogLevel.Info Color: white Tab: Log * - InfoLogLevel.Error Color: red Tab: Log Action: AT-Status-Line: red + flashing (Error) * - InfoLogLevel.Message Color: white Tab: Messages */ Crossreference: a crossreference to Print() and ShowAlert()","title":"Beispiel"},{"location":"schluesselworte/#occurred","text":"","title":"Occurred"},{"location":"schluesselworte/#beschreibung_53","text":"Diese DataSeries werden unter Bedingungen verwendet und geben an, ob ein Signal aufgetreten ist(1-long, -1 short, 0- kein signal )","title":"Beschreibung"},{"location":"schluesselworte/#parameter_28","text":"keiner","title":"Parameter"},{"location":"schluesselworte/#ruckgabewert_15","text":"Int","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#verwendung_40","text":"Im Skriptzustand f\u00fcr short, long, kein Signal","title":"Verwendung"},{"location":"schluesselworte/#beispiel_36","text":"protected override void OnCalculate() { if ( ProcessingBarIndex %2 == 0 ) Occurred.Set(1); // Long else if ( ProcessingBarIndex %3 == 0 ) Occurred.Set(-1); // Short else Occurred.Set(0); }","title":"Beispiel"},{"location":"schluesselworte/#onbarsrequirements","text":"","title":"OnBarsRequirements()"},{"location":"schluesselworte/#beschreibung_54","text":"Die OnBarsRequirements() Methode wird einmal zu Beginn einer Indikator- bzw. Strategieberechnung aufgerufen. Die Methode ist nur bei Verwendung von MultiBars notwendig. Innerhalb von InitRequirements werden keine weiteren Programmierbefehle ausgef\u00fchrt. F\u00fcr eigene Initialisierungen sind die MethodenOnInit() bzw. OnStart() zu verwenden.","title":"Beschreibung"},{"location":"schluesselworte/#parameter_29","text":"keiner","title":"Parameter"},{"location":"schluesselworte/#ruckgabewert_16","text":"keiner","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#beispiel_37","text":"protected override void OnBarsRequirements() { Add(DatafeedHistoryPeriodicity.Day, 1); Add(DatafeedHistoryPeriodicity.Week, 1); }","title":"Beispiel"},{"location":"schluesselworte/#oninit","text":"","title":"OnInit()"},{"location":"schluesselworte/#beschreibung_55","text":"Die OnInit()-Methode wird einmal zu Beginn einer Indikator- bzw. Strategieberechnung aufgerufen. Die Methode kann verwendet werden um Indikatoreigenschaften zu setzen, eigene Variablen zu initialisieren oder Plots hinzuzuf\u00fcgen.","title":"Beschreibung"},{"location":"schluesselworte/#parameter_30","text":"keiner","title":"Parameter"},{"location":"schluesselworte/#ruckgabewert_17","text":"keiner","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#verwendung_41","text":"protected override void OnInit()","title":"Verwendung"},{"location":"schluesselworte/#wichtige-schlusselworte","text":"Add() AllowRemovalOfChartDrawings IsAutoScale RequiredBarsCount CalculateOnClosedBar ClearTraceWindow Displacement IsShowInDataBox IsAddDrawingsToPricePanel InputPriceType IsOverlay IsShowPriceMarkers IsShowChartVerticalGrid zus\u00e4tzlich f\u00fcr Strategien DefaultOrderQuantity EntriesPerDirection SetUpStopLoss() SetUpProfitTarget() SetUpTrailStop() TimeInForce TraceOrders","title":"wichtige Schl\u00fcsselworte"},{"location":"schluesselworte/#weitere-informationen_2","text":"Achtung: Die OnInit()-Methode wird nicht nur am Beginn einer Indikator- bzw. Strategieberechnung aufgerufen, sondern auch unerwartet z.B. wenn ein Chart neu geladen wird oder der Eigenschaftsdialog von Indikatoren ge\u00f6ffnet wird usw. Entwickler von eigenen AgenaScripts sollten diese Methode NICHT verwenden, um eigene Routinen laufen zu lassen, Forms zu \u00f6ffnen, Lizenzchecks auszuf\u00fchren u. dgl. mehr. Hierzu ist die Methode OnStart() zu verwenden.","title":"Weitere Informationen"},{"location":"schluesselworte/#beispiel_38","text":"protected override void OnInit() { AddOutput(new OutputDescriptor(Color.FromKnownColor(KnownColor.Black), \"MyPlot1\")); ClearTraceWindow(); IsAutoScale = false; IsOverlay = true; IsShowPriceMarkers = false; IsShowInDataBox = false; CalculateOnClosedBar = true; }","title":"Beispiel"},{"location":"schluesselworte/#outputdescriptor","text":"","title":"OutputDescriptor()"},{"location":"schluesselworte/#beschreibung_56","text":"Ein OutputDescriptor (drawing)wird genutzt, um einen Indikator in einem Chart graphisch darzustellen. Plot-Objekte werden einem Indikator mit Hilfe der Add()-Methode hinzugef\u00fcgt und damit in die Plots-Collection aufgenommen. Siehe auch LevelLine .","title":"Beschreibung"},{"location":"schluesselworte/#parameter_31","text":"Color Zeichenfarbe Pen ein Pen-Objekt PlotStyle Linienart: PlotStyle.Bar, PlotStyle.Block, PlotStyle.Cross, PlotStyle.Dot, PlotStyle.Hash, PlotStyle.LevelLine, PlotStyle.Square, PlotStyle.TriangleDown, PlotStyle.TriangleUp Name Bezeichnung","title":"Parameter"},{"location":"schluesselworte/#verwendung_42","text":"OutputDescriptor(Color color, string name) OutputDescriptorOutputDescriptorOutputDescriptor(Pen pen, string name) OutputDescriptorOutputDescriptor(Color color, PlotStyle plotStyle, string name) OutputDescriptor(Pen pen, PlotStyle plotStyle, string name)","title":"Verwendung"},{"location":"schluesselworte/#weitere-informationen_3","text":"Informationen zur Klasse Pen: http://msdn.microsoft.com/de-de/library/system.drawing.pen.aspx","title":"Weitere Informationen"},{"location":"schluesselworte/#beispiele_13","text":"// Beispiel 1 // Plot mit Standardwerten (Linie mit Linienst\u00e4rke 1) Add(new OutputDescriptor(Color.Green, \"MyPlot\")); // Beispiel 2 // benutzerdefinierte Werte f\u00fcr Pen und PlotStyle private OutputDescriptor plot; private Pen pen; protected override void OnInit() { // einen roten Stift mit der Linienst\u00e4rke 6 definieren pen = new Pen(Color.Blue, 6); // eine Punkt-Linie mit dem dicken roten Stift von oben definieren plot = new OutputDescriptor(pen, PlotStyle.Dot, \"MyPlot\"); // den oben def. Plot als Darstellung f\u00fcr den Indikator verwenden Add(plot); } // Beispiel 3 // Kurzform von Beispiel 2 protected override void OnInit() { Add(new OutputDescriptor(new Pen(Color.Blue, 6), PlotStyle.Dot, \"MyPlot\")); }","title":"Beispiele"},{"location":"schluesselworte/#inputparameter","text":"","title":"InputParameter()"},{"location":"schluesselworte/#beschreibung_57","text":"Attribut, das f\u00fcr die Anpassung der Indikatoren verwendet wird","title":"Beschreibung"},{"location":"schluesselworte/#ruckgabewert_18","text":"keiner","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#parameter_32","text":"keiner","title":"Parameter"},{"location":"schluesselworte/#beispiele_14","text":"[Description(\"Period for the medium mean average\")] [InputParameter] [DisplayName(\"MA Medium\")] public int MA_Medium { get { return _ma_medium; } set { _ma_medium = value; } }","title":"Beispiele"},{"location":"schluesselworte/#playsound","text":"","title":"PlaySound()"},{"location":"schluesselworte/#beschreibung_58","text":"Die Methode PlaySound() dient dazu, ein Wav-File abzuspielen.","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_43","text":"PlaySound (wavFile)","title":"Verwendung"},{"location":"schluesselworte/#ruckgabewert_19","text":"keiner","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#parameter_33","text":"wavFile Dateiname der Wav-Datei zum Abspielen","title":"Parameter"},{"location":"schluesselworte/#beispiel_39","text":"using System.IO; string path = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments); string file = \"\\\\\\\\AgenaTrader\\\\\\\\Sounds\\\\\\\\Alert1.wav\"; PlaySound(path + file);","title":"Beispiel"},{"location":"schluesselworte/#plotmethod","text":"","title":"PlotMethod"},{"location":"schluesselworte/#beschreibung_59","text":"In jedem Indikator kann die Plot-Methode \u00fcberschrieben werden um mit Mittlen der Graphics-Klasse (System.Drawing) dem Preis-Chart eigene Grafiken hinzuzuf\u00fcgen (GDI+). Siehe http://msdn.microsoft.com/de-de/library/system.drawing.graphics.aspx . Das Objekt Chart bietet einige n\u00fctzliche Parameter. Weitere Beispiele: Bar Numbering , PlotSample , Chart Background Image .","title":"Beschreibung"},{"location":"schluesselworte/#parameter_34","text":"graphics Das graphics-Objekt des Preischarts (der sog. context) rectangle Die Gr\u00f6\u00dfe der Zeichenfl\u00e4che (Type public struct rectangle) double min Der kleinste Kurs in der y-Achse double max Der gr\u00f6\u00dfte Kurs in der y-Achse","title":"Parameter"},{"location":"schluesselworte/#ruckgabewert_20","text":"keiner","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#verwendung_44","text":"public override void OutputDescriptor(Graphics graphics, Rectangle r, double min, double max)","title":"Verwendung"},{"location":"schluesselworte/#beispiel_40","text":"using System; using System.Collections.Generic; using System.ComponentModel; using System.Drawing; using System.Drawing.Drawing2D; using AgenaTrader.API; using AgenaTrader.Custom; using AgenaTrader.Plugins; namespace AgenaTrader.UserCode { [Description(\"Example for the usage of the plot method.\")] public class PlotSample : UserIndicator { private StringFormat stringFormat = new StringFormat(); private SolidBrush brush = new SolidBrush(Color.Black); private Font font = new Font(\"Arial\", 10); protected override void OnInit() { IsChartOnlyIndicator = true; IsOverlay = true; } protected override void OnCalculate() {} protected override void OnDispose() { brush.Dispose(); stringFormat.Dispose(); } public override void OutputDescriptor(Graphics graphics, Rectangle r, double min, double max) { // Ausfuellen eines Rechtecks SolidBrush tmpBrush = new SolidBrush(Color.LightGray); graphics.FillRectangle(tmpBrush, new Rectangle (0, 0, 300, 300)); tmpBrush.Dispose(); // Zeichnen einer roten Linie von oben links nach unten recht Pen pen = new Pen(Color.Red); graphics.AddChartLine(pen, r.X, r.Y, r.X + r.Width, r.Y + r.Height); // Zeichnen einer roten Linie von unten links nach oben rechts // Verwenden von AnitAlias (Die Linie erscheint glatter) // Die aktuellen Einstellungen fuer die Glaettung werden gesichert // und nach dem Zeichnen wiederhergestellt SmoothingMode oldSmoothingMode = graphics.SmoothingMode; //Einstellung sichern graphics.SmoothingMode = SmoothingMode.AntiAlias; // hohe Glaettung verwenden graphics.AddChartLine(pen, r.X, r.Y + r.Height, r.X + r.Width, r.Y); graphics.SmoothingMode = oldSmoothingMode; // Einstellungen wiederherstellen pen.Dispose(); // Text in die obere linke Ecke (Position 10,35) schreiben stringFormat.Alignment = StringAlignment.Near; // Text links ausrichten brush.Color = Color.Blue; graphics.DrawString(\"Hello world!\", font, brush, r.X + 10, r.Y + 35, stringFormat); // Text in die linke untere Ecke schreiben und eine Linie darum herumzeichnen brush.Color = Color.Aquamarine; graphics.FillRectangle(brush, r.X + 10, r.Y + r.Height - 20, 140, 19); // Aeussere Linie zeichnen pen = new Pen(Color.Black); graphics.AddChartRectangle(pen, r.X + 10, r.Y + r.Height - 20, 140, 19); pen.Dispose(); // Text schreiben brush.Color = Color.Red; graphics.DrawString(\"Here is bottom left!\", font, brush, r.X + 10, r.Y + r.Height - 20, stringFormat); } } }","title":"Beispiel"},{"location":"schluesselworte/#pricetype","text":"","title":"PriceType"},{"location":"schluesselworte/#beschreibung_60","text":"PriceType beschreibt die Art von Kursdaten. Siehe auch InputPriceType Folgende Werte stehen zur Verf\u00fcgung: - PriceType.Close - PriceType.High - PriceType.Low - PriceType.Median - PriceType.Open - PriceType.Typical - PriceType.Volume - PriceType.Weighted","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_45","text":"PriceType","title":"Verwendung"},{"location":"schluesselworte/#beispiel_41","text":"Siehe Beispiel unter InputPriceType","title":"Beispiel"},{"location":"schluesselworte/#print","text":"","title":"Print()"},{"location":"schluesselworte/#beschreibung_61","text":"Die Methode Print() schreibt Ausgaben in das AgenaTrader Output-Window. Siehe auch ClearTraceWindow .","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_46","text":"Print(string message) Print(bool value) Print(double value) Print(int value) Print(DateTime value) Print(string format, string message)","title":"Verwendung"},{"location":"schluesselworte/#parameter_35","text":"string Text ein individueller Meldungstext","title":"Parameter"},{"location":"schluesselworte/#ruckgabewert_21","text":"keiner","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#weitere-informationen_4","text":"Hinweise zum Formatieren von Ausgaben finden Sie unter Formatting numbers . Hinweise zur String.Format()-Methode: http://msdn.microsoft.com/de-de/library/fht0f5be%28v=vs.80%29.aspx","title":"Weitere Informationen"},{"location":"schluesselworte/#beispiel_42","text":"// \"Quick&Dirty\"-Formatierung einer Zahl mit 2 Nachkommastellen Print(Close[0].ToString(\"0.00\")); // Wochentag aus dem Zeitstempel des Bars ausgeben Print(string.Format(\"{0:dddd}\", Time[0])); // Ein zus\u00e4tzlicher Zeilenvorschub mit ESC-Sequenz Print(\"One empty row afterwards \\\\n\");","title":"Beispiel"},{"location":"schluesselworte/#processingbarindex","text":"","title":"ProcessingBarIndex"},{"location":"schluesselworte/#beschreibung_62","text":"ProcessingBarIndex ist eine Nummerierung von Bars, die in der Methode OnCalculate() verwendet wird. Wenn in einem Chart z.B. 500 Bars dargestellt werden und auf diese ein Indikator berechnet werden soll, so beginnt AgenaTrader mit der Berechnung (also dem Aufruf von OnCalculate() bei dem \u00e4ltesten Bar. Dieser bekommt die Nummer 0. Ist die Berechnung f\u00fcr diesen Bar abgeschlossen, wird OnCalculate() f\u00fcr den n\u00e4chsten Bar aufgerufen. Dieser bekommt dann die Nummer 1 usw. bis zum letzten Bar, der die Nummer 499 bekommt.","title":"Beschreibung"},{"location":"schluesselworte/#parameter_36","text":"keiner","title":"Parameter"},{"location":"schluesselworte/#ruckgabewert_22","text":"ProcessingBarIndex ist eine Variable vom Typ int, die immer die Nummer des sich gerade in Bearbeitung befindenden Bars enth\u00e4lt.","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#verwendung_47","text":"ProcessingBarIndex","title":"Verwendung"},{"location":"schluesselworte/#weitere-informationen_5","text":"Die in der Methode OnCalculate() verwendete Nummerierung mit ProcessingBarIndex unterscheidet sich vom Barindex und Bars . Das Verst\u00e4ndnis dieses Unterschiedes ist sehr wichtig! Bitte das folgende genau lesen! ProcessingBarIndex nummeriert fortlaufend vom \u00e4ltesten zum j\u00fcngsten Bar beginnend bei 0. Der Barindex ist f\u00fcr den j\u00fcngsten Bar immer 0. Im Beispiel unten steht Time[0] f\u00fcr den Zeitstempel des aktuellen Bars. Der Index des \u00e4ltesten Bars wird mit jedem neu hinzukommenden Damit wird eine logische Z\u00e4hlung f\u00fcr barsAgo m\u00f6glich. Der Zeitstempel f\u00fcr den Bar von vor 5 Perioden ist damit Time[5]. Bei Verwendung mehrerer Zeiteinheiten (multi-bars)in einem Indikator siehe ProcessingBarIndexes.","title":"Weitere Informationen"},{"location":"schluesselworte/#beispiel_43","text":"protected override void OnCalculate() { Print(\"Call of OnCalculate for bar nr. \" + ProcessingBarIndex + \" of \" + Time[0]); }","title":"Beispiel"},{"location":"schluesselworte/#removechartdrawing","text":"","title":"RemoveChartDrawing()"},{"location":"schluesselworte/#beschreibung_63","text":"Die Methode RemoveChartDrawing() entfernt ein bestimmtes Zeichenobjekt vom Chart anhand einer eindeutigen Kennzeichnung (tag). Siehe auch RemoveChartDrawings() .","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_48","text":"RemoveChartDrawings(string tag)","title":"Verwendung"},{"location":"schluesselworte/#ruckgabewert_23","text":"keiner","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#parameter_37","text":"string tag Der Name eines Zeichenobjekts zur eindeutigen Identifizierung","title":"Parameter"},{"location":"schluesselworte/#beispiel_44","text":"RemoveChartDrawings(\"Meine Linie\");","title":"Beispiel"},{"location":"schluesselworte/#removechartdrawings","text":"","title":"RemoveChartDrawings()"},{"location":"schluesselworte/#beschreibung_64","text":"Die Methode RemoveDrawObjects() entfernt alle Zeichenobjekte vom Chart. Siehe auch RemoveChartDrawings() .","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_49","text":"RemoveChartDrawings()","title":"Verwendung"},{"location":"schluesselworte/#ruckgabewert_24","text":"keiner","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#beispiel_45","text":"//Alle Zeicheobjekte vom Chart l\u00f6schen RemoveChartDrawings();","title":"Beispiel"},{"location":"schluesselworte/#requiredbarscount","text":"","title":"RequiredBarsCount"},{"location":"schluesselworte/#beschreibung_65","text":"Die Eigenschaft BarsRequired gibt an, wieviele historische Bars mindestens ben\u00f6tigt werden, damit ein Indikator bzw. eine Strategie erstmal die Methode OnCalculate() aufrufen und mit den Berechnungen beginnen kann. BarsRequired sollte in der OnInit() Methode angegeben werden. Die Einstellung sollte sorgf\u00e4ltig gew\u00e4hlt werden. Z.B. braucht man zur Berechnung eines gleitenden Durchschnittes \u00fcber 100 Tage auch mindestens 100 Tage historische Daten, damit das Ergebnis korrekt ist. Die Eigenschaft kann im Script abgefragt werden und liefert einen int-Wert. Wenn OnBarUpdate erstmals aufgerufen wird, ist ProcessingBarIndex property = 0, unabh\u00e4ngig vom Wert von RequiredBarsCount.","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_50","text":"RequiredBarsCount","title":"Verwendung"},{"location":"schluesselworte/#beispiel_46","text":"protected override void OnInit() { //Der Indikator ben\u00f6tigt mindestens 50 Bars Historie RequiredBarsCount = 50; }","title":"Beispiel"},{"location":"schluesselworte/#showalert","text":"","title":"ShowAlert()"},{"location":"schluesselworte/#beschreibung_66","text":"Mit der Methode ShowAlert wird ein akustischer und/oder visueller Alarm erzeugt.","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_51","text":"ShowAlert(string message, bool showMessageBox, string soundLocation); //Aus Kompatibilit\u00e4tsgr\u00fcnden ist noch eine veraltete Signatur enthalten. Bei Nutzung dieses Aufrufvariante werden die Farbangaben und \"rearmSeconds\" ignoriert. ShowAlert(string id, AlertPriority priority, string message, string soundLocation, int rearmSeconds, Color backColor, Color forColor);","title":"Verwendung"},{"location":"schluesselworte/#ruckgabewert_25","text":"keiner","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#parameter_38","text":"message Nachrichtentext, der im Messages-Tab angezeigt wird. soundLocation Name eines Sound-Files im *.wav Format. Ist kein Pfad angegeben, wird \"Eigene Dokumente\\AgenaTrader\\Sounds\" verwendet. showMessageBox wenn true, wird zus\u00e4tzlich zum Sound eine Messagebox auf dem Bildschim angezeigt.","title":"Parameter"},{"location":"schluesselworte/#beispiel_47","text":"// Hinweis ausgeben, wenn der SMA(20) unter SMA(50) kreuzt if (CrossBelow(SMA(20), SMA(50), 1)) Alert(\"Check short signal!\", true, \"Alert4.wav\"); Um Musikdateien in anderen Verzeichnissen wiederzugeben, muss der vollst\u00e4ndige Pfad angegeben werden, z.B.: string pathOfSoundfile = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments)+@\"\\\\MyAlertSounds\\\\\"; string nameOfSoundFile = \"MyAlertSoundFile.wav\"; Alert(\"Message text\", true, pathOfSoundfile + nameOfSoundFile);","title":"Beispiel"},{"location":"schluesselworte/#ticksize","text":"Ein Tick ist die kleinst m\u00f6gliche Kurs\u00e4nderung eines Finanzinstruments an einer B\u00f6rse. Wenn die Handelspreise z.B. mit zwei Stellen nach dem Komma angegeben werden, betr\u00e4gt ein Tick 0,01. Im Forexhandel (W\u00e4hrungshandel) wird mit 4 bzw. 5 Stellen nach dem Komma gearbeitet. Ein Tick - der im Forexhandel als Pip bezeichnet wird - betr\u00e4gt dementsprechend 0,0001 bzw. 0,00001. Der Tickwert wird durch die B\u00f6rse fest vorgegeben und \u00e4ndert sich (in der Regel) nicht. Siehe auch Instrument.TickSize . \u00dcblicherweise wird heute ein Tick als Dezimalzahl angegeben. Historisch wurden besonders im amerikanischen Raum Aktien jedoch mit einer Tickgr\u00f6\u00dfe von 1/16 von einem Dollar notiert. Bei Rohstoffen ist diese Notierung noch weit verbreitet. Der Corn-Future (ZC - Mais) wird genau wie Wheat (ZW - Weizen) in \u00bc US-Cent/bushel (entspricht 12,50 US-$ je Kontrakt) notiert. US-Statsanleihen (T-Bonds) werden mit Tickgr\u00f6\u00dfen von 1/32 Punkten gehandelt, was 31,25 US-Dollar entspricht. Die Notierung erfolgt mit Hochkomma: 149'00 entspricht genau 149, 149'01 entspricht 149 1/32 (also 149,03125), 149'31 enspricht 149 31/32 (149,96875), danach folgt dann 150'00. In sog. T-Bond-Intermonth Spreads werden die Notierungen in Vierteln von 1/32 angegeben, was dann einem Punktwert von $7.8125 per Kontrakt entspricht. Die Notierungen erfolgt mit Bindestrich: 17-24 entspricht 17 24/32 Punkten, 17-242 entspricht 17 24,25/32 Punkten, 17-245 entspricht 17 24,5/32 Punkten und 17-247 entspricht 17 24,75/32 Punkten. Die n\u00e4chste Notierung nach 17-247 ist 17-25, dann wieder 17-252, 17-255 usw. Nach 17-317 folgt 18. Die Kontraktspezifikationen sind auf den Internetseiten der jeweiligen B\u00f6rsen ver\u00f6ffentlicht. CME: http://www.cmegroup.com under Products & Trading Eurex (FDAX): http://www.eurexchange.com/exchange-en/products/idx/dax/17206/ siehe auch Instrument.TickSize .","title":"TickSize"},{"location":"schluesselworte/#timeframe","text":"siehe Bars.TimeFrame . Bei Verwendung mehrerer Zeiteinheiten ( Multibars ) in einem Indikator siehe TimeFrames .","title":"TimeFrame"},{"location":"schluesselworte/#update","text":"","title":"Update()"},{"location":"schluesselworte/#beschreibung_67","text":"Die Methode Update() ruft die OnCalculateMethode einmal auf, um Indikatorwerte neu zu berechnen. Update() ist mit Vorsicht und nur von erfahrenen Programmierern zu verwenden.","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_52","text":"Update()","title":"Verwendung"},{"location":"schluesselworte/#ruckgabewert_26","text":"keiner","title":"R\u00fcckgabewert"},{"location":"schluesselworte/#parameter_39","text":"keiner","title":"Parameter"},{"location":"schluesselworte/#beispiel_48","text":"Die Wirkung von Update l\u00e4\u00dft sich mit Hilfe von 2 Indikatoren veranschaulichen. Der erste Indikator \"Ind1\" nutzt eine public Variable aus Indikator \"Ind2\". Code von Ind1: public class Ind1 : UserIndicator { protected override void OnCalculate() { Print( Ind2().MyPublicVariable ); } } Code von Ind2: private double myPublicVariable = 0; protected override void OnCalculate() { myPublicVariable = 1; } public double MyPublicVariable { get { Update(); return myPublicVariable; } } Ohne Update() - Falsch Wenn Ind2 von Ind1 aufgerufen wird, wird die get-Methode von MyPublicVariable in Ind2 aufgerufen. Ohne Update() w\u00fcrde der Wert von myPublicVariable zur\u00fcckgegeben werden. In diesem Falle eine 0. Mit Update() - Richtig Durch den Aufruf von Update() wird zun\u00e4chst OnBarUpdate() von Ind2 ausgef\u00fchrt. Damit wird myPublicVariable auf 1 gesetzt. Anschlie\u00dfend wird der Wert 1 an den aufrufenden Indikator Ind1 \u00fcbergeben.","title":"Beispiel"},{"location":"schluesselworte/#value","text":"","title":"Value"},{"location":"schluesselworte/#beschreibung_68","text":"Value ist ein DataSeries-Objekt, welches die erste Datenserie eines Indikators enth\u00e4lt. Beim Aufruf der Add()-Methode wird automatisch ein Value-Objekt erzeugt und der Collection Values hinzugef\u00fcgt. Value ist identisch mit Values[0].","title":"Beschreibung"},{"location":"schluesselworte/#verwendung_53","text":"Value Value[ int barsAgo]","title":"Verwendung"},{"location":"schluesselworte/#weitere-informationen_6","text":"Die f\u00fcr eine Collection bekannten Methoden Set(), Reset() und Count() sind auf Value anwendbar.","title":"Weitere Informationen"},{"location":"schluesselworte/#beispiel_49","text":"Siehe Values .","title":"Beispiel"},{"location":"strategieprogrammierung/","text":"Strategieprogrammierung Account Beschreibung Account ist ein Objekt, welches Informationen zu dem Konto enth\u00e4lt, mit dem die aktuelle Strategie arbeitet. Die einzelnen Eigenschaften sind: Account.AccountConnection Name der verwendeten Brokerverbindung (der Name, der unter Kontoverbindungen vergeben wurde). Account.AccountType Art des Kontos (Livokonto, Simkonto usw.) Account.Broker Bezeichnung des Brokers Account.BuyingPower Der Kontostand unter Ber\u00fccksichtigung des vom Broker gew\u00e4hrten Hebels.(IB hebelt das Kontoguthaben z.B. aktuell mit 4. Ein Guthaben von 10.000 Euro hat so eine \"Kaufkraft\" von 40.000 Euro. Account.CashValue Betrag (double) Account.Currency W\u00e4hrung, in der das Konto gef\u00fchrt wird Account.ExcessEquity \u00dcberschuss Account.InitialMargin Initial Margin (abh. vom jeweiligen Broker, double) Account.InstrumentType Art des Handelsinstrumentes (Typ AgenaTrader.Plugins.InstrumentTypes) Account.IsDemo true, wenn es sich um ein Demokonto handelt Account.Name Name des Kontos (i.d.R. mit Account. AccountConnection identisch) Account.OverNightMargin \u00dcbernacht-Margin (abh. vom jeweiligen Broker, double) Account.RealizedProfitLoss realisierter Gewinn bzw. Verlust (double) Beispiel Print(\"AccountConnection \" + Account.AccountConnection); Print(\"AccountType \" + Account.AccountType); Print(\"Broker \" + Account.Broker); Print(\"BuyingPower \" + Account.BuyingPower); Print(\"CashValue \" + Account.CashValue); Print(\"Currency \" + Account.Currency); Print(\"ExcessEquity \" + Account.ExcessEquity); Print(\"InitialMargin \" + Account.InitialMargin); Print(\"InstrumentTypes \" + Account.InstrumentTypes); Print(\"IsDemo \" + Account.IsDemo); Print(\"Name \" + Account.Name); Print(\"OverNightMargin \" + Account.OverNightMargin); Print(\"RealizedProfitLoss \" + Account.RealizedProfitLoss); BarsCountFromTradeClose() Beschreibung Die Eigenschaft \"BarsCountFromTradeClose\" liefert die Anzahl der Bars, die seit dem letzten Ausstieg (Exit) aus dem Markt vergangen sind. Verwendung BarsCountFromTradeClose() BarsCountFromTradeClose(string strategyName) F\u00fcr Multibar-Strategieen BarsCountFromTradeClose(int multibarSeriesIndex, string strategyName, int exitsAgo) Parameter strategyName Der Signalname (string), der in einer Ausstiegsmethode zur eindeutigen Kennzeichnung des Ausstiegs vergeben wurde multibarSeriesIndex F\u00fcr * Multibar* MultiBars Strategieen. Index der Datenreihe, f\u00fcr die die Ausstiegsorder ausgef\u00fchrt wurde. Siehe ProcessingBarSeriesIndex . exitsAgo Anzahl der in der Vergangenheit liegenden Ausstiege. Eine 0 (Null) an dieser Stelle liefert die Anzahl der Bars, die sich nach dem letzten Ausstieg ausgebildet haben. Beispiel Print(\"Der letzte Ausstieg liegt \" + BarsCountFromTradeClose() + \" Bars zur\u00fcck.\"); BarsCountFromTradeOpen() Beschreibung Die Eigenschaft \"BarsCountFromTradeOpen\" liefert die Anzahl der Bars, die seit dem letzten Einstieg (Entry) in den Markt vergangen sind. Verwendung BarsCountFromTradeOpen() BarsCountFromTradeOpen(string strategyName) F\u00fcr Multibar-Strategieen BarsCountFromTradeOpen(int multibarSeriesIndex, string strategyName, int entriesAgo) Parameter strategyName Der Signalname (string), der in einer Einstiegsmethode zur eindeutigen Kennzeichnung des Einstiegs vergeben wurde. multibarSeriesIndex F\u00fcr * Multibar* , MultiBars Strategieen.Index der Datenreihe, f\u00fcr die die Einstiegsorder ausgef\u00fchrt wurde. Siehe ProcessingBarSeriesIndex , ProcessingBarSeriesIndex . entriesAgo Anzahl der in der Vergangenheit liegenden Einstiege. Eine 0 (Null) an dieser Stelle liefert die Anzahl der Bars, die sich nach dem letzten Einstieg ausgebildet haben. Beispiel Print(\"Der letzte Einstieg liegt \" + BarsCountFromTradeOpen() + \" Bars zur\u00fcck.\"); CancelAllOrders() Beschreibung CancelAllOrders l\u00f6scht alle Oders (cancel), die von der Strategie verwaltet werden. Es wird ein Cancel-Request an den Broker verschickt. Ob eine Oder dort wirklich gel\u00f6scht wird, kann nicht garantiert werden. Es kann vorkommen, dass eine Order eine Teilausf\u00fchrung erhalten hat, ehe sie gel\u00f6scht wird. Es ist daher ratsam, den jeweils aktuellen Status einer Order mit OnOrderChanged() zu kontrollieren. Verwendung CancelAllOrders() Parameter kein Parameter Beispiel protected override void OnCalculate() { if (BarsCountFromTradeOpen() >= 30) CancelAllOrders(); } Order.Cancel() Beschreibung Cancel order l\u00f6scht eine Oder (cancel). Es wird ein Cancel-Request an den Broker verschickt. Ob eine Oder dort wirklich gel\u00f6scht wird, kann nicht garantiert werden. Es kann vorkommen, dass eine Order eine Teilausf\u00fchrung erhalten hat, ehe sie gel\u00f6scht wird. Es ist daher ratsam, den jeweils aktuellen Status einer Order mit OnOrderChanged() zu kontrollieren. Verwendung Order.Cancel(IOrder order) Parameter Ein order-Objekt vom Typ IOrder Beispiel private IOrder entryOrder = null; private int barNumber = 0; protected override void OnCalculate() { // An das Hoch des aktuellen Bars einen Einstiegsstop legen if (entryOrder == null) { entryOrder = OpenLongStop(High[0], \"stop long\"); barNumber = ProcessingBarIndex; } // Nach 3 Bars die Order l\u00f6schen if (Position.PositionType == PositionType.Flat && ProcessingBarIndex > barNumber + 3) Order.Cancel(entryOrder); } CreateIfDoneGroup() Beschreibung Wenn zwei Orders \u00fcber eine CreateIfDoneGroup miteinander verkn\u00fcpft werden, so bedeutet dies, dass wenn die eine Order ausgef\u00fchrt wurde, die zweite verbundene Order aktiviert wird. Verwendung CreateIfDoneGroup(IEnumerable<IOrder> orders) Parameter Ein order-Objekt vom Typ IOrder als List Beispiel private IOrder oopenlong = null; private IOrder osubmitbuy = null; protected override void OnInit() { IsAutoConfirmOrder = false; } protected override void OnCalculate() { oopenlong = SubmitOrder(new StrategyOrderParameters { Direction = OrderDirection.Buy, Type = OrderType.Market, Quantity = DefaultOrderQuantity, SignalName = \"strategyName\", }); osubmitbuy = SubmitOrder(new StrategyOrderParameters { Direction = OrderDirection.Sell, Type = OrderType.Stop, Quantity = DefaultOrderQuantity, StopPrice = Close[0] * 1.1, SignalName = \"strategyName\", }); CreateIfDoneGroup(new List<IOrder> { oopenlong, osubmitbuy }); oopenlong.ConfirmOrder(); } CreateOCOGroup() Beschreibung Wenn zwei Orders \u00fcber eine CreateOCOGroup miteinander verkn\u00fcpft werden, so bedeutet dies, dass sobald die eine Order ausgef\u00fchrt wurde, die zweite verbundene Order gel\u00f6scht wird. Verwendung CreateOCOGroup(IEnumerable<IOrder> orders) Parameter Ein order-Objekt vom Typ IOrder als List Beispiel private IOrder oopenlong = null; private IOrder oEnterShort = null; protected override void OnInit() { IsAutoConfirmOrder = false; } protected override void OnCalculate() { oopenlong = SubmitOrder(new StrategyOrderParameters { Direction = OrderDirection.Buy, Type = OrderType.Stop, Quantity = DefaultOrderQuantity, StopPrice = Close[0] * 1.1, SignalName = \"strategyName\", }); oEnterShort = SubmitOrder(new StrategyOrderParameters { Direction = OrderDirection.Sell, Type = OrderType.Stop, Quantity = DefaultOrderQuantity, StopPrice = Close[0] * -1.1, SignalName = \"strategyName\", }); CreateOCOGroup(new List<IOrder> { oopenlong, oEnterShort }); oopenlong.ConfirmOrder(); oEnterShort.ConfirmOrder(); } CreateOROGroup() Beschreibung Wenn zwei Orders \u00fcber eine CreateOROGroup miteinander verkn\u00fcpft werden, so bedeutet dies, dass sobald die eine Order ausgef\u00fchrt wurde, die Ordergr\u00f6\u00dfe der zweiten Order um das Ordervolumen der ersten Order reduziert wird. Verwendung CreateOROGroup(IEnumerable<IOrder> orders) Parameter Ein order-Objekt vom Typ IOrder Beispiel private IOrder oStopLong = null; private IOrder oLimitLong = null; protected override void OnInit() { IsAutoConfirmOrder = false; } protected override void OnCalculate() { oStopLong = SubmitOrder(new StrategyOrderParameters { Direction = OrderDirection.Buy, Type = OrderType.Stop, Quantity = DefaultOrderQuantity, StopPrice = Close[0] * -1.1, SignalName = \"strategyName\", }); oLimitLong = SubmitOrder(new StrategyOrderParameters { Direction = OrderDirection.Buy, Type = OrderType.Limit, Quantity = DefaultOrderQuantity*0.5, Price = Close[0] * 1.1, SignalName = \"strategyName\", }); CreateOROGroup(new List<IOrder> { oLimitLong, oStopLong }); } DataSeriesConfigurable DefaultOrderQuantity Beschreibung DefaultQuantity legt die in einer Strategie zu verwendende St\u00fcckzahl fest. DefaultQuantity wird in der OnInit() -Methode angegeben. Verwendung ReplaceOrder(IOrder iOrder, int quantity, double limitPrice, double stopPrice) Parameter ein int-Wert, der die St\u00fcckzahn (Aktien, Kontrakte usw.) enth\u00e4lt Beispiel protected override void OnInit() { DefaultOrderQuantity = 100; } ExcludeTradeHistoryInBacktest CloseLongTrade() Beschreibung CloseLongTrade erzeugt eine Sell-Order um eine Long Position zu schlie\u00dfen (zu verkaufen). Siehe auch: SubmitOrder() , CloseShortTrade() Verwendung Siehe StrategyOrderParameters Parameter Siehe StrategyOrderParameters Return Value ein order-Objekt vom Typ IOrder Beispiel var order = CloseLongTrade(new StrategyOrderParameters { Type = OrderType.Market }); ExitOnClose ExitOnCloseSeconds CloseShortTrade() Beschreibung CloseShortTrade erzeugt eine Buy-to-Cover Order um eine Short Position zu schlie\u00dfen (zu kaufen). Siehe auch: SubmitOrder() , CloselongTrade() Verwendung Siehe StrategyOrderParameters Parameter Siehe StrategyOrderParameters R\u00fcckgabewert ein order-Objekt vom Typ IOrder Example var order = CloseShortTrade(new StrategyOrderParameters { Type = OrderType.Stop, Quantity = quantity, StopPrice = price }); Account.GetValue() Beschreibung Account.GetValue() liefert Informationen \u00fcber das Konto, f\u00fcr das die Strategie ausgef\u00fchrt wird. Siehe auch GetProfitLoss() . Verwendung Account.GetValue(AccountItem accountItem) Parameter M\u00f6gliche Werte f\u00fcr accountItem sind AccountItem.BuyingPower AccountItem.CashValue AccountItem.RealizedProfitLoss R\u00fcckgabewert ein double-Wert f\u00fcr das jeweilige AccountItem, F\u00fcr historische Bars wird eine 0 (Null) zur\u00fcckgegeben. Beispiel Print(\"The current account cash value is \" + Account.GetValue(AccountItem.CashValue)); Print(\"The current account cash value with the leverage provided by the broker is \" + Account.GetValue(AccountItem.BuyingPower)); Print(\"The current P/L already realized is \" + Account.GetValue(AccountItem.RealizedProfitLoss)); GetEntries() Beschreibung Diese Datenserie wird f\u00fcr Conditions verwendet und zeigt mehrfache Einstiegspreise f\u00fcr Einstiegsorders an. Verwendung \u00dcberladung von programmierten Conditions f\u00fcr eine Short und Long Signal Anzeige. Parameter None R\u00fcckgabewert int Beispiel public class MyTestEntry : UserScriptedCondition { double _percentage = 100; protected override void Initialize() { IsEntry = true; IsStop = false; IsTarget= false; Add(new OutputDescriptor(Color.FromKnownColor(KnownColor.Black), \"Occurred\")); Add(new OutputDescriptor(Color.FromArgb(255, 118, 222, 90), \"Entry1\")); Add(new OutputDescriptor(Color.FromArgb(255, 118, 222, 90), \"Entry2\")); Add(new OutputDescriptor(Color.FromArgb(255, 118, 222, 90), \"Entry3\")); Overlay = true; CalculateOnBarClose = true; } protected override void OnBarUpdate() { Calculate(); } public override void Recalculate() { Calculate(); } private void Calculate () { if (TradeDirection == PositionType.Long) { Entry1.Set(Close[0] + 0.5); Entry2.Set(Close[0] + 1); Entry3.Set(Close[0] + 1.5); } else { Entry1.Set(Close[0] - 0.5); Entry2.Set(Close[0] - 1); Entry3.Set(Close[0] - 1.5); } } #region Properties [Browsable(false)] [XmlIgnore()] public DataSeries Occurred { get { return Values[0]; } } [Browsable(false)] [XmlIgnore()] public DataSeries Entry1 { get { return Values[1]; } } [Browsable(false)] [XmlIgnore()] public DataSeries Entry2 { get { return Values[2]; } } [Browsable(false)] [XmlIgnore()] public DataSeries Entry3 { get { return Values[3]; } } public override IList<DataSeries> GetEntrys() { return new[] { Entry1, Entry2, Entry3 }; GetProfitLoss() Beschreibung GetProfitLoss() liefert den aktuell unrealisierten Gewinn bzw. Verlust einer laufenden Position. Siehe auch Account.GetValue() . Usage GetProfitLoss(int pLType); Verwendung M\u00f6gliche Werte f\u00fcr pLType sind 0 - Amount, P/L als W\u00e4hrungsbetrag 1 - Percent, P/L in Prozent 2 \u2013 Risk, P/L in Van Tharp R-Multiples www.vantharp.com 3 \u2013 P/L in Ticks R\u00fcckgabewert ein double-Wert f\u00fcr den unrealisierten Gewinn bzw. Verlust Beispiel Print(\"The current risk for the strategy \" + this.Name + \" is \" + GetProfitLoss(1) + \" \" + Instrument.Currency); Print(\"This equals \"+ string.Format( \"{0:F1} R.\", GetProfitLoss(3))); GetProfitLossAmount() Beschreibung GetProfitLossAmount() liefert den aktuell unrealisierten Gewinn bzw. Verlust einer laufenden Position als W\u00e4hrungsbetrag. Siehe auch Account.GetValue() . Verwendung GetProfitLossAmount(double profitLoss); Parameter Ein Objekt vom Typ double R\u00fcckgabewert ein double-Wert f\u00fcr den unrealisierten Gewinn bzw. Verlust Beispiel Print(\"the current P&L \" + this.Name + \" is \" + GetProfitLossAmount(Position.OpenProfitLoss) + \" \" + Instrument.Currency); GetProfitLossRisk() Beschreibung GetProfitLossRisk() liefert den aktuell unrealisierten Gewinn bzw. Verlust einer laufenden Position in R-Multiplen. Siehe auch Account.GetValue() . Verwendung GetProfitLossRisk(); Parameter keine R\u00fcckgabewert ein double-Wert f\u00fcr denie R-Multiple Beispiel Print(\"the current P&L \" + this.Name + \" is \" + string.Format( \"{0:F1} R.\", GetProfitLossRisk())); GetScriptedCondition() Beschreibung Mit dieser Methode k\u00f6nnen Benutzer zwischen Skripte zu kommunizieren. IsAutoConfirmOrder Beschreibung IsAutoConfirmOrder legt fest ob Orders automatisch aktiviert werden. IsAutoConfirmOrder wird in der OnInit() -Methode angegeben. Ist IsAutoConfirmOrder = true, dann werden Orders automatisch aktiviert (Default). Wenn IsAutoConfirmOrder der Wert false zugewiesen wurde, dann muss die entsprechende Order mit order. ConfirmOrder() aktiviert werden. Parameter ein bool-Wert Beispiel protected override void OnInit() { IsAutoConfirmOrder = false; } Order Beschreibung IOrder ist ein Objekt, welches Informationen zu einer Order enth\u00e4lt, die aktuell von einer Strategie verwaltet wird. Die einzelnen Eigenschaften sind: Action Eine der vier m\u00f6glichen Aktionen: OrderDirection.Buy OrderDirection.Sell AveragePrice Der durchschnittliche Kauf- bzw. Verkaufspreis einer Position. Bei Positionen ohne Teilausf\u00fchrungen entspricht dies dem Einstiegskurs. FilledQuantity Bei Teilausf\u00fchrungen ist Filled kleiner als Quantity LimitPrice Name Der eindeutige SignalName OrderId Die eindeutige OrderId OrderMode Eines der drei m\u00f6glichen Optionen: OrderMode.Direct OrderMode.Dynamic OrderMode.Synthetic OrderState Hiermit kann der aktuelle Zustand der Order abgefragt werden (siehe OnOrderExecution und OnOrderChanged ) OrderState.Accepted OrderState.Cancelled OrderState.CancelRejected OrderState.FilledQuantity OrderState.PartFilled OrderState.PendingCancel OrderState.PendingReplace OrderState.PendingSubmit OrderState.Rejected OrderState.ReplaceRejected OrderState.Unknown OrderState.Working OrderType M\u00f6gliche Orderarten: OrderType.Limit OrderType.Market OrderType.Stop OrderType.StopLimit Quantity Die zu ordernde St\u00fcckzahl StopPrice Timestamp Zeitstempel TimeFrame Der TimeFrame, der f\u00fcr die Order g\u00fcltig ist. TimeFrame M\u00f6gliche Methoden: order Order.Cancel() L\u00f6scht die Order order.ConfirmOrder() Best\u00e4tig die Order. Diese Methode muss ausgef\u00fchrt werden, wenn IsAutoConfirmOrder auf false gesetzt wird und man die Order dennoch automatisch ausf\u00fchren m\u00f6chte. Dies ist z. B. dann der Fall, wenn eine OCO- oder IfDone-Verk\u00fcpfung hergestellt werden soll. Performance Beschreibung Performance ist ein Objekt, welches Informationen zu allen Trades enth\u00e4lt, die von einer Strategie generiert wurden. Es gibt mehrere Listen, in denen die Trades eingeordnet sind. Mit Hilfe dieser Listen ist es leicht, weitere Performance-Auswertungen zu erstellen. Siehe Performance-Kennzahlen. Die einzelnen Listen sind: Performance.AllTrades Ist ein Trade Collection Objekt, das alle von einer Strategie generierten Trades enth\u00e4lt. Performance.LongTrades Ist ein Trade Collection Objekt, das alle von einer Strategie generierten Long-Trades enth\u00e4lt. Performance.ShortTrades Ist ein Trade Collection Objekt, das alle von einer Strategie generierten ShortTrades enth\u00e4lt. Performance.WinningTrades Ist ein Trade Collection Objekt, das alle von einer Strategie generierten Gewinntrades enth\u00e4lt. Performance.LosingTrades Ist ein Trade Collection Objekt, das alle von einer Strategie generierten Verlusttrades enth\u00e4lt. Beispiel // beim Verlassen der Strategie eine Auswertung erstellen protected override void OnDispose() { Print(\"Performance evaluation of the strategy : \" + this.Name); Print(\"----------------------------------------------------\"); Print(\"Amount of all trades: \" + Performance.AllTrades.Count); Print(\"Amount of winning trades: \" + Performance.WinningTrades.Count); Print(\"Amount of all loss trades: \" + Performance.LosingTrades.Count); Print(\"Amount of all long trades: \" + Performance.LongTrades.Count); Print(\"Amount of short trades: \" + Performance.ShortTrades.Count); Print(\"Result: \" + Account.RealizedProfitLoss + \" \" + Account.Currency); } Position Beschreibung Position ist ein Objekt, welches Informationen zu einer Position enth\u00e4lt, die aktuell von einer Strategie verwaltet wird. Die einzelnen Eigenschaften sind: Position.AvgPrice Der durchschnittliche Kauf- bzw. Verkaufspreis einer Position. Bei Positionen ohne Teilausf\u00fchrungen entspricht dies dem Einstiegskurs. Position.CreatedDateTime Datum und Uhrzeit der Positionser\u00f6ffnung. Position.Instrument Das Handelsinstrument, in welchem die Position besteht. siehe auch Instruments . Position.PositionType Eines der drei m\u00f6glichen Positionierungen im Markt: PositionType.Flat PositionType.Long PositionType.Short Position.OpenProfitLoss Der aktuell noch unrealisierte Gewinn bzw. Verlust. siehe auch GetProfitLoss() . Position.ProfitCurrency Gewinn (bzw. Verlust) ausgewiesen als W\u00e4hrungsbetrag. Position.ProfitPercent Gewinn (bzw. Verlust) ausgewiesen in Prozent. Position.ProfitPoints Gewinn (bzw. Verlust) ausgewiesen in Punkten bzw. Pips. Position.Quantity St\u00fcckzahl der Aktien, Kontrakte, CFD's o.\u00e4. in der Position. Beispiel if (Position.PositionType != PositionType.Flat) { Print(\"Average price \" + Position.AvgPrice); Print(\"Opening time \" + Position.CreatedDateTime); Print(\"Instrument \" + Position.Instrument); Print(\"Current positioning \" + Position.PositionType); Print(\"Unrealized P/L \" + Position.OpenProfitLoss); Print(\"P/L (currency) \" + Position.ProfitCurrency); Print(\"P/L (in percent) \" + Position.ProfitPercent); Print(\"P/L (in points) \" + Position.ProfitPoints); Print(\"Pieces \" + Position.Quantity); } PositionType Siehe Position.PositionType . TraceOrders Beschreibung Die Eigenschaft TraceOrders ist sehr n\u00fctzlich, um Orders, die von Strategien generiert werden, nachzuverfolgen. TraceOrders wird in der OnInit() Methode angegeben. Wenn TraceOrders eingeschaltet ist, werden f\u00fcr jede Order die folgenden Werte im OutputWindow ausgegeben: Instrument Time frame Action Type Limit price Stop price Quantity Name Diese Informationen sind z.B. bei der Erstellung von Strategien und f\u00fcr das Debugging sehr n\u00fctzlich. Verwendung TraceOrders Parameter keine R\u00fcckgabewert true Tracing ist aktuell eingeschaltet false Tracing ist abgeschaltet Beispiel protected override void OnInit() { ClearTraceWindow(); TraceOrders = true; } Quantity siehe unter Position.Quantity , Position.PositionType . ReplaceOrder() Beschreibung ChangeOrder \u00e4ndert eine Order. Verwendung ReplaceOrder(IOrder iOrder, int quantity, double limitPrice, double stopPrice) Parameter iOrder ein Order -Objekt vom Typ IOrder quantity zu ordernde St\u00fcckzahl limitPrice Limitpreis. Wenn nicht ben\u00f6tigt, auf 0 setzen stopPrice Stoppreis. Wenn nicht ben\u00f6tigt, auf 0 setzen Beispiel private IOrder stopOrder = null; protected override void OnCalculate() { // Wenn die Position 10 Ticks im Gewinn liegt, Stopp auf Einstand anheben if (stopOrder != null && Close[0] >= Position.AvgPrice + (10 * TickSize) && stopOrder.StopPrice < Position.AvgPrice) ReplaceOrder(stopOrder, stopOrder.Quantity, stopOrder.LimitPrice, Position.AvgPrice); } SetUpProfitTarget() Beschreibung Serzeugt sofort nach Ausf\u00fchrung einer Einstiegsorder eine Profit Target-Order um eine laufende Position zu einem bestimmten Kurs im Gewinn zu schlie\u00dfen. Die Order wird direkt an den Broker \u00fcbergeben und ist sofort im Markt wirksam. Wenn das Gewinnziel statisch ist, kann SetUpProfitTarget() in der OnInit() Methode angegeben werden. Siehe auch SetUpStopLoss() , SetUpTrailStop() . Verwendung SetUpProfitTarget(double currency) SetUpProfitTarget(CalculationMode mode, double value) SetUpProfitTarget(string fromEntry signal, CalculationMode mode, double value) Parameter currency Gibt das Gewinnziel in einer W\u00e4hrung an, z.B. 500,- Euro. mode M\u00f6gliche Werte sind: CalculationMode.Percent (Angabe in Prozent); CalculationMode.Price (Angabe als Kurswert); CalculationMode.Ticks (Angabe in Ticks bzw. Pips) value Ein Wert, der den Abstand zwischen Einstiegskurs und Gewinnziel angibt. Die Angabe bezieht sich abh\u00e4ngig von \"mode\" auf einen Geldbetrag, eine Prozentangabe bzw. auf eine Angabe in Ticks. fromEntry signal Der Name eines Einstiegssignals, f\u00fcr das eine Profit Target-Order generiert werden soll. Die St\u00fcckzahl wird nur aus der angegebenen Einstiegsorder \u00fcbernommen. Beispiel protected override void OnInit() { // Erzeugt eine Profit Target-Order 10 Ticks \u00fcber Einstand SetUpProfitTarget(CalculationMode.Ticks, 20); } SetUpStopLoss() Beschreibung Set up stop loss erzeugt sofort nach Ausf\u00fchrung einer Einstiegsorder eine StopLoss-Order um eine laufende Position zu einem bestimmten Kurs zu schlie\u00dfen. Die Order wird direkt an den Broker \u00fcbergeben und ist sofort im Markt wirksam (wenn sie nicht simuliert wird, s.u.). Wenn der StopLoss-Kurs statisch ist, kann SetUpStopLoss() in der OnInit() Methode angegeben werden. Siehe auch SetUpProfitTarget() , SetUpTrailStop() . Verwendung SetUpStopLoss(double currency) SetUpStopLoss(double currency, bool simulated) SetUpStopLoss(CalculationMode mode, double value) SetUpStopLoss(string fromEntry signal, CalculationMode mode, double value, bool simulated) Parameter currency Gibt den StopLoss-Abstand zum Einstiegskurs (=Risiko) in einer W\u00e4hrung an, z.B. 500,- Euro. mode M\u00f6gliche Werte sind: CalculationMode.Percent ( Angabe in Prozent); CalculationMode.Price (Angabe als Kurswert); CalculationMode.Ticks (Angabe in Ticks bzw. Pips) simulated Wenn \"simulated\" auf \"true\" gesetzt ist, wird die Stoporder erst dann live (als Marketorder) zum Broker \u00fcbermittelt, wenn der Kurs sie erstmals \"ber\u00fchrt\" hat (d.h wenn sie ausgel\u00f6st werden w\u00fcrde wenn sie im Markt gelegen h\u00e4tte). value Ein Wert, der den Abstand zwischen Einstiegskurs und Stoppkurs angibt. Die Angabe bezieht sich abh\u00e4ngig von \"mode\" auf einen Geldbetrag, eine Prozentangabe bzw. auf eine Angabe in Ticks. fromEntry signal Der Name eines Einstiegssignals, f\u00fcr das eine Stoporder generiert werden soll. Die St\u00fcckzahl wird nur aus der angegebenen Einstiegsorder \u00fcbernommen. Beispiel protected override void OnInit() { // Sets profitTarget 15 Ticks \u00fcber dem Markt SetUpStopLoss(\"MACDEntry\", CalculationMode.Ticks, 15, true); } SetUpTrailStop() Beschreibung SetTrailStop() erzeugt sofort nach Ausf\u00fchrung einer Einstiegsorder eine Trail Stop-Order um eine laufende Position zun\u00e4chst im Verlust zu sch\u00fctzen bzw. nach dem BreakEven den Gewinn zu sichern. Die Order wird direkt an den Broker \u00fcbergeben und ist sofort im Markt wirksam (wenn sie nicht simuliert wird, s.u.). Wenn der StopLoss-Kurs und der Offset-Wert statisch ist, kann SetUpTrailStop() in der OnInit() Methode angegeben werden. Sollte SetUpTrailStop() in der OnCalculate() Methode verwendet werden, um sie dynamisch dem Kursverlauf anpassen zu k\u00f6nnen, ist darauf zu achten, die Parameter vor einer weiteren (neuen) Position auf die gew\u00fcnschten Initialwerte zur\u00fcckzusetzten, da die zuletzt gesetzten Werte ansonsten auch f\u00fcr die neue Position wirksam sind. Funktionsweise: Angenommen es ist SetUpTrailStop(CalculationMode.Ticks, 30) gesetzt: In einer Long-Position wird der Stop nun 30 Ticks vom jeweils letzten erreichten Hoch entfernt gesetzt. Macht der Markt ein neues Hoch, wird der Stop angepasst. Der Stop wird jedoch nicht mehr nach unten ver\u00e4ndert. In einer Shortposition ist das Verhalten analog vom erreichten tiefsten Tief ausgehend. Hinweise: Es ist nicht m\u00f6glich, in einer Strategie f\u00fcr ein und dieselbe SetUpStopLoss und SetUpTrailStop gleichzeitig zu verwenden. Es wird immer SetUpStopLoss() der Vorrang einger\u00e4umt Es ist aber m\u00f6glich, in einer Strategie beide Varianten parallel zu verwenden, wenn sie auf unterschiedliche Einstiegssignale referenzieren Bei Teilausf\u00fchrungen einer einzelnen Order wird f\u00fcr jede Teilposition ein separater Trailing Stop angelegt. Wird zus\u00e4tzlich zu SetUpProfitTarget() auch SetUpTrailStop(), verwendet, werden beide Orders automatisch OCO-verkn\u00fcpft (OCO = one cancels the other) Es wird immer eine Stop-Market oder erzeugt, keine Stop-Limit-Order. Wird die Position innerhalb der Strategie von einer anderen Ausstiegsorder geschlossen, so wird die Trailing-Stoporder automatisch gel\u00f6scht. Siehe auch SetUpStopLoss() , SetUpProfitTarget() . Verwendung SetUpTrailStop(double currency) SetUpTrailStop(double currency, bool simulated) SetUpTrailStop(CalculationMode mode, double value) SetUpTrailStop(string fromEntry signal, CalculationMode mode, double value, bool simulated) Parameter currency Gibt den StopLoss-Abstand zum Einstiegskurs (=Risiko) in einer W\u00e4hrung an, z.B. 500,- Euro. mode M\u00f6gliche Werte sind: CalculationMode.Percent; CalculationMode.Ticks simulated Wenn \"simulated\" auf \"true\" gesetzt ist, wird die Trail-Stoporder erst dann live (als Marketorder) zum Broker \u00fcbermittelt, wenn der Kurs sie erstmals \"ber\u00fchrt\" hat (d.h wenn sie ausgel\u00f6st werden w\u00fcrde wenn sie im Markt gelegen h\u00e4tte). value Ein Wert, der den Abstand zwischen Einstiegskurs und Stoppkurs angibt. Die Angabe bezieht sich abh\u00e4ngig von \"mode\" auf einen Geldbetrag, eine Prozentangabe bzw. auf eine Angabe in Ticks. fromEntry signal Der Name eines Einstiegssignals, f\u00fcr das eine Trail-Stoporder generiert werden soll. Die St\u00fcckzahl wird nur aus der angegebenen Einstiegsorder \u00fcbernommen. Beispiel protected override void OnInit() { // Setzt einen Trailing Stop von 30 Ticks SetUpTrailStop(CalculationMode.Price, Low[0]); } StrategyOrderParameters Beschreibung Diese Klasse aggregiert alle Eigenschaften, die zum \u00dcbergeben der Bestellung ben\u00f6tigt werden. Siehe SubmitOrder() , CloseLongTrade() , CloseShortTrade() . Verwendung public class StrategyOrderParameters { public OrderDirection Direction { get; set; } public OrderMode Mode { get; set; } = OrderMode.Direct; public OrderType Type { get; set; } public bool LiveUntilCancelled { get; set; } public int Quantity { get; set; } public double Price { get; set; } public double StopPrice { get; set; } public string SignalName { get; set; } = String.Empty; public IInstrument Instrument { get; set; } public ITimeFrame TimeFrame { get; set; } public string FromEntrySignal { get; set; } = String.Empty; } Parameter OrderDirection M\u00f6gliche Werte sind: OrderDirection.Buy Kauforder zum Long-Einstieg; OrderDirection.Sell Verkaufsorder zum Schlie\u00dfen einer Long-Position; OrderMode One of three possible positions in the market: Direct, Dynamic, Synthetic OrderType M\u00f6gliche Werte sind: OrderType.Limit, OrderType.Market, OrderType.Stop, OrderType.StopLimit LiveUntilCancelled Die Order wird nicht am Ende des Bars gel\u00f6scht, sondern bleibt so lange aktiv, bis sie mit Order.Cancel gel\u00f6scht wird, bzw. bis ihre Ablaufzeit (siehe TimeInForce ) erreicht ist. Quantity St\u00fcckzahl Price Limit-Kurs. Die Angabe einer 0 (Null) bedeutet, dass dieser Parameter irrelevant ist. StopPrice Stop-Kurs. Die Angabe einer 0 (Null) bedeutet, dass dieser Parameter irrelevant ist SignalName Ein eindeutiger Signalname (string) Instrument Das Handelsinstrument, in welchem die Position besteht. TimeFrame T Der TimeFrame, der f\u00fcr die Order g\u00fcltig ist. FromEntrySignal Der Name eines Einstiegssignals, f\u00fcr das eine Trail-Stoporder generiert werden soll. Die St\u00fcckzahl wird nur aus der angegebenen Einstiegsorder \u00fcbernommen. SubmitOrder() Beschreibung SubmitOrder erzeugt eine benutzerdefinierte Order. F\u00fcr diese Order wird kein Stop und kein Limit in den Markt gelegt. Alle Kontrollmechanismen von AgenaTrader sind f\u00fcr diese Orderart abgeschaltet. Der Nutzer ist f\u00fcr die Verwaltung, Stop, Target und f\u00fcr die Behandlung von Teilausf\u00fchrungen selbst verantwortlich und kann sich ein Ordermanagement nach seinen eigenen W\u00fcnschen selbst erstellen. Siehe auch OnOrderChanged() , OnOrderExecution() . Verwendung Siehe StrategyOrderParameters Parameter Siehe StrategyOrderParameters R\u00fcckgabewert an order object of the type \"IOrder\" Beispiel // Limit Long order Submit Limit Buy var order = SubmitOrder(new StrategyOrderParameters { Direction = OrderDirection.Buy, Type = OrderType.Limit, Mode = orderMode, Price = limitPrice, Quantity = quantity, SignalName = entryName, Instrument = Instrument, TimeFrame = TimeFrame, LiveUntilCancelled = true }); // Short Market order Submit Sell Market var order = SubmitOrder(new StrategyOrderParameters { Direction = OrderDirection.Sell, Type = OrderType.Market, Mode = ordermode, Quantity = quantity, SignalName = entryName, Instrument = Instrument, TimeFrame = TimeFrame }); TimeInForce Beschreibung Die Eigenschaft TimeInForce bestimmt die G\u00fcltigkeitsdauer einer Order. Die G\u00fcltigkeitsdauer ist davon abh\u00e4ngig, welche Werte von einem Broker akzeptiert werden. TimeInForce wird in der OnInit() Methode angegeben. M\u00f6gliche Werte sind: TimeInForce.day TimeInForce.loc TimeInForce.gtc (GTC = good till canceled) TimeInForce.gtd Default: TimeInForce.GTC Verwendung TimeInForce Beispiel protected override void OnInit() { TimeInForce = TimeInForce.Day; } Trade Beschreibung Trade ist ein Objekt, welches Informationen zu einem Trade enth\u00e4lt, der von einer Strategie ausgef\u00fchrt wurde bzw. der aktuell l\u00e4uft. Die einzelnen Eigenschaften sind: Trade.AvgPrice durchschnittlicher Einstiegskurs Trade.ClosedProfitLoss bereits realisierter Gewinn bzw. Verlust Trade.Commission Geb\u00fchren (Kommissionen) Trade.CreatedDateTime Zeitpunkt der Er\u00f6ffnung eines Trades Trade.EntryReason Bezeichnung des Einstiegssignals bei Strategien: Name der Strategie Trade.ExitDateTime Zeitpunkt, an dem der Trade geschlossen wurde Trade.ExitPrice Ausstiegskurs Trade.ExitReason Bezeichnung des Ausstiegssignals bei Strategien: Name der Strategie Trade.Instrument Bezeichnung des Handelsinstrumentes Trade.PositionType Positionierung im Markt PositionType.Flat PositionType.Long PositionType.Short Trade.OpenProfitLoss noch unrealisierter Gewinn bzw. Verlust in einer laufenden Position Trade.ProfitCurrency Gewinn bzw. Verlust in der W\u00e4hrung, in der das Handelskonto gef\u00fchrt wird Trade.ProfitLoss Gewinn bzw. Verlust Trade.ProfitPercent Gewinn bzw. Verlust in Prozent Trade.ProfitPercentWithCommission Gewinn bzw. Verlust in Prozent mit Geb\u00fchren Trade.ProfitPoints Gewinn bzw. Verlust in Punkten bzw. Pips Trade.Quantity St\u00fcckzahl von Aktien, CFD, Kontrakten usw. Trade.TimeFrame Zeiteinheit, in der der Trade er\u00f6ffnet wurde Trade.Url URL zum Snapshot des Charts zum Zeitpunkt der Er\u00f6ffnung Beispiel protected override void OnDispose() { foreach (ITrade trade in Performance.AllTrades) { ITrade trade = tradeState.Trade; if (trade == null) continue; Print(\"Trade #\"+trade.Id); Print(\"--------------------------------------------\"); Print(\"Durchschnittspreis \" + trade.AvgPrice); Print(\"realisierter G/V \" + trade.ClosedProfitLoss); Print(\"Geb\u00fchren \" + trade.Commission); Print(\"Zeitpunkt Einstieg \" + trade.CreatedDateTime); Print(\"Bezeichnung Einst \" + trade.EntryReason); Print(\"Zeitpunkt Ausstieg \" + trade.ExitDateTime); Print(\"Ausstiegskurs \" + trade.ExitPrice); Print(\"Bezeichnung Ausstieg \" + trade.ExitReason); Print(\"Instrument \" + trade.Instrument); Print(\"Positionierung \" + trade.PositionType); Print(\"unrealisierter G/V \" + trade.OpenProfitLoss); Print(\"G/V (W\u00e4hrung) \" + trade.ProfitCurrency); Print(\"G/V \" + trade.ProfitLoss); Print(\"G/V (in Prozent) \" + trade.ProfitPercent); Print(\"G/V (in % mit Geb\u00fchren)\" + trade.ProfitPercentWithCommission); Print(\"GV (in Punkten) \" + trade.ProfitPoints); Print(\"St\u00fcckzahl \" + trade.Quantity); Print(\"Zeiteinheit \" + trade.TimeFrame); Print(\"URL zum Snapshot \" + trade.Url); } } Unmanaged Backtesting and Optimization Performance Characteristics Unter Performance-Kennzahlen werden verschiedene Kennzahlen verstanden, die jeweils f\u00fcr eine Liste von Trades berechnet werden k\u00f6nnen. Die Trades k\u00f6nnen von einer Strategie in Realtime generiert worden sein oder von einem Backtestlauf stammen. Es stehen folgende Listen zur Verf\u00fcgung: alle trades alle long trades alle short trades alle winning trades alle losing trades Siehe hierzu Performance . Die einzelnen Kennzahlen sind: AvgEtd der durchschnittliche DrawDown am Ende eines Trades (avg end trade drawdown) <TradeCollection>.TradesPerformance.<TradesPerformanceValues>.AvgEtd Print(\"Average ETD of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.AvgEtd); AvgMae der durchschnittliche max. Kursr\u00fcckgang nach den Einstiegen (avg maximum adverse excursion) <TradeCollection>.TradesPerformance.<TradesPerformanceValues>.AvgMae Print(\"Average MAE of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.AvgMae); AvgMfe der durchschnittliche max Kursanstieg im Verlauf der Trades (avg maximum favorable excursion) <TradeCollection>.TradesPerformance.<TradesPerformanceValues>.AvgMfe Print(\"Average MFE of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.AvgMfe); AvgProfit der durchschnittliche Gewinn \u00fcber alle Trades (avg profit) <TradeCollection>.TradesPerformance.<TradesPerformanceValues>.AvgProfit Print(\"Average profit of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.AvgProfit); CumProfit der Gesamtgewinn \u00fcber alle Trades <TradeCollection>.TradesPerformance.<TradesPerformanceValues>.CumProfit Print(\"Average cumulative profit of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.CumProfit); DrawDown der DrawDown \u00fcber alle Trades <TradeCollection>.TradesPerformance.<TradesPerformanceValues>.DrawDow Print(\"Drawdown of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.DrawDown); LargestLoser der gr\u00f6\u00dfte Verlust <TradeCollection>.TradesPerformance.<TradesPerformanceValues>.LargestLoser Print(\"Largest loss of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.LargestLoser); LargestWinner der gr\u00f6\u00dfte Gewinn <TradeCollection>.TradesPerformance.<TradesPerformanceValues>.LargestWinner Print(\"Largest win of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.LargestWinner); ProfitPerMonth hochgerechneter Gewinn/Verlust im Monat (auch in Prozent) <TradeCollection>.TradesPerformance.<TradesPerformanceValues>.ProfitPerMonth Print(\"Profit per month of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.ProfitPerMonth); StdDev die Standardabweichung der Gewinne bzw. Verluste. Hier k\u00f6nnen Ausrei\u00dfer erkannt werden. Je besser ein Handelssystem ist, desto kleiner ist die Standardabweichung und desto h\u00f6her ist die Erwartung von Gewinnen. Alle Kennzahlen sind double-Werte.","title":"Strategieprogrammierung"},{"location":"strategieprogrammierung/#strategieprogrammierung","text":"","title":"Strategieprogrammierung"},{"location":"strategieprogrammierung/#account","text":"","title":"Account"},{"location":"strategieprogrammierung/#beschreibung","text":"Account ist ein Objekt, welches Informationen zu dem Konto enth\u00e4lt, mit dem die aktuelle Strategie arbeitet. Die einzelnen Eigenschaften sind: Account.AccountConnection Name der verwendeten Brokerverbindung (der Name, der unter Kontoverbindungen vergeben wurde). Account.AccountType Art des Kontos (Livokonto, Simkonto usw.) Account.Broker Bezeichnung des Brokers Account.BuyingPower Der Kontostand unter Ber\u00fccksichtigung des vom Broker gew\u00e4hrten Hebels.(IB hebelt das Kontoguthaben z.B. aktuell mit 4. Ein Guthaben von 10.000 Euro hat so eine \"Kaufkraft\" von 40.000 Euro. Account.CashValue Betrag (double) Account.Currency W\u00e4hrung, in der das Konto gef\u00fchrt wird Account.ExcessEquity \u00dcberschuss Account.InitialMargin Initial Margin (abh. vom jeweiligen Broker, double) Account.InstrumentType Art des Handelsinstrumentes (Typ AgenaTrader.Plugins.InstrumentTypes) Account.IsDemo true, wenn es sich um ein Demokonto handelt Account.Name Name des Kontos (i.d.R. mit Account. AccountConnection identisch) Account.OverNightMargin \u00dcbernacht-Margin (abh. vom jeweiligen Broker, double) Account.RealizedProfitLoss realisierter Gewinn bzw. Verlust (double)","title":"Beschreibung"},{"location":"strategieprogrammierung/#beispiel","text":"Print(\"AccountConnection \" + Account.AccountConnection); Print(\"AccountType \" + Account.AccountType); Print(\"Broker \" + Account.Broker); Print(\"BuyingPower \" + Account.BuyingPower); Print(\"CashValue \" + Account.CashValue); Print(\"Currency \" + Account.Currency); Print(\"ExcessEquity \" + Account.ExcessEquity); Print(\"InitialMargin \" + Account.InitialMargin); Print(\"InstrumentTypes \" + Account.InstrumentTypes); Print(\"IsDemo \" + Account.IsDemo); Print(\"Name \" + Account.Name); Print(\"OverNightMargin \" + Account.OverNightMargin); Print(\"RealizedProfitLoss \" + Account.RealizedProfitLoss);","title":"Beispiel"},{"location":"strategieprogrammierung/#barscountfromtradeclose","text":"","title":"BarsCountFromTradeClose()"},{"location":"strategieprogrammierung/#beschreibung_1","text":"Die Eigenschaft \"BarsCountFromTradeClose\" liefert die Anzahl der Bars, die seit dem letzten Ausstieg (Exit) aus dem Markt vergangen sind.","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung","text":"BarsCountFromTradeClose() BarsCountFromTradeClose(string strategyName) F\u00fcr Multibar-Strategieen BarsCountFromTradeClose(int multibarSeriesIndex, string strategyName, int exitsAgo)","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter","text":"strategyName Der Signalname (string), der in einer Ausstiegsmethode zur eindeutigen Kennzeichnung des Ausstiegs vergeben wurde multibarSeriesIndex F\u00fcr * Multibar* MultiBars Strategieen. Index der Datenreihe, f\u00fcr die die Ausstiegsorder ausgef\u00fchrt wurde. Siehe ProcessingBarSeriesIndex . exitsAgo Anzahl der in der Vergangenheit liegenden Ausstiege. Eine 0 (Null) an dieser Stelle liefert die Anzahl der Bars, die sich nach dem letzten Ausstieg ausgebildet haben.","title":"Parameter"},{"location":"strategieprogrammierung/#beispiel_1","text":"Print(\"Der letzte Ausstieg liegt \" + BarsCountFromTradeClose() + \" Bars zur\u00fcck.\");","title":"Beispiel"},{"location":"strategieprogrammierung/#barscountfromtradeopen","text":"","title":"BarsCountFromTradeOpen()"},{"location":"strategieprogrammierung/#beschreibung_2","text":"Die Eigenschaft \"BarsCountFromTradeOpen\" liefert die Anzahl der Bars, die seit dem letzten Einstieg (Entry) in den Markt vergangen sind.","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_1","text":"BarsCountFromTradeOpen() BarsCountFromTradeOpen(string strategyName) F\u00fcr Multibar-Strategieen BarsCountFromTradeOpen(int multibarSeriesIndex, string strategyName, int entriesAgo)","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter_1","text":"strategyName Der Signalname (string), der in einer Einstiegsmethode zur eindeutigen Kennzeichnung des Einstiegs vergeben wurde. multibarSeriesIndex F\u00fcr * Multibar* , MultiBars Strategieen.Index der Datenreihe, f\u00fcr die die Einstiegsorder ausgef\u00fchrt wurde. Siehe ProcessingBarSeriesIndex , ProcessingBarSeriesIndex . entriesAgo Anzahl der in der Vergangenheit liegenden Einstiege. Eine 0 (Null) an dieser Stelle liefert die Anzahl der Bars, die sich nach dem letzten Einstieg ausgebildet haben.","title":"Parameter"},{"location":"strategieprogrammierung/#beispiel_2","text":"Print(\"Der letzte Einstieg liegt \" + BarsCountFromTradeOpen() + \" Bars zur\u00fcck.\");","title":"Beispiel"},{"location":"strategieprogrammierung/#cancelallorders","text":"","title":"CancelAllOrders()"},{"location":"strategieprogrammierung/#beschreibung_3","text":"CancelAllOrders l\u00f6scht alle Oders (cancel), die von der Strategie verwaltet werden. Es wird ein Cancel-Request an den Broker verschickt. Ob eine Oder dort wirklich gel\u00f6scht wird, kann nicht garantiert werden. Es kann vorkommen, dass eine Order eine Teilausf\u00fchrung erhalten hat, ehe sie gel\u00f6scht wird. Es ist daher ratsam, den jeweils aktuellen Status einer Order mit OnOrderChanged() zu kontrollieren.","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_2","text":"CancelAllOrders()","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter_2","text":"kein Parameter","title":"Parameter"},{"location":"strategieprogrammierung/#beispiel_3","text":"protected override void OnCalculate() { if (BarsCountFromTradeOpen() >= 30) CancelAllOrders(); }","title":"Beispiel"},{"location":"strategieprogrammierung/#ordercancel","text":"","title":"Order.Cancel()"},{"location":"strategieprogrammierung/#beschreibung_4","text":"Cancel order l\u00f6scht eine Oder (cancel). Es wird ein Cancel-Request an den Broker verschickt. Ob eine Oder dort wirklich gel\u00f6scht wird, kann nicht garantiert werden. Es kann vorkommen, dass eine Order eine Teilausf\u00fchrung erhalten hat, ehe sie gel\u00f6scht wird. Es ist daher ratsam, den jeweils aktuellen Status einer Order mit OnOrderChanged() zu kontrollieren.","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_3","text":"Order.Cancel(IOrder order)","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter_3","text":"Ein order-Objekt vom Typ IOrder","title":"Parameter"},{"location":"strategieprogrammierung/#beispiel_4","text":"private IOrder entryOrder = null; private int barNumber = 0; protected override void OnCalculate() { // An das Hoch des aktuellen Bars einen Einstiegsstop legen if (entryOrder == null) { entryOrder = OpenLongStop(High[0], \"stop long\"); barNumber = ProcessingBarIndex; } // Nach 3 Bars die Order l\u00f6schen if (Position.PositionType == PositionType.Flat && ProcessingBarIndex > barNumber + 3) Order.Cancel(entryOrder); }","title":"Beispiel"},{"location":"strategieprogrammierung/#createifdonegroup","text":"","title":"CreateIfDoneGroup()"},{"location":"strategieprogrammierung/#beschreibung_5","text":"Wenn zwei Orders \u00fcber eine CreateIfDoneGroup miteinander verkn\u00fcpft werden, so bedeutet dies, dass wenn die eine Order ausgef\u00fchrt wurde, die zweite verbundene Order aktiviert wird.","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_4","text":"CreateIfDoneGroup(IEnumerable<IOrder> orders)","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter_4","text":"Ein order-Objekt vom Typ IOrder als List","title":"Parameter"},{"location":"strategieprogrammierung/#beispiel_5","text":"private IOrder oopenlong = null; private IOrder osubmitbuy = null; protected override void OnInit() { IsAutoConfirmOrder = false; } protected override void OnCalculate() { oopenlong = SubmitOrder(new StrategyOrderParameters { Direction = OrderDirection.Buy, Type = OrderType.Market, Quantity = DefaultOrderQuantity, SignalName = \"strategyName\", }); osubmitbuy = SubmitOrder(new StrategyOrderParameters { Direction = OrderDirection.Sell, Type = OrderType.Stop, Quantity = DefaultOrderQuantity, StopPrice = Close[0] * 1.1, SignalName = \"strategyName\", }); CreateIfDoneGroup(new List<IOrder> { oopenlong, osubmitbuy }); oopenlong.ConfirmOrder(); }","title":"Beispiel"},{"location":"strategieprogrammierung/#createocogroup","text":"","title":"CreateOCOGroup()"},{"location":"strategieprogrammierung/#beschreibung_6","text":"Wenn zwei Orders \u00fcber eine CreateOCOGroup miteinander verkn\u00fcpft werden, so bedeutet dies, dass sobald die eine Order ausgef\u00fchrt wurde, die zweite verbundene Order gel\u00f6scht wird.","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_5","text":"CreateOCOGroup(IEnumerable<IOrder> orders)","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter_5","text":"Ein order-Objekt vom Typ IOrder als List","title":"Parameter"},{"location":"strategieprogrammierung/#beispiel_6","text":"private IOrder oopenlong = null; private IOrder oEnterShort = null; protected override void OnInit() { IsAutoConfirmOrder = false; } protected override void OnCalculate() { oopenlong = SubmitOrder(new StrategyOrderParameters { Direction = OrderDirection.Buy, Type = OrderType.Stop, Quantity = DefaultOrderQuantity, StopPrice = Close[0] * 1.1, SignalName = \"strategyName\", }); oEnterShort = SubmitOrder(new StrategyOrderParameters { Direction = OrderDirection.Sell, Type = OrderType.Stop, Quantity = DefaultOrderQuantity, StopPrice = Close[0] * -1.1, SignalName = \"strategyName\", }); CreateOCOGroup(new List<IOrder> { oopenlong, oEnterShort }); oopenlong.ConfirmOrder(); oEnterShort.ConfirmOrder(); }","title":"Beispiel"},{"location":"strategieprogrammierung/#createorogroup","text":"","title":"CreateOROGroup()"},{"location":"strategieprogrammierung/#beschreibung_7","text":"Wenn zwei Orders \u00fcber eine CreateOROGroup miteinander verkn\u00fcpft werden, so bedeutet dies, dass sobald die eine Order ausgef\u00fchrt wurde, die Ordergr\u00f6\u00dfe der zweiten Order um das Ordervolumen der ersten Order reduziert wird.","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_6","text":"CreateOROGroup(IEnumerable<IOrder> orders)","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter_6","text":"Ein order-Objekt vom Typ IOrder","title":"Parameter"},{"location":"strategieprogrammierung/#beispiel_7","text":"private IOrder oStopLong = null; private IOrder oLimitLong = null; protected override void OnInit() { IsAutoConfirmOrder = false; } protected override void OnCalculate() { oStopLong = SubmitOrder(new StrategyOrderParameters { Direction = OrderDirection.Buy, Type = OrderType.Stop, Quantity = DefaultOrderQuantity, StopPrice = Close[0] * -1.1, SignalName = \"strategyName\", }); oLimitLong = SubmitOrder(new StrategyOrderParameters { Direction = OrderDirection.Buy, Type = OrderType.Limit, Quantity = DefaultOrderQuantity*0.5, Price = Close[0] * 1.1, SignalName = \"strategyName\", }); CreateOROGroup(new List<IOrder> { oLimitLong, oStopLong }); }","title":"Beispiel"},{"location":"strategieprogrammierung/#dataseriesconfigurable","text":"","title":"DataSeriesConfigurable"},{"location":"strategieprogrammierung/#defaultorderquantity","text":"","title":"DefaultOrderQuantity"},{"location":"strategieprogrammierung/#beschreibung_8","text":"DefaultQuantity legt die in einer Strategie zu verwendende St\u00fcckzahl fest. DefaultQuantity wird in der OnInit() -Methode angegeben.","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_7","text":"ReplaceOrder(IOrder iOrder, int quantity, double limitPrice, double stopPrice)","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter_7","text":"ein int-Wert, der die St\u00fcckzahn (Aktien, Kontrakte usw.) enth\u00e4lt","title":"Parameter"},{"location":"strategieprogrammierung/#beispiel_8","text":"protected override void OnInit() { DefaultOrderQuantity = 100; }","title":"Beispiel"},{"location":"strategieprogrammierung/#excludetradehistoryinbacktest","text":"","title":"ExcludeTradeHistoryInBacktest"},{"location":"strategieprogrammierung/#closelongtrade","text":"","title":"CloseLongTrade()"},{"location":"strategieprogrammierung/#beschreibung_9","text":"CloseLongTrade erzeugt eine Sell-Order um eine Long Position zu schlie\u00dfen (zu verkaufen). Siehe auch: SubmitOrder() , CloseShortTrade()","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_8","text":"Siehe StrategyOrderParameters","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter_8","text":"Siehe StrategyOrderParameters","title":"Parameter"},{"location":"strategieprogrammierung/#return-value","text":"ein order-Objekt vom Typ IOrder","title":"Return Value"},{"location":"strategieprogrammierung/#beispiel_9","text":"var order = CloseLongTrade(new StrategyOrderParameters { Type = OrderType.Market });","title":"Beispiel"},{"location":"strategieprogrammierung/#exitonclose","text":"","title":"ExitOnClose"},{"location":"strategieprogrammierung/#exitoncloseseconds","text":"","title":"ExitOnCloseSeconds"},{"location":"strategieprogrammierung/#closeshorttrade","text":"","title":"CloseShortTrade()"},{"location":"strategieprogrammierung/#beschreibung_10","text":"CloseShortTrade erzeugt eine Buy-to-Cover Order um eine Short Position zu schlie\u00dfen (zu kaufen). Siehe auch: SubmitOrder() , CloselongTrade()","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_9","text":"Siehe StrategyOrderParameters","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter_9","text":"Siehe StrategyOrderParameters","title":"Parameter"},{"location":"strategieprogrammierung/#ruckgabewert","text":"ein order-Objekt vom Typ IOrder","title":"R\u00fcckgabewert"},{"location":"strategieprogrammierung/#example","text":"var order = CloseShortTrade(new StrategyOrderParameters { Type = OrderType.Stop, Quantity = quantity, StopPrice = price });","title":"Example"},{"location":"strategieprogrammierung/#accountgetvalue","text":"","title":"Account.GetValue()"},{"location":"strategieprogrammierung/#beschreibung_11","text":"Account.GetValue() liefert Informationen \u00fcber das Konto, f\u00fcr das die Strategie ausgef\u00fchrt wird. Siehe auch GetProfitLoss() .","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_10","text":"Account.GetValue(AccountItem accountItem)","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter_10","text":"M\u00f6gliche Werte f\u00fcr accountItem sind AccountItem.BuyingPower AccountItem.CashValue AccountItem.RealizedProfitLoss","title":"Parameter"},{"location":"strategieprogrammierung/#ruckgabewert_1","text":"ein double-Wert f\u00fcr das jeweilige AccountItem, F\u00fcr historische Bars wird eine 0 (Null) zur\u00fcckgegeben.","title":"R\u00fcckgabewert"},{"location":"strategieprogrammierung/#beispiel_10","text":"Print(\"The current account cash value is \" + Account.GetValue(AccountItem.CashValue)); Print(\"The current account cash value with the leverage provided by the broker is \" + Account.GetValue(AccountItem.BuyingPower)); Print(\"The current P/L already realized is \" + Account.GetValue(AccountItem.RealizedProfitLoss));","title":"Beispiel"},{"location":"strategieprogrammierung/#getentries","text":"","title":"GetEntries()"},{"location":"strategieprogrammierung/#beschreibung_12","text":"Diese Datenserie wird f\u00fcr Conditions verwendet und zeigt mehrfache Einstiegspreise f\u00fcr Einstiegsorders an.","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_11","text":"\u00dcberladung von programmierten Conditions f\u00fcr eine Short und Long Signal Anzeige.","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter_11","text":"None","title":"Parameter"},{"location":"strategieprogrammierung/#ruckgabewert_2","text":"int","title":"R\u00fcckgabewert"},{"location":"strategieprogrammierung/#beispiel_11","text":"public class MyTestEntry : UserScriptedCondition { double _percentage = 100; protected override void Initialize() { IsEntry = true; IsStop = false; IsTarget= false; Add(new OutputDescriptor(Color.FromKnownColor(KnownColor.Black), \"Occurred\")); Add(new OutputDescriptor(Color.FromArgb(255, 118, 222, 90), \"Entry1\")); Add(new OutputDescriptor(Color.FromArgb(255, 118, 222, 90), \"Entry2\")); Add(new OutputDescriptor(Color.FromArgb(255, 118, 222, 90), \"Entry3\")); Overlay = true; CalculateOnBarClose = true; } protected override void OnBarUpdate() { Calculate(); } public override void Recalculate() { Calculate(); } private void Calculate () { if (TradeDirection == PositionType.Long) { Entry1.Set(Close[0] + 0.5); Entry2.Set(Close[0] + 1); Entry3.Set(Close[0] + 1.5); } else { Entry1.Set(Close[0] - 0.5); Entry2.Set(Close[0] - 1); Entry3.Set(Close[0] - 1.5); } } #region Properties [Browsable(false)] [XmlIgnore()] public DataSeries Occurred { get { return Values[0]; } } [Browsable(false)] [XmlIgnore()] public DataSeries Entry1 { get { return Values[1]; } } [Browsable(false)] [XmlIgnore()] public DataSeries Entry2 { get { return Values[2]; } } [Browsable(false)] [XmlIgnore()] public DataSeries Entry3 { get { return Values[3]; } } public override IList<DataSeries> GetEntrys() { return new[] { Entry1, Entry2, Entry3 };","title":"Beispiel"},{"location":"strategieprogrammierung/#getprofitloss","text":"","title":"GetProfitLoss()"},{"location":"strategieprogrammierung/#beschreibung_13","text":"GetProfitLoss() liefert den aktuell unrealisierten Gewinn bzw. Verlust einer laufenden Position. Siehe auch Account.GetValue() .","title":"Beschreibung"},{"location":"strategieprogrammierung/#usage","text":"GetProfitLoss(int pLType);","title":"Usage"},{"location":"strategieprogrammierung/#verwendung_12","text":"M\u00f6gliche Werte f\u00fcr pLType sind 0 - Amount, P/L als W\u00e4hrungsbetrag 1 - Percent, P/L in Prozent 2 \u2013 Risk, P/L in Van Tharp R-Multiples www.vantharp.com 3 \u2013 P/L in Ticks","title":"Verwendung"},{"location":"strategieprogrammierung/#ruckgabewert_3","text":"ein double-Wert f\u00fcr den unrealisierten Gewinn bzw. Verlust","title":"R\u00fcckgabewert"},{"location":"strategieprogrammierung/#beispiel_12","text":"Print(\"The current risk for the strategy \" + this.Name + \" is \" + GetProfitLoss(1) + \" \" + Instrument.Currency); Print(\"This equals \"+ string.Format( \"{0:F1} R.\", GetProfitLoss(3)));","title":"Beispiel"},{"location":"strategieprogrammierung/#getprofitlossamount","text":"","title":"GetProfitLossAmount()"},{"location":"strategieprogrammierung/#beschreibung_14","text":"GetProfitLossAmount() liefert den aktuell unrealisierten Gewinn bzw. Verlust einer laufenden Position als W\u00e4hrungsbetrag. Siehe auch Account.GetValue() .","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_13","text":"GetProfitLossAmount(double profitLoss);","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter_12","text":"Ein Objekt vom Typ double","title":"Parameter"},{"location":"strategieprogrammierung/#ruckgabewert_4","text":"ein double-Wert f\u00fcr den unrealisierten Gewinn bzw. Verlust","title":"R\u00fcckgabewert"},{"location":"strategieprogrammierung/#beispiel_13","text":"Print(\"the current P&L \" + this.Name + \" is \" + GetProfitLossAmount(Position.OpenProfitLoss) + \" \" + Instrument.Currency);","title":"Beispiel"},{"location":"strategieprogrammierung/#getprofitlossrisk","text":"","title":"GetProfitLossRisk()"},{"location":"strategieprogrammierung/#beschreibung_15","text":"GetProfitLossRisk() liefert den aktuell unrealisierten Gewinn bzw. Verlust einer laufenden Position in R-Multiplen. Siehe auch Account.GetValue() .","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_14","text":"GetProfitLossRisk();","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter_13","text":"keine","title":"Parameter"},{"location":"strategieprogrammierung/#ruckgabewert_5","text":"ein double-Wert f\u00fcr denie R-Multiple","title":"R\u00fcckgabewert"},{"location":"strategieprogrammierung/#beispiel_14","text":"Print(\"the current P&L \" + this.Name + \" is \" + string.Format( \"{0:F1} R.\", GetProfitLossRisk()));","title":"Beispiel"},{"location":"strategieprogrammierung/#getscriptedcondition","text":"","title":"GetScriptedCondition()"},{"location":"strategieprogrammierung/#beschreibung_16","text":"Mit dieser Methode k\u00f6nnen Benutzer zwischen Skripte zu kommunizieren.","title":"Beschreibung"},{"location":"strategieprogrammierung/#isautoconfirmorder","text":"","title":"IsAutoConfirmOrder"},{"location":"strategieprogrammierung/#beschreibung_17","text":"IsAutoConfirmOrder legt fest ob Orders automatisch aktiviert werden. IsAutoConfirmOrder wird in der OnInit() -Methode angegeben. Ist IsAutoConfirmOrder = true, dann werden Orders automatisch aktiviert (Default). Wenn IsAutoConfirmOrder der Wert false zugewiesen wurde, dann muss die entsprechende Order mit order. ConfirmOrder() aktiviert werden.","title":"Beschreibung"},{"location":"strategieprogrammierung/#parameter_14","text":"ein bool-Wert","title":"Parameter"},{"location":"strategieprogrammierung/#beispiel_15","text":"protected override void OnInit() { IsAutoConfirmOrder = false; }","title":"Beispiel"},{"location":"strategieprogrammierung/#order","text":"","title":"Order"},{"location":"strategieprogrammierung/#beschreibung_18","text":"IOrder ist ein Objekt, welches Informationen zu einer Order enth\u00e4lt, die aktuell von einer Strategie verwaltet wird. Die einzelnen Eigenschaften sind: Action Eine der vier m\u00f6glichen Aktionen: OrderDirection.Buy OrderDirection.Sell AveragePrice Der durchschnittliche Kauf- bzw. Verkaufspreis einer Position. Bei Positionen ohne Teilausf\u00fchrungen entspricht dies dem Einstiegskurs. FilledQuantity Bei Teilausf\u00fchrungen ist Filled kleiner als Quantity LimitPrice Name Der eindeutige SignalName OrderId Die eindeutige OrderId OrderMode Eines der drei m\u00f6glichen Optionen: OrderMode.Direct OrderMode.Dynamic OrderMode.Synthetic OrderState Hiermit kann der aktuelle Zustand der Order abgefragt werden (siehe OnOrderExecution und OnOrderChanged ) OrderState.Accepted OrderState.Cancelled OrderState.CancelRejected OrderState.FilledQuantity OrderState.PartFilled OrderState.PendingCancel OrderState.PendingReplace OrderState.PendingSubmit OrderState.Rejected OrderState.ReplaceRejected OrderState.Unknown OrderState.Working OrderType M\u00f6gliche Orderarten: OrderType.Limit OrderType.Market OrderType.Stop OrderType.StopLimit Quantity Die zu ordernde St\u00fcckzahl StopPrice Timestamp Zeitstempel TimeFrame Der TimeFrame, der f\u00fcr die Order g\u00fcltig ist. TimeFrame M\u00f6gliche Methoden: order Order.Cancel() L\u00f6scht die Order order.ConfirmOrder() Best\u00e4tig die Order. Diese Methode muss ausgef\u00fchrt werden, wenn IsAutoConfirmOrder auf false gesetzt wird und man die Order dennoch automatisch ausf\u00fchren m\u00f6chte. Dies ist z. B. dann der Fall, wenn eine OCO- oder IfDone-Verk\u00fcpfung hergestellt werden soll.","title":"Beschreibung"},{"location":"strategieprogrammierung/#performance","text":"","title":"Performance"},{"location":"strategieprogrammierung/#beschreibung_19","text":"Performance ist ein Objekt, welches Informationen zu allen Trades enth\u00e4lt, die von einer Strategie generiert wurden. Es gibt mehrere Listen, in denen die Trades eingeordnet sind. Mit Hilfe dieser Listen ist es leicht, weitere Performance-Auswertungen zu erstellen. Siehe Performance-Kennzahlen. Die einzelnen Listen sind: Performance.AllTrades Ist ein Trade Collection Objekt, das alle von einer Strategie generierten Trades enth\u00e4lt. Performance.LongTrades Ist ein Trade Collection Objekt, das alle von einer Strategie generierten Long-Trades enth\u00e4lt. Performance.ShortTrades Ist ein Trade Collection Objekt, das alle von einer Strategie generierten ShortTrades enth\u00e4lt. Performance.WinningTrades Ist ein Trade Collection Objekt, das alle von einer Strategie generierten Gewinntrades enth\u00e4lt. Performance.LosingTrades Ist ein Trade Collection Objekt, das alle von einer Strategie generierten Verlusttrades enth\u00e4lt.","title":"Beschreibung"},{"location":"strategieprogrammierung/#beispiel_16","text":"// beim Verlassen der Strategie eine Auswertung erstellen protected override void OnDispose() { Print(\"Performance evaluation of the strategy : \" + this.Name); Print(\"----------------------------------------------------\"); Print(\"Amount of all trades: \" + Performance.AllTrades.Count); Print(\"Amount of winning trades: \" + Performance.WinningTrades.Count); Print(\"Amount of all loss trades: \" + Performance.LosingTrades.Count); Print(\"Amount of all long trades: \" + Performance.LongTrades.Count); Print(\"Amount of short trades: \" + Performance.ShortTrades.Count); Print(\"Result: \" + Account.RealizedProfitLoss + \" \" + Account.Currency); }","title":"Beispiel"},{"location":"strategieprogrammierung/#position","text":"","title":"Position"},{"location":"strategieprogrammierung/#beschreibung_20","text":"Position ist ein Objekt, welches Informationen zu einer Position enth\u00e4lt, die aktuell von einer Strategie verwaltet wird. Die einzelnen Eigenschaften sind: Position.AvgPrice Der durchschnittliche Kauf- bzw. Verkaufspreis einer Position. Bei Positionen ohne Teilausf\u00fchrungen entspricht dies dem Einstiegskurs. Position.CreatedDateTime Datum und Uhrzeit der Positionser\u00f6ffnung. Position.Instrument Das Handelsinstrument, in welchem die Position besteht. siehe auch Instruments . Position.PositionType Eines der drei m\u00f6glichen Positionierungen im Markt: PositionType.Flat PositionType.Long PositionType.Short Position.OpenProfitLoss Der aktuell noch unrealisierte Gewinn bzw. Verlust. siehe auch GetProfitLoss() . Position.ProfitCurrency Gewinn (bzw. Verlust) ausgewiesen als W\u00e4hrungsbetrag. Position.ProfitPercent Gewinn (bzw. Verlust) ausgewiesen in Prozent. Position.ProfitPoints Gewinn (bzw. Verlust) ausgewiesen in Punkten bzw. Pips. Position.Quantity St\u00fcckzahl der Aktien, Kontrakte, CFD's o.\u00e4. in der Position.","title":"Beschreibung"},{"location":"strategieprogrammierung/#beispiel_17","text":"if (Position.PositionType != PositionType.Flat) { Print(\"Average price \" + Position.AvgPrice); Print(\"Opening time \" + Position.CreatedDateTime); Print(\"Instrument \" + Position.Instrument); Print(\"Current positioning \" + Position.PositionType); Print(\"Unrealized P/L \" + Position.OpenProfitLoss); Print(\"P/L (currency) \" + Position.ProfitCurrency); Print(\"P/L (in percent) \" + Position.ProfitPercent); Print(\"P/L (in points) \" + Position.ProfitPoints); Print(\"Pieces \" + Position.Quantity); }","title":"Beispiel"},{"location":"strategieprogrammierung/#positiontype","text":"Siehe Position.PositionType .","title":"PositionType"},{"location":"strategieprogrammierung/#traceorders","text":"","title":"TraceOrders"},{"location":"strategieprogrammierung/#beschreibung_21","text":"Die Eigenschaft TraceOrders ist sehr n\u00fctzlich, um Orders, die von Strategien generiert werden, nachzuverfolgen. TraceOrders wird in der OnInit() Methode angegeben. Wenn TraceOrders eingeschaltet ist, werden f\u00fcr jede Order die folgenden Werte im OutputWindow ausgegeben: Instrument Time frame Action Type Limit price Stop price Quantity Name Diese Informationen sind z.B. bei der Erstellung von Strategien und f\u00fcr das Debugging sehr n\u00fctzlich.","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_15","text":"TraceOrders","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter_15","text":"keine","title":"Parameter"},{"location":"strategieprogrammierung/#ruckgabewert_6","text":"true Tracing ist aktuell eingeschaltet false Tracing ist abgeschaltet","title":"R\u00fcckgabewert"},{"location":"strategieprogrammierung/#beispiel_18","text":"protected override void OnInit() { ClearTraceWindow(); TraceOrders = true; }","title":"Beispiel"},{"location":"strategieprogrammierung/#quantity","text":"siehe unter Position.Quantity , Position.PositionType .","title":"Quantity"},{"location":"strategieprogrammierung/#replaceorder","text":"","title":"ReplaceOrder()"},{"location":"strategieprogrammierung/#beschreibung_22","text":"ChangeOrder \u00e4ndert eine Order.","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_16","text":"ReplaceOrder(IOrder iOrder, int quantity, double limitPrice, double stopPrice)","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter_16","text":"iOrder ein Order -Objekt vom Typ IOrder quantity zu ordernde St\u00fcckzahl limitPrice Limitpreis. Wenn nicht ben\u00f6tigt, auf 0 setzen stopPrice Stoppreis. Wenn nicht ben\u00f6tigt, auf 0 setzen","title":"Parameter"},{"location":"strategieprogrammierung/#beispiel_19","text":"private IOrder stopOrder = null; protected override void OnCalculate() { // Wenn die Position 10 Ticks im Gewinn liegt, Stopp auf Einstand anheben if (stopOrder != null && Close[0] >= Position.AvgPrice + (10 * TickSize) && stopOrder.StopPrice < Position.AvgPrice) ReplaceOrder(stopOrder, stopOrder.Quantity, stopOrder.LimitPrice, Position.AvgPrice); }","title":"Beispiel"},{"location":"strategieprogrammierung/#setupprofittarget","text":"","title":"SetUpProfitTarget()"},{"location":"strategieprogrammierung/#beschreibung_23","text":"Serzeugt sofort nach Ausf\u00fchrung einer Einstiegsorder eine Profit Target-Order um eine laufende Position zu einem bestimmten Kurs im Gewinn zu schlie\u00dfen. Die Order wird direkt an den Broker \u00fcbergeben und ist sofort im Markt wirksam. Wenn das Gewinnziel statisch ist, kann SetUpProfitTarget() in der OnInit() Methode angegeben werden. Siehe auch SetUpStopLoss() , SetUpTrailStop() .","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_17","text":"SetUpProfitTarget(double currency) SetUpProfitTarget(CalculationMode mode, double value) SetUpProfitTarget(string fromEntry signal, CalculationMode mode, double value)","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter_17","text":"currency Gibt das Gewinnziel in einer W\u00e4hrung an, z.B. 500,- Euro. mode M\u00f6gliche Werte sind: CalculationMode.Percent (Angabe in Prozent); CalculationMode.Price (Angabe als Kurswert); CalculationMode.Ticks (Angabe in Ticks bzw. Pips) value Ein Wert, der den Abstand zwischen Einstiegskurs und Gewinnziel angibt. Die Angabe bezieht sich abh\u00e4ngig von \"mode\" auf einen Geldbetrag, eine Prozentangabe bzw. auf eine Angabe in Ticks. fromEntry signal Der Name eines Einstiegssignals, f\u00fcr das eine Profit Target-Order generiert werden soll. Die St\u00fcckzahl wird nur aus der angegebenen Einstiegsorder \u00fcbernommen.","title":"Parameter"},{"location":"strategieprogrammierung/#beispiel_20","text":"protected override void OnInit() { // Erzeugt eine Profit Target-Order 10 Ticks \u00fcber Einstand SetUpProfitTarget(CalculationMode.Ticks, 20); }","title":"Beispiel"},{"location":"strategieprogrammierung/#setupstoploss","text":"","title":"SetUpStopLoss()"},{"location":"strategieprogrammierung/#beschreibung_24","text":"Set up stop loss erzeugt sofort nach Ausf\u00fchrung einer Einstiegsorder eine StopLoss-Order um eine laufende Position zu einem bestimmten Kurs zu schlie\u00dfen. Die Order wird direkt an den Broker \u00fcbergeben und ist sofort im Markt wirksam (wenn sie nicht simuliert wird, s.u.). Wenn der StopLoss-Kurs statisch ist, kann SetUpStopLoss() in der OnInit() Methode angegeben werden. Siehe auch SetUpProfitTarget() , SetUpTrailStop() .","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_18","text":"SetUpStopLoss(double currency) SetUpStopLoss(double currency, bool simulated) SetUpStopLoss(CalculationMode mode, double value) SetUpStopLoss(string fromEntry signal, CalculationMode mode, double value, bool simulated)","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter_18","text":"currency Gibt den StopLoss-Abstand zum Einstiegskurs (=Risiko) in einer W\u00e4hrung an, z.B. 500,- Euro. mode M\u00f6gliche Werte sind: CalculationMode.Percent ( Angabe in Prozent); CalculationMode.Price (Angabe als Kurswert); CalculationMode.Ticks (Angabe in Ticks bzw. Pips) simulated Wenn \"simulated\" auf \"true\" gesetzt ist, wird die Stoporder erst dann live (als Marketorder) zum Broker \u00fcbermittelt, wenn der Kurs sie erstmals \"ber\u00fchrt\" hat (d.h wenn sie ausgel\u00f6st werden w\u00fcrde wenn sie im Markt gelegen h\u00e4tte). value Ein Wert, der den Abstand zwischen Einstiegskurs und Stoppkurs angibt. Die Angabe bezieht sich abh\u00e4ngig von \"mode\" auf einen Geldbetrag, eine Prozentangabe bzw. auf eine Angabe in Ticks. fromEntry signal Der Name eines Einstiegssignals, f\u00fcr das eine Stoporder generiert werden soll. Die St\u00fcckzahl wird nur aus der angegebenen Einstiegsorder \u00fcbernommen.","title":"Parameter"},{"location":"strategieprogrammierung/#beispiel_21","text":"protected override void OnInit() { // Sets profitTarget 15 Ticks \u00fcber dem Markt SetUpStopLoss(\"MACDEntry\", CalculationMode.Ticks, 15, true); }","title":"Beispiel"},{"location":"strategieprogrammierung/#setuptrailstop","text":"","title":"SetUpTrailStop()"},{"location":"strategieprogrammierung/#beschreibung_25","text":"SetTrailStop() erzeugt sofort nach Ausf\u00fchrung einer Einstiegsorder eine Trail Stop-Order um eine laufende Position zun\u00e4chst im Verlust zu sch\u00fctzen bzw. nach dem BreakEven den Gewinn zu sichern. Die Order wird direkt an den Broker \u00fcbergeben und ist sofort im Markt wirksam (wenn sie nicht simuliert wird, s.u.). Wenn der StopLoss-Kurs und der Offset-Wert statisch ist, kann SetUpTrailStop() in der OnInit() Methode angegeben werden. Sollte SetUpTrailStop() in der OnCalculate() Methode verwendet werden, um sie dynamisch dem Kursverlauf anpassen zu k\u00f6nnen, ist darauf zu achten, die Parameter vor einer weiteren (neuen) Position auf die gew\u00fcnschten Initialwerte zur\u00fcckzusetzten, da die zuletzt gesetzten Werte ansonsten auch f\u00fcr die neue Position wirksam sind. Funktionsweise: Angenommen es ist SetUpTrailStop(CalculationMode.Ticks, 30) gesetzt: In einer Long-Position wird der Stop nun 30 Ticks vom jeweils letzten erreichten Hoch entfernt gesetzt. Macht der Markt ein neues Hoch, wird der Stop angepasst. Der Stop wird jedoch nicht mehr nach unten ver\u00e4ndert. In einer Shortposition ist das Verhalten analog vom erreichten tiefsten Tief ausgehend. Hinweise: Es ist nicht m\u00f6glich, in einer Strategie f\u00fcr ein und dieselbe SetUpStopLoss und SetUpTrailStop gleichzeitig zu verwenden. Es wird immer SetUpStopLoss() der Vorrang einger\u00e4umt Es ist aber m\u00f6glich, in einer Strategie beide Varianten parallel zu verwenden, wenn sie auf unterschiedliche Einstiegssignale referenzieren Bei Teilausf\u00fchrungen einer einzelnen Order wird f\u00fcr jede Teilposition ein separater Trailing Stop angelegt. Wird zus\u00e4tzlich zu SetUpProfitTarget() auch SetUpTrailStop(), verwendet, werden beide Orders automatisch OCO-verkn\u00fcpft (OCO = one cancels the other) Es wird immer eine Stop-Market oder erzeugt, keine Stop-Limit-Order. Wird die Position innerhalb der Strategie von einer anderen Ausstiegsorder geschlossen, so wird die Trailing-Stoporder automatisch gel\u00f6scht. Siehe auch SetUpStopLoss() , SetUpProfitTarget() .","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_19","text":"SetUpTrailStop(double currency) SetUpTrailStop(double currency, bool simulated) SetUpTrailStop(CalculationMode mode, double value) SetUpTrailStop(string fromEntry signal, CalculationMode mode, double value, bool simulated)","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter_19","text":"currency Gibt den StopLoss-Abstand zum Einstiegskurs (=Risiko) in einer W\u00e4hrung an, z.B. 500,- Euro. mode M\u00f6gliche Werte sind: CalculationMode.Percent; CalculationMode.Ticks simulated Wenn \"simulated\" auf \"true\" gesetzt ist, wird die Trail-Stoporder erst dann live (als Marketorder) zum Broker \u00fcbermittelt, wenn der Kurs sie erstmals \"ber\u00fchrt\" hat (d.h wenn sie ausgel\u00f6st werden w\u00fcrde wenn sie im Markt gelegen h\u00e4tte). value Ein Wert, der den Abstand zwischen Einstiegskurs und Stoppkurs angibt. Die Angabe bezieht sich abh\u00e4ngig von \"mode\" auf einen Geldbetrag, eine Prozentangabe bzw. auf eine Angabe in Ticks. fromEntry signal Der Name eines Einstiegssignals, f\u00fcr das eine Trail-Stoporder generiert werden soll. Die St\u00fcckzahl wird nur aus der angegebenen Einstiegsorder \u00fcbernommen.","title":"Parameter"},{"location":"strategieprogrammierung/#beispiel_22","text":"protected override void OnInit() { // Setzt einen Trailing Stop von 30 Ticks SetUpTrailStop(CalculationMode.Price, Low[0]); }","title":"Beispiel"},{"location":"strategieprogrammierung/#strategyorderparameters","text":"","title":"StrategyOrderParameters"},{"location":"strategieprogrammierung/#beschreibung_26","text":"Diese Klasse aggregiert alle Eigenschaften, die zum \u00dcbergeben der Bestellung ben\u00f6tigt werden. Siehe SubmitOrder() , CloseLongTrade() , CloseShortTrade() .","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_20","text":"public class StrategyOrderParameters { public OrderDirection Direction { get; set; } public OrderMode Mode { get; set; } = OrderMode.Direct; public OrderType Type { get; set; } public bool LiveUntilCancelled { get; set; } public int Quantity { get; set; } public double Price { get; set; } public double StopPrice { get; set; } public string SignalName { get; set; } = String.Empty; public IInstrument Instrument { get; set; } public ITimeFrame TimeFrame { get; set; } public string FromEntrySignal { get; set; } = String.Empty; }","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter_20","text":"OrderDirection M\u00f6gliche Werte sind: OrderDirection.Buy Kauforder zum Long-Einstieg; OrderDirection.Sell Verkaufsorder zum Schlie\u00dfen einer Long-Position; OrderMode One of three possible positions in the market: Direct, Dynamic, Synthetic OrderType M\u00f6gliche Werte sind: OrderType.Limit, OrderType.Market, OrderType.Stop, OrderType.StopLimit LiveUntilCancelled Die Order wird nicht am Ende des Bars gel\u00f6scht, sondern bleibt so lange aktiv, bis sie mit Order.Cancel gel\u00f6scht wird, bzw. bis ihre Ablaufzeit (siehe TimeInForce ) erreicht ist. Quantity St\u00fcckzahl Price Limit-Kurs. Die Angabe einer 0 (Null) bedeutet, dass dieser Parameter irrelevant ist. StopPrice Stop-Kurs. Die Angabe einer 0 (Null) bedeutet, dass dieser Parameter irrelevant ist SignalName Ein eindeutiger Signalname (string) Instrument Das Handelsinstrument, in welchem die Position besteht. TimeFrame T Der TimeFrame, der f\u00fcr die Order g\u00fcltig ist. FromEntrySignal Der Name eines Einstiegssignals, f\u00fcr das eine Trail-Stoporder generiert werden soll. Die St\u00fcckzahl wird nur aus der angegebenen Einstiegsorder \u00fcbernommen.","title":"Parameter"},{"location":"strategieprogrammierung/#submitorder","text":"","title":"SubmitOrder()"},{"location":"strategieprogrammierung/#beschreibung_27","text":"SubmitOrder erzeugt eine benutzerdefinierte Order. F\u00fcr diese Order wird kein Stop und kein Limit in den Markt gelegt. Alle Kontrollmechanismen von AgenaTrader sind f\u00fcr diese Orderart abgeschaltet. Der Nutzer ist f\u00fcr die Verwaltung, Stop, Target und f\u00fcr die Behandlung von Teilausf\u00fchrungen selbst verantwortlich und kann sich ein Ordermanagement nach seinen eigenen W\u00fcnschen selbst erstellen. Siehe auch OnOrderChanged() , OnOrderExecution() .","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_21","text":"Siehe StrategyOrderParameters","title":"Verwendung"},{"location":"strategieprogrammierung/#parameter_21","text":"Siehe StrategyOrderParameters","title":"Parameter"},{"location":"strategieprogrammierung/#ruckgabewert_7","text":"an order object of the type \"IOrder\"","title":"R\u00fcckgabewert"},{"location":"strategieprogrammierung/#beispiel_23","text":"// Limit Long order Submit Limit Buy var order = SubmitOrder(new StrategyOrderParameters { Direction = OrderDirection.Buy, Type = OrderType.Limit, Mode = orderMode, Price = limitPrice, Quantity = quantity, SignalName = entryName, Instrument = Instrument, TimeFrame = TimeFrame, LiveUntilCancelled = true }); // Short Market order Submit Sell Market var order = SubmitOrder(new StrategyOrderParameters { Direction = OrderDirection.Sell, Type = OrderType.Market, Mode = ordermode, Quantity = quantity, SignalName = entryName, Instrument = Instrument, TimeFrame = TimeFrame });","title":"Beispiel"},{"location":"strategieprogrammierung/#timeinforce","text":"","title":"TimeInForce"},{"location":"strategieprogrammierung/#beschreibung_28","text":"Die Eigenschaft TimeInForce bestimmt die G\u00fcltigkeitsdauer einer Order. Die G\u00fcltigkeitsdauer ist davon abh\u00e4ngig, welche Werte von einem Broker akzeptiert werden. TimeInForce wird in der OnInit() Methode angegeben. M\u00f6gliche Werte sind: TimeInForce.day TimeInForce.loc TimeInForce.gtc (GTC = good till canceled) TimeInForce.gtd Default: TimeInForce.GTC","title":"Beschreibung"},{"location":"strategieprogrammierung/#verwendung_22","text":"TimeInForce","title":"Verwendung"},{"location":"strategieprogrammierung/#beispiel_24","text":"protected override void OnInit() { TimeInForce = TimeInForce.Day; }","title":"Beispiel"},{"location":"strategieprogrammierung/#trade","text":"","title":"Trade"},{"location":"strategieprogrammierung/#beschreibung_29","text":"Trade ist ein Objekt, welches Informationen zu einem Trade enth\u00e4lt, der von einer Strategie ausgef\u00fchrt wurde bzw. der aktuell l\u00e4uft. Die einzelnen Eigenschaften sind: Trade.AvgPrice durchschnittlicher Einstiegskurs Trade.ClosedProfitLoss bereits realisierter Gewinn bzw. Verlust Trade.Commission Geb\u00fchren (Kommissionen) Trade.CreatedDateTime Zeitpunkt der Er\u00f6ffnung eines Trades Trade.EntryReason Bezeichnung des Einstiegssignals bei Strategien: Name der Strategie Trade.ExitDateTime Zeitpunkt, an dem der Trade geschlossen wurde Trade.ExitPrice Ausstiegskurs Trade.ExitReason Bezeichnung des Ausstiegssignals bei Strategien: Name der Strategie Trade.Instrument Bezeichnung des Handelsinstrumentes Trade.PositionType Positionierung im Markt PositionType.Flat PositionType.Long PositionType.Short Trade.OpenProfitLoss noch unrealisierter Gewinn bzw. Verlust in einer laufenden Position Trade.ProfitCurrency Gewinn bzw. Verlust in der W\u00e4hrung, in der das Handelskonto gef\u00fchrt wird Trade.ProfitLoss Gewinn bzw. Verlust Trade.ProfitPercent Gewinn bzw. Verlust in Prozent Trade.ProfitPercentWithCommission Gewinn bzw. Verlust in Prozent mit Geb\u00fchren Trade.ProfitPoints Gewinn bzw. Verlust in Punkten bzw. Pips Trade.Quantity St\u00fcckzahl von Aktien, CFD, Kontrakten usw. Trade.TimeFrame Zeiteinheit, in der der Trade er\u00f6ffnet wurde Trade.Url URL zum Snapshot des Charts zum Zeitpunkt der Er\u00f6ffnung","title":"Beschreibung"},{"location":"strategieprogrammierung/#beispiel_25","text":"protected override void OnDispose() { foreach (ITrade trade in Performance.AllTrades) { ITrade trade = tradeState.Trade; if (trade == null) continue; Print(\"Trade #\"+trade.Id); Print(\"--------------------------------------------\"); Print(\"Durchschnittspreis \" + trade.AvgPrice); Print(\"realisierter G/V \" + trade.ClosedProfitLoss); Print(\"Geb\u00fchren \" + trade.Commission); Print(\"Zeitpunkt Einstieg \" + trade.CreatedDateTime); Print(\"Bezeichnung Einst \" + trade.EntryReason); Print(\"Zeitpunkt Ausstieg \" + trade.ExitDateTime); Print(\"Ausstiegskurs \" + trade.ExitPrice); Print(\"Bezeichnung Ausstieg \" + trade.ExitReason); Print(\"Instrument \" + trade.Instrument); Print(\"Positionierung \" + trade.PositionType); Print(\"unrealisierter G/V \" + trade.OpenProfitLoss); Print(\"G/V (W\u00e4hrung) \" + trade.ProfitCurrency); Print(\"G/V \" + trade.ProfitLoss); Print(\"G/V (in Prozent) \" + trade.ProfitPercent); Print(\"G/V (in % mit Geb\u00fchren)\" + trade.ProfitPercentWithCommission); Print(\"GV (in Punkten) \" + trade.ProfitPoints); Print(\"St\u00fcckzahl \" + trade.Quantity); Print(\"Zeiteinheit \" + trade.TimeFrame); Print(\"URL zum Snapshot \" + trade.Url); } }","title":"Beispiel"},{"location":"strategieprogrammierung/#unmanaged","text":"","title":"Unmanaged"},{"location":"strategieprogrammierung/#backtesting-and-optimization","text":"","title":"Backtesting and Optimization"},{"location":"strategieprogrammierung/#performance-characteristics","text":"Unter Performance-Kennzahlen werden verschiedene Kennzahlen verstanden, die jeweils f\u00fcr eine Liste von Trades berechnet werden k\u00f6nnen. Die Trades k\u00f6nnen von einer Strategie in Realtime generiert worden sein oder von einem Backtestlauf stammen. Es stehen folgende Listen zur Verf\u00fcgung: alle trades alle long trades alle short trades alle winning trades alle losing trades Siehe hierzu Performance . Die einzelnen Kennzahlen sind: AvgEtd der durchschnittliche DrawDown am Ende eines Trades (avg end trade drawdown) <TradeCollection>.TradesPerformance.<TradesPerformanceValues>.AvgEtd Print(\"Average ETD of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.AvgEtd); AvgMae der durchschnittliche max. Kursr\u00fcckgang nach den Einstiegen (avg maximum adverse excursion) <TradeCollection>.TradesPerformance.<TradesPerformanceValues>.AvgMae Print(\"Average MAE of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.AvgMae); AvgMfe der durchschnittliche max Kursanstieg im Verlauf der Trades (avg maximum favorable excursion) <TradeCollection>.TradesPerformance.<TradesPerformanceValues>.AvgMfe Print(\"Average MFE of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.AvgMfe); AvgProfit der durchschnittliche Gewinn \u00fcber alle Trades (avg profit) <TradeCollection>.TradesPerformance.<TradesPerformanceValues>.AvgProfit Print(\"Average profit of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.AvgProfit); CumProfit der Gesamtgewinn \u00fcber alle Trades <TradeCollection>.TradesPerformance.<TradesPerformanceValues>.CumProfit Print(\"Average cumulative profit of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.CumProfit); DrawDown der DrawDown \u00fcber alle Trades <TradeCollection>.TradesPerformance.<TradesPerformanceValues>.DrawDow Print(\"Drawdown of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.DrawDown); LargestLoser der gr\u00f6\u00dfte Verlust <TradeCollection>.TradesPerformance.<TradesPerformanceValues>.LargestLoser Print(\"Largest loss of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.LargestLoser); LargestWinner der gr\u00f6\u00dfte Gewinn <TradeCollection>.TradesPerformance.<TradesPerformanceValues>.LargestWinner Print(\"Largest win of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.LargestWinner); ProfitPerMonth hochgerechneter Gewinn/Verlust im Monat (auch in Prozent) <TradeCollection>.TradesPerformance.<TradesPerformanceValues>.ProfitPerMonth Print(\"Profit per month of all trades is: \" + Performance.AllTrades.TradesPerformance.Currency.ProfitPerMonth); StdDev die Standardabweichung der Gewinne bzw. Verluste. Hier k\u00f6nnen Ausrei\u00dfer erkannt werden. Je besser ein Handelssystem ist, desto kleiner ist die Standardabweichung und desto h\u00f6her ist die Erwartung von Gewinnen. Alle Kennzahlen sind double-Werte.","title":"Performance Characteristics"},{"location":"tipps_und_tricks/","text":"Tipps und Tricks Hinweis: Code \u00c4nderungen in selbst-erstellten Indikatoren werden automatisch auf Conditions angewandt, welche den Indikator verwenden sofern diese im \"body\" von z.B. \"OnCalculate/OnBarUpdate\" durchgef\u00fchrt wurden. \u00c4nderungen von Parametern, Output Serien, etc. ben\u00f6tigen eine manuelle \u00c4nderung der Conditions. Bar Nummerierung im Chart Das Beispiel zeigt die Verwendung der Plot-Methode und der Eigenschaften des Chart Objekts. Hinweis: Hinweis: Zu Demonstrationszwecken wird innerhalb des Teils \"Bar-Nummerierung\" f\u00fcr jeden Aufruf von Paint jeweils einige male new und Dispose aufgerufen. Aus Performance-Sicht ist die L\u00f6sung im Teil \"Eigenschaften von ChartControl\" mit einer festen Variablendeklaration und den Aufrufen von Dispose in OnTermination wesentlich besser. using System; using System.Collections.Generic; using System.ComponentModel; using System.Drawing; using System.Drawing.Drawing2D; using System.Linq; using System.Xml; using System.Xml.Serialization; using AgenaTrader.API; using AgenaTrader.Custom; using AgenaTrader.Plugins; using AgenaTrader.Helper; namespace AgenaTrader.UserCode { [Description(\"PlotSample\")] public class PlotSample : UserIndicator { Pen pen = new Pen(Color.Blue); StringFormat sf = new StringFormat(); SolidBrush brush = new SolidBrush(Color.Black); Font font = new Font(\"Arial\", 10, FontStyle.Bold); protected override void OnInit() { IsOverlay = true; } protected override void OnDispose() { if (pen!=null) pen.Dispose(); if (sf!=null) sf.Dispose(); if (brush!=null) brush.Dispose(); if (font!=null) font.Dispose(); } protected override void OnCalculate() {} public override void OnPaint(Graphics g, Rectangle r, double min, double max) { if (Bars == null || Chart == null) return; // Eigenschaften von Chart string s; s = \"bounds: \"+r.X.ToString()+\" \"+r.Y.ToString()+\" \"+r.Height.ToString()+\" \"+r.Width.ToString(); g.DrawString(s, font, brush, 10, 50, sf); s = \"min: \"+Instrument.Round2TickSize(min).ToString()+\" max: \"+Instrument.Round2TickSize(max).ToString(); g.DrawString(s, font, brush, 10, 70, sf); s = \"BarSpace: \"+Chart.BarSpace.ToString()+\" BarWidth: \"+Chart.BarWidth.ToString(); g.DrawString(s, font, brush, 10, 90, sf); s = \"Bars.Count: \"+Bars.Count.ToString(); g.DrawString(s, font, brush, 10, 110, sf); s = \"BarsPainted: \"+Chart.BarsPainted.ToString() + \" FirstBarPainted: \"+Chart.FirstBarPainted.ToString() + \" LastBarPainted: \"+Chart.LastBarPainted.ToString(); g.DrawString(s, font, brush, 10, 130, sf); s = \"BarsVisible: \"+Chart.BarsVisible.ToString() + \" FirstBarVisible: \"+Chart.FirstBarVisible.ToString() + \" LastBarVisible: \"+Chart.LastBarVisible.ToString(); g.DrawString(s, font, brush, 10, 150, sf); // Bar Nummerierung StringFormat _sf = new StringFormat(); SolidBrush _brush = new SolidBrush(Color.Blue); Font _font = new Font(\"Arial\", 8); SizeF _stringSize = new SizeF(); _sf.Alignment = StringAlignment.Center; for (int i=Chart.FirstBarVisible; i<=Chart.LastBarVisible; i++) { string text = i.ToString(); _stringSize = g.MeasureString(text, _font); int x = Chart.GetXByBarIdx(Bars, i); int y = Chart.GetYByValue(this, High[Abs2Ago(i)] + 3*TickSize) - (int) _stringSize.Height; g.DrawString(text, _font, _brush, x, y, _sf); } _sf.Dispose(); _brush.Dispose(); _font.Dispose(); } private int Abs2Ago(int idx) { return Math.Max(0,Bars.Count-idx-1-(CalculateOnClosedBar?1:0)); } } } Eigenes Chart-Hintergrundbild Durch die Plot-Methode ist es sehr leicht m\u00f6glich, dem Chart ein eigenes Hintergrundbild hinzuzuf\u00fcgen. Das folgende Beispiel verwendet ein Bild im JPG-Format im Hauptverzeichnis auf der Festplatte (C:). using System; using System.Drawing; using AgenaTrader.Custom; using AgenaTrader.Plugins; namespace AgenaTrader.UserCode { public class BackgroundPicture : UserIndicator { Image img; protected override void OnStart() { try { img = Image.FromFile(\"C:\\\\\\\\MyCar.jpg\"); } catch {} } public override void OnPaint(Graphics g, Rectangle r, double min, double max) { if (Chart == null || img == null) return; g.DrawImage(img,r); } } } File-Auswahl in den Properties Um in den Properties (Eigenschaften) eines Indikators eine File-Auswahl zu erm\u00f6glichen, ben\u00f6tigt man einen Typ-Converter. Das folgende Beispiel zeigt, wie eine Auswahl von WAV-Dateien f\u00fcr einen Alarm programmiert werden kann: using System; using System.IO; using System.Collections; using System.ComponentModel; using AgenaTrader.Custom; using AgenaTrader.Plugins; namespace AgenaTrader.UserCode { [Description(\"File Picker Example.\")] public class FilePicker : UserIndicator { private string _soundFile = \"Alert4.wav\"; private static string _dir = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments) + @\"\\\\AgenaTrader\\\\Sounds\\\\\"; internal class MyConverter : TypeConverter { public override bool GetStandardValuesSupported(ITypeDescriptorContext context) { return true; } public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) { if (context == null) return null; ArrayList list = new ArrayList(); DirectoryInfo dir = new DirectoryInfo(_dir); FileInfo[] files = dir.GetFiles(\"*.wav\"); foreach (FileInfo file in files) list.Add(file.Name); return new TypeConverter.StandardValuesCollection(list); } } protected override void OnStart() { PlaySound(_soundFile); } [Description(\"Choose file to play.\")] [Category (\"Sound\")] [TypeConverter(typeof(MyConverter))] public string SoundFile { get { return _soundFile; } set { _soundFile = value; } } } } Formatieren von Zahlen Formatieren von Zahlen Generelles zur Formatierung in C# double d = 123.4567890; Print(\"Ohne Formatierung : \" + d.ToString()); // 123.456789 Print(\"als W\u00e4hrung : \" + d.ToString(\"C\")); // 123.46 \u20ac Print(\"Exponential : \" + d.ToString(\"E\")); // 1.234568E+002 Print(\"als Festkommazahl : \" + d.ToString(\"F2\")); // 123.46 Print(\"Generell : \" + d.ToString(\"G\")); // 123.456789 Print(\"als Prozentzahl : \" + d.ToString(\"P0\")); // 12.346% Print(\"Tmit 2 Nachkommastellen : \" + d.ToString(\"N2\")); // 123.45 Print(\"mit 3 Nachkommastellen : \" + d.ToString(\"N3\")); // 123.457 Print(\"mit 4 Nachkommastellen : \" + d.ToString(\"N4\")); // 123.4568 N\u00fctzliche Funktionen Liefert das W\u00e4hrungssymbol des aktuellen Instruments: public string getWaehrungssymbol() { string s = \"\"; switch (Instrument.Currency) { case Currencies.USD : s = \"$\"; break; case Currencies.EUR : s = \"\u20ac\"; break; case Currencies.CHF : s = \"CHF\"; break; case Currencies.GBP : s = ((char)163).ToString(); break; case Currencies.JPY : s = ((char)165).ToString(); break; } return s; } Wandelt eine Zahl in eine W\u00e4hrung mit Tausendertrennung und 2 Nachkommastellen um Das Tausendertrennzeichen ist abh\u00e4ngig von eingestellter \"Culture\". public string getWaehrungOhneSymbol(double d) { // Tausender Trennzeichen (abh. von eingestellter Culture) und 2 Nachkommastellen return d.ToString(\"\\#,\\#\\#0.00\"); } Wandelt eine Zahl in eine W\u00e4hrung mit Tausendertrennung, 2 Nachkommastellen und einem W\u00e4hrungssymbol um. public string getWaehrungMitSymbol(double d) { // Dollar wird vorangestellt. Alles andere kommt hintendran string s=getWaehrungOhneSymbol(d); string w=getWaehrungssymbol(); if (w==\"$\") s=w+\" \"+s; else s+=\" \"+w; return s; } Wandelt eine Zahl in eine W\u00e4hrung mit Tausendertrennung, 2 Nachkommastellen und einem W\u00e4hrungssymbol um und f\u00fcllt bis zu einer festen L\u00e4nge mit f\u00fchrenden Leerzeichen auf. Diese Funktion ist sehr gut f\u00fcr eine tabellarische Ausgabe geeignet. public string getWaehrungMitSymbol(double d, int Laenge) { // fuehrende Leerzeichen bis feste Laenge erreicht ist string s=getWaehrungMitSymbol(d); for (int i=s.Length; i<Laenge; i++) s=\" \"+s; return s; } Wandelt eine Zahl in eine Prozentangabe um. Es wird nicht gerechnet, nur formatiert. F\u00fchrendes Pluszeichen, eine Nachkommastelle und Prozentzeichen public string getPercent(double d) { d=Math.Round(d, 1); string s=(d>0)?\"+\":\"\"; // Leading plus sign return s+d.ToString(\"0.0\")+\"%\"; } Formatiert einen Kurswert in Abh\u00e4ngigkeit von der Anzahl der Nachkommastellen, in der der Wert notiert wird. Mit Tausendertrennzeichen und fester L\u00e4nge, d.h. es wird auch rechts ggf. mit Nullen aufgef\u00fcllt. Wegen der Verwendung von CultureInfo mu\u00df der NameSpace System.Globalization eingebunden sein. public string format(double d) { int tickLength = 0; // ticksize.ToString() ist z.B. bei 6J = \"1E-06\" und Length ist dann 5 // und nicht richtigerweise 8 wie bei \"0,000001\") if (TickSize < 1) tickLength = TickSize.ToString(\"0.\\#\\#\\#\\#\\#\\#\\#\\#\\#\\#\\#\").Length - 2; string f = \"{0:n\"+tickLength.ToString()+\"}\"; return string.Format(CultureInfo.CurrentCulture, f, d); } Beispiele double profit = 1234.567890; Print(\"getCurrencyWithoutSymbol \": + getWaehrungOhneSymbol(Gewinn)); // 1234.57 Print(\"getCurrencyWithSymbol :\" + getWaehrungMitSymbol(Gewinn)); // $ 1,234.57 Print(\"getCurrencyWithSymbol :\" + getWaehrungMitSymbol(Gewinn)); // $ 1,234.57 double percentage profit = 12.3456789; Print(\"getPercent :\" + getPercent(ProzGewinn)); // +12.3% double price = 123.4567; Print(\"getPrice :\" + getKurs(Kurs)); // 123.46 Index-Convertierung Es gibt 2 Arten der Indizierung in AgenaTrader. Die Bars werden vom j\u00fcngsten zum \u00e4ltesten Bar nummeriert. Diese Art wird in der OnBarUpdate()-Methode verwenden. Der jeweils letzte Bar bekommt den Index 0, der \u00e4lteste hat den Index Bars.Count-1. Die Bars werden vom \u00e4ltesten zum j\u00fcngsten Bar nummeriert. Diese Art wird h\u00e4ufig in der OnPaint()-Methode in for-Schleifen verwendet. Der \u00e4lteste Bar bekommt den Index 0, der j\u00fcngste Bar hat den Index Bars.Count-1. Die folgende Funktion kann zur Umrechnung der Index-Arten verwendet werden: private int Convert(int idx) { return Math.Max(0,Bars.Count-idx-1-(CalculateOnClosedBar?1:0)); } Indikatornamen \u00fcberschreiben Der Namen des Indikators (bzw. einer Strategie), der im Eigenschaftendialog und am oberen Rand des Charts angezeigt wird. Verwenden Sie die ToString() Methode und die Eigenschaft DisplayName, um sie zu \u00fcberschreiben. public override string ToString() { return \"My Name\"; } public override string DisplayName { get { return \"My Name\"; } } Hinweis: Verwenden Sie immer beide Methoden in Ihren Skripts, um sicherzustellen, dass Ihr spezieller Name auf allen AgenaTrader-Formularen verwendet wird. Rechteck mit abgerundeten Ecken Durch die Verwendung der Graphics Methoden k\u00f6nnen sehr interessante Formen in einen Chart gezeichnet werden. Ein Beispiel hierf\u00fcr ist die Klasse RoundedRectangle, die Rechtecke mit abgerundeten Ecken zeichnet. Das Ergebnis sieht sehr viel \"moderner\" aus, als ein klassisches Rectangle. Example Code: using System; using System.Collections.Generic; using System.ComponentModel; using System.Drawing; using System.Linq; using System.Xml; using System.Xml.Serialization; using System.Drawing.Drawing2D; using AgenaTrader.API; using AgenaTrader.Custom; using AgenaTrader.Plugins; namespace AgenaTrader.UserCode { [Description(\"Demo of RoundedRectangles\")] public class DemoRoundedRectangle : UserIndicator { protected override void OnInit() { IsOverlay = true; } protected override void OnCalculate() {} public override void OnPaint(Graphics g, Rectangle r, double min, double max) { GraphicsPath path; // zeichnet ein Rechteck mit abgerundeten Ecken path = RoundedRectangle.Create(30, 50, 100, 100,8); g.DrawPath(Pens.Black, path); // zeichnet ein ausgef\u00fclltes Rechteck mit Radius 20 // abgerundet sind nur die linke obere und rechte untere Ecke path = RoundedRectangle.Create(160, 50, 100, 100, 20, RoundedRectangle.RectangleCorners.TopLeft|RoundedRectangle.RectangleCorners.BottomRight); g.FillPath(Brushes.Orange, path); } } public abstract class RoundedRectangle { public enum RectangleCorners { None = 0, TopLeft = 1, TopRight = 2, BottomLeft = 4, BottomRight = 8, All = TopLeft | TopRight | BottomLeft | BottomRight } public static GraphicsPath Create(int x, int y, int width, int height, int radius, RectangleCorners corners) { Rectangle r = new Rectangle(x,y,width, height); Rectangle tlc = new Rectangle(r.Left, r.Top,Math.Min(2 * radius, r.Width),Math.Min(2 * radius, r.Height)); Rectangle trc = tlc; trc.X = r.Right - 2 * radius; Rectangle blc = tlc; blc.Y = r.Bottom - 2 * radius; Rectangle brc = blc; brc.X = r.Right - 2 * radius; Point[] n = new Point[] { new Point(tlc.Left, tlc.Bottom), tlc.Location, new Point(tlc.Right, tlc.Top), trc.Location, new Point(trc.Right, trc.Top), new Point(trc.Right, trc.Bottom), new Point(brc.Right, brc.Top), new Point(brc.Right, brc.Bottom), new Point(brc.Left, brc.Bottom), new Point(blc.Right, blc.Bottom), new Point(blc.Left, blc.Bottom), blc.Location }; GraphicsPath p = new GraphicsPath(); p.StartFigure(); //Top left corner if ((RectangleCorners.TopLeft & corners) == RectangleCorners.TopLeft) p.AddArc(tlc, 180, 90); else p.AddLines(new Point[] { n[0], n[1], n[2] }); //Top edge p.AddLine(n[2], n[3]); //Top right corner if ((RectangleCorners.TopRight & corners) == RectangleCorners.TopRight) p.AddArc(trc, 270, 90); else p.AddLines(new Point[] { n[3], n[4], n[5] }); //Right edge p.AddLine(n[5], n[6]); //Bottom right corner if ((RectangleCorners.BottomRight & corners) == RectangleCorners.BottomRight) p.AddArc(brc, 0, 90); else p.AddLines(new Point[] { n[6], n[7], n[8] }); //Bottom edge p.AddLine(n[8], n[9]); //Bottom left corner if ((RectangleCorners.BottomLeft & corners) == RectangleCorners.BottomLeft) p.AddArc(blc, 90, 90); else p.AddLines(new Point[] { n[9], n[10], n[11] }); //Left edge p.AddLine(n[11], n[0]); p.CloseFigure(); return p; } public static GraphicsPath Create(Rectangle rect, int radius, RectangleCorners c) { return Create(rect.X, rect.Y, rect.Width, rect.Height, Math.Max(1,radius), c); } public static GraphicsPath Create(int x, int y, int width, int height, int radius) { return Create(x, y, width, height, Math.Max(1,radius), RectangleCorners.All); } public static GraphicsPath Create(Rectangle rect, int radius) { return Create(rect.X, rect.Y, rect.Width, rect.Height, Math.Max(1,radius)); } public static GraphicsPath Create(int x, int y, int width, int height) { return Create(x, y, width, height, 8); } public static GraphicsPath Create(Rectangle rect) { return Create(rect.X, rect.Y, rect.Width, rect.Height); } } }","title":"Tipps und Tricks"},{"location":"tipps_und_tricks/#tipps-und-tricks","text":"Hinweis: Code \u00c4nderungen in selbst-erstellten Indikatoren werden automatisch auf Conditions angewandt, welche den Indikator verwenden sofern diese im \"body\" von z.B. \"OnCalculate/OnBarUpdate\" durchgef\u00fchrt wurden. \u00c4nderungen von Parametern, Output Serien, etc. ben\u00f6tigen eine manuelle \u00c4nderung der Conditions.","title":"Tipps und Tricks"},{"location":"tipps_und_tricks/#bar-nummerierung-im-chart","text":"Das Beispiel zeigt die Verwendung der Plot-Methode und der Eigenschaften des Chart Objekts. Hinweis: Hinweis: Zu Demonstrationszwecken wird innerhalb des Teils \"Bar-Nummerierung\" f\u00fcr jeden Aufruf von Paint jeweils einige male new und Dispose aufgerufen. Aus Performance-Sicht ist die L\u00f6sung im Teil \"Eigenschaften von ChartControl\" mit einer festen Variablendeklaration und den Aufrufen von Dispose in OnTermination wesentlich besser. using System; using System.Collections.Generic; using System.ComponentModel; using System.Drawing; using System.Drawing.Drawing2D; using System.Linq; using System.Xml; using System.Xml.Serialization; using AgenaTrader.API; using AgenaTrader.Custom; using AgenaTrader.Plugins; using AgenaTrader.Helper; namespace AgenaTrader.UserCode { [Description(\"PlotSample\")] public class PlotSample : UserIndicator { Pen pen = new Pen(Color.Blue); StringFormat sf = new StringFormat(); SolidBrush brush = new SolidBrush(Color.Black); Font font = new Font(\"Arial\", 10, FontStyle.Bold); protected override void OnInit() { IsOverlay = true; } protected override void OnDispose() { if (pen!=null) pen.Dispose(); if (sf!=null) sf.Dispose(); if (brush!=null) brush.Dispose(); if (font!=null) font.Dispose(); } protected override void OnCalculate() {} public override void OnPaint(Graphics g, Rectangle r, double min, double max) { if (Bars == null || Chart == null) return; // Eigenschaften von Chart string s; s = \"bounds: \"+r.X.ToString()+\" \"+r.Y.ToString()+\" \"+r.Height.ToString()+\" \"+r.Width.ToString(); g.DrawString(s, font, brush, 10, 50, sf); s = \"min: \"+Instrument.Round2TickSize(min).ToString()+\" max: \"+Instrument.Round2TickSize(max).ToString(); g.DrawString(s, font, brush, 10, 70, sf); s = \"BarSpace: \"+Chart.BarSpace.ToString()+\" BarWidth: \"+Chart.BarWidth.ToString(); g.DrawString(s, font, brush, 10, 90, sf); s = \"Bars.Count: \"+Bars.Count.ToString(); g.DrawString(s, font, brush, 10, 110, sf); s = \"BarsPainted: \"+Chart.BarsPainted.ToString() + \" FirstBarPainted: \"+Chart.FirstBarPainted.ToString() + \" LastBarPainted: \"+Chart.LastBarPainted.ToString(); g.DrawString(s, font, brush, 10, 130, sf); s = \"BarsVisible: \"+Chart.BarsVisible.ToString() + \" FirstBarVisible: \"+Chart.FirstBarVisible.ToString() + \" LastBarVisible: \"+Chart.LastBarVisible.ToString(); g.DrawString(s, font, brush, 10, 150, sf); // Bar Nummerierung StringFormat _sf = new StringFormat(); SolidBrush _brush = new SolidBrush(Color.Blue); Font _font = new Font(\"Arial\", 8); SizeF _stringSize = new SizeF(); _sf.Alignment = StringAlignment.Center; for (int i=Chart.FirstBarVisible; i<=Chart.LastBarVisible; i++) { string text = i.ToString(); _stringSize = g.MeasureString(text, _font); int x = Chart.GetXByBarIdx(Bars, i); int y = Chart.GetYByValue(this, High[Abs2Ago(i)] + 3*TickSize) - (int) _stringSize.Height; g.DrawString(text, _font, _brush, x, y, _sf); } _sf.Dispose(); _brush.Dispose(); _font.Dispose(); } private int Abs2Ago(int idx) { return Math.Max(0,Bars.Count-idx-1-(CalculateOnClosedBar?1:0)); } } }","title":"Bar Nummerierung im Chart"},{"location":"tipps_und_tricks/#eigenes-chart-hintergrundbild","text":"Durch die Plot-Methode ist es sehr leicht m\u00f6glich, dem Chart ein eigenes Hintergrundbild hinzuzuf\u00fcgen. Das folgende Beispiel verwendet ein Bild im JPG-Format im Hauptverzeichnis auf der Festplatte (C:). using System; using System.Drawing; using AgenaTrader.Custom; using AgenaTrader.Plugins; namespace AgenaTrader.UserCode { public class BackgroundPicture : UserIndicator { Image img; protected override void OnStart() { try { img = Image.FromFile(\"C:\\\\\\\\MyCar.jpg\"); } catch {} } public override void OnPaint(Graphics g, Rectangle r, double min, double max) { if (Chart == null || img == null) return; g.DrawImage(img,r); } } }","title":"Eigenes Chart-Hintergrundbild"},{"location":"tipps_und_tricks/#file-auswahl-in-den-properties","text":"Um in den Properties (Eigenschaften) eines Indikators eine File-Auswahl zu erm\u00f6glichen, ben\u00f6tigt man einen Typ-Converter. Das folgende Beispiel zeigt, wie eine Auswahl von WAV-Dateien f\u00fcr einen Alarm programmiert werden kann: using System; using System.IO; using System.Collections; using System.ComponentModel; using AgenaTrader.Custom; using AgenaTrader.Plugins; namespace AgenaTrader.UserCode { [Description(\"File Picker Example.\")] public class FilePicker : UserIndicator { private string _soundFile = \"Alert4.wav\"; private static string _dir = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments) + @\"\\\\AgenaTrader\\\\Sounds\\\\\"; internal class MyConverter : TypeConverter { public override bool GetStandardValuesSupported(ITypeDescriptorContext context) { return true; } public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) { if (context == null) return null; ArrayList list = new ArrayList(); DirectoryInfo dir = new DirectoryInfo(_dir); FileInfo[] files = dir.GetFiles(\"*.wav\"); foreach (FileInfo file in files) list.Add(file.Name); return new TypeConverter.StandardValuesCollection(list); } } protected override void OnStart() { PlaySound(_soundFile); } [Description(\"Choose file to play.\")] [Category (\"Sound\")] [TypeConverter(typeof(MyConverter))] public string SoundFile { get { return _soundFile; } set { _soundFile = value; } } } }","title":"File-Auswahl in den Properties"},{"location":"tipps_und_tricks/#formatieren-von-zahlen","text":"","title":"Formatieren von Zahlen"},{"location":"tipps_und_tricks/#formatieren-von-zahlen_1","text":"Generelles zur Formatierung in C# double d = 123.4567890; Print(\"Ohne Formatierung : \" + d.ToString()); // 123.456789 Print(\"als W\u00e4hrung : \" + d.ToString(\"C\")); // 123.46 \u20ac Print(\"Exponential : \" + d.ToString(\"E\")); // 1.234568E+002 Print(\"als Festkommazahl : \" + d.ToString(\"F2\")); // 123.46 Print(\"Generell : \" + d.ToString(\"G\")); // 123.456789 Print(\"als Prozentzahl : \" + d.ToString(\"P0\")); // 12.346% Print(\"Tmit 2 Nachkommastellen : \" + d.ToString(\"N2\")); // 123.45 Print(\"mit 3 Nachkommastellen : \" + d.ToString(\"N3\")); // 123.457 Print(\"mit 4 Nachkommastellen : \" + d.ToString(\"N4\")); // 123.4568","title":"Formatieren von Zahlen"},{"location":"tipps_und_tricks/#nutzliche-funktionen","text":"Liefert das W\u00e4hrungssymbol des aktuellen Instruments: public string getWaehrungssymbol() { string s = \"\"; switch (Instrument.Currency) { case Currencies.USD : s = \"$\"; break; case Currencies.EUR : s = \"\u20ac\"; break; case Currencies.CHF : s = \"CHF\"; break; case Currencies.GBP : s = ((char)163).ToString(); break; case Currencies.JPY : s = ((char)165).ToString(); break; } return s; } Wandelt eine Zahl in eine W\u00e4hrung mit Tausendertrennung und 2 Nachkommastellen um Das Tausendertrennzeichen ist abh\u00e4ngig von eingestellter \"Culture\". public string getWaehrungOhneSymbol(double d) { // Tausender Trennzeichen (abh. von eingestellter Culture) und 2 Nachkommastellen return d.ToString(\"\\#,\\#\\#0.00\"); } Wandelt eine Zahl in eine W\u00e4hrung mit Tausendertrennung, 2 Nachkommastellen und einem W\u00e4hrungssymbol um. public string getWaehrungMitSymbol(double d) { // Dollar wird vorangestellt. Alles andere kommt hintendran string s=getWaehrungOhneSymbol(d); string w=getWaehrungssymbol(); if (w==\"$\") s=w+\" \"+s; else s+=\" \"+w; return s; } Wandelt eine Zahl in eine W\u00e4hrung mit Tausendertrennung, 2 Nachkommastellen und einem W\u00e4hrungssymbol um und f\u00fcllt bis zu einer festen L\u00e4nge mit f\u00fchrenden Leerzeichen auf. Diese Funktion ist sehr gut f\u00fcr eine tabellarische Ausgabe geeignet. public string getWaehrungMitSymbol(double d, int Laenge) { // fuehrende Leerzeichen bis feste Laenge erreicht ist string s=getWaehrungMitSymbol(d); for (int i=s.Length; i<Laenge; i++) s=\" \"+s; return s; } Wandelt eine Zahl in eine Prozentangabe um. Es wird nicht gerechnet, nur formatiert. F\u00fchrendes Pluszeichen, eine Nachkommastelle und Prozentzeichen public string getPercent(double d) { d=Math.Round(d, 1); string s=(d>0)?\"+\":\"\"; // Leading plus sign return s+d.ToString(\"0.0\")+\"%\"; } Formatiert einen Kurswert in Abh\u00e4ngigkeit von der Anzahl der Nachkommastellen, in der der Wert notiert wird. Mit Tausendertrennzeichen und fester L\u00e4nge, d.h. es wird auch rechts ggf. mit Nullen aufgef\u00fcllt. Wegen der Verwendung von CultureInfo mu\u00df der NameSpace System.Globalization eingebunden sein. public string format(double d) { int tickLength = 0; // ticksize.ToString() ist z.B. bei 6J = \"1E-06\" und Length ist dann 5 // und nicht richtigerweise 8 wie bei \"0,000001\") if (TickSize < 1) tickLength = TickSize.ToString(\"0.\\#\\#\\#\\#\\#\\#\\#\\#\\#\\#\\#\").Length - 2; string f = \"{0:n\"+tickLength.ToString()+\"}\"; return string.Format(CultureInfo.CurrentCulture, f, d); }","title":"N\u00fctzliche Funktionen"},{"location":"tipps_und_tricks/#beispiele","text":"double profit = 1234.567890; Print(\"getCurrencyWithoutSymbol \": + getWaehrungOhneSymbol(Gewinn)); // 1234.57 Print(\"getCurrencyWithSymbol :\" + getWaehrungMitSymbol(Gewinn)); // $ 1,234.57 Print(\"getCurrencyWithSymbol :\" + getWaehrungMitSymbol(Gewinn)); // $ 1,234.57 double percentage profit = 12.3456789; Print(\"getPercent :\" + getPercent(ProzGewinn)); // +12.3% double price = 123.4567; Print(\"getPrice :\" + getKurs(Kurs)); // 123.46","title":"Beispiele"},{"location":"tipps_und_tricks/#index-convertierung","text":"Es gibt 2 Arten der Indizierung in AgenaTrader. Die Bars werden vom j\u00fcngsten zum \u00e4ltesten Bar nummeriert. Diese Art wird in der OnBarUpdate()-Methode verwenden. Der jeweils letzte Bar bekommt den Index 0, der \u00e4lteste hat den Index Bars.Count-1. Die Bars werden vom \u00e4ltesten zum j\u00fcngsten Bar nummeriert. Diese Art wird h\u00e4ufig in der OnPaint()-Methode in for-Schleifen verwendet. Der \u00e4lteste Bar bekommt den Index 0, der j\u00fcngste Bar hat den Index Bars.Count-1. Die folgende Funktion kann zur Umrechnung der Index-Arten verwendet werden: private int Convert(int idx) { return Math.Max(0,Bars.Count-idx-1-(CalculateOnClosedBar?1:0)); }","title":"Index-Convertierung"},{"location":"tipps_und_tricks/#indikatornamen-uberschreiben","text":"Der Namen des Indikators (bzw. einer Strategie), der im Eigenschaftendialog und am oberen Rand des Charts angezeigt wird. Verwenden Sie die ToString() Methode und die Eigenschaft DisplayName, um sie zu \u00fcberschreiben. public override string ToString() { return \"My Name\"; } public override string DisplayName { get { return \"My Name\"; } } Hinweis: Verwenden Sie immer beide Methoden in Ihren Skripts, um sicherzustellen, dass Ihr spezieller Name auf allen AgenaTrader-Formularen verwendet wird.","title":"Indikatornamen \u00fcberschreiben"},{"location":"tipps_und_tricks/#rechteck-mit-abgerundeten-ecken","text":"Durch die Verwendung der Graphics Methoden k\u00f6nnen sehr interessante Formen in einen Chart gezeichnet werden. Ein Beispiel hierf\u00fcr ist die Klasse RoundedRectangle, die Rechtecke mit abgerundeten Ecken zeichnet. Das Ergebnis sieht sehr viel \"moderner\" aus, als ein klassisches Rectangle. Example Code: using System; using System.Collections.Generic; using System.ComponentModel; using System.Drawing; using System.Linq; using System.Xml; using System.Xml.Serialization; using System.Drawing.Drawing2D; using AgenaTrader.API; using AgenaTrader.Custom; using AgenaTrader.Plugins; namespace AgenaTrader.UserCode { [Description(\"Demo of RoundedRectangles\")] public class DemoRoundedRectangle : UserIndicator { protected override void OnInit() { IsOverlay = true; } protected override void OnCalculate() {} public override void OnPaint(Graphics g, Rectangle r, double min, double max) { GraphicsPath path; // zeichnet ein Rechteck mit abgerundeten Ecken path = RoundedRectangle.Create(30, 50, 100, 100,8); g.DrawPath(Pens.Black, path); // zeichnet ein ausgef\u00fclltes Rechteck mit Radius 20 // abgerundet sind nur die linke obere und rechte untere Ecke path = RoundedRectangle.Create(160, 50, 100, 100, 20, RoundedRectangle.RectangleCorners.TopLeft|RoundedRectangle.RectangleCorners.BottomRight); g.FillPath(Brushes.Orange, path); } } public abstract class RoundedRectangle { public enum RectangleCorners { None = 0, TopLeft = 1, TopRight = 2, BottomLeft = 4, BottomRight = 8, All = TopLeft | TopRight | BottomLeft | BottomRight } public static GraphicsPath Create(int x, int y, int width, int height, int radius, RectangleCorners corners) { Rectangle r = new Rectangle(x,y,width, height); Rectangle tlc = new Rectangle(r.Left, r.Top,Math.Min(2 * radius, r.Width),Math.Min(2 * radius, r.Height)); Rectangle trc = tlc; trc.X = r.Right - 2 * radius; Rectangle blc = tlc; blc.Y = r.Bottom - 2 * radius; Rectangle brc = blc; brc.X = r.Right - 2 * radius; Point[] n = new Point[] { new Point(tlc.Left, tlc.Bottom), tlc.Location, new Point(tlc.Right, tlc.Top), trc.Location, new Point(trc.Right, trc.Top), new Point(trc.Right, trc.Bottom), new Point(brc.Right, brc.Top), new Point(brc.Right, brc.Bottom), new Point(brc.Left, brc.Bottom), new Point(blc.Right, blc.Bottom), new Point(blc.Left, blc.Bottom), blc.Location }; GraphicsPath p = new GraphicsPath(); p.StartFigure(); //Top left corner if ((RectangleCorners.TopLeft & corners) == RectangleCorners.TopLeft) p.AddArc(tlc, 180, 90); else p.AddLines(new Point[] { n[0], n[1], n[2] }); //Top edge p.AddLine(n[2], n[3]); //Top right corner if ((RectangleCorners.TopRight & corners) == RectangleCorners.TopRight) p.AddArc(trc, 270, 90); else p.AddLines(new Point[] { n[3], n[4], n[5] }); //Right edge p.AddLine(n[5], n[6]); //Bottom right corner if ((RectangleCorners.BottomRight & corners) == RectangleCorners.BottomRight) p.AddArc(brc, 0, 90); else p.AddLines(new Point[] { n[6], n[7], n[8] }); //Bottom edge p.AddLine(n[8], n[9]); //Bottom left corner if ((RectangleCorners.BottomLeft & corners) == RectangleCorners.BottomLeft) p.AddArc(blc, 90, 90); else p.AddLines(new Point[] { n[9], n[10], n[11] }); //Left edge p.AddLine(n[11], n[0]); p.CloseFigure(); return p; } public static GraphicsPath Create(Rectangle rect, int radius, RectangleCorners c) { return Create(rect.X, rect.Y, rect.Width, rect.Height, Math.Max(1,radius), c); } public static GraphicsPath Create(int x, int y, int width, int height, int radius) { return Create(x, y, width, height, Math.Max(1,radius), RectangleCorners.All); } public static GraphicsPath Create(Rectangle rect, int radius) { return Create(rect.X, rect.Y, rect.Width, rect.Height, Math.Max(1,radius)); } public static GraphicsPath Create(int x, int y, int width, int height) { return Create(x, y, width, height, 8); } public static GraphicsPath Create(Rectangle rect) { return Create(rect.X, rect.Y, rect.Width, rect.Height); } } }","title":"Rechteck mit abgerundeten Ecken"},{"location":"umgang_mit_bars_und_instrumenten/","text":"Umgang mit Bars und Instrumenten Unter \"Daten\" werden hier einerseits Informationen verstanden, die \"von au\u00dfen\" in AgenaTrader geladen werden und zum anderen Datenreihen, die aus selbst erstellten AgenaSripts stammen. Detailierte Informatonen finden sich unter dem jeweiligen Stichwort. Bars Collections Data series Instruments Multibars Bars Funktionsweise Ein klassischer Indikator berechnet \u00fcblicherweise aus einer vorliegenden Datenreihe einen oder mehrere Werte. Datenreihen k\u00f6nnen dabei z.B. alle Schlusskurse oder auch alle Tiefkurse eines Tages, einer Stunde oder einer 10 Min. Periode sein. Jeder Periode (also jeder Kerze eines Tages, einer Stunde usw.) wird/werden folglich ein oder mehrere Indikatorwert(e) zugeordnet. Im Folgenden gehen wir von einem Indikatorwert, wie z.B. bei einem gleitenden Durchschnitt aus. Zur Berechnung eines gleitenden Durchschnitts ben\u00f6tigt AgenaTrader eine Datenreihe. Im Beispiel nehmen wir die Schlusskurse. Alle Schlusskurse der Bars (Kerzen), die in einem Chart dargestellt sind, sind in einer Liste gespeichert und sozusagen durchnummeriert. Der aktuelle Schlusskurs, also der Schlusskurs des Bars, der am rechten Rand des Charts dargestellt wird, bekommt die Nummer 0. Der Bar links davon die Nummer 1 usw. Der \u00e4lteste dargestellte Bar hat dann z.B. die Nummer 500. Kommt im Laufe der Handelssitzung ein neuer Bar hinzu, erh\u00e4lt dieser nun die Nummer 0, der links von ihm, der gerade noch die Nummer 0 hatte, wird zu Nummer 1 usw. Der letzte dargestellte Bar wird zu Nummer 501. In einem Script (einem selbsterstellten Programm) steht Close close f\u00fcr die Liste (Array) aller Schlusskurse. Der letzte Schlusskurs ist dann Close [0] ; t der Schlusskurs davor (bei Tagesdaten ist das z.B. der Schlusskurs von gestern) ist Close [1] , der davor Close [2] bis zum ersten Bar im Chart (ganz links) mit Close [501] . Die Zahl in den eckigen Klammern ist ein Index. In AgenaTrader steht hierf\u00fcr im allgemeinen Fall der Ausdruck \"barsAgo\". F\u00fcr jeden Bar gibt es nicht nur Close, sondern zudem auch High , Low , Open , Median , Typical , Weighted , Time and Volume . Das Hoch der Kerze, von vor 10 Tagen ist also z.B. High [10] , Das Tief von gestern Low [1] ... wichtiger Hinweis Die o.g. Beispiele gelten, wenn die Berechnung am Ende einer Periode erfolgt. Die Werte der aktuell laufenden (noch nicht fertigen Kerze) sind nicht ber\u00fccksichtigt. M\u00f6chte man bereits auf die Werte der sich gerade ausbildenden Kerze zur\u00fcckgreifen, mu\u00df man dies AgenaTrader im Script mit CalculateOnClosedBar = false mitteilen. In diesem Fall bekommt der aktuell laufende Bar die Nummer 0, der Bar links neben dem aktuell laufenden die Nummer 1 usw. Der letzte Bar (im Beispiel oben) h\u00e4tte jetzt die Nummer 502. Mit close [0] bekommt man nun den jeweils letzten Kurs, der gerade vom Datenanbieter an AgenaTrader \u00fcbermittelt wurde. Alle Werte des Bars (high [0], low [0]\u2026) k\u00f6nnen sich solange ver\u00e4ndern, bis der Bar fertig ausgebildet ist und ein neuer Bar begonnen hat. Nur Open[0] \u00e4ndert sich auch in diesem Fall nicht mehr. Eigenschaften Eigenschaften von Bars \"Bars\" steht f\u00fcr eine Liste aller Bars (Kerzen) in einem Chart (siehe Funktionsweise , Bars ). Bars ( public IBars Bars) kann direkt in einem Script verwendet werden und entspricht in diesem Fall BarsArray [0] (siehe Bars.GetNextSessionTimeSpan). Eigenschaften werden immer mit einem Punkt hinter dem Objekt (in diesem Falle Bars, der Liste der Kerzen) angegeben. Bars.Count Bars.CurrentSessionBeginTime Bars.CurrentSessionEndTime Bars.GetBar Bars.GetBarIndex Bars.GetBarsAgo Bars.GetByIndex Bars.GetClose Bars.GetHigh Bars.GetLow Bars.GetNextSessionTimeSpan Bars.GetOpen Bars.GetSessionBegin Bars.GetTime Bars.GetVolume Bars.Instrument Bars.IsEod Bars.IsFalling Bars.IsFirstBarInSession Bars.IsGrowing Bars.IsIntraday Bars.IsNtb Bars.SessionBreak Bars.LastBarCompleteness Bars.NextSessionBeginTime Bars.NextSessionEndTime Bars.TailBottom Bars.TailTop Bars.TicksCountForLastBar Bars.TicksCountInTotal Bars.TimeFrame BarsCountForSession IsProcessingBarIndexLast Innerhalb von OnCalculate() k\u00f6nnen alle Eigenschaften verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Funktion OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden. Falls diese Eigenschaften ausserhalb von OnCalculate() verwendet werden, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null ) ausgef\u00fchrt werden. Bars.Count Beschreibung Bars.Count liefert die Anzahl der Bars in einer Datenreihe. Siehe auch weitere Eigenschaften von Bars. R\u00fcckgabewert Typ int Anzahl der Bars Verwendung Bars.Count Weitere Informationen Der Wert von ProcessingBarIndex kann immer nur kleiner oder gleich Bars.Count - 1 sein. Wenn in AgenaTrader angegeben wurde, wieviel Bars in einen Chart geladen werden sollen, entspricht der Wert von Bars.Count genau dieser Einstellung. Im Beispiel unten w\u00fcrde Bars.Count 500 liefern. Beispiel Print (\"Es stehen insgesamt\" + Bars.Count + \"Bars zur Verf\u00fcgung.\"); Bars.CurrentSessionBeginTime Beschreibung Bars.CurrentSessionBeginTime liefert das Datum und die Uhrzeit des Beginns der aktuell laufenden Handelssitzung. Datum und Uhrzeit f\u00fcr den Beginn der aktuellen Handelssitzung werden auch dann korrekt angegeben, wenn die Funktion von einem Bar in der Vergangenheit aufgerufen wird. Parameter keine R\u00fcckgabewert Typ DateTime Verwendung Bars.GetSessionBegin Weitere Informationen Die Uhrzeit des zur\u00fcckgegebenen Wertes entspricht der im MarketEscort angegebenen Startzeit der Handelssitzung des jeweiligen Handelsplatzes. Der f\u00fcr den Wert verwendete Handelsplatz wird im Instrumet Escort eingestellt und kann in AgenaSript mit der Funktion Instrument.Exchange ermittelt. Beispiel Print(\"Die laufende Handelssitzung hat um \" + Bars.CurrentSessionBeginTime ); Bars.CurrentSessionEndTime Beschreibung Bars.CurrentSessionEndTime liefert das Datum und die Uhrzeit f\u00fcr das Ende der aktuell laufenden Handelssitzung. Datum und Uhrzeit f\u00fcr das Ende der aktuellen Handelssitzung werden auch dann korrekt angegeben, wenn die Funktion von einem Bar in der Vergangenheit aufgerufen wird. Parameter keine R\u00fcckgabewert Typ DateTime Verwendung Bars.GetSessionEnd Weitere Informationen Die Uhrzeit des zur\u00fcckgegebenen Wertes entspricht der im MarketEscort angegebenen Endezeit der Handelssitzung des jeweiligen Handelsplatzes. Der f\u00fcr den Wert verwendete Handelsplatz wird im Instrumet Escort eingestellt und kann in AgenaSript mit der Funktion Instrument.Exchange ermittelt werden. Beispiel Print(\"Die laufende Handelssitzung endet um \" + Bars.CurrentSessionEndTime); Bars.GetBar Beschreibung Bars.GetBar liefert den ersten Bars (vom \u00e4ltesten zum j\u00fcngsten), der dem \u00fcbergebenen Datum bzw. der Uhrzeit entspricht. Siehe auch Bars.GetBarsAgo , Bars.GetByIndex , Bars.GetBarIndex . Parameter Typ DateTime R\u00fcckgabewert Typ IBar Bar-Objekt, des dem Zeitstempel entsprichenden Bars bei Zeitstempel \u00e4lter als der \u00e4lteste Bar: 0 (Null) bei Zeitstempel j\u00fcnger als der letzte Bar: Index des letzten Bars Verwendung Bars.GetBar(DateTime time) Weitere Informationen zur Indizierung von Bars siehe Funktionsweise , Bars zur Benutzung von DateTime siehe http://msdn.microsoft.com/de-de/library/system.datetime.aspx Beispiel Print (\"Der Schlusskurs f\u00fcr den 01.03.2012 um 18:00:00 Uhr war \" + Bars.GetBar(new DateTime(2012, 01, 03, 18, 0, 0)).Close); Bars.GetBarIndex Beschreibung Bars.GetBarIndex liefert den Index eines Bars. \u00dcbergeben werden kann der Methode entweder ein Bar-Objekt oder ein DateTime-Objekt. Siehe Bars.GetBar , Bars.GetBarsAgo , Bars.GetByIndex . Parameter Typ IBar bar oder Typ DateTime R\u00fcckgabewert Typ int der zu dem \u00fcbergebenen Bar-Objekt bzw. dem \u00fcbergebenen DateTime-Objekt geh\u00f6rende Bar-Index Verwendung Bars.GetBarIndex (IBar bar) Bars.GetBarIndex (DateTime dt) Weitere Informationen zur Indizierung von Bars siehe Funktionsweise , Bars Beispiel int barsAgo = 5; IBar bar = Bars.GetBar(Time[barsAgo]); Print(barsAgo + \" und \" + Bars.GetBarIndex(bar) + \" sind in diesem Beispiel gleich.\"); Bars.GetBarsAgo Beschreibung Bars.GetBarsAgo liefert den Index des ersten Bars (vom \u00e4ltesten zum j\u00fcngsten), der dem \u00fcbergebenen Datum bzw. der Uhrzeit entspricht. Siehe auch:: Bars.GetBar , Bars.GetByIndex , Bars.GetBarIndex . Parameter Typ DateTime R\u00fcckgabewert Typ int Index des Bars, der dem Zeitstempel als erstes entspricht. bei Zeitstempel \u00e4lter als der \u00e4lteste Bar: 0 (Null) bei Zeitstempel j\u00fcnger als der letzte Bar: Index des letzten Bars Verwendung Bars.GetBarsAgo(DateTime time) Weitere Informationen zur Indizierung von Bars siehe Funktionsweise , Bars zur Benutzung von DateTime siehe http://msdn.microsoft.com/de-de/library/system.datetime.aspx Beispiel Print(\"Der Bar f\u00fcr den 01.03.2012 um 18:00:00 Uhr hat den Index\" + Bars.GetBarsAgo(new DateTime(2012, 01, 03, 18, 0, 0))); Bars.GetByIndex Beschreibung Bars.GetByIndex liefert das zu einem \u00fcbergebenen Index geh\u00f6rende Bar-Objekt. Siehe Bars.GetBar , Bars.GetBarsAgo , Bars.GetBarIndex . Parameter Typ int Index R\u00fcckgabewert Typ IBar Bar-Objekt zu dem \u00fcbergebenen Index Verwendung Bars.GetByIndex (int Index) Weitere Informationen zur Indizierung von Bars siehe Funktionsweise , Bars Beispiel Print(Close[0] + \" und \" + Bars.GetByIndex(ProcessingBarIndex).Close + \" sind in diesem Beispiel gleich.\"); Bars.GetClose Bars.GetClose(int index) \u2013 siehe Bars.GetOpen . Bars.GetHigh Bars.GetHigh(int index) \u2013 siehe Bars.GetOpen . Bars.GetLow Bars.GetLow(int index) \u2013 siehe Bars.GetOpen . Bars.GetNextSessionTimeSpan Beschreibung Bars.GetNextSessionTimeSpan liefert jeweils Datum und Uhrzeit von Beginn und Ende der n\u00e4chsten Handelssitzung. Siehe Bars.CurrentSessionBeginTime , Bars.CurrentSessionEndTime , Bars.NextSessionBeginTime , Bars.NextSessionEndTime . Parameter DateTime time Datum bzw. Uhrzeit, f\u00fcr die die Daten der folgenden Handelssitzung gesucht werden iBars bars Barobjekt, f\u00fcr das die Daten der folgenden Handelssitzung gesucht werden int barsago Anzahl der Tage in der Vergangenheit, f\u00fcr die die Daten der folgenden Handelssitzung gesucht werden R\u00fcckgabewert DateTime sessionBegin DateTime sessionEnd Hinweis: Das Datum von Beginn und Ende sind jeweils f\u00fcr eine Handelssitzung zusammengeh\u00f6rend. Wenn das \u00fcbergebene Datum dem Ende-Datum der aktuellen Handelssitzung entspricht, kann das zur\u00fcckgegebene Datum f\u00fcr den Beginn der Handelssitzung bereits in der Vergangenheit liegen. Es wird in diesem Fall nicht das Datum der n\u00e4chstfolgenden Handelssitzung zur\u00fcckgegeben. Verwendung Bars.GetNextSessionTimeSpan(Bars bars, int barsAgo, out DateTime sessionBegin, out DateTime sessionEnd) Bars.GetNextSessionTimeSpan(DateTime time, out DateTime sessionBegin, out DateTime sessionEnd) Weitere Informationen Die beiden Signaturen liefern nicht notwendigerweise auch die gleichen Ergebnisse. Bei Verwendung der Bar-Signatur wird der ubergebene Bar daraufhin untersucht, zu welchem Session-Template er geh\u00f6rt. Beginn und Ende der n\u00e4chsten Session werden dann diesem Template entnommen. Bei Verwendung der Zeit-Signatur wierden Datum und Uhrzeit des \u00fcbergebenen Bars genutzt, um die Daten der aktuellen und damit der folgenden Session zu berechnen. Wenn bei Verwendung der Zeit-Signatur ein Zeitstempel \u00fcbergeben wird, der exakt einer Beginn bzw. Endezeit einer Session entspricht, werden Beginn und Ende der davorliegenden Session zur\u00fcckgegeben, d.h. der Zeitstempel wird als \"in der Session enthalten\" angesehen, selbst wenn der fragliche Bar bereits in einer neuen Session enthalten ist. Um dieses Verhaten sicher auszuschlie\u00dfen, ist die Verwendung der Bar-Signatur empfohlen. zur Benutzung von DateTime siehe http://msdn.microsoft.com/de-de/library/system.datetime.aspx Beispiel DateTime sessionBegin; DateTime sessionEnd; protected override void OnCalculate() { Bars.GetNextSessionTimeSpan(Bars, 0, out sessionBegin, out sessionEnd); Print(\"Session Start: \" + sessionBegin + \" Session End: \" + sessionEnd); } Bars.GetOpen Beschreibung Die folgenden Methoden sind aus Gr\u00fcnden der Kompatibilit\u00e4t vorhanden. Bars.GetOpen(int index) liefert das Open des mit <index> referenzierten Bars. Bars.GetHigh(int index) liefert das High des mit <index> referenzierten Bars.. Bars.GetLow(int index) liefert das Low des mit <index> referenzierten Bars. Bars.GetClose(int index) liefert das Close des mit <index> referenzierten Bars. Bars.GetTime(int index) liefert das Zeitstempel des mit <index> referenzierten Bars. Bars.GetVolume(int index) liefert das Volumen des mit <index> referenzierten Bars. Achtung : Die Indizierung weicht von der sonst verwendeten Indexing , Bars ab. Hier beginnt die Indizierung mit 0 am \u00e4ltesten Bar (links im Chart) und endet mit dem j\u00fcngsten Bar rechts im Chart (=Bars.Count-1). Die Indizierungen k\u00f6nnen leicht (in beiden Richtungen!) wie folgt umgerechnet werden: private int Convert(int idx) { return Math.Max(0,Bars.Count-idx-1-(CalculateOnClosedBar?1:0)); } Parameter int index (0 .. Bars.Count-1) R\u00fcckgabewert Typ double f\u00fcr GetOpen, GetHigh, GetLow, GetClose und GetVolume Typ DateTime f\u00fcr GetTime Bars.GetSessionBegin Beschreibung Bars.GetSessionBegin liefert das Datum und die Uhrzeit des Beginns einer bestimmten Handelssitzung. Datum und Uhrzeit f\u00fcr den Beginn der aktuellen Handelssitzung werden auch dann korrekt angegeben, wenn die Funktion von einem Bar in der Vergangenheit aufgerufen wird. Siehe auch weitere Eigenschaften von Bars. Parameter keine R\u00fcckgabewert Typ DateTime Verwendung Bars.GetSessionBegin(DateTime dt) Weitere Informationen Die Uhrzeit des zur\u00fcckgegebenen Wertes entspricht der im MarketEscort angegebenen Startzeit der Handelssitzung des jeweiligen Handelsplatzes. Der f\u00fcr den Wert verwendete Handelsplatz wird im Instrumet Escort eingestellt und kann in AgenaSript mit der Funktion Instrument.Exchange ermittelt werden. Beispiel Print(\"Die Handelssitzung am 25.03.2015 hat um \"+ Bars.GetSessionBegin(new DateTime(2015, 03, 25)) + \" begonnen.\"); } Bars.GetTime Bars.GetTime(int index) \u2013 siehe Bars.GetOpen . Bars.GetVolume Bars.GetVolume(int index) \u2013 siehe Bars.GetOpen . Bars.Instrument Beschreibung Bars.Instrument liefert ein Instrument-Objekt, f\u00fcr das im Chart dargestellte Handelsinstrument. Siehe auch weitere Eigenschaften von Bars. Parameter keine R\u00fcckgabewert Typ Instrument Verwendung Bars.Instrument Weitere Informationen F\u00fcr weitere Informationen zu Handelsinstrumenten siehe unter Instrument . Beispiel // beide Ausgaben liefern das gleiche Ergebnis Print(\"Das aktuell dargestellte Handelsinstrument hat das Symbol \" + Bars.Instrument); Instrument i = Bars.Instrument; Print(\"Das aktuell dargestellte Handelsinstrument hat das Symbol \" + i.Symbol); Bars.IsEod Beschreibung Mit Bars.IsEod kann \u00fcberpr\u00fcft werden, ob es sich um End-of-Day-Bars handelt. Siehe auch weitere Eigenschaften von Bars. Parameter keine R\u00fcckgabewert Typ bool Verwendung Bars.IsEod More Information Innerhalb von OnCalculate() kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden. Falls diese Eigenschaft ausserhalb von OnCalculate ()verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (bars! = Null) ausgef\u00fchrt werden. Beispiel Print(\"Die Bars sind Eod: \" + Bars.IsEod); Bars.IsFalling Beschreibung Bar-Eigenschaften, die verwendet werden, wenn Bar herunterf\u00e4llt. Parameter keine R\u00fcckgabewert keine Beispiel Bars[0].IsFalling; Bars.IsFirstBarInSession Beschreibung Mit Bars.IsFirstBarInSession kann festgestellt werden, ob der aktuelle Bar der erste Bar einer Handelssitzung ist. Siehe auch weitere Eigenschaften von Bars. R\u00fcckgabewert Typ bool true : Der Bar ist der erste Bar einer Handelssitzung false : Der Bar ist nicht der erste Bar einer Handelssitzung Verwendung Bars.IsFirstBarInSession Weitere Informationen Innerhalb von OnCalculate() kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden. Falls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null) ausgef\u00fchrt werden. Beispiel if (Bars.IsFirstBarInSession) Print (\"Die aktuelle Handelsitzung hat um\" + Time [0]); Bars.isGrowing Beschreibung Bar-Eigenschaften verwendet, wenn Bar aufw\u00e4chst. Parameter keine R\u00fcckgabewert keine Beispiel Bars[0].isGrowing; Bars.IsIntraday Beschreibung Mit Bars.IsIntraday kann \u00fcberpr\u00fcft werden, ob es sich um reine Intraday-Bars handelt. Entweder mit Ber\u00fccksichtigung von Ticks - Bars.IsIntraday. R\u00fcckgabewert bool Er gibt \"true\" zur\u00fcck, wenn TimeFrame intra-day (z. B. 1 min, 15 min, 1 h usw.) und \"false\" in anderen F\u00e4llen ist. Verwendung Bars.IsIntraday Beispiel if(Bars.IsIntraday) { Print(\"TimeFrame is Intraday.\"); } else { Print(\"TimeFrame is not Intraday.\"); } Bars.IsNtb Beschreibung Mit Bars.IsNtb kann \u00fcberpr\u00fcft werden, ob es sich um Not-Time-Based-Bars handelt. Bei Ntb-Bars handelt es sich beispielsweise um Point & Figure oder Renko Charts. Siehe auch weitere Eigenschaften von Bars. Parameter keine R\u00fcckgabewert Typ bool Verwendung Bars.IsNtb Weitere Informationen Innerhalb von OnCalculate() kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden. Falls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null) ausgef\u00fchrt werden. Beispiel Print(\"Die angezeigten Bars sind Ntb:\" + Bars.IsNtb); Bars.IsSessionBreak Beschreibung Mit Bars.IsSessionBreak kann ermittelt werden, ob die Bars innerhalb der laufenden Handelssitzung in den im Marktplatz-Escort definierten Handelspausen liegen. Siehe auch weitere Eigenschaften von Bars. Parameter keine R\u00fcckgabewert Typ bool Verwendung Bars.IsSessionBreak Weitere Informationen Beispiel if (Bars.IsSessionBreak) { Print(\"Die B\u00f6rse Xetra hat gerade eine Handelspause.\"); } Bars.LastBarCompleteness Beschreibung Bars.LastBarCompleteness liefert einen Wert, der angibt, zu wieviel Prozent ein Bar bereits fertiggestellt ist. Ein Bar in der Zeiteinheit 10 Minuten ist z.B. nach 5 Minuten genau zu 50% fertig. F\u00fcr nicht-zeitbasierte Chartarten (Kagi, LineBreak, Renko, Range, P&F usw.) und w\u00e4hrend eines Backtests liefert die Eigenschaft immer eine 0. R\u00fcckgabewert double als Prozentwert, d.h. f\u00fcr 30% wird 0.3 zur\u00fcckgegeben- Verwendung Bars.LastBarCompleteness Weitere Informationen Innerhalb von OnCalculate() kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden. Falls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null) ausgef\u00fchrt werden. Beispiel // Ein 60 Min. Chart wird intraday beobachtet. // Jeweils 5 Min. bevor der aktuelle Bar schlie\u00dft, // soll ein akustisches Signal ausgegeben werden. // 55 Min. entsprechen 92% bool remind = false; protected override void OnCalculate() { if (FirstTickOfBar) remind = true; if (remind && Bars.LastBarCompleteness >= 0.92) { remind = false; PlaySound(\"Alert1\"); } } Bars.NextSessionBeginTime Beschreibung Bars.NextSessionBeginTime liefert das Datum und die Uhrzeit des Beginns der auf die aktuell laufende Handelssitzung folgenden Sitzung. Datum und Uhrzeit f\u00fcr den Beginn der n\u00e4chsten Handelssitzung werden auch dann korrekt angegeben, wenn die Funktion von einem Bar in der Vergangenheit aufgerufen wird. Parameter keine R\u00fcckgabewert Typ DateTime Verwendung Bars.GetSessionNextBegin Weitere Informationen Die Uhrzeit des zur\u00fcckgegebenen Wertes entspricht der im MarketEscort angegebenen Startzeit der Handelssitzung des jeweiligen Handelsplatzes. Der f\u00fcr den Wert verwendete Handelsplatz wird im Instrumet Escort eingestellt und kann in AgenaSript mit der Funktion Instrument.Exchange ermittelt werden. Beispiel Print(\"Die n\u00e4chste Handelssitzung beginnt um \" + Bars.NextSessionBeginTime); Bars.NextSessionEndTime Beschreibung Bars.NextSessionEndTime liefert das Datum und die Uhrzeit f\u00fcr das Ende der auf die aktuell laufende Handelssitzung folgenden Sitzung. Datum und Uhrzeit f\u00fcr das Ende der n\u00e4chsten Handelssitzung werden auch dann korrekt angegeben, wenn die Funktion von einem Bar in der Vergangenheit aufgerufen wird. Siehe auch weitere Eigenschaften von Bars. Parameter keine R\u00fcckgabewert Typ DateTime Verwendung Bars.GetSessionNextEnd Weitere Informationen Die Uhrzeit des zur\u00fcckgegebenen Wertes entspricht der im MarketEscort angegebenen Endezeit der Handelssitzung des jeweiligen Handelsplatzes. Der f\u00fcr den Wert verwendete Handelsplatz wird im Instrumet Escort eingestellt und kann in AgenaSript mit der Funktion Instrument.Exchange ermittelt werden. Beispiel Print(\"Die n\u00e4chste Handelssitzung endet um \" + Bars.NextSessionEndTime); Bars.TailBottom Beschreibung Mit dieser Eigenschaft ist es m\u00f6glich die H\u00f6he des unteren Dochtes der Kerze zu ermitteln. Parameter keine R\u00fcckgabewert keine Verwendung Bars[0].TailBottom; Beispiel Print(\"Die H\u00f6he des unteren Dochtes ist: \" + Bars.TailBottom); Bars.TailTop Beschreibung Mit dieser Eigenschaft ist es m\u00f6glich die H\u00f6he des oberen Dochtes der Kerze zu ermitteln. Parameter keine R\u00fcckgabewert keine Verwendung Bars[0].TailTop; Beispiel Print(\"Die H\u00f6he des oberen Dochtes ist: \" + Bars.TailTop); Bars.TicksCountForLastBar Beschreibung Bars.TicksCountForLastBar liefert die Gesamtanzahl der in einem Bar enthaltenen Ticks. Siehe auch weitere Eigenschaften von Bars. Parameter keine R\u00fcckgabewert Typ int Verwendung Bars.TicksCountForLastBar Weitere Informationen Innerhalb von OnCalculate() kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden. Falls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null ) ausgef\u00fchrt werden. Beispiel Print(\"Der aktuelle Bar besteht aus \" + Bars.TicksCountForLastBar + \" Ticks.\"); Bars.TicksCountInTotal Beschreibung Bars.TicksCountInTotal liefert die Gesamtzahl aller Ticks von dem Moment an, von dem die Funktion aufgerufen wird. Siehe auch weitere Eigenschaften von Bars. Parameter keine R\u00fcckgabewert Typ int Verwendung Bars.TicksCountInTotal Weitere Informationen Der Datentyp int hat einen positiven Wertebereich von 2147483647. Wenn 10 Ticks je Sekunde angenommen werden, gibt es auch nach 2 Handelsmonaten bei einem 24h-Handel noch kein \u00dcberlauf. Innerhalb von OnCalculate() kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden. Falls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null ) ausgef\u00fchrt werden. Beispiel //Anwendung in einem 30 Minuten Chart Print(\"Die Gesamtanzahl der gelieferten Ticks in diesem Wert betr\u00e4gt \" + Bars.TicksCountInTotal); Bars.TimeFrame Beschreibung Bars.TimeFrame liefert ein TimeFrame-Objekt, das Informationen zum aktuell verwendeten Zeiteinheit enth\u00e4lt. Siehe auch weitere Eigenschaften von Bars. Parameter keine R\u00fcckgabewert Typ ITimeFrame Verwendung Bars.TimeFrame Weitere Informationen F\u00fcr weitere Informationen zum TimeFrame-Objekt siehe unter TimeFrame . Innerhalb von OnCalculate() kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden. Falls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null ) ausgef\u00fchrt werden. Beispiel //Anwendung in einem 30 Minuten Chart TimeFrame tf = (TimeFrame) Bars.TimeFrame; Print(Bars.TimeFrame); //liefert \"30 Min\" Print(tf.Periodicity); // liefert \"Minute\" Print(tf.PeriodicityValue); // liefert \"30\" BarsCountForSession Beschreibung Bars.BarsCountForSession liefert die Anzahl der Bars, die seit dem Beginn der aktuellen Handelssitzung entstanden sind. Siehe auch weitere Eigenschaften von Bars. R\u00fcckgabewert Typ int Anzahl der Bars Ein Wert von -1 deutet auf ein Problem bei der Ermittlung des Sessionbeginns hin. Verwendung Bars.BarsCountForSession Weitere Informationen Innerhalb von OnCalculate() kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden. Falls diese Eigenschaft ausserhalb von OnBarUpdate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars!= null ) ausgef\u00fchrt werden. Beispiel Print (\"Seit dem Start der letzten Handelssitzung sind\" + Bars.BarsCountForSession + \"Bars entstanden.\"); ProcessingBarIndexLast Beschreibung Gibt an, ob der aktuelle Bar zuletzt berechnet wurde. Parameter keine R\u00fcckgabewert Typ bool Verwendung ProcessingBarIndexLast Weitere Informationen Verwendet f\u00fcr komplizierte Berechnung auf einem letzten Bar Beispiel protected override void OnCalculate() { base.OnCalculate(); if (!IsProcessingBarIndexLast) return; bool isUpdated; } Collections ChartDrawings Beschreibung ChartDrawings ist eine Collection, die alle Zeichenobjekte im Chart enth\u00e4lt. In ChartDrawings werden sowohl dem Chart manuell hinzugef\u00fcgte Zeichenobjekte, als auch von einem Script gezeichnete Objekte aufgenommen. Der Index f\u00fcr ChartDrawings ist der eindeutige Name der Zeichenobjekte (string tag). Verwendung ChartDrawings [string tag] Beispiele Hinweis: Um die Interface-Definitionen nutzen zu k\u00f6nnen, mu\u00df in den Using-Anweisungen using AgenaTrader.Plugins; // Anzahl der Zeichenobjekte auf dem Chart und deren Tags ausgeben Print(\"Auf dem Chart befinden sich \" + ChartDrawings.Count + \" Zeichenobjekte\"); foreach (IDrawObject draw in ChartDrawings) Print(draw.Tag); //Eine schwarze Trendlinie zeichnen ... AddChartLine(\"MyLine\", true, 10, Close[10], 0, Close[0], Color.Black, DashStyle.Solid, 3); / ... und die Farbe auf Rot \u00e4ndern ITrendLine line = (ITrendLine) ChartDrawings[\"MyLine\"]; if (line != null) line.Pen.Color = Color.Red; // alle vertikalen Linien in Chart auf Linienst\u00e4rke 3 setzen, // und nicht verschiebbar und nicht editierbar machen foreach (IDrawObject draw in ChartDrawings) if (draw is IVerticalLine) { IVerticalLine vline = (IVerticalLine) draw; vline.IsLocked = true; vline.Editable = false; vline.Pen.Width = 3; } InSeries Beschreibung InSeries ist ein DatenSerien Objekt, in dem die Eingangsdaten f\u00fcr einen Indikator bzw. eine Strategie enthalten sind. Wird ein Indikator ohne explizite Angabe von Eingangsdaten aufgerufen, wird immer der Schlusskurs (Close) der aktuell im Chart geladenen Kursdaten verwendet. Bei einem Aufruf von SMA(20) wird der gl. Durchschnitt auf die Schlusskurse der aktuellen Chart-Kursdaten berechnet (dies entspricht SMA(Close, 20). InSeries[0] = Close[0]. Bei dem Aufruf von SMA(High, 20) werden die H\u00f6chstkurse der geladenen Daten f\u00fcr die Berechnung des gl. Durchschnitts verwendet. InSeries[0] = High[0]. So kann jede beliebige Datenreihe als Input f\u00fcr einen Indikator verwendet werden. double d = RSI ( SMA (20), 14, 3)[0]; berechnet beispielsweise den 14-Perioden-RSI \u00fcber die SMA(20) Werte als Eingangsdatenreihe. InSeries[0] = SMA(20)[0]. Verwendung InSeries InSeries[int barsAgo] Beispiele Print(\"Die Eingangsdaten f\u00fcr den Indikator sind \" + InSeries[0]); Lines Beschreibung Lines ist eine Collection, die die LevelLine Objekte eines Indikators enth\u00e4lt. Wenn einem Indikator mit der Add() Methode ein Line-Objekt hinzugef\u00fcgt wird, wird dieses automatisch der Collection Lines hinzugef\u00fcgt. Die Reihenfolge der Add-Befehle bestimmt dabei auch die Sortierung in Lines. Der erste Aufruf von Add() erzeugt Lines[0], der n\u00e4chste Lines[1] usw. Siehe auch OutputDescriptor . Verwendung Lines[int index] Beispiele // Add \"using System.Drawing.Drawing2D;\" for DashStyle protected override void OnInit() { Add(new LevelLine(Color.Blue, 70, \"Upper\")); // gespeichert in Lines[0] Add(new LevelLine(Color.Blue, 30, \"Lower\")); // gespeichert in Lines[1] } protected override void OnCalculate() { // Wenn RSI \u00fcber 70, Eigenschaften der Linie \u00e4ndern if (RSI(14 ,3) >= 70) { Lines[0].Width = 3; Lines[0].Color = Color.Red; Lines[0].DashStyle = DashStyle.Dot; } else { Lines[0].Width = 1; Lines[0].Color = Color.Blue; Lines[0].DashStyle = DashStyle.Solid; } } PlotColors Beschreibung PlotColors ist eine Collection, die die ColorSeries aller Plot-Objekte enth\u00e4lt. Wenn einem Indikator mit der Add() Methode ein Plot hinzugef\u00fcgt wird, wird automatisch auch ein ColorSeries-Objekt erzeugt und der Collection PlotColors hinzugef\u00fcgt. Die Reihenfolge der Add-Befehle bestimmt dabei auch die Sortierung in PlotColors. Der erste Aufruf von Add() erzeugt PlotColors[0], der n\u00e4chste PlotColors[1] usw. Verwendung PlotColors[int PlotIndex][int barsAgo] Weitere Informationen Informationen zur Klasse Collection: http://msdn.microsoft.com/en-us/library/ybcx56wz%28v=vs.80%29.aspx Beispiel using System; using System.Collections.Generic; using System.ComponentModel; using System.Drawing; using AgenaTrader.API; namespace AgenaTrader.UserCode { [Description(\"PlotColor Demo\")] public class PlotColorsDemo : UserIndicator { public DataSeries SMA20 { get {return Outputs[0];} } public DataSeries SMA50 { get {return Outputs[1];} } public DataSeries SMA100 { get {return Outputs[2];} } private Pen pen; protected override void OnInit() { // Linienst\u00e4rke (Width) auf 4 einstellen pen = new Pen(Color.Empty, 4); // Dem Chart drei Plots mit der def. Linienst\u00e4rke hinzuf\u00fcgen Add(new OutputDescriptorOutputDescriptor(pen, OutputSeriesDisplayStyle.LevelLine, \"SMA20\" )); //attached to PlotColors[0] Add(new OutputDescriptor(pen, OutputSeriesDisplayStyle.LevelLine, \"SMA50\" )); //attached to PlotColors[1] Add(new OutputDescriptor(pen, OutputSeriesDisplayStyle.LevelLine, \"SMA100\")); //attached to PlotColors[2] IsOverlay = true; } protected override void OnCalculate() { // Den drei Plots Werte zuweisen SMA20.Set (SMA(20) [0]); SMA50.Set (SMA(50) [0]); SMA100.Set(SMA(100)[0]); // Farben je nach Kursverlauf \u00e4ndern if (IsSerieRising(Close)) { PlotColors[0][0] = Color.LightGreen; PlotColors[1][0] = Color.Green; PlotColors[2][0] = Color.DarkGreen; } else if (IsSerieFalling(Close)) { PlotColors[0][0] = Color.LightSalmon; PlotColors[1][0] = Color.Red; PlotColors[2][0] = Color.DarkRed; } else { PlotColors[0][0] = Color.LightGray; PlotColors[1][0] = Color.Gray; PlotColors[2][0] = Color.DarkGray; } } } } OutputDescriptor Beschreibung OutputDescriptor ist eine Collection, die die Plot-Objekte eines Indikators enth\u00e4lt. Wenn einem Indikator mit der Add()-Methode ein Plot-Objekt hinzugef\u00fcgt wird, wird dieses automatisch der Collection Plots hinzugef\u00fcgt. Die Reihenfolge der Add-Befehle bestimmt dabei auch die Sortierung in Plots. Der erste Aufruf von Add() erzeugt OutputDescriptor [0], der n\u00e4chste OutputDescriptor[1]\\ usw. Siehe auch Lines . Verwendung OutputDescriptor[int index] Beispiele protected override void OnInit() { AddOutput(new OutputDescriptor(Color.FromKnownColor(KnownColor.Black), \"MySMA 20\")); // saved to OutputDescriptor[0] } protected override void OnCalculate() { Value.Set(SMA(20)[0]); // Wenn Kurs \u00fcber SMA, Plot gr\u00fcn f\u00e4rben, sonst rot if (Close[0] > SMA(20)[0]) OutputDescriptor[0].PlotColor = Color.Green; else OutputDescriptor[0].PlotColor = Color.Red; } Values Beschreibung Values ist eine Collection, die die DataSeries-Objekte eines Indikators enth\u00e4lt. Wenn einem Indikator mit der Add()-Methode ein Plot hinzugef\u00fcgt wird, wird automatisch auch ein Value-Objekt erzeugt und der Collection Values hinzugef\u00fcgt. Die Reihenfolge der Add-Befehle bestimmt dabei auch die Sortierung in Values. Der erste Aufruf von Add() erzeugt Values[0], der n\u00e4chste Values[1] usw. Value ist immer identisch mit Values[0]. Verwendung Outputs[int index] Outputs[int index][int barsAgo] Weitere Informationen Die f\u00fcr eine Collection bekannten Methoden Set(), Reset() und Count() sind auf Value bzw. Values anwendbar. Informationen zur Klasse Collection: http://msdn.microsoft.com/en-us/library/ybcx56wz%28v=vs.80%29.aspx Beispiel // \u00dcberp\u00fcfung des zweiten Indikatorwertes (d.h. der sekund\u00e4ren DatenSerie) // von vor einem Bar // und in Abh\u00e4ngigkeit davon Setzen des aktuellen Indikatorwertes if (Outputs[1][1] < High[0] - Low[0]) Value.Set(High[0] - Low[0]); else Value.Set(High[0] - Close[0]); Data Series Beschreibung Datenserien werden in AgenaTrader zum einen unterschieden in die frei f\u00fcr die eigene Programmierung verwendbaren Datenserien zum Speichern von Werten unterschiedlicher Datentypen und zum anderen in die in AgenaTrader fest integrierten Datenserien, die die Kursdaten der einzelnen Bars enthalten. Die letzteren werden hier vorgestellt. Das Konzept von Datenserien wird sehr konsequent und durchg\u00e4ngig verfolgt. Alle Kursdaten der einzelnen Bars sind in Datenserien organisiert. Folgende Datenserien sind verf\u00fcgbar: Open Opens High Highs Low Lows Close Closes Median Medians Typical Typicals Weighted Weighteds Time Times TimeFrame TimeFrames Volume Volumes Open Beschreibung Open ist eine DataSeries vom Typ DataSeries , in der die historischen Er\u00f6ffnungskurse gespeichert sind. Parameter BarsAgo Indexwert (s. Bars ) Verwendung Open Open[int barsAgo] Weitere Informationen Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Beispiel // Er\u00f6ffnungskurs der aktuellen Periode Print(Time[0] + \" \" + Open[0]); // Er\u00f6ffnungskurs des Bars von vor 5 Perioden Print(Time[5] + \" \" + Open[5]); // aktueller Wert f\u00fcr den SMA 14 \u00fcber die Er\u00f6ffnungskurse (gerundet) Print(\"SMA(14) calculated using the opening prices: \" + Instrument.Round2TickSize(SMA(Open, 14)[0])); Opens Beschreibung Opens ist ein Array von Datenserien, welches alle Open-Datenserien enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird. Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge: Opens[0] die Open-Dataseries der Chart-Zeiteinheit Opens[1] die Open-Dataseries aller Bars auf Tagesbasis Opens[2] die Open-Dataseries aller Bars auf Wochenbasis. Opens[0][0] entspricht Open[0]. Siehe auch MultiBars Parameter barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries (s. Bars ) barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten Verwendung Opens[int barSeriesIndex] Opens[int barSeriesIndex][int barsAgo] Weitere Informationen Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Beispiel Siehe Beispiel unter Multibars . High Description High ist eine DataSeries vom Typ DataSeries , in der die historischen H\u00f6chstkurse gespeichert sind. Parameter barsAgo Indexwert (s. Bars ) Verwendung High High[int barsAgo] Weitere Informationen Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Beispiel //H\u00f6chstkurs der aktuellen Periode Print(Time[0] + \" \" + High[0]); // H\u00f6chstkurs des Bars von vor 5 Perioden Print(Time[5] + \" \" + High[5]); // aktueller Wert f\u00fcr den SMA 14 \u00fcber die H\u00f6chstkurse (gerundet) Print(\"SMA(14) Calculated using the high prices: \" + Instrument.Round2TickSize(SMA(High, 14)[0])); Highs Beschreibung Highs ist ein Array von [ DataSeries ][1] welches alle High-Datenserien enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge. Highs[0] die High-Dataseries der Chart-Zeiteinheit Highs[1] die High-Dataseries aller Bars auf Tagesbasis Highs[2] die High-Dataseries aller Bars auf Wochenbasis. Highs[0][0] entspricht High[0]. Siehe auch MultiBars . Parameter barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries (s. Bars ) barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten Verwendung Highs[int barSeriesIndex] Highs[int barSeriesIndex][int barsAgo] Weitere Informationen Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Beispiel Siehe Beispiel unter Multibars . Low Beschreibung Low ist eine DataSeries vom Typ DataSeries , in der die historischen Tiefstkurse gespeichert sind. Parameter barsAgo Indexwert (s. Bars ) Verwendung Low Low[int barsAgo] Weitere Informationen Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Beispiel // Tiefstkurs der aktuellen Periode Print(Time[0] + \" \" + Low[0]); // Tiefstkurs des Bars von vor 5 Perioden Print(Time[5] + \" \" + Low[5]); // aktueller Wert f\u00fcr den SMA 14 \u00fcber die Tiefstkurse (gerundet) Print(\"SMA(14) calculated using the high prices: \" + Instrument.Round2TickSize(SMA(Low, 14)[0])); Lows Beschreibung Lows ist ein Array von [ DataSeries ][1] welches alle Low -Datenserien enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird. Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge. Lows[0] die Low-Dataseries der Chart-Zeiteinheit Lows[1] die Low-Dataseries aller Bars auf Tagesbasis Lows[2] die Low-Dataseries aller Bars auf Wochenbasis. Lows[0][0] entspricht Low[0]. Siehe auch MultiBars . Parameter barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten Verwendung Lows[int barSeriesIndex] Lows[int barSeriesIndex][int barsAgo] Weitere Informationen Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Beispiel Siehe Beispiel unter Multibars . Close Beschreibung Close ist eine DataSeries vom Typ DataSeries , in der die historischen Schlusskurse gespeichert sind. Parameter barsAgo Indexwert (s. Bars ) Verwendung Close Close[int barsAgo] Weitere Informationen Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Indikatoren werden standardm\u00e4\u00dfig \u00fcber die Schlusskurse berechnet. Die Angabe der Input-Serie kann weggelassen werden (siehe Beispiel unten). Beispiel // Schlusskurs der aktuellen Periode Print(Time[0] + \" \" + Close[0]); // Schlusskurs des Bars von vor 5 Perioden Print(Time[5] + \" \" + Close[5]); // aktueller Wert f\u00fcr den SMA 14 \u00fcber die Schlusskurse (gerundet) Print(\"SMA(14) calculated using the closing prices: \" + Instrument.Round2TickSize(SMA(Close, 14)[0])); // Close kann auch weggelassen werden, da es per Default verwendet wird. Print(\"SMA(14) calculated using the closing prices: \" + Instrument.Round2TickSize(SMA(14)[0])); Closes Beschreibung Closes ist ein Array von [ DataSeries ][1] welches alle Low -Datenserien enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird. Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge. Closes[0] die Close-Dataseries der Chart-Zeiteinheit Closes[1] die Close-Dataseries aller Bars auf Tagesbasis Closes[2] die Close-Dataseries aller Bars auf Wochenbasis. Closes[0][0] entspricht Close[0]. Siehe auch MultiBars . Parameter barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten Verwendung Closes[int barSeriesIndex] Closes[int barSeriesIndex][int barsAgo] Weitere Informationen Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Beispiel Siehe Beispiel unter Multibars . Median Beschreibung Median ist eine DataSeries vom Typ DataSeries in der die historischen Median-Werte gespeichert sind. Der Median-Preis eines Bars ergibt sich aus (High + Low) / 2. Siehe auch Typical und Weighted . Parameter barsAgo Indexwert (s. Bars ) Verwendung Median Median[int barsAgo] Weitere Informationen Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Informationen zu Median, Typical und Weighted: http://blog.nobletrading.com/2009/12/median-price-typical-price-weighted.html Beispiel // Median-Preis der aktuellen Periode Print(Time[0] + \" \" + Median[0]); // Median-Preis des Bars von vor 5 Perioden Print(Time[5] + \" \" + Median[5]); // aktueller Wert f\u00fcr den SMA 14 \u00fcber die Median-Preise (gerundet) Print(\"SMA(14) calculated using the median prices: \" + Instrument.Round2TickSize(SMA(Median, 14)[0])); Medians Beschreibung Medians ist ein Array von [ DataSeries ][1] welches alle Median -Datenserien enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird. Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge. Medians[0] die Median-Dataseries der Chart-Zeiteinheit Medians[1] die Median-Dataseries aller Bars auf Tagesbasis Medians[2] die Median-Dataseries aller Bars auf Wochenbasis. Medians[0][0]entspricht Medians[0]. Siehe auch MultiBars . Parameter barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten Verwendung Medians[int barSeriesIndex] Medians[int barSeriesIndex][int barsAgo] Weitere Informationen Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Informationen zu Median, Typical und Weighted: http://www.investopedia.com/terms/m/median.asp Beispiel Siehe Beispiel unter Multibars . Typical Beschreibung Typical ist eine DataSeries vom Typ DataSeries in der die historischen Typical-Werte gespeichert sind. Der Typical-Preis eines Bars ergibt sich aus (High + Low + Close) / 3. Siehe auch Median und Weighted . Parameter barsAgo Indexwert (s. Bars ) Verwendung Typical Typical[int barsAgo] Weitere Informationen Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Informationen zu Median, Typical und Weighted: https://technicianapp.com/resources/typical-price/ Beispiel // Typical-Preis der aktuellen Periode Print(Time[0] + \" \" + Typical[0]); // Typical-Preis des Bars von vor 5 Perioden Print(Time[5] + \" \" + Typical[5]); // aktueller Wert f\u00fcr den SMA 14 \u00fcber die Typical-Preise (gerundet) Print(\"SMA(14) calculated using the typical price: \" + Instrument.Round2TickSize(SMA(Typical, 14)[0])); Typicals Beschreibung Typicals ist ein Array von Datenserien , welches alle Typical -Datenserien enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird. Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge. Typicals[0] die Typical-Dataseries der Chart-Zeiteinheit Typicals[1] die Typical-Dataseries aller Bars auf Tagesbasis Typicals[2] die Typical-Dataseries aller Bars auf Wochenbasis. Typicals[0][0] entspricht Typicals[0]. Siehe auch MultiBars . Parameter barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten Verwendung Typicals[int barSeriesIndex] Typicals[int barSeriesIndex][int barsAgo] Weitere Informationen Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Beispiel Siehe Beispiel unter Multibars . Weighted Beschreibung Weighted ist eine DataSeries vom Typ DataSeries , in der die historischen Weighted-Werte gespeichert. Der Weighted-Preis eines Bars ergibt sich aus (high + low + 2*close) / gewichtet auf den Schlusskurs. Siehe auch Median und Typical . Parameter barsAgo Indexwert (s. Bars ) Verwendung Weighted[int barsAgo] Weitere Informationen Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Informationen zu Median, Typical und Weighted: http://www.stock-trading-infocentre.com/pivot-points.html Beispiel // Weighted-Preis der aktuellen Periode Print(Time[0] + \" \" + Weighted[0]); // Weighted-Preis des Bars von vor 5 Perioden Print(Time[5] + \" \" + Weighted[5]); // aktueller Wert f\u00fcr den SMA 14 \u00fcber die Weighted-Preise (gerundet) Print(\"SMA(14) calculated using the weighted price: \" + Instrument.Round2TickSize(SMA(Weighted, 14)[0])); Weighteds Beschreibung Weighteds ist ein Array von [ DataSeries ][1] welches alle Weighted -Datenserien enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird. Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge. Weighteds[0] die Weighted-Dataseries der Chart-Zeiteinheit Weighteds[1] die Weighted-Dataseries aller Bars auf Tagesbasis Weighteds[2] die Weighted-Dataseries aller Bars auf Wochenbasis Weighteds[0][0] entspricht Weighteds[0]. Siehe auch MultiBars . Parameter barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten Verwendung Weighteds[int barSeriesIndex] Weighteds[int barSeriesIndex][int barsAgo] Weitere Informationen Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Beispiel Siehe Beispiel unter Multibars . Time Beschreibung Time ist eine DataSeries vom Typ DateTimeSeries , in der die Zeitstempel der einzelnen Bars gespeichert sind. Parameter barsAgo Indexwert (s. Bars ) Verwendung Time Time[int barsAgo] Weitere Informationen Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Beispiel // Zeitstempel der aktuellen Periode Print(Time[0]); // Zeitstempel des Bars von vor 5 Perioden Print(Time[5]); Times Beschreibung Times ist ein Array von DataSeries welches alle Time -Datenserien enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird. Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge. Times[0] die Time-Dataseries der Chart-Zeiteinheit Times[1] die Time-Dataseries aller Bars auf Tagesbasis Times[2] die Time-Dataseries der Chart-Zeiteinheit Times[0][0] entspricht Times[0]. Siehe auch MultiBars . Parameter barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten Verwendung Times[int barSeriesIndex] Times[int barSeriesIndex][int barsAgo] Weitere Informationen Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Beispiel Siehe Beispiel unter Multibars . Volume Beschreibung Volume ist eine DataSeries vom Typ DataSeries , in der die historischen Ums\u00e4tze gespeichert sind. Parameter barsAgo Indexwert (s. Bars ) Verwendung Volume Volume[ int barsAgo] Weitere Informationen Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Der vom Indikator VOL() zur\u00fcckgelieferte Wert ist identisch mit dem hier beschriebenen Volumen. Z.B. liefert Vol()[3] den gleichen Wert wie Volume[3]. Beispiel // Volumen der aktuellen Periode Print(Time[0] + \" \" + Volume[0]); // Volumen des Bars von vor 5 Perioden Print(Time[5] + \" \" + Volume[5]); // aktueller Wert f\u00fcr den SMA 14 \u00fcber das Volumen (gerundet) Print(\"SMA(14) berechnet \u00fcber das Volumen: \" + Instrument.Round2TickSize(SMA(Volume, 14)[0])); Volumes Beschreibung Volumes ist ein Array von DataSeries welches alle Volume -Datenserien enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird. Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge. Volumes[0] die Volume-Dataseries der Chart-Zeiteinheit Volumes[1] die Volume-Dataseries aller Bars auf Tagesbasis Volumes[2] die Volume-Dataseries aller Bars auf Wochenbasis. Volumes[0][0] entspricht Volumes[0]. Siehe auch MultiBars . Parameter barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten Verwendung Volumes[int barSeriesIndex] Volumes[int barSeriesIndex][int barsAgo] Weitere Informationen Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Beispiel Siehe Beispiel unter Multibars . TimeFrame Beschreibung TimeFrame ist ein Zeitrahmenobjekt. Diese Einstellung/Men\u00fcpunkt wird verwendet, um die aktuelle Zeiteinheit zu lesen, nicht um sie zu festzulegen Verwendung TimeFrame TimeFrames Beschreibung TimeFrames ist ein Array von TimeFrame-Objekten, welches f\u00fcr jedes Bar-Objekt ein separates TimeFrame-Objekt enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird. Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge: TimeFrames [0] TimeFrame der prim\u00e4ren Datenserie (Chart-Zeiteinheit) TimeFrames [1] Print (TimeFrames[1]); // liefert \"1 Day\" TimeFrames [2] Print (TimeFrames[2]); // liefert \"1 Week\" TimeFrames [0] entspricht TimeFrame . Siehe auch MultiBars . Parameter barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten Verwendung TimeFrames [int barSeriesIndex] Beispiel if (ProcessingBarSeriesIndex == 0 && ProcessingBarIndex == 0) for (int i = BarsArray.Count-1; i >= 0; i--) Print(\"The Indicator \" + this.Name + \" uses Bars of the Timeframe \" + TimeFrames[i]); Instruments \"Instrument\" bezeichnet einen handelbaren Wert, wie z.B. eine Aktie, einen ETF, einen Future, einen CFD usw. Ein Instrument hat viele Eigenschaften, die in einem selbst erstellten AgenaScript verwendet werden k\u00f6nnen. Instrument.Compare Instrument.Currency Instrument.Digits Instrument.ETF Instrument.Exchange Instrument.Expiry Instrument.GetCurrencyFactor Instrument.InstrumentType Instrument.MainSector Instrument.Margin Instrument.Name Instrument.PointValue Instrument.Round2TickSize Instrument.Symbol Instrument.TickSize Innerhalb von OnCalculate() k\u00f6nnen diese Eigenschaften verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Funktion OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Instrument-Objekt vorhanden. Falls diese Eigenschafte ausserhalb von OnCalculate() , verwendet werden, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null ) Instrument.Compare Beschreibung Die Funktion Instrument.Compare vergleicht 2 Kursdaten unter Ber\u00fccksichtigung der richtigen Anzahl Nachkommastellen. Die kleinstm\u00f6gliche Preis\u00e4nderung wird durch den Wert TickSize angegeben. Diese Funktion vereinfacht den sonst etwas aufw\u00e4ndigeren Vergleich mit Hilfe von Floating-Point-Operationen. Parameter double value1 double value2 R\u00fcckgabewert Typ int 1 - Kurs1 ist gr\u00f6\u00dfer als Kurs2 -1 - Kurs1 ist kleiner als Kurs2 0 - Kurs1 und Kurs2 sind gleich Verwendung Instrument.Compare(double Value1, double Value2) Weitere Informationen Be aware this function compares prices based on TickSize. If the ticksize of your instrument is 0.01 these prices will be rounded and compared on 2 decimal digits. If you want a regular comparation of two numbers, you should use the operator \"greater than\" (>) or the operator \"smaller than\" (<). More infomation about math.round() Wenn TickSize z.B. 0,00001 ist, wie bei FX-Werten \u00fcblich, dann liefert Compare(2, 1.99999) eine 1, d.h. 2 ist gr\u00f6\u00dfer als 1.99999 Compare(2, 2.000001) eine 0, d.h. die Kurse sind gleich Compare(2, 1.999999) eine 0, d.h. die Kurse sind gleich Compare(2, 2.00001) eine -1, d.h. 2 ist kleiner als 2.00001. Beispiel Print(Instrument.Compare(2, 1.999999)); Instrument.Currency Beschreibung Instrument.Currency liefert ein Currencies-Objekt zur\u00fcck, das die jeweilige W\u00e4hrung beinhaltet, in der das Instrument gehandelt wird. Parameter keine R\u00fcckgabewert eine Konstante vom Typ public enum Currencies Verwendung Instrument.Currency Weitere Informationen \u00dcbliche W\u00e4hrungen sind z.B. AUD, CAD, EUR, GBP, JPY oder USD. Beispiel Print(Instrument.Name + \"wird in \" + Instrument.Currency + \" gehandelt\".); Instrument.Digits Beschreibung Instrument.Digits liefert die Anzahl der Nachkommastellen, mit denen der Kurs des Instrument notiert wird. Parameter keine R\u00fcckgabewert int Digits Verwendung Instrument.Digits Weitere Informationen Aktie werden \u00fcblicherweise mit 2 Stellen nach dem Komma gehandelt. Bei Forex sind es je nach Datenanbieter 4 oder 5 Stellen. Die Funktion findet u.a. Verwendung f\u00fcr das Formatieren von Ausgaben oder zur Rundung von Kursdaten. Siehe auch TickSize und Instrument.Round2Ticks , Instrument.Round2TickSize . Ausf\u00fchrliche Anleitung zum: Formatieren von Zahlen. . Beispiel Print(\"Der Kurs von \" +Instrument.Name + \" wird mit einer Genauigkeit von\" + Instrument.Digits +\" Nachkommastellen angegeben.\"); Instrument.ETF Beschreibung Instrument.ETF dient der Unterscheidung zwischen einer Aktie und einem ETF. Dies ist notwendig, da ETF's von den B\u00f6rsen auch als \"Stock\" (dt. Aktie) angesehen werden.. Parameter keine R\u00fcckgabewert Typ bool Verwendung Instrument.ETF Weitere Informationen Was ist ein ETF? Wikipedia: http://de.wikipedia.org/wiki/Exchange-traded_fund Beispiel if (Instrument.InstrumentType == InstrumentType.Stock) if (Instrument.ETF) Print(\"Der Wert ist ein Exchange-traded Fund.\"); else Print(\"Der Wert ist eine Aktie.\"); Instrument.Exchange Beschreibung Instrument.Exchange (Exchange = dt. B\u00f6rse) liefert die Bezeichnung des B\u00f6rsenhandelsplatzes f\u00fcr das aktuelle Instrument. Parameter keine R\u00fcckgabewert ein Exchange-Objekt vom Typ public enum Exchanges Verwendung Instrument.Exchange Weitere Informationen \u00dcbersicht B\u00f6rsenhandelspl\u00e4tze Beispiel Print(\"Das Instrument \" + Instrument.Name +\" wird an der B\u00f6rse \" + Instrument.Exchange + \" gehandelt.\"); Instrument.Expiry Beschreibung Instrument.Expiry gibt das Datum (Monat und Jahr) des Ablauf eines Finanzinstrumentes an. Nur derivative Handelsinstrumente, wie Optionen oder Futures besitzen ein Ablaufdatum, das sog. Verfallsdatum. Parameter keine R\u00fcckgabewert Typ DateTime F\u00fcr Instrumente ohne Verfallsdatum wird Instrument.Expiry auf DateTime.MaxValue (= 31.12.9999 23.59:59) gesetzt. Verwendung Instrument.Expiry Weitere Informationen Das Verfallsdatum (Expiry) ist auch im Instrument Escort ersichtlich: Beispiel Print(\"Das Instrument \" + Instrument.Name +\" verf\u00e4llt am \" + Instrument.Expiry); Instrument.GetCurrencyFactor Beschreibung Instrument.GetCurrencyFactor liefert einen Umrechnungsfaktor zur\u00fcck, mit dessen Hilfe man den Kurs eines Instruments in die W\u00e4hrung des Accounts umrechnen kann. Parameter Typ Currencies R\u00fcckgabewert ein double Verwendung Instrument.GetCurrencyFactor(Currencies) Weitere Informationen \u00dcbliche W\u00e4hrungen sind z.B. AUD, CAD, EUR, GBP, JPY oder USD. Beispiel Protected override void OnCalculate() { double currFactor = Instrument.GetCurrencyFactor(Account.Currency); Print(Close[0] + \" in \" + Instrument.Currency.ToString() + \" = \" + (Close[0] * currFactor) + \" in \" + Account.Currency.ToString()); } Instrument.InstrumentType Beschreibung Instrument.InstrumentType liefert ein Typ-Objekt des Handelsinstrumentes. Parameter keine R\u00fcckgabewert Objekt vom Typ public enum InstrumentType Verwendung Instrument.InstrumentType Weitere Informationen M\u00f6gliche Werte sind: Future, Stock, Index, Currency, Option, CFD und Unknown. Einen Typ ETF gibt es nicht. ETF's sind vom Typ Stock, siehe Instrument.ETF . Der Instrument-Typ ist auch im Instrument Escort ersichtlich: Beispiel Print(\"Das Instrument \" + Instrument.Name + \" ist vom Typ \" + Instrument.InstrumentType); Instrument.MainSector Beschreibung Instrument.MainSector liefert den Hauptsektor des Handelsinstrumentes zur\u00fcck. Parameter keine R\u00fcckgabewert String Verwendung Instrument.MainSector Weitere Informationen Der Hauptsektor ist auch im Instrument Escort ersichtlich: Beispiel Print(\"Das Instrument \" + Instrument.Name + \" ist im Sektor \" + Instrument.MainSector + \" t\u00e4tig.\"); Instrument.Margin Beschreibung Instrument.Margin liefert die erforderliche Margin des Handelsinstrumentes zur\u00fcck. Parameter keine R\u00fcckgabewert int Verwendung Instrument.Margin Weitere Informationen Margin ist auch im Instrument Escort ersichtlich: Beispiel Print(\"Das Instrument\" + Instrument.Name + \" hat eine Margin von \" + Instrument.Margin); Instrument.Name Beschreibung Instrument.Name liefert die Bezeichnung des Handelsinstrumentes. Parameter keine R\u00fcckgabewert Typ string Verwendung Instrument.Name Weitere Informationen Der Instrument Name ist auch im Instrument Escort ersichtlich: Beispiel Print(\"Das aktuell im Chart geladene Instrument hei\u00dft \" + Instrument.Name); Instrument.PointValue Beschreibung Instrument.PointValue liefert den Geldwert f\u00fcr die Bewegung eines Instrumentes von einem vollen Punkt. Parameter keine R\u00fcckgabewert Typ double - Punktwert Verwendung Instrument.PointValue Weitere Informationen Beispiele verschieder Punktwerte (je St\u00fcck, CDF, Futurekontrakt, Lot usw.) Aktie: im .allg. 1,00 Euro bzw. 1,00 USD. EUR/USD: 100,000 USD Dax-Future: 25,00 Euro Tickwert Der Tickwert ergibt sich, wenn man den Punktwert mit der TickGr\u00f6\u00dfe (TickSize) multipliziert. z.B. hat der E-mini S&P 500 einen Punktwert von $ 50. Die TickSize betr\u00e4gt 0,25. Es braucht also eine Bewegung von 4 Ticks f\u00fcr einen vollen Punkt. Aus 50 * 0,25 = 50 / 4 ergibt sich ein Tickwert von 12,50 $/ je Tick. Der Punktwert ist auch im Instrument Escort ersichtlich: Beispiel Print(\"Wenn \" + Instrument.Name + \" einen vollen Punkt steigt, entspricht dies dem Gegenwert von \" + Instrument.PointValue + \" \" + Instrument.Currency); Instrument.Round2TickSize Beschreibung Die Funktion Instrument.Round2TickSize rundet einen \u00fcbergebenen Kurswert auf den kleinstm\u00f6glichen Wert, der durch die Tickgr\u00f6\u00dfe (TickSize) des Instrumentes teilbar ist. Parameter double - Kurswert R\u00fcckgabewert double Verwendung Instrument.Round2TickSize(double MarketPrice) Weitere Informationen Die Anzahl der Nachkommastellen, auf die gerundet wird, ist je nach Instrument unterschiedlich. Ist das Instrument eine Aktie, wird auf 2 Nachkommastellen gerundet, bei einem Forex-Wert auf 4 bzw. 5 Nachkommastellen. Siehe auch TickSize und Instrument.Digits . Beispiele f\u00fcr professionelle Formatting , Formatting of Numbers . Beispiel double Price = 12.3456789; Print(Price + \" gerundet auf einen f\u00fcr \" + Instrument.Name + \" g\u00fcltigen Kurs ist \" + Instrument.Round2TickSize(Price)); Instrument.Symbol Beschreibung Instrument.Symbol liefert das Symbol, unter welchem das Handelsinstrument in AgenaTrader eindeutig identifizierbar ist. Anhand des Symbols werden die Mappings zu den verschiedenen Datenanbietern und Brokern verwaltet. Parameter keine R\u00fcckgabewert Typ string Verwendung Instrument.Symbol Weitere Informationen Mit dem Symbol werden gleiche Aktion an verschiedenen B\u00f6rsenpl\u00e4tzen unterschieden. Das Symbol BMW.DE ist z.B. die BMW-Aktie an der Xetra, BMW.CFD ist der CFD auf die BMW-Aktie. Das Instrument Symbol ist auch im Instrument Escort ersichtlich: Beispiel Print(\"Das aktuell im Chart geladene Instrument hat das Symbol \" + Instrument.Symbol); Instrument.TickSize Beschreibung Die Tickgr\u00f6\u00dfe oder TickSize ist die kleinste m\u00f6gliche Einheit um die sich ein Finanzinstrument bewegen kann. Dies ist umgangssprachlich 1 Tick. Parameter keine R\u00fcckgabewert double Verwendung Instrument.TickSize oder vereinfacht TickSize Weitere Informationen Das Schl\u00fcsselwort TickSize entspricht Instrument.TickSize. Beide Aufrufe liefern identische Werte und sind gegeneinander austauschbar. Beispiele Aktie: 0,01 ES-Future: 0,25 EUR/USD: 0,00001 Siehe auch Instrument.PointValue und Instrument.Digits . Beispiele f\u00fcr professionelle Formatting , Formatting of Numbers . Beispiel Print(\"Der Kurs von \" + Instrument.Name + \" kann sich minimal um \" + Instrument.TickSize + \" Punkt(e) ver\u00e4ndern.\"); Multibars Beschreibung Einem Indikator bzw. eine Strategie liegt immer die gleiche Zeiteinheit zugrunde, wie diejenige, in der der Chart angezeigt wird. Wird z.B. ein SMA(14) in einem 5-Minuten-Chart dargestellt, wird der gleitende Durchschnitt \u00fcber die 14 letzten 5-Minuten-Bars berechnet. Auf einem Tageschart w\u00fcrden entsprechend die Schlusskurse der letzten 14 Tage zur Berechnung herangezogen werden. Das gleiche Prinzip gilt f\u00fcr selbst entwickelte Indikatoren. In einem 5-Minuten-Chart w\u00fcrde die Methode OnCalculate() f\u00fcr jeden 5-Minuten-Bar aufgerufen werden. Mit Multibars ist es au\u00dferdem m\u00f6glich, Daten eines anderen Instrumentes zu laden. Beispiel using System; using System.Collections.Generic; using System.ComponentModel; using System.Drawing; using System.Linq; using System.Xml; using System.Xml.Serialization; using AgenaTrader.API; using AgenaTrader.Custom; using AgenaTrader.Plugins; using AgenaTrader.Helper; namespace AgenaTrader.UserCode { [Description(\"Multibar Demo\")] // Der Indikator ben\u00f6tigt Tages- und Wochendaten [TimeFrameRequirements(\"1 Day\", \"1 Week\")] public class MultiBarDemo : UserIndicator { private static readonly TimeFrame TF_Day = new TimeFrame(DatafeedHistoryPeriodicity.Day, 1); private static readonly TimeFrame TF_Week = new TimeFrame(DatafeedHistoryPeriodicity.Week, 1); protected override void OnBarsRequirements() { Add(TF_Day); Add(TF_Week); } protected override void OnInit() { CalculateOnClosedBar = true; } protected override void OnCalculate() { // aktueller Wert f\u00fcr den SMA 14 auf Tagesbasis Print(\"TF0: \" + SMA(Closes[0], 14)[0]); // The current value for the SMA 14 in a daily timeframe Print(\"TF1: \" + SMA(Closes[1], 14)[0]); // aktueller Wert f\u00fcr den SMA 14 auf Wochenbasis Print(\"TF2: \" + SMA(Closes[2], 14)[0]); } } } Weitere Hinweise Bei Verwendung weiterer Zeiteinheiten wird den Arrays Opens , Highs , Lows , Closes , Medians , Typicals , Weighteds , Times und Volumes ein weiterer Eintrag mit den jeweiligen Datenserien der Bars der neuen Zeiteinheit hinzugef\u00fcgt. Die Indizierung erfolgt in der Reihenfolge des Hinzuf\u00fcgens der Zeiteinheiten. Closes[0][0] entspricht Close[0]. Closes[1][0] entspricht dem aktuellen Schlusskurs der Tagesdatenreihe. Closes[2][0] entspricht dem aktuellen Schlusskurs der Wochendatenreihe. \"Closes\"kann in den Beispielen selbstverst\u00e4ndlich auch durch Opens, Highs, Lows usw. ersetzt werden. Siehe auch ProcessingBarIndexes , ProcessingBarSeriesIndex , TimeFrames , TimeFrameRequirements . Es gibt noch eine weitere Schreibweise f\u00fcr Multbars: // unter Variablendeklaration wird die Variable TF_Day definiert private static readonly TimeFrame TF_Day = new TimeFrame(DatafeedHistoryPeriodicity.Day, 1); private static readonly TimeFrame TF_Week = new TimeFrame(DatafeedHistoryPeriodicity.Week, 1); // Die folgende Anweisung ist identisch mit double d = Closes[1][0]; double d = MultiBars.GetBarsItem(TF_Day).Close[0]; // Die folgende Anweisung ist identisch mit double w = Closes[2][0]; double w = MultiBars.GetBarsItem(TF_Week).Close[0]; ProcessingBarIndexes Beschreibung CurrentBars ist ein Array von int-Werten, welches f\u00fcr jedes Bar-Objekt die Nummer von ProcessingBarIndex enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird. Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge: ProcessingBarIndexes[0] ProcessingBarIndexes der prim\u00e4ren Datenserie (Chart-Zeiteinheit) ProcessingBarIndexes[1] ProcessingBarIndexes f\u00fcr die Tagesbars ProcessingBarIndexes[2] ProcessingBarIndexes f\u00fcr die Wochenbars. ProcessingBarIndexes[0] entspricht ProcessingBarIndex . Siehe auch MultiBars . Parameter barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten Verwendung ProcessingBarIndexes[int barSeriesIndex] Beispiel //Sicherstellen, dass mind. 20 Bars geladen sind for (int i=0; i<ProcessingBarIndexes.Count; i++) if (ProcessingBarIndexes[i] < 20) return; ProcessingBarSeriesIndex Description In einem Multibar-Script, d.h. in einem Indikator (bzw. einer Strategie), der mit mehreren Zeiteinheiten arbeitet, sind mehrere Bars-Objekte vorhanden. Die Methode OnCalculate() wird f\u00fcr jeden Bar im Script aufgerufen. Um Ereignisse bestimmter Datenreihen in die Berechnung einzubeziehen bzw. auszublenden ist BarsInProgress zu verwenden. ProcessingBarSeriesIndex ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Mit [TimeFrameRequirements(\"1 Day\", \"1 Week\")] werden 2 weitere Zeiteinheiten zur prim\u00e4ren Chart-Zeiteinheit hinzugef\u00fcgt. Wenn OnCalculate() von der prim\u00e4ren Datenreihe aufgerufen wird, ist ProcessingBarSeriesIndex=0. Wird OnCalculate() von den Tagesbars aufgerufen, ist ProcessingBarSeriesIndex=1, bei den Wochendaten hat BarsInProgress den Wert 2. Siehe auch Multibars and ProcessingBarIndexes . Parameter keine Verwendung ProcessingBarSeriesIndex Weitere Informationen In einem Script, welches nur auf der prim\u00e4ren Zeiteinheit arbeitet, hat BarsInProgress immer den Wert 0. Beispiel // Arbeitsweise veranschaulichen // ggf. CalculateOnBarClose=false setzen Print(Time[0] + \" \" + ProcessingBarSeriesIndex); // Berechnungen nur f\u00fcr die Chart-Zeiteinheit protected override void OnCalculate() { if (ProcessingBarSeriesIndex > 0) return; // Logik f\u00fcr prim\u00e4re Datenreihe }","title":"Umgang mit Bars und Instrumenten"},{"location":"umgang_mit_bars_und_instrumenten/#umgang-mit-bars-und-instrumenten","text":"Unter \"Daten\" werden hier einerseits Informationen verstanden, die \"von au\u00dfen\" in AgenaTrader geladen werden und zum anderen Datenreihen, die aus selbst erstellten AgenaSripts stammen. Detailierte Informatonen finden sich unter dem jeweiligen Stichwort. Bars Collections Data series Instruments Multibars","title":"Umgang mit Bars und Instrumenten"},{"location":"umgang_mit_bars_und_instrumenten/#bars","text":"","title":"Bars"},{"location":"umgang_mit_bars_und_instrumenten/#funktionsweise","text":"Ein klassischer Indikator berechnet \u00fcblicherweise aus einer vorliegenden Datenreihe einen oder mehrere Werte. Datenreihen k\u00f6nnen dabei z.B. alle Schlusskurse oder auch alle Tiefkurse eines Tages, einer Stunde oder einer 10 Min. Periode sein. Jeder Periode (also jeder Kerze eines Tages, einer Stunde usw.) wird/werden folglich ein oder mehrere Indikatorwert(e) zugeordnet. Im Folgenden gehen wir von einem Indikatorwert, wie z.B. bei einem gleitenden Durchschnitt aus. Zur Berechnung eines gleitenden Durchschnitts ben\u00f6tigt AgenaTrader eine Datenreihe. Im Beispiel nehmen wir die Schlusskurse. Alle Schlusskurse der Bars (Kerzen), die in einem Chart dargestellt sind, sind in einer Liste gespeichert und sozusagen durchnummeriert. Der aktuelle Schlusskurs, also der Schlusskurs des Bars, der am rechten Rand des Charts dargestellt wird, bekommt die Nummer 0. Der Bar links davon die Nummer 1 usw. Der \u00e4lteste dargestellte Bar hat dann z.B. die Nummer 500. Kommt im Laufe der Handelssitzung ein neuer Bar hinzu, erh\u00e4lt dieser nun die Nummer 0, der links von ihm, der gerade noch die Nummer 0 hatte, wird zu Nummer 1 usw. Der letzte dargestellte Bar wird zu Nummer 501. In einem Script (einem selbsterstellten Programm) steht Close close f\u00fcr die Liste (Array) aller Schlusskurse. Der letzte Schlusskurs ist dann Close [0] ; t der Schlusskurs davor (bei Tagesdaten ist das z.B. der Schlusskurs von gestern) ist Close [1] , der davor Close [2] bis zum ersten Bar im Chart (ganz links) mit Close [501] . Die Zahl in den eckigen Klammern ist ein Index. In AgenaTrader steht hierf\u00fcr im allgemeinen Fall der Ausdruck \"barsAgo\". F\u00fcr jeden Bar gibt es nicht nur Close, sondern zudem auch High , Low , Open , Median , Typical , Weighted , Time and Volume . Das Hoch der Kerze, von vor 10 Tagen ist also z.B. High [10] , Das Tief von gestern Low [1] ... wichtiger Hinweis Die o.g. Beispiele gelten, wenn die Berechnung am Ende einer Periode erfolgt. Die Werte der aktuell laufenden (noch nicht fertigen Kerze) sind nicht ber\u00fccksichtigt. M\u00f6chte man bereits auf die Werte der sich gerade ausbildenden Kerze zur\u00fcckgreifen, mu\u00df man dies AgenaTrader im Script mit CalculateOnClosedBar = false mitteilen. In diesem Fall bekommt der aktuell laufende Bar die Nummer 0, der Bar links neben dem aktuell laufenden die Nummer 1 usw. Der letzte Bar (im Beispiel oben) h\u00e4tte jetzt die Nummer 502. Mit close [0] bekommt man nun den jeweils letzten Kurs, der gerade vom Datenanbieter an AgenaTrader \u00fcbermittelt wurde. Alle Werte des Bars (high [0], low [0]\u2026) k\u00f6nnen sich solange ver\u00e4ndern, bis der Bar fertig ausgebildet ist und ein neuer Bar begonnen hat. Nur Open[0] \u00e4ndert sich auch in diesem Fall nicht mehr.","title":"Funktionsweise"},{"location":"umgang_mit_bars_und_instrumenten/#eigenschaften","text":"","title":"Eigenschaften"},{"location":"umgang_mit_bars_und_instrumenten/#eigenschaften-von-bars","text":"\"Bars\" steht f\u00fcr eine Liste aller Bars (Kerzen) in einem Chart (siehe Funktionsweise , Bars ). Bars ( public IBars Bars) kann direkt in einem Script verwendet werden und entspricht in diesem Fall BarsArray [0] (siehe Bars.GetNextSessionTimeSpan). Eigenschaften werden immer mit einem Punkt hinter dem Objekt (in diesem Falle Bars, der Liste der Kerzen) angegeben. Bars.Count Bars.CurrentSessionBeginTime Bars.CurrentSessionEndTime Bars.GetBar Bars.GetBarIndex Bars.GetBarsAgo Bars.GetByIndex Bars.GetClose Bars.GetHigh Bars.GetLow Bars.GetNextSessionTimeSpan Bars.GetOpen Bars.GetSessionBegin Bars.GetTime Bars.GetVolume Bars.Instrument Bars.IsEod Bars.IsFalling Bars.IsFirstBarInSession Bars.IsGrowing Bars.IsIntraday Bars.IsNtb Bars.SessionBreak Bars.LastBarCompleteness Bars.NextSessionBeginTime Bars.NextSessionEndTime Bars.TailBottom Bars.TailTop Bars.TicksCountForLastBar Bars.TicksCountInTotal Bars.TimeFrame BarsCountForSession IsProcessingBarIndexLast Innerhalb von OnCalculate() k\u00f6nnen alle Eigenschaften verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Funktion OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden. Falls diese Eigenschaften ausserhalb von OnCalculate() verwendet werden, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null ) ausgef\u00fchrt werden.","title":"Eigenschaften von Bars"},{"location":"umgang_mit_bars_und_instrumenten/#barscount","text":"","title":"Bars.Count"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung","text":"Bars.Count liefert die Anzahl der Bars in einer Datenreihe. Siehe auch weitere Eigenschaften von Bars.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert","text":"Typ int Anzahl der Bars","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung","text":"Bars.Count","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen","text":"Der Wert von ProcessingBarIndex kann immer nur kleiner oder gleich Bars.Count - 1 sein. Wenn in AgenaTrader angegeben wurde, wieviel Bars in einen Chart geladen werden sollen, entspricht der Wert von Bars.Count genau dieser Einstellung. Im Beispiel unten w\u00fcrde Bars.Count 500 liefern.","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel","text":"Print (\"Es stehen insgesamt\" + Bars.Count + \"Bars zur Verf\u00fcgung.\");","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barscurrentsessionbegintime","text":"","title":"Bars.CurrentSessionBeginTime"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_1","text":"Bars.CurrentSessionBeginTime liefert das Datum und die Uhrzeit des Beginns der aktuell laufenden Handelssitzung. Datum und Uhrzeit f\u00fcr den Beginn der aktuellen Handelssitzung werden auch dann korrekt angegeben, wenn die Funktion von einem Bar in der Vergangenheit aufgerufen wird.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_1","text":"Typ DateTime","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_1","text":"Bars.GetSessionBegin","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_1","text":"Die Uhrzeit des zur\u00fcckgegebenen Wertes entspricht der im MarketEscort angegebenen Startzeit der Handelssitzung des jeweiligen Handelsplatzes. Der f\u00fcr den Wert verwendete Handelsplatz wird im Instrumet Escort eingestellt und kann in AgenaSript mit der Funktion Instrument.Exchange ermittelt.","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_1","text":"Print(\"Die laufende Handelssitzung hat um \" + Bars.CurrentSessionBeginTime );","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barscurrentsessionendtime","text":"","title":"Bars.CurrentSessionEndTime"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_2","text":"Bars.CurrentSessionEndTime liefert das Datum und die Uhrzeit f\u00fcr das Ende der aktuell laufenden Handelssitzung. Datum und Uhrzeit f\u00fcr das Ende der aktuellen Handelssitzung werden auch dann korrekt angegeben, wenn die Funktion von einem Bar in der Vergangenheit aufgerufen wird.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_1","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_2","text":"Typ DateTime","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_2","text":"Bars.GetSessionEnd","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_2","text":"Die Uhrzeit des zur\u00fcckgegebenen Wertes entspricht der im MarketEscort angegebenen Endezeit der Handelssitzung des jeweiligen Handelsplatzes. Der f\u00fcr den Wert verwendete Handelsplatz wird im Instrumet Escort eingestellt und kann in AgenaSript mit der Funktion Instrument.Exchange ermittelt werden.","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_2","text":"Print(\"Die laufende Handelssitzung endet um \" + Bars.CurrentSessionEndTime);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barsgetbar","text":"","title":"Bars.GetBar"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_3","text":"Bars.GetBar liefert den ersten Bars (vom \u00e4ltesten zum j\u00fcngsten), der dem \u00fcbergebenen Datum bzw. der Uhrzeit entspricht. Siehe auch Bars.GetBarsAgo , Bars.GetByIndex , Bars.GetBarIndex .","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_2","text":"Typ DateTime","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_3","text":"Typ IBar Bar-Objekt, des dem Zeitstempel entsprichenden Bars bei Zeitstempel \u00e4lter als der \u00e4lteste Bar: 0 (Null) bei Zeitstempel j\u00fcnger als der letzte Bar: Index des letzten Bars","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_3","text":"Bars.GetBar(DateTime time)","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_3","text":"zur Indizierung von Bars siehe Funktionsweise , Bars zur Benutzung von DateTime siehe http://msdn.microsoft.com/de-de/library/system.datetime.aspx","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_3","text":"Print (\"Der Schlusskurs f\u00fcr den 01.03.2012 um 18:00:00 Uhr war \" + Bars.GetBar(new DateTime(2012, 01, 03, 18, 0, 0)).Close);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barsgetbarindex","text":"","title":"Bars.GetBarIndex"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_4","text":"Bars.GetBarIndex liefert den Index eines Bars. \u00dcbergeben werden kann der Methode entweder ein Bar-Objekt oder ein DateTime-Objekt. Siehe Bars.GetBar , Bars.GetBarsAgo , Bars.GetByIndex .","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_3","text":"Typ IBar bar oder Typ DateTime","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_4","text":"Typ int der zu dem \u00fcbergebenen Bar-Objekt bzw. dem \u00fcbergebenen DateTime-Objekt geh\u00f6rende Bar-Index","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_4","text":"Bars.GetBarIndex (IBar bar) Bars.GetBarIndex (DateTime dt)","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_4","text":"zur Indizierung von Bars siehe Funktionsweise , Bars","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_4","text":"int barsAgo = 5; IBar bar = Bars.GetBar(Time[barsAgo]); Print(barsAgo + \" und \" + Bars.GetBarIndex(bar) + \" sind in diesem Beispiel gleich.\");","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barsgetbarsago","text":"","title":"Bars.GetBarsAgo"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_5","text":"Bars.GetBarsAgo liefert den Index des ersten Bars (vom \u00e4ltesten zum j\u00fcngsten), der dem \u00fcbergebenen Datum bzw. der Uhrzeit entspricht. Siehe auch:: Bars.GetBar , Bars.GetByIndex , Bars.GetBarIndex .","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_4","text":"Typ DateTime","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_5","text":"Typ int Index des Bars, der dem Zeitstempel als erstes entspricht. bei Zeitstempel \u00e4lter als der \u00e4lteste Bar: 0 (Null) bei Zeitstempel j\u00fcnger als der letzte Bar: Index des letzten Bars","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_5","text":"Bars.GetBarsAgo(DateTime time)","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_5","text":"zur Indizierung von Bars siehe Funktionsweise , Bars zur Benutzung von DateTime siehe http://msdn.microsoft.com/de-de/library/system.datetime.aspx","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_5","text":"Print(\"Der Bar f\u00fcr den 01.03.2012 um 18:00:00 Uhr hat den Index\" + Bars.GetBarsAgo(new DateTime(2012, 01, 03, 18, 0, 0)));","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barsgetbyindex","text":"","title":"Bars.GetByIndex"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_6","text":"Bars.GetByIndex liefert das zu einem \u00fcbergebenen Index geh\u00f6rende Bar-Objekt. Siehe Bars.GetBar , Bars.GetBarsAgo , Bars.GetBarIndex .","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_5","text":"Typ int Index","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_6","text":"Typ IBar Bar-Objekt zu dem \u00fcbergebenen Index","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_6","text":"Bars.GetByIndex (int Index)","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_6","text":"zur Indizierung von Bars siehe Funktionsweise , Bars","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_6","text":"Print(Close[0] + \" und \" + Bars.GetByIndex(ProcessingBarIndex).Close + \" sind in diesem Beispiel gleich.\");","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barsgetclose","text":"Bars.GetClose(int index) \u2013 siehe Bars.GetOpen .","title":"Bars.GetClose"},{"location":"umgang_mit_bars_und_instrumenten/#barsgethigh","text":"Bars.GetHigh(int index) \u2013 siehe Bars.GetOpen .","title":"Bars.GetHigh"},{"location":"umgang_mit_bars_und_instrumenten/#barsgetlow","text":"Bars.GetLow(int index) \u2013 siehe Bars.GetOpen .","title":"Bars.GetLow"},{"location":"umgang_mit_bars_und_instrumenten/#barsgetnextsessiontimespan","text":"","title":"Bars.GetNextSessionTimeSpan"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_7","text":"Bars.GetNextSessionTimeSpan liefert jeweils Datum und Uhrzeit von Beginn und Ende der n\u00e4chsten Handelssitzung. Siehe Bars.CurrentSessionBeginTime , Bars.CurrentSessionEndTime , Bars.NextSessionBeginTime , Bars.NextSessionEndTime .","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_6","text":"DateTime time Datum bzw. Uhrzeit, f\u00fcr die die Daten der folgenden Handelssitzung gesucht werden iBars bars Barobjekt, f\u00fcr das die Daten der folgenden Handelssitzung gesucht werden int barsago Anzahl der Tage in der Vergangenheit, f\u00fcr die die Daten der folgenden Handelssitzung gesucht werden","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_7","text":"DateTime sessionBegin DateTime sessionEnd Hinweis: Das Datum von Beginn und Ende sind jeweils f\u00fcr eine Handelssitzung zusammengeh\u00f6rend. Wenn das \u00fcbergebene Datum dem Ende-Datum der aktuellen Handelssitzung entspricht, kann das zur\u00fcckgegebene Datum f\u00fcr den Beginn der Handelssitzung bereits in der Vergangenheit liegen. Es wird in diesem Fall nicht das Datum der n\u00e4chstfolgenden Handelssitzung zur\u00fcckgegeben.","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_7","text":"Bars.GetNextSessionTimeSpan(Bars bars, int barsAgo, out DateTime sessionBegin, out DateTime sessionEnd) Bars.GetNextSessionTimeSpan(DateTime time, out DateTime sessionBegin, out DateTime sessionEnd)","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_7","text":"Die beiden Signaturen liefern nicht notwendigerweise auch die gleichen Ergebnisse. Bei Verwendung der Bar-Signatur wird der ubergebene Bar daraufhin untersucht, zu welchem Session-Template er geh\u00f6rt. Beginn und Ende der n\u00e4chsten Session werden dann diesem Template entnommen. Bei Verwendung der Zeit-Signatur wierden Datum und Uhrzeit des \u00fcbergebenen Bars genutzt, um die Daten der aktuellen und damit der folgenden Session zu berechnen. Wenn bei Verwendung der Zeit-Signatur ein Zeitstempel \u00fcbergeben wird, der exakt einer Beginn bzw. Endezeit einer Session entspricht, werden Beginn und Ende der davorliegenden Session zur\u00fcckgegeben, d.h. der Zeitstempel wird als \"in der Session enthalten\" angesehen, selbst wenn der fragliche Bar bereits in einer neuen Session enthalten ist. Um dieses Verhaten sicher auszuschlie\u00dfen, ist die Verwendung der Bar-Signatur empfohlen. zur Benutzung von DateTime siehe http://msdn.microsoft.com/de-de/library/system.datetime.aspx","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_7","text":"DateTime sessionBegin; DateTime sessionEnd; protected override void OnCalculate() { Bars.GetNextSessionTimeSpan(Bars, 0, out sessionBegin, out sessionEnd); Print(\"Session Start: \" + sessionBegin + \" Session End: \" + sessionEnd); }","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barsgetopen","text":"","title":"Bars.GetOpen"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_8","text":"Die folgenden Methoden sind aus Gr\u00fcnden der Kompatibilit\u00e4t vorhanden. Bars.GetOpen(int index) liefert das Open des mit <index> referenzierten Bars. Bars.GetHigh(int index) liefert das High des mit <index> referenzierten Bars.. Bars.GetLow(int index) liefert das Low des mit <index> referenzierten Bars. Bars.GetClose(int index) liefert das Close des mit <index> referenzierten Bars. Bars.GetTime(int index) liefert das Zeitstempel des mit <index> referenzierten Bars. Bars.GetVolume(int index) liefert das Volumen des mit <index> referenzierten Bars. Achtung : Die Indizierung weicht von der sonst verwendeten Indexing , Bars ab. Hier beginnt die Indizierung mit 0 am \u00e4ltesten Bar (links im Chart) und endet mit dem j\u00fcngsten Bar rechts im Chart (=Bars.Count-1). Die Indizierungen k\u00f6nnen leicht (in beiden Richtungen!) wie folgt umgerechnet werden: private int Convert(int idx) { return Math.Max(0,Bars.Count-idx-1-(CalculateOnClosedBar?1:0)); }","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_7","text":"int index (0 .. Bars.Count-1)","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_8","text":"Typ double f\u00fcr GetOpen, GetHigh, GetLow, GetClose und GetVolume Typ DateTime f\u00fcr GetTime","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#barsgetsessionbegin","text":"","title":"Bars.GetSessionBegin"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_9","text":"Bars.GetSessionBegin liefert das Datum und die Uhrzeit des Beginns einer bestimmten Handelssitzung. Datum und Uhrzeit f\u00fcr den Beginn der aktuellen Handelssitzung werden auch dann korrekt angegeben, wenn die Funktion von einem Bar in der Vergangenheit aufgerufen wird. Siehe auch weitere Eigenschaften von Bars.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_8","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_9","text":"Typ DateTime","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_8","text":"Bars.GetSessionBegin(DateTime dt)","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_8","text":"Die Uhrzeit des zur\u00fcckgegebenen Wertes entspricht der im MarketEscort angegebenen Startzeit der Handelssitzung des jeweiligen Handelsplatzes. Der f\u00fcr den Wert verwendete Handelsplatz wird im Instrumet Escort eingestellt und kann in AgenaSript mit der Funktion Instrument.Exchange ermittelt werden.","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_8","text":"Print(\"Die Handelssitzung am 25.03.2015 hat um \"+ Bars.GetSessionBegin(new DateTime(2015, 03, 25)) + \" begonnen.\"); }","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barsgettime","text":"Bars.GetTime(int index) \u2013 siehe Bars.GetOpen .","title":"Bars.GetTime"},{"location":"umgang_mit_bars_und_instrumenten/#barsgetvolume","text":"Bars.GetVolume(int index) \u2013 siehe Bars.GetOpen .","title":"Bars.GetVolume"},{"location":"umgang_mit_bars_und_instrumenten/#barsinstrument","text":"","title":"Bars.Instrument"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_10","text":"Bars.Instrument liefert ein Instrument-Objekt, f\u00fcr das im Chart dargestellte Handelsinstrument. Siehe auch weitere Eigenschaften von Bars.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_9","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_10","text":"Typ Instrument","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_9","text":"Bars.Instrument","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_9","text":"F\u00fcr weitere Informationen zu Handelsinstrumenten siehe unter Instrument .","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_9","text":"// beide Ausgaben liefern das gleiche Ergebnis Print(\"Das aktuell dargestellte Handelsinstrument hat das Symbol \" + Bars.Instrument); Instrument i = Bars.Instrument; Print(\"Das aktuell dargestellte Handelsinstrument hat das Symbol \" + i.Symbol);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barsiseod","text":"","title":"Bars.IsEod"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_11","text":"Mit Bars.IsEod kann \u00fcberpr\u00fcft werden, ob es sich um End-of-Day-Bars handelt. Siehe auch weitere Eigenschaften von Bars.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_10","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_11","text":"Typ bool","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_10","text":"Bars.IsEod","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#more-information","text":"Innerhalb von OnCalculate() kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden. Falls diese Eigenschaft ausserhalb von OnCalculate ()verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (bars! = Null) ausgef\u00fchrt werden.","title":"More Information"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_10","text":"Print(\"Die Bars sind Eod: \" + Bars.IsEod);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barsisfalling","text":"","title":"Bars.IsFalling"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_12","text":"Bar-Eigenschaften, die verwendet werden, wenn Bar herunterf\u00e4llt.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_11","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_12","text":"keine","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_11","text":"Bars[0].IsFalling;","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barsisfirstbarinsession","text":"","title":"Bars.IsFirstBarInSession"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_13","text":"Mit Bars.IsFirstBarInSession kann festgestellt werden, ob der aktuelle Bar der erste Bar einer Handelssitzung ist. Siehe auch weitere Eigenschaften von Bars.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_13","text":"Typ bool true : Der Bar ist der erste Bar einer Handelssitzung false : Der Bar ist nicht der erste Bar einer Handelssitzung","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_11","text":"Bars.IsFirstBarInSession","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_10","text":"Innerhalb von OnCalculate() kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden. Falls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null) ausgef\u00fchrt werden.","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_12","text":"if (Bars.IsFirstBarInSession) Print (\"Die aktuelle Handelsitzung hat um\" + Time [0]);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barsisgrowing","text":"","title":"Bars.isGrowing"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_14","text":"Bar-Eigenschaften verwendet, wenn Bar aufw\u00e4chst.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_12","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_14","text":"keine","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_13","text":"Bars[0].isGrowing;","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barsisintraday","text":"","title":"Bars.IsIntraday"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_15","text":"Mit Bars.IsIntraday kann \u00fcberpr\u00fcft werden, ob es sich um reine Intraday-Bars handelt. Entweder mit Ber\u00fccksichtigung von Ticks - Bars.IsIntraday.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_15","text":"bool Er gibt \"true\" zur\u00fcck, wenn TimeFrame intra-day (z. B. 1 min, 15 min, 1 h usw.) und \"false\" in anderen F\u00e4llen ist.","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_12","text":"Bars.IsIntraday","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_14","text":"if(Bars.IsIntraday) { Print(\"TimeFrame is Intraday.\"); } else { Print(\"TimeFrame is not Intraday.\"); }","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barsisntb","text":"","title":"Bars.IsNtb"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_16","text":"Mit Bars.IsNtb kann \u00fcberpr\u00fcft werden, ob es sich um Not-Time-Based-Bars handelt. Bei Ntb-Bars handelt es sich beispielsweise um Point & Figure oder Renko Charts. Siehe auch weitere Eigenschaften von Bars.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_13","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_16","text":"Typ bool","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_13","text":"Bars.IsNtb","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_11","text":"Innerhalb von OnCalculate() kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden. Falls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null) ausgef\u00fchrt werden.","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_15","text":"Print(\"Die angezeigten Bars sind Ntb:\" + Bars.IsNtb);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barsissessionbreak","text":"","title":"Bars.IsSessionBreak"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_17","text":"Mit Bars.IsSessionBreak kann ermittelt werden, ob die Bars innerhalb der laufenden Handelssitzung in den im Marktplatz-Escort definierten Handelspausen liegen. Siehe auch weitere Eigenschaften von Bars.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_14","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_17","text":"Typ bool","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_14","text":"Bars.IsSessionBreak","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_12","text":"","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_16","text":"if (Bars.IsSessionBreak) { Print(\"Die B\u00f6rse Xetra hat gerade eine Handelspause.\"); }","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barslastbarcompleteness","text":"","title":"Bars.LastBarCompleteness"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_18","text":"Bars.LastBarCompleteness liefert einen Wert, der angibt, zu wieviel Prozent ein Bar bereits fertiggestellt ist. Ein Bar in der Zeiteinheit 10 Minuten ist z.B. nach 5 Minuten genau zu 50% fertig. F\u00fcr nicht-zeitbasierte Chartarten (Kagi, LineBreak, Renko, Range, P&F usw.) und w\u00e4hrend eines Backtests liefert die Eigenschaft immer eine 0.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_18","text":"double als Prozentwert, d.h. f\u00fcr 30% wird 0.3 zur\u00fcckgegeben-","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_15","text":"Bars.LastBarCompleteness","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_13","text":"Innerhalb von OnCalculate() kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden. Falls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null) ausgef\u00fchrt werden.","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_17","text":"// Ein 60 Min. Chart wird intraday beobachtet. // Jeweils 5 Min. bevor der aktuelle Bar schlie\u00dft, // soll ein akustisches Signal ausgegeben werden. // 55 Min. entsprechen 92% bool remind = false; protected override void OnCalculate() { if (FirstTickOfBar) remind = true; if (remind && Bars.LastBarCompleteness >= 0.92) { remind = false; PlaySound(\"Alert1\"); } }","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barsnextsessionbegintime","text":"","title":"Bars.NextSessionBeginTime"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_19","text":"Bars.NextSessionBeginTime liefert das Datum und die Uhrzeit des Beginns der auf die aktuell laufende Handelssitzung folgenden Sitzung. Datum und Uhrzeit f\u00fcr den Beginn der n\u00e4chsten Handelssitzung werden auch dann korrekt angegeben, wenn die Funktion von einem Bar in der Vergangenheit aufgerufen wird.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_15","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_19","text":"Typ DateTime","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_16","text":"Bars.GetSessionNextBegin","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_14","text":"Die Uhrzeit des zur\u00fcckgegebenen Wertes entspricht der im MarketEscort angegebenen Startzeit der Handelssitzung des jeweiligen Handelsplatzes. Der f\u00fcr den Wert verwendete Handelsplatz wird im Instrumet Escort eingestellt und kann in AgenaSript mit der Funktion Instrument.Exchange ermittelt werden.","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_18","text":"Print(\"Die n\u00e4chste Handelssitzung beginnt um \" + Bars.NextSessionBeginTime);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barsnextsessionendtime","text":"","title":"Bars.NextSessionEndTime"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_20","text":"Bars.NextSessionEndTime liefert das Datum und die Uhrzeit f\u00fcr das Ende der auf die aktuell laufende Handelssitzung folgenden Sitzung. Datum und Uhrzeit f\u00fcr das Ende der n\u00e4chsten Handelssitzung werden auch dann korrekt angegeben, wenn die Funktion von einem Bar in der Vergangenheit aufgerufen wird. Siehe auch weitere Eigenschaften von Bars.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_16","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_20","text":"Typ DateTime","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_17","text":"Bars.GetSessionNextEnd","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_15","text":"Die Uhrzeit des zur\u00fcckgegebenen Wertes entspricht der im MarketEscort angegebenen Endezeit der Handelssitzung des jeweiligen Handelsplatzes. Der f\u00fcr den Wert verwendete Handelsplatz wird im Instrumet Escort eingestellt und kann in AgenaSript mit der Funktion Instrument.Exchange ermittelt werden.","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_19","text":"Print(\"Die n\u00e4chste Handelssitzung endet um \" + Bars.NextSessionEndTime);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barstailbottom","text":"","title":"Bars.TailBottom"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_21","text":"Mit dieser Eigenschaft ist es m\u00f6glich die H\u00f6he des unteren Dochtes der Kerze zu ermitteln.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_17","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_21","text":"keine","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_18","text":"Bars[0].TailBottom;","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_20","text":"Print(\"Die H\u00f6he des unteren Dochtes ist: \" + Bars.TailBottom);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barstailtop","text":"","title":"Bars.TailTop"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_22","text":"Mit dieser Eigenschaft ist es m\u00f6glich die H\u00f6he des oberen Dochtes der Kerze zu ermitteln.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_18","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_22","text":"keine","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_19","text":"Bars[0].TailTop;","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_21","text":"Print(\"Die H\u00f6he des oberen Dochtes ist: \" + Bars.TailTop);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barstickscountforlastbar","text":"","title":"Bars.TicksCountForLastBar"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_23","text":"Bars.TicksCountForLastBar liefert die Gesamtanzahl der in einem Bar enthaltenen Ticks. Siehe auch weitere Eigenschaften von Bars.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_19","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_23","text":"Typ int","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_20","text":"Bars.TicksCountForLastBar","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_16","text":"Innerhalb von OnCalculate() kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden. Falls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null ) ausgef\u00fchrt werden.","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_22","text":"Print(\"Der aktuelle Bar besteht aus \" + Bars.TicksCountForLastBar + \" Ticks.\");","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barstickscountintotal","text":"","title":"Bars.TicksCountInTotal"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_24","text":"Bars.TicksCountInTotal liefert die Gesamtzahl aller Ticks von dem Moment an, von dem die Funktion aufgerufen wird. Siehe auch weitere Eigenschaften von Bars.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_20","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_24","text":"Typ int","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_21","text":"Bars.TicksCountInTotal","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_17","text":"Der Datentyp int hat einen positiven Wertebereich von 2147483647. Wenn 10 Ticks je Sekunde angenommen werden, gibt es auch nach 2 Handelsmonaten bei einem 24h-Handel noch kein \u00dcberlauf. Innerhalb von OnCalculate() kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden. Falls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null ) ausgef\u00fchrt werden.","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_23","text":"//Anwendung in einem 30 Minuten Chart Print(\"Die Gesamtanzahl der gelieferten Ticks in diesem Wert betr\u00e4gt \" + Bars.TicksCountInTotal);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barstimeframe","text":"","title":"Bars.TimeFrame"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_25","text":"Bars.TimeFrame liefert ein TimeFrame-Objekt, das Informationen zum aktuell verwendeten Zeiteinheit enth\u00e4lt. Siehe auch weitere Eigenschaften von Bars.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_21","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_25","text":"Typ ITimeFrame","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_22","text":"Bars.TimeFrame","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_18","text":"F\u00fcr weitere Informationen zum TimeFrame-Objekt siehe unter TimeFrame . Innerhalb von OnCalculate() kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden. Falls diese Eigenschaft ausserhalb von OnCalculate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null ) ausgef\u00fchrt werden.","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_24","text":"//Anwendung in einem 30 Minuten Chart TimeFrame tf = (TimeFrame) Bars.TimeFrame; Print(Bars.TimeFrame); //liefert \"30 Min\" Print(tf.Periodicity); // liefert \"Minute\" Print(tf.PeriodicityValue); // liefert \"30\"","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#barscountforsession","text":"","title":"BarsCountForSession"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_26","text":"Bars.BarsCountForSession liefert die Anzahl der Bars, die seit dem Beginn der aktuellen Handelssitzung entstanden sind. Siehe auch weitere Eigenschaften von Bars.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_26","text":"Typ int Anzahl der Bars Ein Wert von -1 deutet auf ein Problem bei der Ermittlung des Sessionbeginns hin.","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_23","text":"Bars.BarsCountForSession","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_19","text":"Innerhalb von OnCalculate() kann diese Eigenschaft verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Methode OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Bars Objekt vorhanden. Falls diese Eigenschaft ausserhalb von OnBarUpdate() verwendet wird, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars!= null ) ausgef\u00fchrt werden.","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_25","text":"Print (\"Seit dem Start der letzten Handelssitzung sind\" + Bars.BarsCountForSession + \"Bars entstanden.\");","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#processingbarindexlast","text":"","title":"ProcessingBarIndexLast"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_27","text":"Gibt an, ob der aktuelle Bar zuletzt berechnet wurde.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_22","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_27","text":"Typ bool","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_24","text":"ProcessingBarIndexLast","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_20","text":"Verwendet f\u00fcr komplizierte Berechnung auf einem letzten Bar","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_26","text":"protected override void OnCalculate() { base.OnCalculate(); if (!IsProcessingBarIndexLast) return; bool isUpdated; }","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#collections","text":"","title":"Collections"},{"location":"umgang_mit_bars_und_instrumenten/#chartdrawings","text":"","title":"ChartDrawings"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_28","text":"ChartDrawings ist eine Collection, die alle Zeichenobjekte im Chart enth\u00e4lt. In ChartDrawings werden sowohl dem Chart manuell hinzugef\u00fcgte Zeichenobjekte, als auch von einem Script gezeichnete Objekte aufgenommen. Der Index f\u00fcr ChartDrawings ist der eindeutige Name der Zeichenobjekte (string tag).","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_25","text":"ChartDrawings [string tag]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#beispiele","text":"Hinweis: Um die Interface-Definitionen nutzen zu k\u00f6nnen, mu\u00df in den Using-Anweisungen using AgenaTrader.Plugins; // Anzahl der Zeichenobjekte auf dem Chart und deren Tags ausgeben Print(\"Auf dem Chart befinden sich \" + ChartDrawings.Count + \" Zeichenobjekte\"); foreach (IDrawObject draw in ChartDrawings) Print(draw.Tag); //Eine schwarze Trendlinie zeichnen ... AddChartLine(\"MyLine\", true, 10, Close[10], 0, Close[0], Color.Black, DashStyle.Solid, 3); / ... und die Farbe auf Rot \u00e4ndern ITrendLine line = (ITrendLine) ChartDrawings[\"MyLine\"]; if (line != null) line.Pen.Color = Color.Red; // alle vertikalen Linien in Chart auf Linienst\u00e4rke 3 setzen, // und nicht verschiebbar und nicht editierbar machen foreach (IDrawObject draw in ChartDrawings) if (draw is IVerticalLine) { IVerticalLine vline = (IVerticalLine) draw; vline.IsLocked = true; vline.Editable = false; vline.Pen.Width = 3; }","title":"Beispiele"},{"location":"umgang_mit_bars_und_instrumenten/#inseries","text":"","title":"InSeries"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_29","text":"InSeries ist ein DatenSerien Objekt, in dem die Eingangsdaten f\u00fcr einen Indikator bzw. eine Strategie enthalten sind. Wird ein Indikator ohne explizite Angabe von Eingangsdaten aufgerufen, wird immer der Schlusskurs (Close) der aktuell im Chart geladenen Kursdaten verwendet. Bei einem Aufruf von SMA(20) wird der gl. Durchschnitt auf die Schlusskurse der aktuellen Chart-Kursdaten berechnet (dies entspricht SMA(Close, 20). InSeries[0] = Close[0]. Bei dem Aufruf von SMA(High, 20) werden die H\u00f6chstkurse der geladenen Daten f\u00fcr die Berechnung des gl. Durchschnitts verwendet. InSeries[0] = High[0]. So kann jede beliebige Datenreihe als Input f\u00fcr einen Indikator verwendet werden. double d = RSI ( SMA (20), 14, 3)[0]; berechnet beispielsweise den 14-Perioden-RSI \u00fcber die SMA(20) Werte als Eingangsdatenreihe. InSeries[0] = SMA(20)[0].","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_26","text":"InSeries InSeries[int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#beispiele_1","text":"Print(\"Die Eingangsdaten f\u00fcr den Indikator sind \" + InSeries[0]);","title":"Beispiele"},{"location":"umgang_mit_bars_und_instrumenten/#lines","text":"","title":"Lines"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_30","text":"Lines ist eine Collection, die die LevelLine Objekte eines Indikators enth\u00e4lt. Wenn einem Indikator mit der Add() Methode ein Line-Objekt hinzugef\u00fcgt wird, wird dieses automatisch der Collection Lines hinzugef\u00fcgt. Die Reihenfolge der Add-Befehle bestimmt dabei auch die Sortierung in Lines. Der erste Aufruf von Add() erzeugt Lines[0], der n\u00e4chste Lines[1] usw. Siehe auch OutputDescriptor .","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_27","text":"Lines[int index]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#beispiele_2","text":"// Add \"using System.Drawing.Drawing2D;\" for DashStyle protected override void OnInit() { Add(new LevelLine(Color.Blue, 70, \"Upper\")); // gespeichert in Lines[0] Add(new LevelLine(Color.Blue, 30, \"Lower\")); // gespeichert in Lines[1] } protected override void OnCalculate() { // Wenn RSI \u00fcber 70, Eigenschaften der Linie \u00e4ndern if (RSI(14 ,3) >= 70) { Lines[0].Width = 3; Lines[0].Color = Color.Red; Lines[0].DashStyle = DashStyle.Dot; } else { Lines[0].Width = 1; Lines[0].Color = Color.Blue; Lines[0].DashStyle = DashStyle.Solid; } }","title":"Beispiele"},{"location":"umgang_mit_bars_und_instrumenten/#plotcolors","text":"","title":"PlotColors"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_31","text":"PlotColors ist eine Collection, die die ColorSeries aller Plot-Objekte enth\u00e4lt. Wenn einem Indikator mit der Add() Methode ein Plot hinzugef\u00fcgt wird, wird automatisch auch ein ColorSeries-Objekt erzeugt und der Collection PlotColors hinzugef\u00fcgt. Die Reihenfolge der Add-Befehle bestimmt dabei auch die Sortierung in PlotColors. Der erste Aufruf von Add() erzeugt PlotColors[0], der n\u00e4chste PlotColors[1] usw.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_28","text":"PlotColors[int PlotIndex][int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_21","text":"Informationen zur Klasse Collection: http://msdn.microsoft.com/en-us/library/ybcx56wz%28v=vs.80%29.aspx","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_27","text":"using System; using System.Collections.Generic; using System.ComponentModel; using System.Drawing; using AgenaTrader.API; namespace AgenaTrader.UserCode { [Description(\"PlotColor Demo\")] public class PlotColorsDemo : UserIndicator { public DataSeries SMA20 { get {return Outputs[0];} } public DataSeries SMA50 { get {return Outputs[1];} } public DataSeries SMA100 { get {return Outputs[2];} } private Pen pen; protected override void OnInit() { // Linienst\u00e4rke (Width) auf 4 einstellen pen = new Pen(Color.Empty, 4); // Dem Chart drei Plots mit der def. Linienst\u00e4rke hinzuf\u00fcgen Add(new OutputDescriptorOutputDescriptor(pen, OutputSeriesDisplayStyle.LevelLine, \"SMA20\" )); //attached to PlotColors[0] Add(new OutputDescriptor(pen, OutputSeriesDisplayStyle.LevelLine, \"SMA50\" )); //attached to PlotColors[1] Add(new OutputDescriptor(pen, OutputSeriesDisplayStyle.LevelLine, \"SMA100\")); //attached to PlotColors[2] IsOverlay = true; } protected override void OnCalculate() { // Den drei Plots Werte zuweisen SMA20.Set (SMA(20) [0]); SMA50.Set (SMA(50) [0]); SMA100.Set(SMA(100)[0]); // Farben je nach Kursverlauf \u00e4ndern if (IsSerieRising(Close)) { PlotColors[0][0] = Color.LightGreen; PlotColors[1][0] = Color.Green; PlotColors[2][0] = Color.DarkGreen; } else if (IsSerieFalling(Close)) { PlotColors[0][0] = Color.LightSalmon; PlotColors[1][0] = Color.Red; PlotColors[2][0] = Color.DarkRed; } else { PlotColors[0][0] = Color.LightGray; PlotColors[1][0] = Color.Gray; PlotColors[2][0] = Color.DarkGray; } } } }","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#outputdescriptor","text":"","title":"OutputDescriptor"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_32","text":"OutputDescriptor ist eine Collection, die die Plot-Objekte eines Indikators enth\u00e4lt. Wenn einem Indikator mit der Add()-Methode ein Plot-Objekt hinzugef\u00fcgt wird, wird dieses automatisch der Collection Plots hinzugef\u00fcgt. Die Reihenfolge der Add-Befehle bestimmt dabei auch die Sortierung in Plots. Der erste Aufruf von Add() erzeugt OutputDescriptor [0], der n\u00e4chste OutputDescriptor[1]\\ usw. Siehe auch Lines .","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_29","text":"OutputDescriptor[int index]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#beispiele_3","text":"protected override void OnInit() { AddOutput(new OutputDescriptor(Color.FromKnownColor(KnownColor.Black), \"MySMA 20\")); // saved to OutputDescriptor[0] } protected override void OnCalculate() { Value.Set(SMA(20)[0]); // Wenn Kurs \u00fcber SMA, Plot gr\u00fcn f\u00e4rben, sonst rot if (Close[0] > SMA(20)[0]) OutputDescriptor[0].PlotColor = Color.Green; else OutputDescriptor[0].PlotColor = Color.Red; }","title":"Beispiele"},{"location":"umgang_mit_bars_und_instrumenten/#values","text":"","title":"Values"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_33","text":"Values ist eine Collection, die die DataSeries-Objekte eines Indikators enth\u00e4lt. Wenn einem Indikator mit der Add()-Methode ein Plot hinzugef\u00fcgt wird, wird automatisch auch ein Value-Objekt erzeugt und der Collection Values hinzugef\u00fcgt. Die Reihenfolge der Add-Befehle bestimmt dabei auch die Sortierung in Values. Der erste Aufruf von Add() erzeugt Values[0], der n\u00e4chste Values[1] usw. Value ist immer identisch mit Values[0].","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_30","text":"Outputs[int index] Outputs[int index][int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_22","text":"Die f\u00fcr eine Collection bekannten Methoden Set(), Reset() und Count() sind auf Value bzw. Values anwendbar. Informationen zur Klasse Collection: http://msdn.microsoft.com/en-us/library/ybcx56wz%28v=vs.80%29.aspx","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_28","text":"// \u00dcberp\u00fcfung des zweiten Indikatorwertes (d.h. der sekund\u00e4ren DatenSerie) // von vor einem Bar // und in Abh\u00e4ngigkeit davon Setzen des aktuellen Indikatorwertes if (Outputs[1][1] < High[0] - Low[0]) Value.Set(High[0] - Low[0]); else Value.Set(High[0] - Close[0]);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#data-series","text":"","title":"Data Series"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_34","text":"Datenserien werden in AgenaTrader zum einen unterschieden in die frei f\u00fcr die eigene Programmierung verwendbaren Datenserien zum Speichern von Werten unterschiedlicher Datentypen und zum anderen in die in AgenaTrader fest integrierten Datenserien, die die Kursdaten der einzelnen Bars enthalten. Die letzteren werden hier vorgestellt. Das Konzept von Datenserien wird sehr konsequent und durchg\u00e4ngig verfolgt. Alle Kursdaten der einzelnen Bars sind in Datenserien organisiert. Folgende Datenserien sind verf\u00fcgbar: Open Opens High Highs Low Lows Close Closes Median Medians Typical Typicals Weighted Weighteds Time Times TimeFrame TimeFrames Volume Volumes","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#open","text":"","title":"Open"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_35","text":"Open ist eine DataSeries vom Typ DataSeries , in der die historischen Er\u00f6ffnungskurse gespeichert sind.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_23","text":"BarsAgo Indexwert (s. Bars )","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_31","text":"Open Open[int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_23","text":"Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar .","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_29","text":"// Er\u00f6ffnungskurs der aktuellen Periode Print(Time[0] + \" \" + Open[0]); // Er\u00f6ffnungskurs des Bars von vor 5 Perioden Print(Time[5] + \" \" + Open[5]); // aktueller Wert f\u00fcr den SMA 14 \u00fcber die Er\u00f6ffnungskurse (gerundet) Print(\"SMA(14) calculated using the opening prices: \" + Instrument.Round2TickSize(SMA(Open, 14)[0]));","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#opens","text":"","title":"Opens"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_36","text":"Opens ist ein Array von Datenserien, welches alle Open-Datenserien enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird. Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge: Opens[0] die Open-Dataseries der Chart-Zeiteinheit Opens[1] die Open-Dataseries aller Bars auf Tagesbasis Opens[2] die Open-Dataseries aller Bars auf Wochenbasis. Opens[0][0] entspricht Open[0]. Siehe auch MultiBars","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_24","text":"barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries (s. Bars ) barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_32","text":"Opens[int barSeriesIndex] Opens[int barSeriesIndex][int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_24","text":"Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar .","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_30","text":"Siehe Beispiel unter Multibars .","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#high","text":"","title":"High"},{"location":"umgang_mit_bars_und_instrumenten/#description","text":"High ist eine DataSeries vom Typ DataSeries , in der die historischen H\u00f6chstkurse gespeichert sind.","title":"Description"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_25","text":"barsAgo Indexwert (s. Bars )","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_33","text":"High High[int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_25","text":"Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar .","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_31","text":"//H\u00f6chstkurs der aktuellen Periode Print(Time[0] + \" \" + High[0]); // H\u00f6chstkurs des Bars von vor 5 Perioden Print(Time[5] + \" \" + High[5]); // aktueller Wert f\u00fcr den SMA 14 \u00fcber die H\u00f6chstkurse (gerundet) Print(\"SMA(14) Calculated using the high prices: \" + Instrument.Round2TickSize(SMA(High, 14)[0]));","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#highs","text":"","title":"Highs"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_37","text":"Highs ist ein Array von [ DataSeries ][1] welches alle High-Datenserien enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge. Highs[0] die High-Dataseries der Chart-Zeiteinheit Highs[1] die High-Dataseries aller Bars auf Tagesbasis Highs[2] die High-Dataseries aller Bars auf Wochenbasis. Highs[0][0] entspricht High[0]. Siehe auch MultiBars .","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_26","text":"barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries (s. Bars ) barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_34","text":"Highs[int barSeriesIndex] Highs[int barSeriesIndex][int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_26","text":"Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar .","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_32","text":"Siehe Beispiel unter Multibars .","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#low","text":"","title":"Low"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_38","text":"Low ist eine DataSeries vom Typ DataSeries , in der die historischen Tiefstkurse gespeichert sind.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_27","text":"barsAgo Indexwert (s. Bars )","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_35","text":"Low Low[int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_27","text":"Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar .","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_33","text":"// Tiefstkurs der aktuellen Periode Print(Time[0] + \" \" + Low[0]); // Tiefstkurs des Bars von vor 5 Perioden Print(Time[5] + \" \" + Low[5]); // aktueller Wert f\u00fcr den SMA 14 \u00fcber die Tiefstkurse (gerundet) Print(\"SMA(14) calculated using the high prices: \" + Instrument.Round2TickSize(SMA(Low, 14)[0]));","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#lows","text":"","title":"Lows"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_39","text":"Lows ist ein Array von [ DataSeries ][1] welches alle Low -Datenserien enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird. Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge. Lows[0] die Low-Dataseries der Chart-Zeiteinheit Lows[1] die Low-Dataseries aller Bars auf Tagesbasis Lows[2] die Low-Dataseries aller Bars auf Wochenbasis. Lows[0][0] entspricht Low[0]. Siehe auch MultiBars .","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_28","text":"barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_36","text":"Lows[int barSeriesIndex] Lows[int barSeriesIndex][int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_28","text":"Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar .","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_34","text":"Siehe Beispiel unter Multibars .","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#close","text":"","title":"Close"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_40","text":"Close ist eine DataSeries vom Typ DataSeries , in der die historischen Schlusskurse gespeichert sind.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_29","text":"barsAgo Indexwert (s. Bars )","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_37","text":"Close Close[int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_29","text":"Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Indikatoren werden standardm\u00e4\u00dfig \u00fcber die Schlusskurse berechnet. Die Angabe der Input-Serie kann weggelassen werden (siehe Beispiel unten).","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_35","text":"// Schlusskurs der aktuellen Periode Print(Time[0] + \" \" + Close[0]); // Schlusskurs des Bars von vor 5 Perioden Print(Time[5] + \" \" + Close[5]); // aktueller Wert f\u00fcr den SMA 14 \u00fcber die Schlusskurse (gerundet) Print(\"SMA(14) calculated using the closing prices: \" + Instrument.Round2TickSize(SMA(Close, 14)[0])); // Close kann auch weggelassen werden, da es per Default verwendet wird. Print(\"SMA(14) calculated using the closing prices: \" + Instrument.Round2TickSize(SMA(14)[0]));","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#closes","text":"","title":"Closes"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_41","text":"Closes ist ein Array von [ DataSeries ][1] welches alle Low -Datenserien enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird. Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge. Closes[0] die Close-Dataseries der Chart-Zeiteinheit Closes[1] die Close-Dataseries aller Bars auf Tagesbasis Closes[2] die Close-Dataseries aller Bars auf Wochenbasis. Closes[0][0] entspricht Close[0]. Siehe auch MultiBars .","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_30","text":"barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_38","text":"Closes[int barSeriesIndex] Closes[int barSeriesIndex][int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_30","text":"Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar .","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_36","text":"Siehe Beispiel unter Multibars .","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#median","text":"","title":"Median"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_42","text":"Median ist eine DataSeries vom Typ DataSeries in der die historischen Median-Werte gespeichert sind. Der Median-Preis eines Bars ergibt sich aus (High + Low) / 2. Siehe auch Typical und Weighted .","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_31","text":"barsAgo Indexwert (s. Bars )","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_39","text":"Median Median[int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_31","text":"Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Informationen zu Median, Typical und Weighted: http://blog.nobletrading.com/2009/12/median-price-typical-price-weighted.html","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_37","text":"// Median-Preis der aktuellen Periode Print(Time[0] + \" \" + Median[0]); // Median-Preis des Bars von vor 5 Perioden Print(Time[5] + \" \" + Median[5]); // aktueller Wert f\u00fcr den SMA 14 \u00fcber die Median-Preise (gerundet) Print(\"SMA(14) calculated using the median prices: \" + Instrument.Round2TickSize(SMA(Median, 14)[0]));","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#medians","text":"","title":"Medians"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_43","text":"Medians ist ein Array von [ DataSeries ][1] welches alle Median -Datenserien enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird. Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge. Medians[0] die Median-Dataseries der Chart-Zeiteinheit Medians[1] die Median-Dataseries aller Bars auf Tagesbasis Medians[2] die Median-Dataseries aller Bars auf Wochenbasis. Medians[0][0]entspricht Medians[0]. Siehe auch MultiBars .","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_32","text":"barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_40","text":"Medians[int barSeriesIndex] Medians[int barSeriesIndex][int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_32","text":"Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Informationen zu Median, Typical und Weighted: http://www.investopedia.com/terms/m/median.asp","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_38","text":"Siehe Beispiel unter Multibars .","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#typical","text":"","title":"Typical"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_44","text":"Typical ist eine DataSeries vom Typ DataSeries in der die historischen Typical-Werte gespeichert sind. Der Typical-Preis eines Bars ergibt sich aus (High + Low + Close) / 3. Siehe auch Median und Weighted .","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_33","text":"barsAgo Indexwert (s. Bars )","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_41","text":"Typical Typical[int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_33","text":"Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Informationen zu Median, Typical und Weighted: https://technicianapp.com/resources/typical-price/","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_39","text":"// Typical-Preis der aktuellen Periode Print(Time[0] + \" \" + Typical[0]); // Typical-Preis des Bars von vor 5 Perioden Print(Time[5] + \" \" + Typical[5]); // aktueller Wert f\u00fcr den SMA 14 \u00fcber die Typical-Preise (gerundet) Print(\"SMA(14) calculated using the typical price: \" + Instrument.Round2TickSize(SMA(Typical, 14)[0]));","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#typicals","text":"","title":"Typicals"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_45","text":"Typicals ist ein Array von Datenserien , welches alle Typical -Datenserien enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird. Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge. Typicals[0] die Typical-Dataseries der Chart-Zeiteinheit Typicals[1] die Typical-Dataseries aller Bars auf Tagesbasis Typicals[2] die Typical-Dataseries aller Bars auf Wochenbasis. Typicals[0][0] entspricht Typicals[0]. Siehe auch MultiBars .","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_34","text":"barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_42","text":"Typicals[int barSeriesIndex] Typicals[int barSeriesIndex][int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_34","text":"Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar .","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_40","text":"Siehe Beispiel unter Multibars .","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#weighted","text":"","title":"Weighted"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_46","text":"Weighted ist eine DataSeries vom Typ DataSeries , in der die historischen Weighted-Werte gespeichert. Der Weighted-Preis eines Bars ergibt sich aus (high + low + 2*close) / gewichtet auf den Schlusskurs. Siehe auch Median und Typical .","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_35","text":"barsAgo Indexwert (s. Bars )","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_43","text":"Weighted[int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_35","text":"Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Informationen zu Median, Typical und Weighted: http://www.stock-trading-infocentre.com/pivot-points.html","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_41","text":"// Weighted-Preis der aktuellen Periode Print(Time[0] + \" \" + Weighted[0]); // Weighted-Preis des Bars von vor 5 Perioden Print(Time[5] + \" \" + Weighted[5]); // aktueller Wert f\u00fcr den SMA 14 \u00fcber die Weighted-Preise (gerundet) Print(\"SMA(14) calculated using the weighted price: \" + Instrument.Round2TickSize(SMA(Weighted, 14)[0]));","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#weighteds","text":"","title":"Weighteds"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_47","text":"Weighteds ist ein Array von [ DataSeries ][1] welches alle Weighted -Datenserien enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird. Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge. Weighteds[0] die Weighted-Dataseries der Chart-Zeiteinheit Weighteds[1] die Weighted-Dataseries aller Bars auf Tagesbasis Weighteds[2] die Weighted-Dataseries aller Bars auf Wochenbasis Weighteds[0][0] entspricht Weighteds[0]. Siehe auch MultiBars .","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_36","text":"barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_44","text":"Weighteds[int barSeriesIndex] Weighteds[int barSeriesIndex][int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_36","text":"Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar .","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_42","text":"Siehe Beispiel unter Multibars .","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#time","text":"","title":"Time"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_48","text":"Time ist eine DataSeries vom Typ DateTimeSeries , in der die Zeitstempel der einzelnen Bars gespeichert sind.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_37","text":"barsAgo Indexwert (s. Bars )","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_45","text":"Time Time[int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_37","text":"Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar .","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_43","text":"// Zeitstempel der aktuellen Periode Print(Time[0]); // Zeitstempel des Bars von vor 5 Perioden Print(Time[5]);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#times","text":"","title":"Times"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_49","text":"Times ist ein Array von DataSeries welches alle Time -Datenserien enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird. Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge. Times[0] die Time-Dataseries der Chart-Zeiteinheit Times[1] die Time-Dataseries aller Bars auf Tagesbasis Times[2] die Time-Dataseries der Chart-Zeiteinheit Times[0][0] entspricht Times[0]. Siehe auch MultiBars .","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_38","text":"barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_46","text":"Times[int barSeriesIndex] Times[int barSeriesIndex][int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_38","text":"Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar .","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_44","text":"Siehe Beispiel unter Multibars .","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#volume","text":"","title":"Volume"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_50","text":"Volume ist eine DataSeries vom Typ DataSeries , in der die historischen Ums\u00e4tze gespeichert sind.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_39","text":"barsAgo Indexwert (s. Bars )","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_47","text":"Volume Volume[ int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_39","text":"Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar . Der vom Indikator VOL() zur\u00fcckgelieferte Wert ist identisch mit dem hier beschriebenen Volumen. Z.B. liefert Vol()[3] den gleichen Wert wie Volume[3].","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_45","text":"// Volumen der aktuellen Periode Print(Time[0] + \" \" + Volume[0]); // Volumen des Bars von vor 5 Perioden Print(Time[5] + \" \" + Volume[5]); // aktueller Wert f\u00fcr den SMA 14 \u00fcber das Volumen (gerundet) Print(\"SMA(14) berechnet \u00fcber das Volumen: \" + Instrument.Round2TickSize(SMA(Volume, 14)[0]));","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#volumes","text":"","title":"Volumes"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_51","text":"Volumes ist ein Array von DataSeries welches alle Volume -Datenserien enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird. Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge. Volumes[0] die Volume-Dataseries der Chart-Zeiteinheit Volumes[1] die Volume-Dataseries aller Bars auf Tagesbasis Volumes[2] die Volume-Dataseries aller Bars auf Wochenbasis. Volumes[0][0] entspricht Volumes[0]. Siehe auch MultiBars .","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_40","text":"barsAgo Indexwert der einzelnen Bars innerhalb der Dataseries barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_48","text":"Volumes[int barSeriesIndex] Volumes[int barSeriesIndex][int barsAgo]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_40","text":"Der zur\u00fcckgegebene Wert ist abh\u00e4ngig von der Eigenschaft CalculateOnClosedBar .","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_46","text":"Siehe Beispiel unter Multibars .","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#timeframe","text":"","title":"TimeFrame"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_52","text":"TimeFrame ist ein Zeitrahmenobjekt. Diese Einstellung/Men\u00fcpunkt wird verwendet, um die aktuelle Zeiteinheit zu lesen, nicht um sie zu festzulegen","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_49","text":"TimeFrame","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#timeframes","text":"","title":"TimeFrames"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_53","text":"TimeFrames ist ein Array von TimeFrame-Objekten, welches f\u00fcr jedes Bar-Objekt ein separates TimeFrame-Objekt enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird. Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge: TimeFrames [0] TimeFrame der prim\u00e4ren Datenserie (Chart-Zeiteinheit) TimeFrames [1] Print (TimeFrames[1]); // liefert \"1 Day\" TimeFrames [2] Print (TimeFrames[2]); // liefert \"1 Week\" TimeFrames [0] entspricht TimeFrame . Siehe auch MultiBars .","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_41","text":"barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_50","text":"TimeFrames [int barSeriesIndex]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_47","text":"if (ProcessingBarSeriesIndex == 0 && ProcessingBarIndex == 0) for (int i = BarsArray.Count-1; i >= 0; i--) Print(\"The Indicator \" + this.Name + \" uses Bars of the Timeframe \" + TimeFrames[i]);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#instruments","text":"\"Instrument\" bezeichnet einen handelbaren Wert, wie z.B. eine Aktie, einen ETF, einen Future, einen CFD usw. Ein Instrument hat viele Eigenschaften, die in einem selbst erstellten AgenaScript verwendet werden k\u00f6nnen. Instrument.Compare Instrument.Currency Instrument.Digits Instrument.ETF Instrument.Exchange Instrument.Expiry Instrument.GetCurrencyFactor Instrument.InstrumentType Instrument.MainSector Instrument.Margin Instrument.Name Instrument.PointValue Instrument.Round2TickSize Instrument.Symbol Instrument.TickSize Innerhalb von OnCalculate() k\u00f6nnen diese Eigenschaften verwendet werden, ohne vorher auf Null-Reference testen zu m\u00fcssen. Sobald die Funktion OnCalculate() von AgenaScript aufgerufen wird, ist immer auch ein Instrument-Objekt vorhanden. Falls diese Eigenschafte ausserhalb von OnCalculate() , verwendet werden, sollte vorher ein entsprechender Test auf Null-Reference z.B. mit if (Bars != null )","title":"Instruments"},{"location":"umgang_mit_bars_und_instrumenten/#instrumentcompare","text":"","title":"Instrument.Compare"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_54","text":"Die Funktion Instrument.Compare vergleicht 2 Kursdaten unter Ber\u00fccksichtigung der richtigen Anzahl Nachkommastellen. Die kleinstm\u00f6gliche Preis\u00e4nderung wird durch den Wert TickSize angegeben. Diese Funktion vereinfacht den sonst etwas aufw\u00e4ndigeren Vergleich mit Hilfe von Floating-Point-Operationen.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_42","text":"double value1 double value2","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_28","text":"Typ int 1 - Kurs1 ist gr\u00f6\u00dfer als Kurs2 -1 - Kurs1 ist kleiner als Kurs2 0 - Kurs1 und Kurs2 sind gleich","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_51","text":"Instrument.Compare(double Value1, double Value2)","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_41","text":"Be aware this function compares prices based on TickSize. If the ticksize of your instrument is 0.01 these prices will be rounded and compared on 2 decimal digits. If you want a regular comparation of two numbers, you should use the operator \"greater than\" (>) or the operator \"smaller than\" (<). More infomation about math.round() Wenn TickSize z.B. 0,00001 ist, wie bei FX-Werten \u00fcblich, dann liefert Compare(2, 1.99999) eine 1, d.h. 2 ist gr\u00f6\u00dfer als 1.99999 Compare(2, 2.000001) eine 0, d.h. die Kurse sind gleich Compare(2, 1.999999) eine 0, d.h. die Kurse sind gleich Compare(2, 2.00001) eine -1, d.h. 2 ist kleiner als 2.00001.","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_48","text":"Print(Instrument.Compare(2, 1.999999));","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#instrumentcurrency","text":"","title":"Instrument.Currency"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_55","text":"Instrument.Currency liefert ein Currencies-Objekt zur\u00fcck, das die jeweilige W\u00e4hrung beinhaltet, in der das Instrument gehandelt wird.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_43","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_29","text":"eine Konstante vom Typ public enum Currencies","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_52","text":"Instrument.Currency","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_42","text":"\u00dcbliche W\u00e4hrungen sind z.B. AUD, CAD, EUR, GBP, JPY oder USD.","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_49","text":"Print(Instrument.Name + \"wird in \" + Instrument.Currency + \" gehandelt\".);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#instrumentdigits","text":"","title":"Instrument.Digits"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_56","text":"Instrument.Digits liefert die Anzahl der Nachkommastellen, mit denen der Kurs des Instrument notiert wird.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_44","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_30","text":"int Digits","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_53","text":"Instrument.Digits","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_43","text":"Aktie werden \u00fcblicherweise mit 2 Stellen nach dem Komma gehandelt. Bei Forex sind es je nach Datenanbieter 4 oder 5 Stellen. Die Funktion findet u.a. Verwendung f\u00fcr das Formatieren von Ausgaben oder zur Rundung von Kursdaten. Siehe auch TickSize und Instrument.Round2Ticks , Instrument.Round2TickSize . Ausf\u00fchrliche Anleitung zum: Formatieren von Zahlen. .","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_50","text":"Print(\"Der Kurs von \" +Instrument.Name + \" wird mit einer Genauigkeit von\" + Instrument.Digits +\" Nachkommastellen angegeben.\");","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#instrumentetf","text":"","title":"Instrument.ETF"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_57","text":"Instrument.ETF dient der Unterscheidung zwischen einer Aktie und einem ETF. Dies ist notwendig, da ETF's von den B\u00f6rsen auch als \"Stock\" (dt. Aktie) angesehen werden..","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_45","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_31","text":"Typ bool","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_54","text":"Instrument.ETF","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_44","text":"Was ist ein ETF? Wikipedia: http://de.wikipedia.org/wiki/Exchange-traded_fund","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_51","text":"if (Instrument.InstrumentType == InstrumentType.Stock) if (Instrument.ETF) Print(\"Der Wert ist ein Exchange-traded Fund.\"); else Print(\"Der Wert ist eine Aktie.\");","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#instrumentexchange","text":"","title":"Instrument.Exchange"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_58","text":"Instrument.Exchange (Exchange = dt. B\u00f6rse) liefert die Bezeichnung des B\u00f6rsenhandelsplatzes f\u00fcr das aktuelle Instrument.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_46","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_32","text":"ein Exchange-Objekt vom Typ public enum Exchanges","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_55","text":"Instrument.Exchange","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_45","text":"\u00dcbersicht B\u00f6rsenhandelspl\u00e4tze","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_52","text":"Print(\"Das Instrument \" + Instrument.Name +\" wird an der B\u00f6rse \" + Instrument.Exchange + \" gehandelt.\");","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#instrumentexpiry","text":"","title":"Instrument.Expiry"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_59","text":"Instrument.Expiry gibt das Datum (Monat und Jahr) des Ablauf eines Finanzinstrumentes an. Nur derivative Handelsinstrumente, wie Optionen oder Futures besitzen ein Ablaufdatum, das sog. Verfallsdatum.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_47","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_33","text":"Typ DateTime F\u00fcr Instrumente ohne Verfallsdatum wird Instrument.Expiry auf DateTime.MaxValue (= 31.12.9999 23.59:59) gesetzt.","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_56","text":"Instrument.Expiry","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_46","text":"Das Verfallsdatum (Expiry) ist auch im Instrument Escort ersichtlich:","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_53","text":"Print(\"Das Instrument \" + Instrument.Name +\" verf\u00e4llt am \" + Instrument.Expiry);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#instrumentgetcurrencyfactor","text":"","title":"Instrument.GetCurrencyFactor"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_60","text":"Instrument.GetCurrencyFactor liefert einen Umrechnungsfaktor zur\u00fcck, mit dessen Hilfe man den Kurs eines Instruments in die W\u00e4hrung des Accounts umrechnen kann.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_48","text":"Typ Currencies","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_34","text":"ein double","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_57","text":"Instrument.GetCurrencyFactor(Currencies)","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_47","text":"\u00dcbliche W\u00e4hrungen sind z.B. AUD, CAD, EUR, GBP, JPY oder USD.","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_54","text":"Protected override void OnCalculate() { double currFactor = Instrument.GetCurrencyFactor(Account.Currency); Print(Close[0] + \" in \" + Instrument.Currency.ToString() + \" = \" + (Close[0] * currFactor) + \" in \" + Account.Currency.ToString()); }","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#instrumentinstrumenttype","text":"","title":"Instrument.InstrumentType"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_61","text":"Instrument.InstrumentType liefert ein Typ-Objekt des Handelsinstrumentes.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_49","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_35","text":"Objekt vom Typ public enum InstrumentType","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_58","text":"Instrument.InstrumentType","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_48","text":"M\u00f6gliche Werte sind: Future, Stock, Index, Currency, Option, CFD und Unknown. Einen Typ ETF gibt es nicht. ETF's sind vom Typ Stock, siehe Instrument.ETF . Der Instrument-Typ ist auch im Instrument Escort ersichtlich:","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_55","text":"Print(\"Das Instrument \" + Instrument.Name + \" ist vom Typ \" + Instrument.InstrumentType);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#instrumentmainsector","text":"","title":"Instrument.MainSector"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_62","text":"Instrument.MainSector liefert den Hauptsektor des Handelsinstrumentes zur\u00fcck.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_50","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_36","text":"String","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_59","text":"Instrument.MainSector","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_49","text":"Der Hauptsektor ist auch im Instrument Escort ersichtlich:","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_56","text":"Print(\"Das Instrument \" + Instrument.Name + \" ist im Sektor \" + Instrument.MainSector + \" t\u00e4tig.\");","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#instrumentmargin","text":"","title":"Instrument.Margin"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_63","text":"Instrument.Margin liefert die erforderliche Margin des Handelsinstrumentes zur\u00fcck.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_51","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_37","text":"int","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_60","text":"Instrument.Margin","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_50","text":"Margin ist auch im Instrument Escort ersichtlich:","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_57","text":"Print(\"Das Instrument\" + Instrument.Name + \" hat eine Margin von \" + Instrument.Margin);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#instrumentname","text":"","title":"Instrument.Name"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_64","text":"Instrument.Name liefert die Bezeichnung des Handelsinstrumentes.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_52","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_38","text":"Typ string","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_61","text":"Instrument.Name","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_51","text":"Der Instrument Name ist auch im Instrument Escort ersichtlich:","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_58","text":"Print(\"Das aktuell im Chart geladene Instrument hei\u00dft \" + Instrument.Name);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#instrumentpointvalue","text":"","title":"Instrument.PointValue"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_65","text":"Instrument.PointValue liefert den Geldwert f\u00fcr die Bewegung eines Instrumentes von einem vollen Punkt.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_53","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_39","text":"Typ double - Punktwert","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_62","text":"Instrument.PointValue","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_52","text":"Beispiele verschieder Punktwerte (je St\u00fcck, CDF, Futurekontrakt, Lot usw.) Aktie: im .allg. 1,00 Euro bzw. 1,00 USD. EUR/USD: 100,000 USD Dax-Future: 25,00 Euro Tickwert Der Tickwert ergibt sich, wenn man den Punktwert mit der TickGr\u00f6\u00dfe (TickSize) multipliziert. z.B. hat der E-mini S&P 500 einen Punktwert von $ 50. Die TickSize betr\u00e4gt 0,25. Es braucht also eine Bewegung von 4 Ticks f\u00fcr einen vollen Punkt. Aus 50 * 0,25 = 50 / 4 ergibt sich ein Tickwert von 12,50 $/ je Tick. Der Punktwert ist auch im Instrument Escort ersichtlich:","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_59","text":"Print(\"Wenn \" + Instrument.Name + \" einen vollen Punkt steigt, entspricht dies dem Gegenwert von \" + Instrument.PointValue + \" \" + Instrument.Currency);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#instrumentround2ticksize","text":"","title":"Instrument.Round2TickSize"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_66","text":"Die Funktion Instrument.Round2TickSize rundet einen \u00fcbergebenen Kurswert auf den kleinstm\u00f6glichen Wert, der durch die Tickgr\u00f6\u00dfe (TickSize) des Instrumentes teilbar ist.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_54","text":"double - Kurswert","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_40","text":"double","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_63","text":"Instrument.Round2TickSize(double MarketPrice)","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_53","text":"Die Anzahl der Nachkommastellen, auf die gerundet wird, ist je nach Instrument unterschiedlich. Ist das Instrument eine Aktie, wird auf 2 Nachkommastellen gerundet, bei einem Forex-Wert auf 4 bzw. 5 Nachkommastellen. Siehe auch TickSize und Instrument.Digits . Beispiele f\u00fcr professionelle Formatting , Formatting of Numbers .","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_60","text":"double Price = 12.3456789; Print(Price + \" gerundet auf einen f\u00fcr \" + Instrument.Name + \" g\u00fcltigen Kurs ist \" + Instrument.Round2TickSize(Price));","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#instrumentsymbol","text":"","title":"Instrument.Symbol"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_67","text":"Instrument.Symbol liefert das Symbol, unter welchem das Handelsinstrument in AgenaTrader eindeutig identifizierbar ist. Anhand des Symbols werden die Mappings zu den verschiedenen Datenanbietern und Brokern verwaltet.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_55","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_41","text":"Typ string","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_64","text":"Instrument.Symbol","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_54","text":"Mit dem Symbol werden gleiche Aktion an verschiedenen B\u00f6rsenpl\u00e4tzen unterschieden. Das Symbol BMW.DE ist z.B. die BMW-Aktie an der Xetra, BMW.CFD ist der CFD auf die BMW-Aktie. Das Instrument Symbol ist auch im Instrument Escort ersichtlich:","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_61","text":"Print(\"Das aktuell im Chart geladene Instrument hat das Symbol \" + Instrument.Symbol);","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#instrumentticksize","text":"","title":"Instrument.TickSize"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_68","text":"Die Tickgr\u00f6\u00dfe oder TickSize ist die kleinste m\u00f6gliche Einheit um die sich ein Finanzinstrument bewegen kann. Dies ist umgangssprachlich 1 Tick.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_56","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#ruckgabewert_42","text":"double","title":"R\u00fcckgabewert"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_65","text":"Instrument.TickSize oder vereinfacht TickSize","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_55","text":"Das Schl\u00fcsselwort TickSize entspricht Instrument.TickSize. Beide Aufrufe liefern identische Werte und sind gegeneinander austauschbar.","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiele_4","text":"Aktie: 0,01 ES-Future: 0,25 EUR/USD: 0,00001 Siehe auch Instrument.PointValue und Instrument.Digits . Beispiele f\u00fcr professionelle Formatting , Formatting of Numbers .","title":"Beispiele"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_62","text":"Print(\"Der Kurs von \" + Instrument.Name + \" kann sich minimal um \" + Instrument.TickSize + \" Punkt(e) ver\u00e4ndern.\");","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#multibars","text":"","title":"Multibars"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_69","text":"Einem Indikator bzw. eine Strategie liegt immer die gleiche Zeiteinheit zugrunde, wie diejenige, in der der Chart angezeigt wird. Wird z.B. ein SMA(14) in einem 5-Minuten-Chart dargestellt, wird der gleitende Durchschnitt \u00fcber die 14 letzten 5-Minuten-Bars berechnet. Auf einem Tageschart w\u00fcrden entsprechend die Schlusskurse der letzten 14 Tage zur Berechnung herangezogen werden. Das gleiche Prinzip gilt f\u00fcr selbst entwickelte Indikatoren. In einem 5-Minuten-Chart w\u00fcrde die Methode OnCalculate() f\u00fcr jeden 5-Minuten-Bar aufgerufen werden. Mit Multibars ist es au\u00dferdem m\u00f6glich, Daten eines anderen Instrumentes zu laden.","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_63","text":"using System; using System.Collections.Generic; using System.ComponentModel; using System.Drawing; using System.Linq; using System.Xml; using System.Xml.Serialization; using AgenaTrader.API; using AgenaTrader.Custom; using AgenaTrader.Plugins; using AgenaTrader.Helper; namespace AgenaTrader.UserCode { [Description(\"Multibar Demo\")] // Der Indikator ben\u00f6tigt Tages- und Wochendaten [TimeFrameRequirements(\"1 Day\", \"1 Week\")] public class MultiBarDemo : UserIndicator { private static readonly TimeFrame TF_Day = new TimeFrame(DatafeedHistoryPeriodicity.Day, 1); private static readonly TimeFrame TF_Week = new TimeFrame(DatafeedHistoryPeriodicity.Week, 1); protected override void OnBarsRequirements() { Add(TF_Day); Add(TF_Week); } protected override void OnInit() { CalculateOnClosedBar = true; } protected override void OnCalculate() { // aktueller Wert f\u00fcr den SMA 14 auf Tagesbasis Print(\"TF0: \" + SMA(Closes[0], 14)[0]); // The current value for the SMA 14 in a daily timeframe Print(\"TF1: \" + SMA(Closes[1], 14)[0]); // aktueller Wert f\u00fcr den SMA 14 auf Wochenbasis Print(\"TF2: \" + SMA(Closes[2], 14)[0]); } } }","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-hinweise","text":"Bei Verwendung weiterer Zeiteinheiten wird den Arrays Opens , Highs , Lows , Closes , Medians , Typicals , Weighteds , Times und Volumes ein weiterer Eintrag mit den jeweiligen Datenserien der Bars der neuen Zeiteinheit hinzugef\u00fcgt. Die Indizierung erfolgt in der Reihenfolge des Hinzuf\u00fcgens der Zeiteinheiten. Closes[0][0] entspricht Close[0]. Closes[1][0] entspricht dem aktuellen Schlusskurs der Tagesdatenreihe. Closes[2][0] entspricht dem aktuellen Schlusskurs der Wochendatenreihe. \"Closes\"kann in den Beispielen selbstverst\u00e4ndlich auch durch Opens, Highs, Lows usw. ersetzt werden. Siehe auch ProcessingBarIndexes , ProcessingBarSeriesIndex , TimeFrames , TimeFrameRequirements . Es gibt noch eine weitere Schreibweise f\u00fcr Multbars: // unter Variablendeklaration wird die Variable TF_Day definiert private static readonly TimeFrame TF_Day = new TimeFrame(DatafeedHistoryPeriodicity.Day, 1); private static readonly TimeFrame TF_Week = new TimeFrame(DatafeedHistoryPeriodicity.Week, 1); // Die folgende Anweisung ist identisch mit double d = Closes[1][0]; double d = MultiBars.GetBarsItem(TF_Day).Close[0]; // Die folgende Anweisung ist identisch mit double w = Closes[2][0]; double w = MultiBars.GetBarsItem(TF_Week).Close[0];","title":"Weitere Hinweise"},{"location":"umgang_mit_bars_und_instrumenten/#processingbarindexes","text":"","title":"ProcessingBarIndexes"},{"location":"umgang_mit_bars_und_instrumenten/#beschreibung_70","text":"CurrentBars ist ein Array von int-Werten, welches f\u00fcr jedes Bar-Objekt die Nummer von ProcessingBarIndex enth\u00e4lt. Dieses Array ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Ein neuer Eintrag wird dem Array immer dann hinzugef\u00fcgt, wenn dem Indikator bzw. der Strategie eine neue Zeiteinheit hinzugef\u00fcgt wird. Mit [TimeFrameRequirements((\"1 Day\"), (\"1 Week\"))] enth\u00e4lt das Array 3 Eintr\u00e4ge: ProcessingBarIndexes[0] ProcessingBarIndexes der prim\u00e4ren Datenserie (Chart-Zeiteinheit) ProcessingBarIndexes[1] ProcessingBarIndexes f\u00fcr die Tagesbars ProcessingBarIndexes[2] ProcessingBarIndexes f\u00fcr die Wochenbars. ProcessingBarIndexes[0] entspricht ProcessingBarIndex . Siehe auch MultiBars .","title":"Beschreibung"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_57","text":"barSeriesIndex Indexwert der unterschiedlichen Zeiteinheiten","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_66","text":"ProcessingBarIndexes[int barSeriesIndex]","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_64","text":"//Sicherstellen, dass mind. 20 Bars geladen sind for (int i=0; i<ProcessingBarIndexes.Count; i++) if (ProcessingBarIndexes[i] < 20) return;","title":"Beispiel"},{"location":"umgang_mit_bars_und_instrumenten/#processingbarseriesindex","text":"","title":"ProcessingBarSeriesIndex"},{"location":"umgang_mit_bars_und_instrumenten/#description_1","text":"In einem Multibar-Script, d.h. in einem Indikator (bzw. einer Strategie), der mit mehreren Zeiteinheiten arbeitet, sind mehrere Bars-Objekte vorhanden. Die Methode OnCalculate() wird f\u00fcr jeden Bar im Script aufgerufen. Um Ereignisse bestimmter Datenreihen in die Berechnung einzubeziehen bzw. auszublenden ist BarsInProgress zu verwenden. ProcessingBarSeriesIndex ist nur in Indikatoren bzw. Strategien von Bedeutung, die Daten aus mehreren Zeiteinheiten verarbeiten. Mit [TimeFrameRequirements(\"1 Day\", \"1 Week\")] werden 2 weitere Zeiteinheiten zur prim\u00e4ren Chart-Zeiteinheit hinzugef\u00fcgt. Wenn OnCalculate() von der prim\u00e4ren Datenreihe aufgerufen wird, ist ProcessingBarSeriesIndex=0. Wird OnCalculate() von den Tagesbars aufgerufen, ist ProcessingBarSeriesIndex=1, bei den Wochendaten hat BarsInProgress den Wert 2. Siehe auch Multibars and ProcessingBarIndexes .","title":"Description"},{"location":"umgang_mit_bars_und_instrumenten/#parameter_58","text":"keine","title":"Parameter"},{"location":"umgang_mit_bars_und_instrumenten/#verwendung_67","text":"ProcessingBarSeriesIndex","title":"Verwendung"},{"location":"umgang_mit_bars_und_instrumenten/#weitere-informationen_56","text":"In einem Script, welches nur auf der prim\u00e4ren Zeiteinheit arbeitet, hat BarsInProgress immer den Wert 0.","title":"Weitere Informationen"},{"location":"umgang_mit_bars_und_instrumenten/#beispiel_65","text":"// Arbeitsweise veranschaulichen // ggf. CalculateOnBarClose=false setzen Print(Time[0] + \" \" + ProcessingBarSeriesIndex); // Berechnungen nur f\u00fcr die Chart-Zeiteinheit protected override void OnCalculate() { if (ProcessingBarSeriesIndex > 0) return; // Logik f\u00fcr prim\u00e4re Datenreihe }","title":"Beispiel"},{"location":"zeichenobjekte/","text":"Zeichenobjekte AddChartAndrewsPitchfork() Beschreibung AddChartAndrewsPitchfork() zeichnet ein Andrew's Pitchfork. Informationen zur Verwendung: - vtad.de - hvolumen-analyse.de - Godmode-Trader.de Verwendung AddChartAndrewsPitchfork(string name, bool autoScale, int start1BarsBack, double start1Y, int start2BarsBack, double start2Y, int start3BarsBack, double start3Y, Color color, DashStyle dashStyle, int width) AddChartAndrewsPitchfork(string name, bool autoScale, DateTime start1Time, double start1Y, DateTime start2Time, double start2Y, DateTime start3Time, double start3Y, Color color, DashStyle dashStyle, int width) R\u00fcckgabewert A drawing object of the type IAndrewsPitchfork (interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist. start1BarsBack Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt1 (x-Achse) start1Time Datum/Zeit f\u00fcr Ankerpunkt1 (x-Achse) start1Y y-Wert f\u00fcr Ankerpunkt1 start2BarsBack Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt2 (x-Achse) start2Time Datum/Zeit f\u00fcr Ankerpunkt2(x-Achse) start2Y y-Wert f\u00fcr Ankerpunkt2 start3BarsBack Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt3 (x-Achse) start3Time Datum/Zeit f\u00fcr Ankerpunk3 (x-Achse) start3Y -Wert f\u00fcr Ankerpunkt3 color Farbe des Zeichenobjekts dashStyle Linienart DashStyle.Dash DashStyle.DashDot DashStyle.DashDotDot DashStyle.Dot DashStyle.Solid ggf. mu\u00df using System.Drawing.Drawing2D; mit eingebunden werden. width Linienst\u00e4rke in Punkten Beispiel // zeichnet ein Andrew's Pitchfork (\"Mistgabel\") AddChartAndrewsPitchfork(\"MyAPF\", true, 4, Low[4], 3, High[3], 1, Low[1], Color.Black, DashStyle.Solid, 2); AddChartArc() Beschreibung AddChartArc() zeichnet einen Kreisbogen. Verwendung AddChartArc(string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color) AddChartArc(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, DashStyle dashStyle, int width) AddChartArc(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, DashStyle dashStyle, int width) R\u00fcckgabewert Ein Zeichenobjekt vom Typ IArc (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu barsBackStart Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den Startpunkt startTime Datum/Uhrzeit f\u00fcr den Startpunkt startY y-Wert f\u00fcr den Startpunkt barsBackEnd Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den Endpunkt endTime Datum/Uhrzeit f\u00fcr den Endpunkt endY y-Wert f\u00fcr den Endpunkt color Farbe des Zeichenobjekts dashStyle Linienart DashStyle.Dash DashStyle.DashDot DashStyle.DashDotDot DashStyle.Dot DashStyle.Solid ggf. mu\u00df using System.Drawing.Drawing2D; mit eingebunden werden. width Linienst\u00e4rke in Punkten Beispiel // zeichnet einen blauen Kreisbogen AddChartArc(\"MyArc-\" + ProcessingBarIndex, true, 10, 10, 0, 20, Color.Blue, DashStyle.Solid, 3); AddChartArrowDown() Beschreibung AddChartArrowDown() zeichnet einen nach unten gerichteten Pfeil: DrawArrowUp(), DrawDiamond(), DrawDot(), DrawSquare(), DrawTriangleUp(), AddChartArrowUp() , AddChartArrowDown() , AddChartDiamond() , AddChartDot() , AddChartSquare() , AddChartTriangleUp() , AddChartTriangleDown() . Verwendung AddChartArrowDown(string name, bool autoScale, int barsAgo, double y, Color color) AddChartArrowDown(string name, bool autoScale, DateTime time, double y, Color color) R\u00fcckgabewert A drawing object of the type IArrowDown (interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen barsAgo Gibt an, an welchem zur\u00fcckliegenden Bar der Pfeil gezeichnet werden soll (0=aktueller Bar) time Datum/Uhrzeit des Bars, an dem der Pfeil gezeichnet werden soll y y-Wert f\u00fcr den Pfeil color Farbe des Zeichenobjekts Beispiel // zeichnet am akt. Bar einen roten Pfeil 3 Ticks \u00fcber dem Hoch AddChartArrowDown(\"MyArrow-\" + ProcessingBarIndex, true, 0, High[0] + 3*TickSize, Color.Red); // Zeichnet einen roten Pfeil auf einem Dreistufen-Umkehrmuster if(High[2] > High[3] && High[1] > High[2] && Close[0] < Open[0]) AddChartArrowDown(ProcessingBarIndex.ToString(), true, 0, High[0] + 3*TickSize, Color.Red); AddChartArrowLine() Beschreibung AddChartArrowLine() zeichnet einen Pfeil. Verwendung AddChartArrowLine (string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color) AddChartArrowLine (string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, DashStyle dashStyle, int width) AddChartArrowLine (string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, DashStyle dashStyle, int width) R\u00fcckgabewert Ein Zeichenobjekt vom Typ IArrowLine (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist barsBackStart Gibt an, an welchem zur\u00fcckliegenden Bar der Pfeil beginnen soll (0=aktueller Bar) startTime Datum/Uhrzeit des Bars, an dem der Pfeil beginnen soll startY y-Wert, an dem der Pfeil beginnen soll barsBackEnd Gibt an, an welchem zur\u00fcckliegenden Bar der Pfeil enden soll (0=aktueller Bar) endTime Datum/Uhrzeit des Bars, an dem der Pfeil enden endY y-Wert, an dem der Pfeil enden soll color Farbe des Zeichenobjekts dashStyle Linienart DashStyle.Dash DashStyle.DashDot DashStyle.DashDotDot DashStyle.Dot DashStyle.Solid ggf. mu\u00df using System.Drawing.Drawing2D; mit eingebunden werden. width Linienst\u00e4rke in Punkten Beispiel // zeichnet einen schwarzen Pfeil AddChartArrowLine(\"MyArrow-\" + ProcessingBarIndex, false, 10, 10, 0, 5, Color.Black, DashStyle.Solid, 4); AddChartArrowUp() Beschreibung AddChartArowUp() zeichnet einen nach oben gerichteten Pfeil: Siehe auch AddChartArrowUp() , AddChartArrowDown() , AddChartDiamond() , AddChartDot() , AddChartSquare() , AddChartTriangleUp() , AddChartTriangleDown() . Verwendung AddChartArrowUp(string name, bool autoScale, int barsAgo, double y, Color color) AddChartArrowUp(string name, bool autoScale, DateTime time, double y, Color color) R\u00fcckgabewert A drawing object of the type IArrowUp (interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen barsAgo Gibt an, an welchem zur\u00fcckliegenden Bar der Pfeil gezeichnet werden soll (0=aktueller Bar) time Datum/Uhrzeit des Bars, an dem der Pfeil gezeichnet werden soll y y-Wert f\u00fcr den Pfeil color Farbe des Zeichenobjekts Example // zeichnet einen gr\u00fcnen Pfeil am akt. Bar 3 Ticks unter dem Tief AddChartArrowUp(\"MyArrow-\" + ProcessingBarIndex, true, 0, Low[0] - 3*TickSize, Color.Green); AddChartDiamond() Beschreibung AddChartDiamond() zeichnet einen Diamanten: Siehe auch AddChartArrowUp() , AddChartArrowDown() , AddChartDiamond() , AddChartDot() , AddChartSquare() , AddChartTriangleUp() , AddChartTriangleDown() . Verwendung AddChartDiamond(string name, bool autoScale, int barsAgo, double y, Color color) AddChartDiamond(string name, bool autoScale, DateTime time, double y, Color color) R\u00fcckgabewert Ein Zeichenobjekt vom Typ IDiamond (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen barsAgo Gibt an, an welchem zur\u00fcckliegenden Bar der Pfeil gezeichnet werden soll (0=aktueller Bar) time Datum/Uhrzeit des Bars, an dem der Pfeil gezeichnet werden soll y y-Wert f\u00fcr den Pfeil color Farbe des Zeichenobjekts Beispiel // zeichnet einen hellblauen Diamanten am akt. Bar 5 Ticks unter dem Tief AddChartDiamond(\"MyDiamond-\" + ProcessingBarIndex, true, 0, Low[0] - 5*TickSize, Color.SteelBlue); AddChartDot() Beschreibung AddChartDot() zeichnet einen Punkt: Siehe auch AddChartArrowUp() , AddChartArrowDown() , AddChartDiamond() , AddChartDot() , AddChartSquare() , AddChartTriangleUp() , AddChartTriangleDown() . Verwendung AddChartDot(string name, bool autoScale, int barsAgo, double y, Color color) AddChartDot(string name, bool autoScale, DateTime time, double y, Color color) R\u00fcckgabewert Ein Zeichenobjekt vom Typ IDot (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen barsAgo Gibt an, an welchem zur\u00fcckliegenden Bar der Pfeil gezeichnet werden soll (0=aktueller Bar) time Datum/Uhrzeit des Bars, an dem der Pfeil gezeichnet werden soll y y-Wert f\u00fcr den Pfeil color Farbe des Zeichenobjekts Beispiel // zeichnet einen orangen Punkt am akt. Bar 5 Ticks \u00fcber dem Hoch AddChartDot(\"MyDot-\" + ProcessingBarIndex, true, 0, High[0] + 5*TickSize, Color.Orange); AddChartEllipse() Beschreibung AddChartEllipse() zeichnet eine Ellipse. Verwendung AddChartEllipse(string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color) AddChartEllipse(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, Color areaColor, int areaOpacity) AddChartEllipse(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, Color areaColor, int areaOpacity) R\u00fcckgabewert Ein Zeichenobjekt vom Typ IEllipse (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist barsBackStart Gibt an, an welchem zur\u00fcckliegenden Bar die Ellipse beginnen soll (0=aktueller Bar) startTime Datum/Uhrzeit des Bars, an dem die Ellipse beginnen soll startY Wert, an dem die Ellipse beginnen soll barsBackEnd Gibt an, an welchem zur\u00fcckliegenden Bar die Ellipse enden soll (0=aktueller Bar) endTime Datum/Uhrzeit des Bars, an dem die Ellipse enden soll endY y-Wert, an dem die Ellipse enden soll color Randfarbe des Zeichenobjekts areaColor F\u00fcllfarbe des Zeichenobjekts areaOpacity Transparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 = komplett transparent; 255 = keine Transparenz) Beispiel // zeichnet eine gelbe Ellipse vom akt. Bar bis 5 Bars zur\u00fcck AddChartEllipse(\"MyEllipse-\" + ProcessingBarIndex, true, 5, High[5], 0, Close[0], Color.Yellow, Color.Yellow, 1); AddChartExtendedLine() Beschreibung AddChartExtendedLine() zeichnet eine Linie mit unendlichem Endpunkt. Siehe auch AddChartLine() , AddChartHorizontalLine() , AddChartVerticalLine() , AddChartRay() . Verwendung AddChartExtendedLine(string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color) AddChartExtendedLine(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, DashStyle dashStyle, int width) AddChartExtendedLine(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, DashStyle dashStyle, int width) R\u00fcckgabewert Ein Zeichenobjekt vom Typ IExtendedLine (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist barsBackStart Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den Startpunkt startTime Datum/Uhrzeit f\u00fcr den Startpunkt startY y-Wert f\u00fcr den Startpunkt barsBackEnd Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den zweiten Punkt (Einen Endpunkt gibt es bei diesem Zeichenobjekt nicht endTime Datum/Uhrzeit f\u00fcr den Endpunkt endY y-Wert f\u00fcr den Endpunkt color Farbe des Zeichenobjekts dashStyle Linienart DashStyle.Dash DashStyle.DashDot DashStyle.DashDotDot DashStyle.Dot DashStyle.Solid ggf. mu\u00df using System.Drawing.Drawing2D; mit eingebunden werden. width Linienst\u00e4rke in Punkten Beispiel // zeichnet eine Linie ohne Endpunkt AddChartExtendedLine(\"MyExt.LevelLine-\" + ProcessingBarIndex, false, 10, Close[10], 0, Close[0], Color.Black, DashStyle.Solid, 1); AddChartFibonacciCircle() Beschreibung AddChartFibonacciCircle() zeichnet Fibonacci-Kreise. Verwendung AddChartFibonacciCircle(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY) AddChartFibonacciCircle(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY) R\u00fcckgabewert Ein Zeichenobjekt vom Typ IFibonacciCircle (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist barsBackStart Gibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci-Kreise beginnen sollen. startTime Datum/Uhrzeit des Bars, an dem die Fibonacci-Kreise beginnen sollen startY y-Wert, an dem die Fibonacci-Kreise beginnen sollen barsBackEnd Gibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci-Kreise enden sollen (0=aktueller Bar) endTime Datum/Uhrzeit des Bars, an dem die Fibonacci-Kreise enden sollen endY y-Wert, an dem die Fibonacci-Kreise enden sollen Beispiel // zeichnet Fibonacci-Kreise AddChartFibonacciCircle(\"MyFibCircle-\" + ProcessingBarIndex, true, 5, Low[5], 0, High[0]); AddChartFibonacciExtensions() Beschreibung AddChartFibonacciExtensions() zeichnet Fibonacci Extensions Verwendung AddChartFibonacciExtensions(string name, bool autoScale, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, int start3BarsAgo, double start3Y) AddChartFibonacciExtensions(string name, bool autoScale, DateTime start1Time, double start1Y, DateTime start2Time, double start2Y, DateTime start3Time, double start3Y) R\u00fcckgabewert Ein Zeichenobjekt vom Typ IFibonacciExtensions (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist. start1BarsAgo Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt1 (x-Achse) start1Time Datum/Zeit f\u00fcr Ankerpunkt1 (x-Achse) start1Y y-Wert f\u00fcr Ankerpunkt1 start2BarsAgo Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt2 (x-Achse) start2Time Datum/Zeit f\u00fcr Ankerpunkt2(x-Achse) start2Y y-Wert f\u00fcr Ankerpunkt2 start3BarsAgo Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt3 (x-Achse) start3Time Datum/Zeit f\u00fcr Ankerpunk3 (x-Achse) start3Y y-Wert f\u00fcr Ankerpunkt3 Beispiel // zeichnet FibonacciExtensions AddChartFibonacciExtensions(\"MyFibExt-\" + ProcessingBarIndex, true, 4, Low[4], 3, High[3], 1, Low[1]); AddChartFibonacciProjections() Beschreibung Draw Fibonacci Projections () zeichnet Fibonacci Projections. Verwendung AddChartFibonacciProjections(string name, bool autoScale, DateTime start1Time, double start1Y,DateTime start2Time, double start2Y, DateTime start3Time, double start3Y) R\u00fcckgabewert Ein Zeichenobjekt vom Typ IFibonacciProjections (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist. start1Time Datum/Zeit f\u00fcr Ankerpunkt1 (x-Achse) start1Y y-Wert f\u00fcr Ankerpunkt1 start2Time Datum/Zeit f\u00fcr Ankerpunkt2(x-Achse) start2Y y-Wert f\u00fcr Ankerpunkt2 start3Time Datum/Zeit f\u00fcr Ankerpunk3 (x-Achse) start3Y y-Wert f\u00fcr Ankerpunkt3 Beispiel // zeichnet FibonacciProjections AddChartFibonacciProjections(\"MyFibPro-\" + ProcessingBarIndex, true, Low[4], 3, High[3], 1, Low[1], 2); AddChartFibonacciRetracements() Beschreibung AddChartFibonacciRetracements() dzeichnet Fibonacci Retracements. Verwendung AddChartFibonacciRetracements(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY) AddChartFibonacciRetracements(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY) R\u00fcckgabewert A drawing object of the type IFibonacciRetracements (interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist barsBackStart Gibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci Retracements beginnen sollen. startTime Datum/Uhrzeit des Bars, an dem die Fibonacci Retracements beginnen sollen startY y-Wert, an dem die Fibonacci Retracements beginnen sollen barsBackEnd Gibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci Retracements enden sollen (0=aktueller Bar) endTime Datum/Uhrzeit des Bars, an dem die Fibonacci Retracements enden sollen endY y-Wert, an dem die Fibonacci Retracements enden sollen Beispiel // zeichnet Fibonnaci Retracements AddChartFibonacciRetracements(\"MyFibRet-\" + ProcessingBarIndex, true, 10, Low[10], 0, High[0]); AddChartFibonacciTimeExtensions() Beschreibung AddChartFibonacciTimeExtensions() zeichnet Fibonacci Retracements. Verwendung AddChartFibonacciTimeExtensions(string name, int barsBackStart, double startY, int barsBackEnd, double endY) AddChartFibonacciTimeExtensions(string name, DateTime startTime, double startY, DateTime endTime, double endY) R\u00fcckgabewert Ein Zeichenobjekt vom Typ IFibonacciTimeExtensions (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung barsBackStart Gibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci TimeExtensions beginnen sollen. startTime Datum/Uhrzeit des Bars, an dem die Fibonacci TimeExtensions beginnen sollen startY y-Wert, an dem die Fibonacci-Kreise beginnen sollen barsBackEnd Gibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci TimeExtensions enden sollen (0=aktueller Bar) endTime Datum/Uhrzeit des Bars, an dem die Fibonacci TimeExtensions enden sollen endY y-Wert, an dem die Fibonacci TimeExtensions enden sollen Beispiel // zeichnet Fibonacci TimeExtensions AddChartFibonacciTimeExtensions(\"MyFibTimeExt-\" + ProcessingBarIndex, 10, Low[10], 0, High[0]); AddChartGannFan() Beschreibung AddChartGannFan() zeichnet Fibonacci Retracements. Verwendung AddChartGannFan(string name, bool autoScale, int barsAgo, double y) AddChartGannFan(string name, bool autoScale, DateTime time, double y) R\u00fcckgabewert Ein Zeichenobjekt vom Typ IGannFan (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist barsAgo Gibt an, an welchem zur\u00fcckliegenden Bar der GannFan gezeichnet werden soll time Datum/Uhrzeit des Bars, an dem der GannFan gezeichnet werden soll y y-Wert, an dem der GannFan gezeichnet werden soll Beispiel // zeichnet einen Gann Fan am Tief des Bars von vor 10 Perioden AddChartGannFan(\"MyGannFan-\" + ProcessingBarIndex, true, 10, Low[10]); AddChartHorizontalLine() Beschreibung AddChartHorizontalLine() zeichnet eine horizontale Linie in den Chart. Siehe auch AddChartLine() , AddChartVerticalLine() , AddChartExtendedLine() , AddChartRay() . Verwendung AddChartHorizontalLine(string name, double y, Color color) AddChartHorizontalLine(string name, bool autoScale, double y, Color color, DashStyle dashStyle, int width) R\u00fcckgabewert Ein Zeichenobjekt vom Typ IHorizontalLine (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist y ein beliebiger double-Wert color Linienfarbe dashStyle Linienart DashStyle.Dash DashStyle.DashDot DashStyle.DashDotDot DashStyle.Dot DashStyle.Solid ggf. mu\u00df using System.Drawing.Drawing2D; mit eingebunden werden. width Linienst\u00e4rke Beispiele // zeichnet eine horizontale Linie bei y=10 AddChartHorizontalLine(\"MyHorizontalLine-\" + ProcessingBarIndex, 10, Color.Black); AddChartLine() Beschreibung AddChartLine() zeichnet eine (Trend-) Linie. Siehe auch AddChartHorizontalLine() , AddChartVerticalLine() , AddChartExtendedLine() , AddChartRay() . Verwendung AddChartLine(string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color) AddChartLine(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, DashStyle dashStyle, int width) AddChartLine(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, DashStyle dashStyle, int width) R\u00fcckgabewert Ein Zeichenobjekt vom Typ ITrendLine (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist barsBackStart Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den Startpunkt startTime Datum/Uhrzeit f\u00fcr den Startpunkt startY y-Wert f\u00fcr den Startpunkt barsBackEnd Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den zweiten Punkt (Einen Endpunkt gibt es bei diesem Zeichenobjekt nicht) endTime Datum/Uhrzeit f\u00fcr den Endpunkt endY y-Wert f\u00fcr den Endpunkt color Farbe des Zeichenobjekts dashStyle Linienart DashStyle.Dash DashStyle.DashDot DashStyle.DashDotDot DashStyle.Dot DashStyle.Solid ggf. mu\u00df using System.Drawing.Drawing2D; mit eingebunden werden. width Linienst\u00e4rke in Punkten Beispiel // zeichnet eine Linie AddChartLine(\"MyLine-\" + ProcessingBarIndex, false, 10, Close[10], 0, Close[0], Color.Black, DashStyle.Solid, 1); AddChartRay() Beschreibung AddChartRay() zeichnet eine (Trend-) Linie, die zu einer Seite ins Unendliche verl\u00e4ngert wird. Siehe auch AddChartLine() , AddChartHorizontalLine() , AddChartVerticalLine() , AddChartExtendedLine() . Verwendung AddChartRay(string name, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, Color color) AddChartRay(string name, bool autoScale, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, Color color, DashStyle dashStyle, int width) AddChartRay(string name, bool autoScale, DateTime start1Time, double start1Y, DateTime start2Time, double start2Y, Color color, DashStyle dashStyle, int width) R\u00fcckgabewert Ein Zeichenobjekt vom Typ IRay (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist. start1BarsAgo Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt1 (x-Achse) start1Time Datum/Zeit f\u00fcr Ankerpunkt1 (x-Achse) start1Y y-Wert f\u00fcr Ankerpunkt1 start2BarsAgo Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt2 (x-Achse) start2Time Datum/Zeit f\u00fcr Ankerpunkt2(x-Achse) start2Y y-Wert f\u00fcr Ankerpunkt2 color Farbe des Zeichenobjekts dashStyle Linienart DashStyle.Dash DashStyle.DashDot DashStyle.DashDotDot DashStyle.Dot DashStyle.Solid ggf. mu\u00df using System.Drawing.Drawing2D; mit eingebunden werden. width Linienst\u00e4rke Beispiele // zeichnet eine Linie vom Bar von vor 10 Perioden \u00fcber den aktuellen Bar (x-Achse) // --> Linie wird nach rechts verl\u00e4ngert // von y=3 \u00fcber y=7 AddChartRay(\"MyRay-\" + ProcessingBarIndex, 10, 3, 0, 7, Color.Green); // zeichnet eine Linie vom akt. Bar \u00fcber den Bar von vor 10 Perioden // --> Linie wird nach links verl\u00e4ngert // von y=3 \u00fcber y=7 AddChartRay(\"MyRay-\" + ProcessingBarIndex, 0, 3, 10, 7, Color.Green); AddChartRectangle() Beschreibung AddChartRectangle() zeichnet ein Rechteck. Verwendung AddChartRectangle(string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color) AddChartRectangle(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, Color areaColor, int areaOpacity) AddChartRectangle(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, Color areaColor, int areaOpacity) R\u00fcckgabewert Ein Zeichenobjekt vom Typ IRectangle (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist. barsBackStart Gibt an, an welchem zur\u00fcckliegenden Bar sich die eine Ecke des Rechtecks befinden soll (0=aktueller Bar) startTime Datum/Uhrzeit des Bars, an dem sich die eine Ecke des Rechtecks befinden soll startY y-Wert, an dem die sich die eine Ecke des Rechtecks befinden soll barsBackEnd Gibt an, an welchem zur\u00fcckliegenden Bar sich die zweite Ecke des Rechtecks befinden soll (0=aktueller Bar) endTime Datum/Uhrzeit des Bars, an dem sich die zweite Ecke des Rechtecks befinden soll endY y-Wert, an dem die sich die zweite Ecke des Rechtecks befinden soll color Farbe des Zeichenobjekts areaColor F\u00fcllfarbe des Zeichenobjekts areaOpacity Transparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 = komplett transparent, 255 = keine Transparenz) Beispiel // zeichnet ein gr\u00fcnes Rechteck vom Tief von vor 10 Perioden zum Hoch von vor 5 Perioden // mit der F\u00fcllfarbe PaleGreen und einer Transparenz von 2 AddChartRectangle(\"MyRect-\" + ProcessingBarIndex, true, 10, Low[10], 5, High[5], Color.PaleGreen, Color.PaleGreen, 2); AddChartRegion() Beschreibung AddChartRegion() DrawRegion() f\u00fcllt einen bestimmten Bereich auf einem Chart aus. Verwendung AddChartRegion(string name, int barsBackStart, int barsBackEnd, IDataSeries series, double y, Color outlineColor, Color areaColor, int areaOpacity) AddChartRegion(string name, int barsBackStart, int barsBackEnd, IDataSeries series1, IDataSeries series2, Color outlineColor, Color areaColor, int areaOpacity) AddChartRegion(string name, DateTime startTime, DateTime endTime, IDataSeries series, double y, Color outlineColor, Color areaColor, int areaOpacity) AddChartRegion(string name, DateTime startTime, DateTime endTime, IDataSeries series1, IDataSeries series2, Color outlineColor, Color areaColor, int areaOpacity) R\u00fcckgabewert Ein Zeichenobjekt vom Typ IRegion (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung barsBackStart Gibt an, an welchem zur\u00fcckliegenden Bar sich die eine Ecke des Rechtecks befinden soll (0=aktueller Bar) startTime Datum/Uhrzeit des Bars, an dem sich die eine Ecke des Rechtecks befinden soll barsBackEnd Gibt an, an welchem zur\u00fcckliegenden Bar sich die zweite Ecke des Rechtecks befinden soll (0=aktueller Bar) endTime Datum/Uhrzeit des Bars, an dem sich die zweite Ecke des Rechtecks befinden soll series1, series2 jedes Datenserie, wie z.B. ein Indikator, Close, High, Low usw. Der jeweilige Wert der Datenserie f\u00fcr den aktuellen Bar wird als y-Wert herangezogen y ein beliebiger double-Wert outlineColor Farbe f\u00fcr die Umrandung des Bereichs areaColor F\u00fcllfarbe des Zeichenobjekts areaOpacity Transparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 = komplett transparent, 255 = keine Transparenz) Beispiel // f\u00fcllt den Bereich zwischen dem oberen und dem unteren Bollinger Band AddChartRegion(\"MyRegion\", ProcessingBarIndex, 0, Bollinger(2, 14).Upper, Bollinger(2, 14).Lower, Color.Empty, Color.Lime, 100); AddChartRegressionChannel() Beschreibung AddChartRegressionChannel()zeichnet einen Regressionskanal. Verwendung AddChartRegressionChannel(string name, int barsBackStart, int barsBackEnd, Color color) AddChartRegressionChannel(string name, bool autoScale, int barsBackStart, int barsBackEnd, Color upperColor, DashStyle upperDashStyle, int upperWidth, Color middleColor, DashStyle middleDashStyle, int middleWidth, Color lowerColor, DashStyle lowerDashStyle, int lowerWidth) AddChartRegressionChannel(string name, bool autoScale, DateTime startTime, DateTime endTime, Color upperColor, DashStyle upperDashStyle, int upperWidth, Color middleColor, DashStyle middleDashStyle, int middleWidth, Color lowerColor, DashStyle lowerDashStyle, int lowerWidth) R\u00fcckgabewert Ein Zeichenobjekt vom Typ IRegressionChannel (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist. barsBackStart Gibt an, an welchem zur\u00fcckliegenden Bar der Regressionskanal beginnen soll (0=aktueller Bar) startTime Datum/Uhrzeit des Bars, an dem der Regressionskanal beginnen soll barsBackEnd Gibt an, an welchem zur\u00fcckliegenden Bar der Regressionskanal enden soll (0=aktueller Bar) endTime Datum/Uhrzeit des Bars, an dem der Regressionskanal enden soll color Farbe des Zeichenobjekts upperDashStyle, middleDashStyle, lowerDashStyle Linienart DashStyle.Dash DashStyle.DashDot DashStyle.DashDotDot DashStyle.Dot DashStyle.Solid ggf. mu\u00df: using System.Drawing.Drawing2D; mit eingebunden werden. upperColor, middleColor, lowerColor jeweilige Linienfarbe upperWidth, middleWidth, lowerWidth jeweilige Linienst\u00e4rke Beispiel // zeichnet einen Regressionskanal vom Tief des Bars von vor 10 Tagen // zum Hoch des Bars von vor 5 Tagen AddChartRegressionChannel(\"MyRegChannel-\" + ProcessingBarIndex, 10, 0, Color.Black); AddChartSquare() Beschreibung AddChartSquare() zeichnet ein Quadrat: Siehe auch AddChartArrowUp() , AddChartArrowDown() , AddChartDiamond() , AddChartDot() , AddChartTriangleUp() , AddChartTriangleDown() . Verwendung DrawSqare(string name, bool autoScale, int barsAgo, double y, Color color) DrawSqare(string name, bool autoScale, DateTime time, double y, Color color) R\u00fcckgabewert Ein Zeichenobjekt vom Typ ISquare (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen barsAgo Gibt an, an welchem zur\u00fcckliegenden Bar das Quadrat gezeichnet werden soll (0=aktueller Bar) Time Datum/Uhrzeit des Bars, an dem das Quadrat gezeichnet werden soll Y y-Wert, an dem das Quadrat gezeichnet werden soll color Farbe des Zeichenobjekts Beispiel // zeichnet ein durnkelrotes Quadrat am akt. Bar 10 Ticks \u00fcber dem Hoch AddChartSquare(\"MySquare\", true, 0, High[0] + 10*TickSize, Color.DarkRed); AddChartText() Beschreibung AddChartText() schreibt einen beliebigen Text auf den Chart. Siehe auch AddChartTextFixed() . Verwendung AddChartText(string tag, string text, int barsAgo, double y, Color color); AddChartText(string tag, string text, TextPosition textPosition, Color textColor, Font font, Color outlineColor, Color areaColor, int areaOpacity); AddChartText(string tag, string text, int barsAgo, double y, Color textColor, Font font, StringAlignment alignment, Color outlineColor, Color areaColor, int areaOpacity); AddChartText(string tag, bool autoScale, string text, int barsAgo, double y, int yPixelOffset, Color textColor, Font font, StringAlignment alignment, Color outlineColor, Color areaColor, int areaOpacity); AddChartText(string tag, bool autoScale, string text, DateTime x, double y, int yPixelOffset, Color textColor, Font font, StringAlignment alignment, Color outlineColor, Color areaColor, int areaOpacity); AddChartText(string tag, bool autoScale, string text, DateTime x, double y, int pixelOffset, Color textColor, Font font, StringAlignment alignment, HorizontalAlignment hAlign, VerticalAlignment vAlign, Color outlineColor, Color areaColor); AddChartText(string tag, bool autoScale, string text, int barsAgo, double y, int yPixelOffset, Color textColor, Font font, StringAlignment alignment, HorizontalAlignment hAlign, VerticalAlignment vAlign, Color outlineColor, Color areaColor, int areaOpacity); AddChartText(string tag, bool autoScale, string text, DateTime x, double y, int pixelOffset, Color textColor, Font font, StringAlignment alignment, HorizontalAlignment hAlign, VerticalAlignment vAlign, Color outlineColor, Color areaColor); wichtiger Hinweis: Bei Verwendung der Signaturen, die HorizontalAlignment und VerticalAlignment enthalten, sind die folgenden beiden Zeilen dem Programmcode hinzuzuf\u00fcgen: using System.Windows.Forms; using System.Windows.Forms.VisualStyles; R\u00fcckgabewert Ein Zeichenobjekt vom Typ IText (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist Text Der auszugebende Text (Der Text darf auch den Zeilenumbruch \"\\n\" enthalten.) barsAgo Gibt an, an welchem zur\u00fcckliegenden Bar der Text ausgegeben werden soll (0=aktueller Bar) (Welcher Bar den Index 0 hat, ist abh\u00e4ngig von CalculateOnBarClose.) Time Datum/Uhrzeit des Bars, an dem der Text beginnen soll Y y-Wert, an dem der Text geschrieben werden soll yPixelOffset vertikale Verschiebung des Textes. Positive Werte verschieben den Text nach oben, negative Werte nach unten. textColor Textfarbe Font Schriftart f\u00fcr den Text Alignment m\u00f6gliche Werte sind: StringAlignment.Center, StringAlignment.Far, StringAlignment.Near HAlign m\u00f6gliche Werte sind: HorizontalAlign.Left, HorizontalAlign.Center, HorizontalAlign.Right VAlign m\u00f6gliche Werte sind: VerticalAlign.Top, VerticalAlign.Center, VerticalAlign.Bottom outlineColor Farbe des Rahmens um den Text (F\u00fcr keinen Rahmen Color.Empty verwenden) areaColor F\u00fcllfarbe der Textbox (F\u00fcr keine F\u00fcllung Color.Empty verwenden) areaOpacity Transparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 = komplett transparent, 255 = keine Transparenz) Beispiele // schreibt einen Text bei y=3.0 AddChartText(\"MyText-\" + ProcessingBarIndex, \"This is sample text.\", 10, 3, Color.Black); // schreibt einen roten Text in Schriftgr\u00f6\u00dfe Arial 7 AddChartText(\"MyText-\" + ProcessingBarIndex, false, \"This is sample text.\", Time[0], Close[0]+50*TickSize, 0, Color.Red, new Font(\"Arial\",7), StringAlignment.Center, Color.Blue, Color.DarkOliveGreen, 10); Nachstehende Anweisung f\u00fchrt zu diesem Ergebnis: AddChartText(\"MyTag\",true,\"Text\",1, // barsAgo High[1], // y 10, // yPixelOffset Color.Blue, // Text color new Font(\"Arial\", 10, FontStyle.Bold), StringAlignment.Center, HorizontalAlignment.Center, VerticalAlignment.Bottom, Color.Red, // Outline color Color.Yellow, // Fill color 100); // Opacity AddChartTextFixed() Beschreibung AddChartTextFixed() schreibt Text an eine von 5 m\u00f6glichen festen Stellen im Chart. Siehe auch AddChartText() . Verwendung AddChartTextFixed(string tag, string text, TextPosition textPosition); AddChartTextFixed(string tag, string text, TextPosition textPosition, Color textColor, Font font, Color outlineColor, Color areaColor); AddChartTextFixed(string tag, string text, TextPosition textPosition, Color textColor, Font font, Color outlineColor, Color areaColor, int areaOpacity); R\u00fcckgabewert Ein Zeichenobjekt vom Typ ITextFixed (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung text The text to be displayed TextPosition TextPosition.BottomLeft, TextPosition.BottomRight, TextPosition.Center, TextPosition.TopLeft, TextPosition.TopRight textColor Textfarbe font Schriftart f\u00fcr den Text outlineColor Farbe des Rahmens um den Text (F\u00fcr keinen Rahmen Color.Empty verwenden) areaColor F\u00fcllfarbe der Textbox (F\u00fcr keine F\u00fcllung Color.Empty verwenden) areaOpacity Transparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 = komplett transparent, 255 = keine Transparenz) Beispiele // schreibt einen Text in die Mitte des Charts AddChartTextFixed(\"MyText-\" + ProcessingBarIndex, \"\"Das ist ein Beispieltext.\", TextPosition.Center); // schreibt einen roten Text mit einem blauen Rand in die Mitte des Charts AddChartTextFixed(\"MyText-\" + ProcessingBarIndex, \"Das ist ein Beispieltext.\", TextPosition.Center, Color.Red, new Font(\"Arial\",35), Color.Blue, Color.Empty, 10); AddChartTrendChannel() Beschreibung AddChartTrendChannel() zeichnet einen Trendkanal. Verwendung AddChartTrendChannel(string name, bool autoScale, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, int start3BarsAgo, double start3Y) AddChartTrendChannel(string name, bool autoScale, DateTime start1Time, double start1Y, DateTime start2Time, double start2Y, DateTime start3Time, double start3Y) R\u00fcckgabewert Ein Zeichenobjekt vom Typ ITrendChannel (Interface) Parameter name A clearly identifiable name for the drawing object autoScale Adjusts the scale of the y-axis so that drawing objects can be viewed in their entirety start1BarsAgo Number of bars ago for start point 1 (x-axis) start1Time Date/time for start point 1 (x-axis) start1Y y-value for start point 1 start2BarsAgo Number of bars ago for start point 2 (x-axis) start2Time Date/time for start point 2 (x-axis) start2Y y-value for start point 2 start3BarsAgo Number of bars ago for start point 3 (x-axis) start3Time Date/time for start point 3 (x-axis) start3Y y-value for start point 3 Beispiele // zeichnet einen Trendkanal AddChartTrendChannel(\"MyTrendChannel-\" + ProcessingBarIndex, true, 10, Low[10], 0, High[0], 10, High[10] + 5 * TickSize); AddChartTriangle() Beschreibung AddChartTriangle() zeichnet ein Dreieck. Verwendung AddChartTriangle(string name, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, int start3BarsAgo, double start3Y, Color color) AddChartTriangle(string name, bool autoScale, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, int start3BarsAgo, double start3Y, Color color, Color areaColor, int areaOpacity) AddChartTriangle(string name, bool autoScale, DateTime start1Time, double start1Y, DateTime start2Time, double start2Y, DateTime start3Time, double start3Y, Color color, Color areaColor, int areaOpacity) R\u00fcckgabewert Ein Zeichenobjekt vom Typ ITriangle (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist start1BarsAgo Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt1 (x-Achse) start1Time Datum/Zeit f\u00fcr Ankerpunkt1 (x-Achse) start1Y y-Wert f\u00fcr Ankerpunkt1 start2BarsAgo Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt2 (x-Achse) start2Time Datum/Zeit f\u00fcr Ankerpunkt2 (x-Achse) start2Y y-Wert f\u00fcr Ankerpunkt2 start3BarsAgo Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt3 (x-Achse) start3Time Datum/Zeit f\u00fcr Ankerpunkt3 (x-Achse) start3Y y-Wert f\u00fcr Ankerpunkt3 color Farbe des Zeichenobjekts areaColor F\u00fcllen Sie Farbe des Zeichnungsobjekt areaOpacity Transparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 = komplett transparent, 255 = keine Transparenz) Beispiel // zeichnet ein gr\u00fcnes Dreieck AddChartTriangle(\"tag1\", 4, Low[4], 3, High[3], 1, Low[1], Color.Green); AddChartTriangleDown() Beschreibung AddChartTriangleDown() zeichnet ein kleines abw\u00e4rtsgerichtetes Dreieck. Siehe auch AddChartArrowUp() , AddChartArrowDown() , AddChartDiamond() , AddChartDot() , AddChartSquare() , AddChartTriangleUp() . Verwendung AddChartTriangleDown(string name, bool autoScale, int barsAgo, double y, Color color) AddChartTriangleDown(string name, bool autoScale, DateTime time, double y, Color color) R\u00fcckgabewert Ein Zeichenobjekt vom Typ ITriangleDown (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist barsAgo Gibt an, an welchem zur\u00fcckliegenden Bar das Dreieck gezeichnet werden soll time Datum/Uhrzeit des Bars, an dem das Dreieck gezeichnet werden soll y y-Wert, an dem das Dreieck gezeichnet werden color Farbe des Zeichenobjekts Beispiel // zeichnet ein kleines rotes Dreieck am akt. Bar 10 Ticks \u00fcber dem Hoch AddChartTriangleDown(\"MyTriangleDown-\" + ProcessingBarIndex, true, 0, High[0] + 10*TickSize, Color.Red); AddChartTriangleUp() Beschreibung AddChartTriangleUp() zeichnet ein kleines aufw\u00e4rtsgerichtetes Dreieck. Siehe auch AddChartArrowUp() , AddChartArrowDown() , AddChartDiamond() , AddChartDot() , AddChartSquare() , AddChartTriangleDown() . Verwendung AddChartTriangleUp(string name, bool autoScale, int barsAgo, double y, Color color) AddChartTriangleUp(string name, bool autoScale, DateTime time, double y, Color color) R\u00fcckgabewert Ein Zeichenobjekt vom Typ ITriangleUp (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist barsAgo Gibt an, an welchem zur\u00fcckliegenden Bar das Dreieck gezeichnet werden soll time Datum/Uhrzeit des Bars, an dem das Dreieck gezeichnet werden soll y y-Wert, an dem das Dreieck gezeichnet werden color Farbe des Zeichenobjekts Beispiel // zeichnet ein kleines hellgr\u00fcnes Dreieck am akt. Bar 10 Ticks unter dem Tief AddChartTriangleUp(\"MyTriangleUp-\" + ProcessingBarIndex, true, 0, Low[0] - 10*TickSize, Color.LightGreen); AddChartVerticalLine() Beschreibung AddChartVerticalLine() zeichnet eine vertikale Linie in den Chart. Siehe auch AddChartLine() , AddChartHorizontalLine() , AddChartExtendedLine() , AddChartRay() . Verwendung AddChartVerticalLine(string name, int barsAgo, Color color) AddChartVerticalLine(string name, int barsAgo, Color color, DashStyle dashStyle, int width) AddChartVerticalLine(string name, DateTime time, Color color, DashStyle dashStyle, int width) R\u00fcckgabewert Ein Zeichenobjekt vom Typ IVerticalLine (Interface) Parameter name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung barsAgo Gibt an, an welchem zur\u00fcckliegenden Bar die vertikale Linie gezeichnet werden soll (0=aktueller Bar) time Datum/Uhrzeit des Bars, an dem die vertikale Linie gezeichnet werden soll color Linienfarbe dashStyle Linienart DashStyle.Dash DashStyle.DashDot DashStyle.DashDotDot DashStyle.Dot DashStyle.Solid ggf. mu\u00df using System.Drawing.Drawing2D; mit eingebunden werden. width Linienst\u00e4rke Beispiele // zeichnet eine vertikale Linie am Bar von vor 10 Perioden AddChartVerticalLine(\"MyVerticalLine-\" + ProcessingBarIndex, 10, Color.Black);","title":"Zeichenobjekte"},{"location":"zeichenobjekte/#zeichenobjekte","text":"","title":"Zeichenobjekte"},{"location":"zeichenobjekte/#addchartandrewspitchfork","text":"","title":"AddChartAndrewsPitchfork()"},{"location":"zeichenobjekte/#beschreibung","text":"AddChartAndrewsPitchfork() zeichnet ein Andrew's Pitchfork. Informationen zur Verwendung: - vtad.de - hvolumen-analyse.de - Godmode-Trader.de","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung","text":"AddChartAndrewsPitchfork(string name, bool autoScale, int start1BarsBack, double start1Y, int start2BarsBack, double start2Y, int start3BarsBack, double start3Y, Color color, DashStyle dashStyle, int width) AddChartAndrewsPitchfork(string name, bool autoScale, DateTime start1Time, double start1Y, DateTime start2Time, double start2Y, DateTime start3Time, double start3Y, Color color, DashStyle dashStyle, int width)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert","text":"A drawing object of the type IAndrewsPitchfork (interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist. start1BarsBack Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt1 (x-Achse) start1Time Datum/Zeit f\u00fcr Ankerpunkt1 (x-Achse) start1Y y-Wert f\u00fcr Ankerpunkt1 start2BarsBack Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt2 (x-Achse) start2Time Datum/Zeit f\u00fcr Ankerpunkt2(x-Achse) start2Y y-Wert f\u00fcr Ankerpunkt2 start3BarsBack Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt3 (x-Achse) start3Time Datum/Zeit f\u00fcr Ankerpunk3 (x-Achse) start3Y -Wert f\u00fcr Ankerpunkt3 color Farbe des Zeichenobjekts dashStyle Linienart DashStyle.Dash DashStyle.DashDot DashStyle.DashDotDot DashStyle.Dot DashStyle.Solid ggf. mu\u00df using System.Drawing.Drawing2D; mit eingebunden werden. width Linienst\u00e4rke in Punkten","title":"Parameter"},{"location":"zeichenobjekte/#beispiel","text":"// zeichnet ein Andrew's Pitchfork (\"Mistgabel\") AddChartAndrewsPitchfork(\"MyAPF\", true, 4, Low[4], 3, High[3], 1, Low[1], Color.Black, DashStyle.Solid, 2);","title":"Beispiel"},{"location":"zeichenobjekte/#addchartarc","text":"","title":"AddChartArc()"},{"location":"zeichenobjekte/#beschreibung_1","text":"AddChartArc() zeichnet einen Kreisbogen.","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_1","text":"AddChartArc(string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color) AddChartArc(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, DashStyle dashStyle, int width) AddChartArc(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, DashStyle dashStyle, int width)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_1","text":"Ein Zeichenobjekt vom Typ IArc (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_1","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu barsBackStart Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den Startpunkt startTime Datum/Uhrzeit f\u00fcr den Startpunkt startY y-Wert f\u00fcr den Startpunkt barsBackEnd Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den Endpunkt endTime Datum/Uhrzeit f\u00fcr den Endpunkt endY y-Wert f\u00fcr den Endpunkt color Farbe des Zeichenobjekts dashStyle Linienart DashStyle.Dash DashStyle.DashDot DashStyle.DashDotDot DashStyle.Dot DashStyle.Solid ggf. mu\u00df using System.Drawing.Drawing2D; mit eingebunden werden. width Linienst\u00e4rke in Punkten","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_1","text":"// zeichnet einen blauen Kreisbogen AddChartArc(\"MyArc-\" + ProcessingBarIndex, true, 10, 10, 0, 20, Color.Blue, DashStyle.Solid, 3);","title":"Beispiel"},{"location":"zeichenobjekte/#addchartarrowdown","text":"","title":"AddChartArrowDown()"},{"location":"zeichenobjekte/#beschreibung_2","text":"AddChartArrowDown() zeichnet einen nach unten gerichteten Pfeil: DrawArrowUp(), DrawDiamond(), DrawDot(), DrawSquare(), DrawTriangleUp(), AddChartArrowUp() , AddChartArrowDown() , AddChartDiamond() , AddChartDot() , AddChartSquare() , AddChartTriangleUp() , AddChartTriangleDown() .","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_2","text":"AddChartArrowDown(string name, bool autoScale, int barsAgo, double y, Color color) AddChartArrowDown(string name, bool autoScale, DateTime time, double y, Color color)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_2","text":"A drawing object of the type IArrowDown (interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_2","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen barsAgo Gibt an, an welchem zur\u00fcckliegenden Bar der Pfeil gezeichnet werden soll (0=aktueller Bar) time Datum/Uhrzeit des Bars, an dem der Pfeil gezeichnet werden soll y y-Wert f\u00fcr den Pfeil color Farbe des Zeichenobjekts","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_2","text":"// zeichnet am akt. Bar einen roten Pfeil 3 Ticks \u00fcber dem Hoch AddChartArrowDown(\"MyArrow-\" + ProcessingBarIndex, true, 0, High[0] + 3*TickSize, Color.Red); // Zeichnet einen roten Pfeil auf einem Dreistufen-Umkehrmuster if(High[2] > High[3] && High[1] > High[2] && Close[0] < Open[0]) AddChartArrowDown(ProcessingBarIndex.ToString(), true, 0, High[0] + 3*TickSize, Color.Red);","title":"Beispiel"},{"location":"zeichenobjekte/#addchartarrowline","text":"","title":"AddChartArrowLine()"},{"location":"zeichenobjekte/#beschreibung_3","text":"AddChartArrowLine() zeichnet einen Pfeil.","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_3","text":"AddChartArrowLine (string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color) AddChartArrowLine (string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, DashStyle dashStyle, int width) AddChartArrowLine (string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, DashStyle dashStyle, int width)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_3","text":"Ein Zeichenobjekt vom Typ IArrowLine (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_3","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist barsBackStart Gibt an, an welchem zur\u00fcckliegenden Bar der Pfeil beginnen soll (0=aktueller Bar) startTime Datum/Uhrzeit des Bars, an dem der Pfeil beginnen soll startY y-Wert, an dem der Pfeil beginnen soll barsBackEnd Gibt an, an welchem zur\u00fcckliegenden Bar der Pfeil enden soll (0=aktueller Bar) endTime Datum/Uhrzeit des Bars, an dem der Pfeil enden endY y-Wert, an dem der Pfeil enden soll color Farbe des Zeichenobjekts dashStyle Linienart DashStyle.Dash DashStyle.DashDot DashStyle.DashDotDot DashStyle.Dot DashStyle.Solid ggf. mu\u00df using System.Drawing.Drawing2D; mit eingebunden werden. width Linienst\u00e4rke in Punkten","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_3","text":"// zeichnet einen schwarzen Pfeil AddChartArrowLine(\"MyArrow-\" + ProcessingBarIndex, false, 10, 10, 0, 5, Color.Black, DashStyle.Solid, 4);","title":"Beispiel"},{"location":"zeichenobjekte/#addchartarrowup","text":"","title":"AddChartArrowUp()"},{"location":"zeichenobjekte/#beschreibung_4","text":"AddChartArowUp() zeichnet einen nach oben gerichteten Pfeil: Siehe auch AddChartArrowUp() , AddChartArrowDown() , AddChartDiamond() , AddChartDot() , AddChartSquare() , AddChartTriangleUp() , AddChartTriangleDown() .","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_4","text":"AddChartArrowUp(string name, bool autoScale, int barsAgo, double y, Color color) AddChartArrowUp(string name, bool autoScale, DateTime time, double y, Color color)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_4","text":"A drawing object of the type IArrowUp (interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_4","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen barsAgo Gibt an, an welchem zur\u00fcckliegenden Bar der Pfeil gezeichnet werden soll (0=aktueller Bar) time Datum/Uhrzeit des Bars, an dem der Pfeil gezeichnet werden soll y y-Wert f\u00fcr den Pfeil color Farbe des Zeichenobjekts","title":"Parameter"},{"location":"zeichenobjekte/#example","text":"// zeichnet einen gr\u00fcnen Pfeil am akt. Bar 3 Ticks unter dem Tief AddChartArrowUp(\"MyArrow-\" + ProcessingBarIndex, true, 0, Low[0] - 3*TickSize, Color.Green);","title":"Example"},{"location":"zeichenobjekte/#addchartdiamond","text":"","title":"AddChartDiamond()"},{"location":"zeichenobjekte/#beschreibung_5","text":"AddChartDiamond() zeichnet einen Diamanten: Siehe auch AddChartArrowUp() , AddChartArrowDown() , AddChartDiamond() , AddChartDot() , AddChartSquare() , AddChartTriangleUp() , AddChartTriangleDown() .","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_5","text":"AddChartDiamond(string name, bool autoScale, int barsAgo, double y, Color color) AddChartDiamond(string name, bool autoScale, DateTime time, double y, Color color)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_5","text":"Ein Zeichenobjekt vom Typ IDiamond (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_5","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen barsAgo Gibt an, an welchem zur\u00fcckliegenden Bar der Pfeil gezeichnet werden soll (0=aktueller Bar) time Datum/Uhrzeit des Bars, an dem der Pfeil gezeichnet werden soll y y-Wert f\u00fcr den Pfeil color Farbe des Zeichenobjekts","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_4","text":"// zeichnet einen hellblauen Diamanten am akt. Bar 5 Ticks unter dem Tief AddChartDiamond(\"MyDiamond-\" + ProcessingBarIndex, true, 0, Low[0] - 5*TickSize, Color.SteelBlue);","title":"Beispiel"},{"location":"zeichenobjekte/#addchartdot","text":"","title":"AddChartDot()"},{"location":"zeichenobjekte/#beschreibung_6","text":"AddChartDot() zeichnet einen Punkt: Siehe auch AddChartArrowUp() , AddChartArrowDown() , AddChartDiamond() , AddChartDot() , AddChartSquare() , AddChartTriangleUp() , AddChartTriangleDown() .","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_6","text":"AddChartDot(string name, bool autoScale, int barsAgo, double y, Color color) AddChartDot(string name, bool autoScale, DateTime time, double y, Color color)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_6","text":"Ein Zeichenobjekt vom Typ IDot (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_6","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen barsAgo Gibt an, an welchem zur\u00fcckliegenden Bar der Pfeil gezeichnet werden soll (0=aktueller Bar) time Datum/Uhrzeit des Bars, an dem der Pfeil gezeichnet werden soll y y-Wert f\u00fcr den Pfeil color Farbe des Zeichenobjekts","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_5","text":"// zeichnet einen orangen Punkt am akt. Bar 5 Ticks \u00fcber dem Hoch AddChartDot(\"MyDot-\" + ProcessingBarIndex, true, 0, High[0] + 5*TickSize, Color.Orange);","title":"Beispiel"},{"location":"zeichenobjekte/#addchartellipse","text":"","title":"AddChartEllipse()"},{"location":"zeichenobjekte/#beschreibung_7","text":"AddChartEllipse() zeichnet eine Ellipse.","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_7","text":"AddChartEllipse(string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color) AddChartEllipse(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, Color areaColor, int areaOpacity) AddChartEllipse(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, Color areaColor, int areaOpacity)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_7","text":"Ein Zeichenobjekt vom Typ IEllipse (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_7","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist barsBackStart Gibt an, an welchem zur\u00fcckliegenden Bar die Ellipse beginnen soll (0=aktueller Bar) startTime Datum/Uhrzeit des Bars, an dem die Ellipse beginnen soll startY Wert, an dem die Ellipse beginnen soll barsBackEnd Gibt an, an welchem zur\u00fcckliegenden Bar die Ellipse enden soll (0=aktueller Bar) endTime Datum/Uhrzeit des Bars, an dem die Ellipse enden soll endY y-Wert, an dem die Ellipse enden soll color Randfarbe des Zeichenobjekts areaColor F\u00fcllfarbe des Zeichenobjekts areaOpacity Transparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 = komplett transparent; 255 = keine Transparenz)","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_6","text":"// zeichnet eine gelbe Ellipse vom akt. Bar bis 5 Bars zur\u00fcck AddChartEllipse(\"MyEllipse-\" + ProcessingBarIndex, true, 5, High[5], 0, Close[0], Color.Yellow, Color.Yellow, 1);","title":"Beispiel"},{"location":"zeichenobjekte/#addchartextendedline","text":"","title":"AddChartExtendedLine()"},{"location":"zeichenobjekte/#beschreibung_8","text":"AddChartExtendedLine() zeichnet eine Linie mit unendlichem Endpunkt. Siehe auch AddChartLine() , AddChartHorizontalLine() , AddChartVerticalLine() , AddChartRay() .","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_8","text":"AddChartExtendedLine(string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color) AddChartExtendedLine(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, DashStyle dashStyle, int width) AddChartExtendedLine(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, DashStyle dashStyle, int width)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_8","text":"Ein Zeichenobjekt vom Typ IExtendedLine (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_8","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist barsBackStart Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den Startpunkt startTime Datum/Uhrzeit f\u00fcr den Startpunkt startY y-Wert f\u00fcr den Startpunkt barsBackEnd Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den zweiten Punkt (Einen Endpunkt gibt es bei diesem Zeichenobjekt nicht endTime Datum/Uhrzeit f\u00fcr den Endpunkt endY y-Wert f\u00fcr den Endpunkt color Farbe des Zeichenobjekts dashStyle Linienart DashStyle.Dash DashStyle.DashDot DashStyle.DashDotDot DashStyle.Dot DashStyle.Solid ggf. mu\u00df using System.Drawing.Drawing2D; mit eingebunden werden. width Linienst\u00e4rke in Punkten","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_7","text":"// zeichnet eine Linie ohne Endpunkt AddChartExtendedLine(\"MyExt.LevelLine-\" + ProcessingBarIndex, false, 10, Close[10], 0, Close[0], Color.Black, DashStyle.Solid, 1);","title":"Beispiel"},{"location":"zeichenobjekte/#addchartfibonaccicircle","text":"","title":"AddChartFibonacciCircle()"},{"location":"zeichenobjekte/#beschreibung_9","text":"AddChartFibonacciCircle() zeichnet Fibonacci-Kreise.","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_9","text":"AddChartFibonacciCircle(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY) AddChartFibonacciCircle(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_9","text":"Ein Zeichenobjekt vom Typ IFibonacciCircle (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_9","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist barsBackStart Gibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci-Kreise beginnen sollen. startTime Datum/Uhrzeit des Bars, an dem die Fibonacci-Kreise beginnen sollen startY y-Wert, an dem die Fibonacci-Kreise beginnen sollen barsBackEnd Gibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci-Kreise enden sollen (0=aktueller Bar) endTime Datum/Uhrzeit des Bars, an dem die Fibonacci-Kreise enden sollen endY y-Wert, an dem die Fibonacci-Kreise enden sollen","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_8","text":"// zeichnet Fibonacci-Kreise AddChartFibonacciCircle(\"MyFibCircle-\" + ProcessingBarIndex, true, 5, Low[5], 0, High[0]);","title":"Beispiel"},{"location":"zeichenobjekte/#addchartfibonacciextensions","text":"","title":"AddChartFibonacciExtensions()"},{"location":"zeichenobjekte/#beschreibung_10","text":"AddChartFibonacciExtensions() zeichnet Fibonacci Extensions","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_10","text":"AddChartFibonacciExtensions(string name, bool autoScale, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, int start3BarsAgo, double start3Y) AddChartFibonacciExtensions(string name, bool autoScale, DateTime start1Time, double start1Y, DateTime start2Time, double start2Y, DateTime start3Time, double start3Y)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_10","text":"Ein Zeichenobjekt vom Typ IFibonacciExtensions (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_10","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist. start1BarsAgo Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt1 (x-Achse) start1Time Datum/Zeit f\u00fcr Ankerpunkt1 (x-Achse) start1Y y-Wert f\u00fcr Ankerpunkt1 start2BarsAgo Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt2 (x-Achse) start2Time Datum/Zeit f\u00fcr Ankerpunkt2(x-Achse) start2Y y-Wert f\u00fcr Ankerpunkt2 start3BarsAgo Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt3 (x-Achse) start3Time Datum/Zeit f\u00fcr Ankerpunk3 (x-Achse) start3Y y-Wert f\u00fcr Ankerpunkt3","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_9","text":"// zeichnet FibonacciExtensions AddChartFibonacciExtensions(\"MyFibExt-\" + ProcessingBarIndex, true, 4, Low[4], 3, High[3], 1, Low[1]);","title":"Beispiel"},{"location":"zeichenobjekte/#addchartfibonacciprojections","text":"","title":"AddChartFibonacciProjections()"},{"location":"zeichenobjekte/#beschreibung_11","text":"Draw Fibonacci Projections () zeichnet Fibonacci Projections.","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_11","text":"AddChartFibonacciProjections(string name, bool autoScale, DateTime start1Time, double start1Y,DateTime start2Time, double start2Y, DateTime start3Time, double start3Y)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_11","text":"Ein Zeichenobjekt vom Typ IFibonacciProjections (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_11","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist. start1Time Datum/Zeit f\u00fcr Ankerpunkt1 (x-Achse) start1Y y-Wert f\u00fcr Ankerpunkt1 start2Time Datum/Zeit f\u00fcr Ankerpunkt2(x-Achse) start2Y y-Wert f\u00fcr Ankerpunkt2 start3Time Datum/Zeit f\u00fcr Ankerpunk3 (x-Achse) start3Y y-Wert f\u00fcr Ankerpunkt3","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_10","text":"// zeichnet FibonacciProjections AddChartFibonacciProjections(\"MyFibPro-\" + ProcessingBarIndex, true, Low[4], 3, High[3], 1, Low[1], 2);","title":"Beispiel"},{"location":"zeichenobjekte/#addchartfibonacciretracements","text":"","title":"AddChartFibonacciRetracements()"},{"location":"zeichenobjekte/#beschreibung_12","text":"AddChartFibonacciRetracements() dzeichnet Fibonacci Retracements.","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_12","text":"AddChartFibonacciRetracements(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY) AddChartFibonacciRetracements(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_12","text":"A drawing object of the type IFibonacciRetracements (interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_12","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist barsBackStart Gibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci Retracements beginnen sollen. startTime Datum/Uhrzeit des Bars, an dem die Fibonacci Retracements beginnen sollen startY y-Wert, an dem die Fibonacci Retracements beginnen sollen barsBackEnd Gibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci Retracements enden sollen (0=aktueller Bar) endTime Datum/Uhrzeit des Bars, an dem die Fibonacci Retracements enden sollen endY y-Wert, an dem die Fibonacci Retracements enden sollen","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_11","text":"// zeichnet Fibonnaci Retracements AddChartFibonacciRetracements(\"MyFibRet-\" + ProcessingBarIndex, true, 10, Low[10], 0, High[0]);","title":"Beispiel"},{"location":"zeichenobjekte/#addchartfibonaccitimeextensions","text":"","title":"AddChartFibonacciTimeExtensions()"},{"location":"zeichenobjekte/#beschreibung_13","text":"AddChartFibonacciTimeExtensions() zeichnet Fibonacci Retracements.","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_13","text":"AddChartFibonacciTimeExtensions(string name, int barsBackStart, double startY, int barsBackEnd, double endY) AddChartFibonacciTimeExtensions(string name, DateTime startTime, double startY, DateTime endTime, double endY)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_13","text":"Ein Zeichenobjekt vom Typ IFibonacciTimeExtensions (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_13","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung barsBackStart Gibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci TimeExtensions beginnen sollen. startTime Datum/Uhrzeit des Bars, an dem die Fibonacci TimeExtensions beginnen sollen startY y-Wert, an dem die Fibonacci-Kreise beginnen sollen barsBackEnd Gibt an, an welchem zur\u00fcckliegenden Bar die Fibonacci TimeExtensions enden sollen (0=aktueller Bar) endTime Datum/Uhrzeit des Bars, an dem die Fibonacci TimeExtensions enden sollen endY y-Wert, an dem die Fibonacci TimeExtensions enden sollen","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_12","text":"// zeichnet Fibonacci TimeExtensions AddChartFibonacciTimeExtensions(\"MyFibTimeExt-\" + ProcessingBarIndex, 10, Low[10], 0, High[0]);","title":"Beispiel"},{"location":"zeichenobjekte/#addchartgannfan","text":"","title":"AddChartGannFan()"},{"location":"zeichenobjekte/#beschreibung_14","text":"AddChartGannFan() zeichnet Fibonacci Retracements.","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_14","text":"AddChartGannFan(string name, bool autoScale, int barsAgo, double y) AddChartGannFan(string name, bool autoScale, DateTime time, double y)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_14","text":"Ein Zeichenobjekt vom Typ IGannFan (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_14","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist barsAgo Gibt an, an welchem zur\u00fcckliegenden Bar der GannFan gezeichnet werden soll time Datum/Uhrzeit des Bars, an dem der GannFan gezeichnet werden soll y y-Wert, an dem der GannFan gezeichnet werden soll","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_13","text":"// zeichnet einen Gann Fan am Tief des Bars von vor 10 Perioden AddChartGannFan(\"MyGannFan-\" + ProcessingBarIndex, true, 10, Low[10]);","title":"Beispiel"},{"location":"zeichenobjekte/#addcharthorizontalline","text":"","title":"AddChartHorizontalLine()"},{"location":"zeichenobjekte/#beschreibung_15","text":"AddChartHorizontalLine() zeichnet eine horizontale Linie in den Chart. Siehe auch AddChartLine() , AddChartVerticalLine() , AddChartExtendedLine() , AddChartRay() .","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_15","text":"AddChartHorizontalLine(string name, double y, Color color) AddChartHorizontalLine(string name, bool autoScale, double y, Color color, DashStyle dashStyle, int width)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_15","text":"Ein Zeichenobjekt vom Typ IHorizontalLine (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_15","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist y ein beliebiger double-Wert color Linienfarbe dashStyle Linienart DashStyle.Dash DashStyle.DashDot DashStyle.DashDotDot DashStyle.Dot DashStyle.Solid ggf. mu\u00df using System.Drawing.Drawing2D; mit eingebunden werden. width Linienst\u00e4rke","title":"Parameter"},{"location":"zeichenobjekte/#beispiele","text":"// zeichnet eine horizontale Linie bei y=10 AddChartHorizontalLine(\"MyHorizontalLine-\" + ProcessingBarIndex, 10, Color.Black);","title":"Beispiele"},{"location":"zeichenobjekte/#addchartline","text":"","title":"AddChartLine()"},{"location":"zeichenobjekte/#beschreibung_16","text":"AddChartLine() zeichnet eine (Trend-) Linie. Siehe auch AddChartHorizontalLine() , AddChartVerticalLine() , AddChartExtendedLine() , AddChartRay() .","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_16","text":"AddChartLine(string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color) AddChartLine(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, DashStyle dashStyle, int width) AddChartLine(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, DashStyle dashStyle, int width)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_16","text":"Ein Zeichenobjekt vom Typ ITrendLine (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_16","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist barsBackStart Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den Startpunkt startTime Datum/Uhrzeit f\u00fcr den Startpunkt startY y-Wert f\u00fcr den Startpunkt barsBackEnd Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr den zweiten Punkt (Einen Endpunkt gibt es bei diesem Zeichenobjekt nicht) endTime Datum/Uhrzeit f\u00fcr den Endpunkt endY y-Wert f\u00fcr den Endpunkt color Farbe des Zeichenobjekts dashStyle Linienart DashStyle.Dash DashStyle.DashDot DashStyle.DashDotDot DashStyle.Dot DashStyle.Solid ggf. mu\u00df using System.Drawing.Drawing2D; mit eingebunden werden. width Linienst\u00e4rke in Punkten","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_14","text":"// zeichnet eine Linie AddChartLine(\"MyLine-\" + ProcessingBarIndex, false, 10, Close[10], 0, Close[0], Color.Black, DashStyle.Solid, 1);","title":"Beispiel"},{"location":"zeichenobjekte/#addchartray","text":"","title":"AddChartRay()"},{"location":"zeichenobjekte/#beschreibung_17","text":"AddChartRay() zeichnet eine (Trend-) Linie, die zu einer Seite ins Unendliche verl\u00e4ngert wird. Siehe auch AddChartLine() , AddChartHorizontalLine() , AddChartVerticalLine() , AddChartExtendedLine() .","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_17","text":"AddChartRay(string name, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, Color color) AddChartRay(string name, bool autoScale, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, Color color, DashStyle dashStyle, int width) AddChartRay(string name, bool autoScale, DateTime start1Time, double start1Y, DateTime start2Time, double start2Y, Color color, DashStyle dashStyle, int width)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_17","text":"Ein Zeichenobjekt vom Typ IRay (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_17","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist. start1BarsAgo Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt1 (x-Achse) start1Time Datum/Zeit f\u00fcr Ankerpunkt1 (x-Achse) start1Y y-Wert f\u00fcr Ankerpunkt1 start2BarsAgo Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt2 (x-Achse) start2Time Datum/Zeit f\u00fcr Ankerpunkt2(x-Achse) start2Y y-Wert f\u00fcr Ankerpunkt2 color Farbe des Zeichenobjekts dashStyle Linienart DashStyle.Dash DashStyle.DashDot DashStyle.DashDotDot DashStyle.Dot DashStyle.Solid ggf. mu\u00df using System.Drawing.Drawing2D; mit eingebunden werden. width Linienst\u00e4rke","title":"Parameter"},{"location":"zeichenobjekte/#beispiele_1","text":"// zeichnet eine Linie vom Bar von vor 10 Perioden \u00fcber den aktuellen Bar (x-Achse) // --> Linie wird nach rechts verl\u00e4ngert // von y=3 \u00fcber y=7 AddChartRay(\"MyRay-\" + ProcessingBarIndex, 10, 3, 0, 7, Color.Green); // zeichnet eine Linie vom akt. Bar \u00fcber den Bar von vor 10 Perioden // --> Linie wird nach links verl\u00e4ngert // von y=3 \u00fcber y=7 AddChartRay(\"MyRay-\" + ProcessingBarIndex, 0, 3, 10, 7, Color.Green);","title":"Beispiele"},{"location":"zeichenobjekte/#addchartrectangle","text":"","title":"AddChartRectangle()"},{"location":"zeichenobjekte/#beschreibung_18","text":"AddChartRectangle() zeichnet ein Rechteck.","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_18","text":"AddChartRectangle(string name, int barsBackStart, double startY, int barsBackEnd, double endY, Color color) AddChartRectangle(string name, bool autoScale, int barsBackStart, double startY, int barsBackEnd, double endY, Color color, Color areaColor, int areaOpacity) AddChartRectangle(string name, bool autoScale, DateTime startTime, double startY, DateTime endTime, double endY, Color color, Color areaColor, int areaOpacity)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_18","text":"Ein Zeichenobjekt vom Typ IRectangle (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_18","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist. barsBackStart Gibt an, an welchem zur\u00fcckliegenden Bar sich die eine Ecke des Rechtecks befinden soll (0=aktueller Bar) startTime Datum/Uhrzeit des Bars, an dem sich die eine Ecke des Rechtecks befinden soll startY y-Wert, an dem die sich die eine Ecke des Rechtecks befinden soll barsBackEnd Gibt an, an welchem zur\u00fcckliegenden Bar sich die zweite Ecke des Rechtecks befinden soll (0=aktueller Bar) endTime Datum/Uhrzeit des Bars, an dem sich die zweite Ecke des Rechtecks befinden soll endY y-Wert, an dem die sich die zweite Ecke des Rechtecks befinden soll color Farbe des Zeichenobjekts areaColor F\u00fcllfarbe des Zeichenobjekts areaOpacity Transparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 = komplett transparent, 255 = keine Transparenz)","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_15","text":"// zeichnet ein gr\u00fcnes Rechteck vom Tief von vor 10 Perioden zum Hoch von vor 5 Perioden // mit der F\u00fcllfarbe PaleGreen und einer Transparenz von 2 AddChartRectangle(\"MyRect-\" + ProcessingBarIndex, true, 10, Low[10], 5, High[5], Color.PaleGreen, Color.PaleGreen, 2);","title":"Beispiel"},{"location":"zeichenobjekte/#addchartregion","text":"","title":"AddChartRegion()"},{"location":"zeichenobjekte/#beschreibung_19","text":"AddChartRegion() DrawRegion() f\u00fcllt einen bestimmten Bereich auf einem Chart aus.","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_19","text":"AddChartRegion(string name, int barsBackStart, int barsBackEnd, IDataSeries series, double y, Color outlineColor, Color areaColor, int areaOpacity) AddChartRegion(string name, int barsBackStart, int barsBackEnd, IDataSeries series1, IDataSeries series2, Color outlineColor, Color areaColor, int areaOpacity) AddChartRegion(string name, DateTime startTime, DateTime endTime, IDataSeries series, double y, Color outlineColor, Color areaColor, int areaOpacity) AddChartRegion(string name, DateTime startTime, DateTime endTime, IDataSeries series1, IDataSeries series2, Color outlineColor, Color areaColor, int areaOpacity)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_19","text":"Ein Zeichenobjekt vom Typ IRegion (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_19","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung barsBackStart Gibt an, an welchem zur\u00fcckliegenden Bar sich die eine Ecke des Rechtecks befinden soll (0=aktueller Bar) startTime Datum/Uhrzeit des Bars, an dem sich die eine Ecke des Rechtecks befinden soll barsBackEnd Gibt an, an welchem zur\u00fcckliegenden Bar sich die zweite Ecke des Rechtecks befinden soll (0=aktueller Bar) endTime Datum/Uhrzeit des Bars, an dem sich die zweite Ecke des Rechtecks befinden soll series1, series2 jedes Datenserie, wie z.B. ein Indikator, Close, High, Low usw. Der jeweilige Wert der Datenserie f\u00fcr den aktuellen Bar wird als y-Wert herangezogen y ein beliebiger double-Wert outlineColor Farbe f\u00fcr die Umrandung des Bereichs areaColor F\u00fcllfarbe des Zeichenobjekts areaOpacity Transparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 = komplett transparent, 255 = keine Transparenz)","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_16","text":"// f\u00fcllt den Bereich zwischen dem oberen und dem unteren Bollinger Band AddChartRegion(\"MyRegion\", ProcessingBarIndex, 0, Bollinger(2, 14).Upper, Bollinger(2, 14).Lower, Color.Empty, Color.Lime, 100);","title":"Beispiel"},{"location":"zeichenobjekte/#addchartregressionchannel","text":"","title":"AddChartRegressionChannel()"},{"location":"zeichenobjekte/#beschreibung_20","text":"AddChartRegressionChannel()zeichnet einen Regressionskanal.","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_20","text":"AddChartRegressionChannel(string name, int barsBackStart, int barsBackEnd, Color color) AddChartRegressionChannel(string name, bool autoScale, int barsBackStart, int barsBackEnd, Color upperColor, DashStyle upperDashStyle, int upperWidth, Color middleColor, DashStyle middleDashStyle, int middleWidth, Color lowerColor, DashStyle lowerDashStyle, int lowerWidth) AddChartRegressionChannel(string name, bool autoScale, DateTime startTime, DateTime endTime, Color upperColor, DashStyle upperDashStyle, int upperWidth, Color middleColor, DashStyle middleDashStyle, int middleWidth, Color lowerColor, DashStyle lowerDashStyle, int lowerWidth)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_20","text":"Ein Zeichenobjekt vom Typ IRegressionChannel (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_20","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist. barsBackStart Gibt an, an welchem zur\u00fcckliegenden Bar der Regressionskanal beginnen soll (0=aktueller Bar) startTime Datum/Uhrzeit des Bars, an dem der Regressionskanal beginnen soll barsBackEnd Gibt an, an welchem zur\u00fcckliegenden Bar der Regressionskanal enden soll (0=aktueller Bar) endTime Datum/Uhrzeit des Bars, an dem der Regressionskanal enden soll color Farbe des Zeichenobjekts upperDashStyle, middleDashStyle, lowerDashStyle Linienart DashStyle.Dash DashStyle.DashDot DashStyle.DashDotDot DashStyle.Dot DashStyle.Solid ggf. mu\u00df: using System.Drawing.Drawing2D; mit eingebunden werden. upperColor, middleColor, lowerColor jeweilige Linienfarbe upperWidth, middleWidth, lowerWidth jeweilige Linienst\u00e4rke","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_17","text":"// zeichnet einen Regressionskanal vom Tief des Bars von vor 10 Tagen // zum Hoch des Bars von vor 5 Tagen AddChartRegressionChannel(\"MyRegChannel-\" + ProcessingBarIndex, 10, 0, Color.Black);","title":"Beispiel"},{"location":"zeichenobjekte/#addchartsquare","text":"","title":"AddChartSquare()"},{"location":"zeichenobjekte/#beschreibung_21","text":"AddChartSquare() zeichnet ein Quadrat: Siehe auch AddChartArrowUp() , AddChartArrowDown() , AddChartDiamond() , AddChartDot() , AddChartTriangleUp() , AddChartTriangleDown() .","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_21","text":"DrawSqare(string name, bool autoScale, int barsAgo, double y, Color color) DrawSqare(string name, bool autoScale, DateTime time, double y, Color color)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_21","text":"Ein Zeichenobjekt vom Typ ISquare (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_21","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen barsAgo Gibt an, an welchem zur\u00fcckliegenden Bar das Quadrat gezeichnet werden soll (0=aktueller Bar) Time Datum/Uhrzeit des Bars, an dem das Quadrat gezeichnet werden soll Y y-Wert, an dem das Quadrat gezeichnet werden soll color Farbe des Zeichenobjekts","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_18","text":"// zeichnet ein durnkelrotes Quadrat am akt. Bar 10 Ticks \u00fcber dem Hoch AddChartSquare(\"MySquare\", true, 0, High[0] + 10*TickSize, Color.DarkRed);","title":"Beispiel"},{"location":"zeichenobjekte/#addcharttext","text":"","title":"AddChartText()"},{"location":"zeichenobjekte/#beschreibung_22","text":"AddChartText() schreibt einen beliebigen Text auf den Chart. Siehe auch AddChartTextFixed() .","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_22","text":"AddChartText(string tag, string text, int barsAgo, double y, Color color); AddChartText(string tag, string text, TextPosition textPosition, Color textColor, Font font, Color outlineColor, Color areaColor, int areaOpacity); AddChartText(string tag, string text, int barsAgo, double y, Color textColor, Font font, StringAlignment alignment, Color outlineColor, Color areaColor, int areaOpacity); AddChartText(string tag, bool autoScale, string text, int barsAgo, double y, int yPixelOffset, Color textColor, Font font, StringAlignment alignment, Color outlineColor, Color areaColor, int areaOpacity); AddChartText(string tag, bool autoScale, string text, DateTime x, double y, int yPixelOffset, Color textColor, Font font, StringAlignment alignment, Color outlineColor, Color areaColor, int areaOpacity); AddChartText(string tag, bool autoScale, string text, DateTime x, double y, int pixelOffset, Color textColor, Font font, StringAlignment alignment, HorizontalAlignment hAlign, VerticalAlignment vAlign, Color outlineColor, Color areaColor); AddChartText(string tag, bool autoScale, string text, int barsAgo, double y, int yPixelOffset, Color textColor, Font font, StringAlignment alignment, HorizontalAlignment hAlign, VerticalAlignment vAlign, Color outlineColor, Color areaColor, int areaOpacity); AddChartText(string tag, bool autoScale, string text, DateTime x, double y, int pixelOffset, Color textColor, Font font, StringAlignment alignment, HorizontalAlignment hAlign, VerticalAlignment vAlign, Color outlineColor, Color areaColor); wichtiger Hinweis: Bei Verwendung der Signaturen, die HorizontalAlignment und VerticalAlignment enthalten, sind die folgenden beiden Zeilen dem Programmcode hinzuzuf\u00fcgen: using System.Windows.Forms; using System.Windows.Forms.VisualStyles;","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_22","text":"Ein Zeichenobjekt vom Typ IText (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_22","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist Text Der auszugebende Text (Der Text darf auch den Zeilenumbruch \"\\n\" enthalten.) barsAgo Gibt an, an welchem zur\u00fcckliegenden Bar der Text ausgegeben werden soll (0=aktueller Bar) (Welcher Bar den Index 0 hat, ist abh\u00e4ngig von CalculateOnBarClose.) Time Datum/Uhrzeit des Bars, an dem der Text beginnen soll Y y-Wert, an dem der Text geschrieben werden soll yPixelOffset vertikale Verschiebung des Textes. Positive Werte verschieben den Text nach oben, negative Werte nach unten. textColor Textfarbe Font Schriftart f\u00fcr den Text Alignment m\u00f6gliche Werte sind: StringAlignment.Center, StringAlignment.Far, StringAlignment.Near HAlign m\u00f6gliche Werte sind: HorizontalAlign.Left, HorizontalAlign.Center, HorizontalAlign.Right VAlign m\u00f6gliche Werte sind: VerticalAlign.Top, VerticalAlign.Center, VerticalAlign.Bottom outlineColor Farbe des Rahmens um den Text (F\u00fcr keinen Rahmen Color.Empty verwenden) areaColor F\u00fcllfarbe der Textbox (F\u00fcr keine F\u00fcllung Color.Empty verwenden) areaOpacity Transparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 = komplett transparent, 255 = keine Transparenz)","title":"Parameter"},{"location":"zeichenobjekte/#beispiele_2","text":"// schreibt einen Text bei y=3.0 AddChartText(\"MyText-\" + ProcessingBarIndex, \"This is sample text.\", 10, 3, Color.Black); // schreibt einen roten Text in Schriftgr\u00f6\u00dfe Arial 7 AddChartText(\"MyText-\" + ProcessingBarIndex, false, \"This is sample text.\", Time[0], Close[0]+50*TickSize, 0, Color.Red, new Font(\"Arial\",7), StringAlignment.Center, Color.Blue, Color.DarkOliveGreen, 10); Nachstehende Anweisung f\u00fchrt zu diesem Ergebnis: AddChartText(\"MyTag\",true,\"Text\",1, // barsAgo High[1], // y 10, // yPixelOffset Color.Blue, // Text color new Font(\"Arial\", 10, FontStyle.Bold), StringAlignment.Center, HorizontalAlignment.Center, VerticalAlignment.Bottom, Color.Red, // Outline color Color.Yellow, // Fill color 100); // Opacity","title":"Beispiele"},{"location":"zeichenobjekte/#addcharttextfixed","text":"","title":"AddChartTextFixed()"},{"location":"zeichenobjekte/#beschreibung_23","text":"AddChartTextFixed() schreibt Text an eine von 5 m\u00f6glichen festen Stellen im Chart. Siehe auch AddChartText() .","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_23","text":"AddChartTextFixed(string tag, string text, TextPosition textPosition); AddChartTextFixed(string tag, string text, TextPosition textPosition, Color textColor, Font font, Color outlineColor, Color areaColor); AddChartTextFixed(string tag, string text, TextPosition textPosition, Color textColor, Font font, Color outlineColor, Color areaColor, int areaOpacity);","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_23","text":"Ein Zeichenobjekt vom Typ ITextFixed (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_23","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung text The text to be displayed TextPosition TextPosition.BottomLeft, TextPosition.BottomRight, TextPosition.Center, TextPosition.TopLeft, TextPosition.TopRight textColor Textfarbe font Schriftart f\u00fcr den Text outlineColor Farbe des Rahmens um den Text (F\u00fcr keinen Rahmen Color.Empty verwenden) areaColor F\u00fcllfarbe der Textbox (F\u00fcr keine F\u00fcllung Color.Empty verwenden) areaOpacity Transparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 = komplett transparent, 255 = keine Transparenz)","title":"Parameter"},{"location":"zeichenobjekte/#beispiele_3","text":"// schreibt einen Text in die Mitte des Charts AddChartTextFixed(\"MyText-\" + ProcessingBarIndex, \"\"Das ist ein Beispieltext.\", TextPosition.Center); // schreibt einen roten Text mit einem blauen Rand in die Mitte des Charts AddChartTextFixed(\"MyText-\" + ProcessingBarIndex, \"Das ist ein Beispieltext.\", TextPosition.Center, Color.Red, new Font(\"Arial\",35), Color.Blue, Color.Empty, 10);","title":"Beispiele"},{"location":"zeichenobjekte/#addcharttrendchannel","text":"","title":"AddChartTrendChannel()"},{"location":"zeichenobjekte/#beschreibung_24","text":"AddChartTrendChannel() zeichnet einen Trendkanal.","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_24","text":"AddChartTrendChannel(string name, bool autoScale, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, int start3BarsAgo, double start3Y) AddChartTrendChannel(string name, bool autoScale, DateTime start1Time, double start1Y, DateTime start2Time, double start2Y, DateTime start3Time, double start3Y)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_24","text":"Ein Zeichenobjekt vom Typ ITrendChannel (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_24","text":"name A clearly identifiable name for the drawing object autoScale Adjusts the scale of the y-axis so that drawing objects can be viewed in their entirety start1BarsAgo Number of bars ago for start point 1 (x-axis) start1Time Date/time for start point 1 (x-axis) start1Y y-value for start point 1 start2BarsAgo Number of bars ago for start point 2 (x-axis) start2Time Date/time for start point 2 (x-axis) start2Y y-value for start point 2 start3BarsAgo Number of bars ago for start point 3 (x-axis) start3Time Date/time for start point 3 (x-axis) start3Y y-value for start point 3","title":"Parameter"},{"location":"zeichenobjekte/#beispiele_4","text":"// zeichnet einen Trendkanal AddChartTrendChannel(\"MyTrendChannel-\" + ProcessingBarIndex, true, 10, Low[10], 0, High[0], 10, High[10] + 5 * TickSize);","title":"Beispiele"},{"location":"zeichenobjekte/#addcharttriangle","text":"","title":"AddChartTriangle()"},{"location":"zeichenobjekte/#beschreibung_25","text":"AddChartTriangle() zeichnet ein Dreieck.","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_25","text":"AddChartTriangle(string name, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, int start3BarsAgo, double start3Y, Color color) AddChartTriangle(string name, bool autoScale, int start1BarsAgo, double start1Y, int start2BarsAgo, double start2Y, int start3BarsAgo, double start3Y, Color color, Color areaColor, int areaOpacity) AddChartTriangle(string name, bool autoScale, DateTime start1Time, double start1Y, DateTime start2Time, double start2Y, DateTime start3Time, double start3Y, Color color, Color areaColor, int areaOpacity)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_25","text":"Ein Zeichenobjekt vom Typ ITriangle (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_25","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist start1BarsAgo Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt1 (x-Achse) start1Time Datum/Zeit f\u00fcr Ankerpunkt1 (x-Achse) start1Y y-Wert f\u00fcr Ankerpunkt1 start2BarsAgo Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt2 (x-Achse) start2Time Datum/Zeit f\u00fcr Ankerpunkt2 (x-Achse) start2Y y-Wert f\u00fcr Ankerpunkt2 start3BarsAgo Anzahl der r\u00fcckw\u00e4rtigen Bars f\u00fcr Ankerpunkt3 (x-Achse) start3Time Datum/Zeit f\u00fcr Ankerpunkt3 (x-Achse) start3Y y-Wert f\u00fcr Ankerpunkt3 color Farbe des Zeichenobjekts areaColor F\u00fcllen Sie Farbe des Zeichnungsobjekt areaOpacity Transparenz der F\u00fcllfarbe. Wert zwischen 0 und 255 (0 = komplett transparent, 255 = keine Transparenz)","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_19","text":"// zeichnet ein gr\u00fcnes Dreieck AddChartTriangle(\"tag1\", 4, Low[4], 3, High[3], 1, Low[1], Color.Green);","title":"Beispiel"},{"location":"zeichenobjekte/#addcharttriangledown","text":"","title":"AddChartTriangleDown()"},{"location":"zeichenobjekte/#beschreibung_26","text":"AddChartTriangleDown() zeichnet ein kleines abw\u00e4rtsgerichtetes Dreieck. Siehe auch AddChartArrowUp() , AddChartArrowDown() , AddChartDiamond() , AddChartDot() , AddChartSquare() , AddChartTriangleUp() .","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_26","text":"AddChartTriangleDown(string name, bool autoScale, int barsAgo, double y, Color color) AddChartTriangleDown(string name, bool autoScale, DateTime time, double y, Color color)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_26","text":"Ein Zeichenobjekt vom Typ ITriangleDown (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_26","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist barsAgo Gibt an, an welchem zur\u00fcckliegenden Bar das Dreieck gezeichnet werden soll time Datum/Uhrzeit des Bars, an dem das Dreieck gezeichnet werden soll y y-Wert, an dem das Dreieck gezeichnet werden color Farbe des Zeichenobjekts","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_20","text":"// zeichnet ein kleines rotes Dreieck am akt. Bar 10 Ticks \u00fcber dem Hoch AddChartTriangleDown(\"MyTriangleDown-\" + ProcessingBarIndex, true, 0, High[0] + 10*TickSize, Color.Red);","title":"Beispiel"},{"location":"zeichenobjekte/#addcharttriangleup","text":"","title":"AddChartTriangleUp()"},{"location":"zeichenobjekte/#beschreibung_27","text":"AddChartTriangleUp() zeichnet ein kleines aufw\u00e4rtsgerichtetes Dreieck. Siehe auch AddChartArrowUp() , AddChartArrowDown() , AddChartDiamond() , AddChartDot() , AddChartSquare() , AddChartTriangleDown() .","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_27","text":"AddChartTriangleUp(string name, bool autoScale, int barsAgo, double y, Color color) AddChartTriangleUp(string name, bool autoScale, DateTime time, double y, Color color)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_27","text":"Ein Zeichenobjekt vom Typ ITriangleUp (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_27","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung autoScale Skalierung der y-Achse so anpassen, dass das Zeichenobjekt vollst\u00e4ndig zu sehen ist barsAgo Gibt an, an welchem zur\u00fcckliegenden Bar das Dreieck gezeichnet werden soll time Datum/Uhrzeit des Bars, an dem das Dreieck gezeichnet werden soll y y-Wert, an dem das Dreieck gezeichnet werden color Farbe des Zeichenobjekts","title":"Parameter"},{"location":"zeichenobjekte/#beispiel_21","text":"// zeichnet ein kleines hellgr\u00fcnes Dreieck am akt. Bar 10 Ticks unter dem Tief AddChartTriangleUp(\"MyTriangleUp-\" + ProcessingBarIndex, true, 0, Low[0] - 10*TickSize, Color.LightGreen);","title":"Beispiel"},{"location":"zeichenobjekte/#addchartverticalline","text":"","title":"AddChartVerticalLine()"},{"location":"zeichenobjekte/#beschreibung_28","text":"AddChartVerticalLine() zeichnet eine vertikale Linie in den Chart. Siehe auch AddChartLine() , AddChartHorizontalLine() , AddChartExtendedLine() , AddChartRay() .","title":"Beschreibung"},{"location":"zeichenobjekte/#verwendung_28","text":"AddChartVerticalLine(string name, int barsAgo, Color color) AddChartVerticalLine(string name, int barsAgo, Color color, DashStyle dashStyle, int width) AddChartVerticalLine(string name, DateTime time, Color color, DashStyle dashStyle, int width)","title":"Verwendung"},{"location":"zeichenobjekte/#ruckgabewert_28","text":"Ein Zeichenobjekt vom Typ IVerticalLine (Interface)","title":"R\u00fcckgabewert"},{"location":"zeichenobjekte/#parameter_28","text":"name Der Name eines Zeichenobjekts zur eindeutigen Identifizierung barsAgo Gibt an, an welchem zur\u00fcckliegenden Bar die vertikale Linie gezeichnet werden soll (0=aktueller Bar) time Datum/Uhrzeit des Bars, an dem die vertikale Linie gezeichnet werden soll color Linienfarbe dashStyle Linienart DashStyle.Dash DashStyle.DashDot DashStyle.DashDotDot DashStyle.Dot DashStyle.Solid ggf. mu\u00df using System.Drawing.Drawing2D; mit eingebunden werden. width Linienst\u00e4rke","title":"Parameter"},{"location":"zeichenobjekte/#beispiele_5","text":"// zeichnet eine vertikale Linie am Bar von vor 10 Perioden AddChartVerticalLine(\"MyVerticalLine-\" + ProcessingBarIndex, 10, Color.Black);","title":"Beispiele"}]}